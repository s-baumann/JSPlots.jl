<!DOCTYPE html>
<html>
<head>
    <title>JSPlots.jl</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->


<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts various date formats to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
// Handles: ISO strings, Date objects (from Arrow/Parquet), timestamps, and day counts
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Timestamp range for reasonable dates (2000-01-01 to 2100-01-01 in milliseconds)
    // Using year 2000 as minimum to avoid false positives with regular numeric values
    var MIN_TIMESTAMP_MS = 946684800000;  // 2000-01-01
    var MAX_TIMESTAMP_MS = 4102444800000;  // 2100-01-01

    // Day count range (for dates stored as days since epoch, e.g., from some Parquet files)
    // Reasonable range: 0 (1970-01-01) to ~47500 (~2100-01-01)
    var MIN_DAYS = 0;
    var MAX_DAYS = 50000;
    var MS_PER_DAY = 86400000;

    // Scan multiple rows to better detect column types (some rows might have missing values)
    var rowsToCheck = Math.min(10, data.length);
    var dateColumns = [];
    var timeColumns = [];
    var timestampColumns = [];
    var dayCountColumns = [];
    var alreadyDateColumns = [];

    // Helper to check if a numeric value looks like a timestamp (milliseconds since epoch)
    function looksLikeTimestamp(value) {
        return typeof value === 'number' && value >= MIN_TIMESTAMP_MS && value <= MAX_TIMESTAMP_MS && value > MAX_DAYS;
    }

    // Helper to check if a numeric value looks like a day count since epoch
    // DISABLED: This was too aggressive and incorrectly converted normal numeric values
    // (like Month=1, Year=2022, Sales=120) to dates. Only enable for columns with
    // explicit date-like names if needed in the future.
    function looksLikeDayCount(value) {
        return false;  // Disabled - too many false positives
    }

    // Build list of keys from first row
    var keys = Object.keys(data[0]);

    // Check each column across multiple rows
    keys.forEach(function(key) {
        var stringDateCount = 0;
        var timeCount = 0;
        var timestampCount = 0;
        var dayCountCount = 0;
        var alreadyDateCount = 0;
        var nonNullCount = 0;

        for (var i = 0; i < rowsToCheck; i++) {
            var value = data[i][key];
            if (value === null || value === undefined) continue;
            nonNullCount++;

            if (value instanceof Date) {
                alreadyDateCount++;
            } else if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    stringDateCount++;
                } else if (timePattern.test(value)) {
                    timeCount++;
                }
            } else if (typeof value === 'number') {
                if (looksLikeTimestamp(value)) {
                    timestampCount++;
                } else if (looksLikeDayCount(value)) {
                    dayCountCount++;
                }
            }
        }

        // Classify column if majority of non-null values match a pattern
        var threshold = nonNullCount * 0.5;
        if (alreadyDateCount > threshold) {
            alreadyDateColumns.push(key);
        } else if (stringDateCount > threshold) {
            dateColumns.push(key);
        } else if (timeCount > threshold) {
            timeColumns.push(key);
        } else if (timestampCount > threshold) {
            timestampColumns.push(key);
        } else if (dayCountCount > threshold && dayCountCount >= 3) {
            // Be more conservative with day counts - require at least 3 matches
            dayCountColumns.push(key);
        }
    });

    // If no date/time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0 &&
        timestampColumns.length === 0 && dayCountColumns.length === 0 &&
        alreadyDateColumns.length === 0) {
        return data;
    }

    // Convert values in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                var value = row[key];

                if (alreadyDateColumns.indexOf(key) !== -1) {
                    // Already a Date object - keep as is
                    newRow[key] = value;
                } else if (dateColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // ISO date string - convert to Date
                    newRow[key] = new Date(value);
                } else if (timeColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = value.split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else if (timestampColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Timestamp in milliseconds - convert to Date
                    newRow[key] = new Date(value);
                } else if (dayCountColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Day count since epoch - convert to Date
                    newRow[key] = new Date(value * MS_PER_DAY);
                } else {
                    newRow[key] = value;
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        case 'cumulative':
        case 'cumprod':
            // These are handled specially in chart code (computed per group)
            // Here they act as identity
            return values;

        default:
            return values;
    }
}

// Compute cumulative sum of values
// Returns array of same length: [y[0], y[0]+y[1], y[0]+y[1]+y[2], ...]
function computeCumulativeSum(values) {
    if (!values || values.length === 0) return [];
    var result = [];
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);  // Explicitly convert to number
        if (!isNaN(v) && isFinite(v)) {
            sum += v;
        }
        result.push(sum);
    }
    return result;
}

// Compute cumulative product of values
// Returns array of same length: [y[0], y[0]*y[1], y[0]*y[1]*y[2], ...]
function computeCumulativeProduct(values) {
    if (!values || values.length === 0) return [];
    var result = [];
    var product = 1;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);  // Explicitly convert to number
        if (!isNaN(v) && isFinite(v)) {
            product *= v;
        }
        result.push(product);
    }
    return result;
}

// Compute quantile transformation of values (rank-based, maps to [0, 1])
function computeQuantileTransform(values) {
    if (!values || values.length === 0) return [];

    var indexedValues = values.map(function(v, i) {
        return { value: parseFloat(v), index: i };  // Explicitly convert to number
    });

    var validValues = indexedValues.filter(function(item) {
        return !isNaN(item.value) && isFinite(item.value);
    }).sort(function(a, b) {
        return a.value - b.value;
    });

    if (validValues.length === 0) return values;

    var ranks = new Array(values.length).fill(NaN);
    validValues.forEach(function(item, rank) {
        ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
    });

    return ranks;
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        case 'cumulative':
            return 'cumulative(' + originalLabel + ')';
        case 'cumprod':
            return 'cumprod(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

// Global fix for PivotTable.js filter box positioning issue
// See: https://github.com/nicolaskruchten/pivottable/issues/865
// The library calculates position incorrectly - we fix it by repositioning after creation
(function() {
    if (window._pvtFilterBoxFixApplied) return; // Only apply once
    window._pvtFilterBoxFixApplied = true;

    var lastClickedTriangle = null;

    // Helper function to reposition the filter box
    function repositionFilterBox($box, triangle) {
        if (!triangle || !$box.length) return;

        // Get triangle position relative to viewport
        var triangleRect = triangle.getBoundingClientRect();

        // Get box dimensions (use defaults if not yet rendered)
        var boxWidth = $box.outerWidth() || 300;
        var boxHeight = $box.outerHeight() || 400;

        // Calculate position relative to viewport (for position:fixed)
        var newLeft = triangleRect.left;
        var newTop = triangleRect.bottom + 5;

        // Adjust if it would go off the right edge
        if (newLeft + boxWidth > window.innerWidth - 20) {
            newLeft = triangleRect.right - boxWidth;
        }

        // Adjust if it would go off the bottom edge
        if (newTop + boxHeight > window.innerHeight - 20) {
            newTop = triangleRect.top - boxHeight - 5;
        }

        // Ensure minimum positions
        if (newLeft < 10) newLeft = 10;
        if (newTop < 10) newTop = 10;

        // Use position:fixed for viewport-relative positioning
        $box.css({
            'position': 'fixed',
            'left': newLeft + 'px',
            'top': newTop + 'px'
        });
    }

    // Capture which triangle was clicked
    $(document).on('click', '.pvtTriangle', function(e) {
        lastClickedTriangle = this;
    });

    // Watch for filter box creation and fix position
    var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1 && $(node).hasClass('pvtFilterBox')) {
                    var $box = $(node);
                    var triangle = lastClickedTriangle;

                    // Apply the fix multiple times to ensure it sticks after PivotTable.js finishes
                    // The library may set position after initial render
                    var timings = [0, 10, 50, 100, 200];
                    timings.forEach(function(delay) {
                        setTimeout(function() {
                            repositionFilterBox($box, triangle);
                        }, delay);
                    });

                    // Also reposition on any style changes to the box (in case library updates position)
                    var styleObserver = new MutationObserver(function(styleMutations) {
                        repositionFilterBox($box, triangle);
                    });
                    styleObserver.observe(node, { attributes: true, attributeFilter: ['style'] });

                    // Disconnect the style observer when the filter box is removed
                    var removalObserver = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            mutation.removedNodes.forEach(function(removedNode) {
                                if (removedNode === node) {
                                    styleObserver.disconnect();
                                    removalObserver.disconnect();
                                    lastClickedTriangle = null;
                                }
                            });
                        });
                    });
                    removalObserver.observe(document.body, { childList: true, subtree: true });
                }
            });
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
})();

(function() {
    let radarData_phones_radar = null;
    let selectedVariables_phones_radar = ["Battery","Camera","Performance","Display","Price_Value","Build_Quality"];
    let selectedLabels_phones_radar = [];
    let selectedScenario_phones_radar = null;

    const VALUE_COLS = ["Battery","Camera","Performance","Display","Price_Value","Build_Quality"];
    const LABEL_COL = "label";
    const GROUP_MAPPING = {};
    const VARIABLE_LIMITS = {};
    const SCENARIO_COL = null;
    const COLOR_COL = null;
    const DEFAULT_COLOR = "#2563eb";
    const MAX_VALUE = 100.0;
    const MAX_VARIABLES = null;
    const SHOW_LEGEND = true;
    const SHOW_GRID_LABELS = true;
    const VARIABLE_SELECTOR = false;

    // Load data
    loadDataset('phones_data').then(function(data) {
        radarData_phones_radar = data;
        initializeRadarChart_phones_radar();
    }).catch(function(error) {
        console.error('Error loading data:', error);
        document.getElementById('radar_phones_radar').innerHTML =
            '<p style="color: red;">Error loading data: ' + error.message + '</p>';
    });

    function initializeRadarChart_phones_radar() {
        const data = radarData_phones_radar;
        if (!data || data.length === 0) {
            document.getElementById('radar_phones_radar').innerHTML = '<p>No data available</p>';
            return;
        }

        // Populate scenario selector
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_phones_radar');
            if (scenarioSelect) {
                const uniqueScenarios = [...new Set(data.map(d => d[SCENARIO_COL]))].filter(s => s);
                scenarioSelect.innerHTML = '';
                uniqueScenarios.forEach(function(scenario, idx) {
                    const option = document.createElement('option');
                    option.value = scenario;
                    option.text = scenario;
                    if (idx === 0) {
                        option.selected = true;
                        selectedScenario_phones_radar = scenario;
                    }
                    scenarioSelect.appendChild(option);
                });
            }
        }

        // Populate variable selector
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_phones_radar');
            if (varSelect) {
                varSelect.innerHTML = '';
                VALUE_COLS.forEach(function(col) {
                    const option = document.createElement('option');
                    option.value = col;
                    option.text = col.replace(/_/g, ' ');
                    option.selected = selectedVariables_phones_radar.includes(col);
                    varSelect.appendChild(option);
                });
            }
        } else {
            selectedVariables_phones_radar = VALUE_COLS;
        }

        // Populate label selector
        const labelSelect = document.getElementById('label_select_phones_radar');
        if (labelSelect) {
            // Filter by scenario if applicable
            let scenarioData = data;
            if (SCENARIO_COL && selectedScenario_phones_radar) {
                scenarioData = data.filter(d => d[SCENARIO_COL] === selectedScenario_phones_radar);
            }

            const uniqueLabels = [...new Set(scenarioData.map(d => d[LABEL_COL]))].filter(l => l);
            labelSelect.innerHTML = '';
            uniqueLabels.forEach(function(label) {
                const option = document.createElement('option');
                option.value = label;
                option.text = label;
                option.selected = true;
                labelSelect.appendChild(option);
            });
            const maxToSelect = MAX_VARIABLES || uniqueLabels.length;
            selectedLabels_phones_radar = uniqueLabels.slice(0, maxToSelect);

            // Set selected options
            Array.from(labelSelect.options).forEach(function(opt) {
                opt.selected = selectedLabels_phones_radar.includes(opt.value);
            });
        }

        updateRadarChart_phones_radar();
    }

    window.updateRadarChart_phones_radar = function() {
        // Get selected scenario
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_phones_radar');
            if (scenarioSelect) {
                selectedScenario_phones_radar = scenarioSelect.value;
            }
        }

        // Get selected variables
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_phones_radar');
            if (varSelect) {
                selectedVariables_phones_radar = Array.from(varSelect.selectedOptions).map(opt => opt.value);

                if (selectedVariables_phones_radar.length < 3) {
                    document.getElementById('radar_phones_radar').innerHTML =
                        '<p style="color: orange;">Please select at least 3 variables to display a radar chart.</p>';
                    return;
                }
            }
        }

        // Get selected labels
        const labelSelect = document.getElementById('label_select_phones_radar');
        if (labelSelect) {
            selectedLabels_phones_radar = Array.from(labelSelect.selectedOptions).map(opt => opt.value);

            if (selectedLabels_phones_radar.length === 0) {
                document.getElementById('radar_phones_radar').innerHTML =
                    '<p style="color: orange;">Please select at least one item to display.</p>';
                return;
            }
        }

        renderRadarChart_phones_radar(selectedVariables_phones_radar, selectedLabels_phones_radar, selectedScenario_phones_radar);
    }

    function renderRadarChart_phones_radar(variables, labels, scenario) {
        const data = radarData_phones_radar;
        const container = document.getElementById('radar_phones_radar');
        if (!container) return;

        container.innerHTML = '';

        // Filter data by labels and scenario
        let filteredData = data.filter(d => labels.includes(d[LABEL_COL]));

        if (SCENARIO_COL && scenario) {
            filteredData = filteredData.filter(d => d[SCENARIO_COL] === scenario);
        }

        if (filteredData.length === 0) {
            container.innerHTML = '<p>No data matches the selected filters.</p>';
            return;
        }

        // Calculate max value per variable (respecting variable_limits)
        const maxValues = {};
        variables.forEach(function(v) {
            if (VARIABLE_LIMITS.hasOwnProperty(v)) {
                maxValues[v] = VARIABLE_LIMITS[v];
            } else if (MAX_VALUE) {
                maxValues[v] = MAX_VALUE;
            } else {
                // Auto-calculate from data
                let maxVal = 0;
                filteredData.forEach(function(d) {
                    const val = parseFloat(d[v]);
                    if (!isNaN(val) && val > maxVal) {
                        maxVal = val;
                    }
                });
                maxValues[v] = Math.ceil(maxVal * 1.1);
            }
        });

        // Group variables by group_mapping
        const groupedVars = {};
        const ungroupedVars = [];

        variables.forEach(function(v) {
            if (GROUP_MAPPING.hasOwnProperty(v)) {
                const group = GROUP_MAPPING[v];
                if (!groupedVars[group]) {
                    groupedVars[group] = [];
                }
                groupedVars[group].push(v);
            } else {
                ungroupedVars.push(v);
            }
        });

        // Create ordered list of axes with groups
        const axes = [];
        const groupBoundaries = [];  // Track where each group starts and ends
        let currentIndex = 0;

        // Sort groups for consistent ordering
        const sortedGroups = Object.keys(groupedVars).sort();

        sortedGroups.forEach(function(group) {
            const startIdx = currentIndex;
            groupedVars[group].forEach(function(v) {
                axes.push({ name: v, group: group, maxValue: maxValues[v] });
                currentIndex++;
            });
            const endIdx = currentIndex - 1;
            groupBoundaries.push({ group: group, startIdx: startIdx, endIdx: endIdx });
        });

        ungroupedVars.forEach(function(v) {
            axes.push({ name: v, group: null, maxValue: maxValues[v] });
            currentIndex++;
        });

        // Create color mapping
        const colorMap = {};
        if (COLOR_COL) {
            const uniqueColors = [...new Set(filteredData.map(d => d[COLOR_COL]))];
            // D3 v3 API: use d3.scale.category10()
            const colorScale = d3.scale.category10();
            uniqueColors.forEach(function(c, i) {
                colorMap[c] = colorScale(i);
            });
        }

        // Calculate layout
        const numCharts = filteredData.length;
        const chartsPerRow = Math.ceil(Math.sqrt(numCharts));
        const chartSize = Math.min(450, Math.max(350, Math.floor((container.offsetWidth || 800) / chartsPerRow)));

        // Create SVG container
        const svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', Math.ceil(numCharts / chartsPerRow) * chartSize);

        // Draw each radar chart
        filteredData.forEach(function(d, idx) {
            const row = Math.floor(idx / chartsPerRow);
            const col = idx % chartsPerRow;
            const x = col * chartSize;
            const y = row * chartSize;

            const color = COLOR_COL ? (colorMap[d[COLOR_COL]] || DEFAULT_COLOR) : DEFAULT_COLOR;

            drawSingleRadar_phones_radar(svg, d, axes, groupBoundaries, x, y, chartSize, color);
        });

        // Add legend
        if (SHOW_LEGEND && COLOR_COL) {
            addLegend_phones_radar(container, colorMap);
        }
    }

    function drawSingleRadar_phones_radar(svg, dataPoint, axes, groupBoundaries, offsetX, offsetY, size, color) {
        const margin = 60;
        const radius = (size - 2 * margin) / 2;
        const centerX = offsetX + size / 2;
        const centerY = offsetY + size / 2;

        const g = svg.append('g')
            .attr('transform', 'translate(' + centerX + ',' + centerY + ')');

        // Determine overall max for grid (use the max of all variable maxes for consistent grid)
        let gridMax = 0;
        axes.forEach(function(axis) {
            if (axis.maxValue > gridMax) gridMax = axis.maxValue;
        });

        // Draw grid circles
        const levels = 5;
        for (let i = 1; i <= levels; i++) {
            const r = radius * i / levels;
            g.append('circle')
                .attr('r', r)
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);

            if (SHOW_GRID_LABELS && i === levels) {
                g.append('text')
                    .attr('x', 5)
                    .attr('y', -r)
                    .attr('font-size', '10px')
                    .attr('fill', '#666')
                    .text(gridMax.toFixed(1));
            }
        }

        // Draw axes
        const angleSlice = Math.PI * 2 / axes.length;

        axes.forEach(function(axis, i) {
            const angle = angleSlice * i - Math.PI / 2;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            // Draw axis line
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', x)
                .attr('y2', y)
                .attr('stroke', '#999')
                .attr('stroke-width', 1);

            // Draw axis label
            const labelRadius = radius + 15;
            const labelX = labelRadius * Math.cos(angle);
            const labelY = labelRadius * Math.sin(angle);

            g.append('text')
                .attr('x', labelX)
                .attr('y', labelY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(axis.name.replace(/_/g, ' '));
        });

        // Draw group labels using boundaries
        groupBoundaries.forEach(function(boundary) {
            const startAngle = angleSlice * boundary.startIdx - Math.PI / 2;
            const endAngle = angleSlice * (boundary.endIdx + 1) - Math.PI / 2;
            const midAngle = (startAngle + endAngle) / 2;
            const labelRadius = radius + 40;
            const x = labelRadius * Math.cos(midAngle);
            const y = labelRadius * Math.sin(midAngle);

            g.append('text')
                .attr('x', x)
                .attr('y', y)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', '#0066cc')
                .text(boundary.group);
        });

        // Draw data polygon
        const points = [];
        axes.forEach(function(axis, i) {
            const value = parseFloat(dataPoint[axis.name]) || 0;
            // Clamp value to axis max, then normalize by grid max for consistent display
            const clampedValue = Math.min(value, axis.maxValue);
            const normalizedValue = Math.min(Math.max(clampedValue / gridMax, 0), 1);
            const angle = angleSlice * i - Math.PI / 2;
            const r = radius * normalizedValue;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push([x, y]);
        });

        // Close the polygon
        if (points.length > 0) {
            const pathData = 'M' + points.map(p => p.join(',')).join('L') + 'Z';

            g.append('path')
                .attr('d', pathData)
                .attr('fill', color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', color)
                .attr('stroke-width', 2);

            // Draw points
            points.forEach(function(p) {
                g.append('circle')
                    .attr('cx', p[0])
                    .attr('cy', p[1])
                    .attr('r', 3)
                    .attr('fill', color);
            });
        }

        // Add title
        g.append('text')
            .attr('x', 0)
            .attr('y', -radius - 45)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .text(dataPoint[LABEL_COL]);
    }

    function addLegend_phones_radar(container, colorMap) {
        const legendDiv = document.createElement('div');
        legendDiv.style.marginTop = '20px';
        legendDiv.innerHTML = '<strong>Legend:</strong>';

        const legendItems = document.createElement('div');
        legendItems.style.display = 'flex';
        legendItems.style.flexWrap = 'wrap';
        legendItems.style.gap = '15px';
        legendItems.style.marginTop = '10px';

        Object.keys(colorMap).forEach(function(key) {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '5px';

            const colorBox = document.createElement('div');
            colorBox.style.width = '20px';
            colorBox.style.height = '20px';
            colorBox.style.backgroundColor = colorMap[key];
            colorBox.style.border = '1px solid #ccc';

            const label = document.createElement('span');
            label.textContent = key;

            item.appendChild(colorBox);
            item.appendChild(label);
            legendItems.appendChild(item);
        });

        legendDiv.appendChild(legendItems);
        container.appendChild(legendDiv);
    }
})();
(function() {
    let radarData_foods_radar = null;
    let selectedVariables_foods_radar = ["Vitamin_C","Fiber","Antioxidants","Sweetness","Aroma","Acidity","Juiciness","Firmness","Smoothness","Affordability","Price","Yield","CO2e","Water_use","Pesticides","Biodiversity"];
    let selectedLabels_foods_radar = [];
    let selectedScenario_foods_radar = null;

    const VALUE_COLS = ["Vitamin_C","Fiber","Antioxidants","Sweetness","Aroma","Acidity","Juiciness","Firmness","Smoothness","Affordability","Price","Yield","CO2e","Water_use","Pesticides","Biodiversity"];
    const LABEL_COL = "label";
    const GROUP_MAPPING = {"Acidity":"Sensory","Sweetness":"Sensory","Firmness":"Sensory","Juiciness":"Sensory","Yield":"Economics","Water_use":"Sustainability","Pesticides":"Sustainability","Affordability":"Economics","Antioxidants":"Nutrition","Smoothness":"Sensory","Aroma":"Sensory","Biodiversity":"Sustainability","CO2e":"Sustainability","Price":"Economics","Vitamin_C":"Nutrition","Fiber":"Nutrition"};
    const VARIABLE_LIMITS = {"Antioxidants":10.0,"Vitamin_C":20.0,"Fiber":10.0};
    const SCENARIO_COL = null;
    const COLOR_COL = "category";
    const DEFAULT_COLOR = "#1f77b4";
    const MAX_VALUE = null;
    const MAX_VARIABLES = null;
    const SHOW_LEGEND = true;
    const SHOW_GRID_LABELS = true;
    const VARIABLE_SELECTOR = false;

    // Load data
    loadDataset('foods_data').then(function(data) {
        radarData_foods_radar = data;
        initializeRadarChart_foods_radar();
    }).catch(function(error) {
        console.error('Error loading data:', error);
        document.getElementById('radar_foods_radar').innerHTML =
            '<p style="color: red;">Error loading data: ' + error.message + '</p>';
    });

    function initializeRadarChart_foods_radar() {
        const data = radarData_foods_radar;
        if (!data || data.length === 0) {
            document.getElementById('radar_foods_radar').innerHTML = '<p>No data available</p>';
            return;
        }

        // Populate scenario selector
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_foods_radar');
            if (scenarioSelect) {
                const uniqueScenarios = [...new Set(data.map(d => d[SCENARIO_COL]))].filter(s => s);
                scenarioSelect.innerHTML = '';
                uniqueScenarios.forEach(function(scenario, idx) {
                    const option = document.createElement('option');
                    option.value = scenario;
                    option.text = scenario;
                    if (idx === 0) {
                        option.selected = true;
                        selectedScenario_foods_radar = scenario;
                    }
                    scenarioSelect.appendChild(option);
                });
            }
        }

        // Populate variable selector
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_foods_radar');
            if (varSelect) {
                varSelect.innerHTML = '';
                VALUE_COLS.forEach(function(col) {
                    const option = document.createElement('option');
                    option.value = col;
                    option.text = col.replace(/_/g, ' ');
                    option.selected = selectedVariables_foods_radar.includes(col);
                    varSelect.appendChild(option);
                });
            }
        } else {
            selectedVariables_foods_radar = VALUE_COLS;
        }

        // Populate label selector
        const labelSelect = document.getElementById('label_select_foods_radar');
        if (labelSelect) {
            // Filter by scenario if applicable
            let scenarioData = data;
            if (SCENARIO_COL && selectedScenario_foods_radar) {
                scenarioData = data.filter(d => d[SCENARIO_COL] === selectedScenario_foods_radar);
            }

            const uniqueLabels = [...new Set(scenarioData.map(d => d[LABEL_COL]))].filter(l => l);
            labelSelect.innerHTML = '';
            uniqueLabels.forEach(function(label) {
                const option = document.createElement('option');
                option.value = label;
                option.text = label;
                option.selected = true;
                labelSelect.appendChild(option);
            });
            const maxToSelect = MAX_VARIABLES || uniqueLabels.length;
            selectedLabels_foods_radar = uniqueLabels.slice(0, maxToSelect);

            // Set selected options
            Array.from(labelSelect.options).forEach(function(opt) {
                opt.selected = selectedLabels_foods_radar.includes(opt.value);
            });
        }

        updateRadarChart_foods_radar();
    }

    window.updateRadarChart_foods_radar = function() {
        // Get selected scenario
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_foods_radar');
            if (scenarioSelect) {
                selectedScenario_foods_radar = scenarioSelect.value;
            }
        }

        // Get selected variables
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_foods_radar');
            if (varSelect) {
                selectedVariables_foods_radar = Array.from(varSelect.selectedOptions).map(opt => opt.value);

                if (selectedVariables_foods_radar.length < 3) {
                    document.getElementById('radar_foods_radar').innerHTML =
                        '<p style="color: orange;">Please select at least 3 variables to display a radar chart.</p>';
                    return;
                }
            }
        }

        // Get selected labels
        const labelSelect = document.getElementById('label_select_foods_radar');
        if (labelSelect) {
            selectedLabels_foods_radar = Array.from(labelSelect.selectedOptions).map(opt => opt.value);

            if (selectedLabels_foods_radar.length === 0) {
                document.getElementById('radar_foods_radar').innerHTML =
                    '<p style="color: orange;">Please select at least one item to display.</p>';
                return;
            }
        }

        renderRadarChart_foods_radar(selectedVariables_foods_radar, selectedLabels_foods_radar, selectedScenario_foods_radar);
    }

    function renderRadarChart_foods_radar(variables, labels, scenario) {
        const data = radarData_foods_radar;
        const container = document.getElementById('radar_foods_radar');
        if (!container) return;

        container.innerHTML = '';

        // Filter data by labels and scenario
        let filteredData = data.filter(d => labels.includes(d[LABEL_COL]));

        if (SCENARIO_COL && scenario) {
            filteredData = filteredData.filter(d => d[SCENARIO_COL] === scenario);
        }

        if (filteredData.length === 0) {
            container.innerHTML = '<p>No data matches the selected filters.</p>';
            return;
        }

        // Calculate max value per variable (respecting variable_limits)
        const maxValues = {};
        variables.forEach(function(v) {
            if (VARIABLE_LIMITS.hasOwnProperty(v)) {
                maxValues[v] = VARIABLE_LIMITS[v];
            } else if (MAX_VALUE) {
                maxValues[v] = MAX_VALUE;
            } else {
                // Auto-calculate from data
                let maxVal = 0;
                filteredData.forEach(function(d) {
                    const val = parseFloat(d[v]);
                    if (!isNaN(val) && val > maxVal) {
                        maxVal = val;
                    }
                });
                maxValues[v] = Math.ceil(maxVal * 1.1);
            }
        });

        // Group variables by group_mapping
        const groupedVars = {};
        const ungroupedVars = [];

        variables.forEach(function(v) {
            if (GROUP_MAPPING.hasOwnProperty(v)) {
                const group = GROUP_MAPPING[v];
                if (!groupedVars[group]) {
                    groupedVars[group] = [];
                }
                groupedVars[group].push(v);
            } else {
                ungroupedVars.push(v);
            }
        });

        // Create ordered list of axes with groups
        const axes = [];
        const groupBoundaries = [];  // Track where each group starts and ends
        let currentIndex = 0;

        // Sort groups for consistent ordering
        const sortedGroups = Object.keys(groupedVars).sort();

        sortedGroups.forEach(function(group) {
            const startIdx = currentIndex;
            groupedVars[group].forEach(function(v) {
                axes.push({ name: v, group: group, maxValue: maxValues[v] });
                currentIndex++;
            });
            const endIdx = currentIndex - 1;
            groupBoundaries.push({ group: group, startIdx: startIdx, endIdx: endIdx });
        });

        ungroupedVars.forEach(function(v) {
            axes.push({ name: v, group: null, maxValue: maxValues[v] });
            currentIndex++;
        });

        // Create color mapping
        const colorMap = {};
        if (COLOR_COL) {
            const uniqueColors = [...new Set(filteredData.map(d => d[COLOR_COL]))];
            // D3 v3 API: use d3.scale.category10()
            const colorScale = d3.scale.category10();
            uniqueColors.forEach(function(c, i) {
                colorMap[c] = colorScale(i);
            });
        }

        // Calculate layout
        const numCharts = filteredData.length;
        const chartsPerRow = Math.ceil(Math.sqrt(numCharts));
        const chartSize = Math.min(450, Math.max(350, Math.floor((container.offsetWidth || 800) / chartsPerRow)));

        // Create SVG container
        const svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', Math.ceil(numCharts / chartsPerRow) * chartSize);

        // Draw each radar chart
        filteredData.forEach(function(d, idx) {
            const row = Math.floor(idx / chartsPerRow);
            const col = idx % chartsPerRow;
            const x = col * chartSize;
            const y = row * chartSize;

            const color = COLOR_COL ? (colorMap[d[COLOR_COL]] || DEFAULT_COLOR) : DEFAULT_COLOR;

            drawSingleRadar_foods_radar(svg, d, axes, groupBoundaries, x, y, chartSize, color);
        });

        // Add legend
        if (SHOW_LEGEND && COLOR_COL) {
            addLegend_foods_radar(container, colorMap);
        }
    }

    function drawSingleRadar_foods_radar(svg, dataPoint, axes, groupBoundaries, offsetX, offsetY, size, color) {
        const margin = 60;
        const radius = (size - 2 * margin) / 2;
        const centerX = offsetX + size / 2;
        const centerY = offsetY + size / 2;

        const g = svg.append('g')
            .attr('transform', 'translate(' + centerX + ',' + centerY + ')');

        // Determine overall max for grid (use the max of all variable maxes for consistent grid)
        let gridMax = 0;
        axes.forEach(function(axis) {
            if (axis.maxValue > gridMax) gridMax = axis.maxValue;
        });

        // Draw grid circles
        const levels = 5;
        for (let i = 1; i <= levels; i++) {
            const r = radius * i / levels;
            g.append('circle')
                .attr('r', r)
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);

            if (SHOW_GRID_LABELS && i === levels) {
                g.append('text')
                    .attr('x', 5)
                    .attr('y', -r)
                    .attr('font-size', '10px')
                    .attr('fill', '#666')
                    .text(gridMax.toFixed(1));
            }
        }

        // Draw axes
        const angleSlice = Math.PI * 2 / axes.length;

        axes.forEach(function(axis, i) {
            const angle = angleSlice * i - Math.PI / 2;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            // Draw axis line
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', x)
                .attr('y2', y)
                .attr('stroke', '#999')
                .attr('stroke-width', 1);

            // Draw axis label
            const labelRadius = radius + 15;
            const labelX = labelRadius * Math.cos(angle);
            const labelY = labelRadius * Math.sin(angle);

            g.append('text')
                .attr('x', labelX)
                .attr('y', labelY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(axis.name.replace(/_/g, ' '));
        });

        // Draw group labels using boundaries
        groupBoundaries.forEach(function(boundary) {
            const startAngle = angleSlice * boundary.startIdx - Math.PI / 2;
            const endAngle = angleSlice * (boundary.endIdx + 1) - Math.PI / 2;
            const midAngle = (startAngle + endAngle) / 2;
            const labelRadius = radius + 40;
            const x = labelRadius * Math.cos(midAngle);
            const y = labelRadius * Math.sin(midAngle);

            g.append('text')
                .attr('x', x)
                .attr('y', y)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', '#0066cc')
                .text(boundary.group);
        });

        // Draw data polygon
        const points = [];
        axes.forEach(function(axis, i) {
            const value = parseFloat(dataPoint[axis.name]) || 0;
            // Clamp value to axis max, then normalize by grid max for consistent display
            const clampedValue = Math.min(value, axis.maxValue);
            const normalizedValue = Math.min(Math.max(clampedValue / gridMax, 0), 1);
            const angle = angleSlice * i - Math.PI / 2;
            const r = radius * normalizedValue;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push([x, y]);
        });

        // Close the polygon
        if (points.length > 0) {
            const pathData = 'M' + points.map(p => p.join(',')).join('L') + 'Z';

            g.append('path')
                .attr('d', pathData)
                .attr('fill', color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', color)
                .attr('stroke-width', 2);

            // Draw points
            points.forEach(function(p) {
                g.append('circle')
                    .attr('cx', p[0])
                    .attr('cy', p[1])
                    .attr('r', 3)
                    .attr('fill', color);
            });
        }

        // Add title
        g.append('text')
            .attr('x', 0)
            .attr('y', -radius - 45)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .text(dataPoint[LABEL_COL]);
    }

    function addLegend_foods_radar(container, colorMap) {
        const legendDiv = document.createElement('div');
        legendDiv.style.marginTop = '20px';
        legendDiv.innerHTML = '<strong>Legend:</strong>';

        const legendItems = document.createElement('div');
        legendItems.style.display = 'flex';
        legendItems.style.flexWrap = 'wrap';
        legendItems.style.gap = '15px';
        legendItems.style.marginTop = '10px';

        Object.keys(colorMap).forEach(function(key) {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '5px';

            const colorBox = document.createElement('div');
            colorBox.style.width = '20px';
            colorBox.style.height = '20px';
            colorBox.style.backgroundColor = colorMap[key];
            colorBox.style.border = '1px solid #ccc';

            const label = document.createElement('span');
            label.textContent = key;

            item.appendChild(colorBox);
            item.appendChild(label);
            legendItems.appendChild(item);
        });

        legendDiv.appendChild(legendItems);
        container.appendChild(legendDiv);
    }
})();
(function() {
    let radarData_skills_radar = null;
    let selectedVariables_skills_radar = ["Programming","System_Design","Data_Analysis","Communication","Presentation","Negotiation","Leadership","Project_Management","Team_Building","Product_Knowledge","Market_Knowledge","Technical_Writing"];
    let selectedLabels_skills_radar = [];
    let selectedScenario_skills_radar = null;

    const VALUE_COLS = ["Programming","System_Design","Data_Analysis","Communication","Presentation","Negotiation","Leadership","Project_Management","Team_Building","Product_Knowledge","Market_Knowledge","Technical_Writing"];
    const LABEL_COL = "label";
    const GROUP_MAPPING = {};
    const VARIABLE_LIMITS = {};
    const SCENARIO_COL = null;
    const COLOR_COL = "department";
    const DEFAULT_COLOR = "#1f77b4";
    const MAX_VALUE = 100.0;
    const MAX_VARIABLES = 5;
    const SHOW_LEGEND = true;
    const SHOW_GRID_LABELS = true;
    const VARIABLE_SELECTOR = true;

    // Load data
    loadDataset('skills_data').then(function(data) {
        radarData_skills_radar = data;
        initializeRadarChart_skills_radar();
    }).catch(function(error) {
        console.error('Error loading data:', error);
        document.getElementById('radar_skills_radar').innerHTML =
            '<p style="color: red;">Error loading data: ' + error.message + '</p>';
    });

    function initializeRadarChart_skills_radar() {
        const data = radarData_skills_radar;
        if (!data || data.length === 0) {
            document.getElementById('radar_skills_radar').innerHTML = '<p>No data available</p>';
            return;
        }

        // Populate scenario selector
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_skills_radar');
            if (scenarioSelect) {
                const uniqueScenarios = [...new Set(data.map(d => d[SCENARIO_COL]))].filter(s => s);
                scenarioSelect.innerHTML = '';
                uniqueScenarios.forEach(function(scenario, idx) {
                    const option = document.createElement('option');
                    option.value = scenario;
                    option.text = scenario;
                    if (idx === 0) {
                        option.selected = true;
                        selectedScenario_skills_radar = scenario;
                    }
                    scenarioSelect.appendChild(option);
                });
            }
        }

        // Populate variable selector
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_skills_radar');
            if (varSelect) {
                varSelect.innerHTML = '';
                VALUE_COLS.forEach(function(col) {
                    const option = document.createElement('option');
                    option.value = col;
                    option.text = col.replace(/_/g, ' ');
                    option.selected = selectedVariables_skills_radar.includes(col);
                    varSelect.appendChild(option);
                });
            }
        } else {
            selectedVariables_skills_radar = VALUE_COLS;
        }

        // Populate label selector
        const labelSelect = document.getElementById('label_select_skills_radar');
        if (labelSelect) {
            // Filter by scenario if applicable
            let scenarioData = data;
            if (SCENARIO_COL && selectedScenario_skills_radar) {
                scenarioData = data.filter(d => d[SCENARIO_COL] === selectedScenario_skills_radar);
            }

            const uniqueLabels = [...new Set(scenarioData.map(d => d[LABEL_COL]))].filter(l => l);
            labelSelect.innerHTML = '';
            uniqueLabels.forEach(function(label) {
                const option = document.createElement('option');
                option.value = label;
                option.text = label;
                option.selected = true;
                labelSelect.appendChild(option);
            });
            const maxToSelect = MAX_VARIABLES || uniqueLabels.length;
            selectedLabels_skills_radar = uniqueLabels.slice(0, maxToSelect);

            // Set selected options
            Array.from(labelSelect.options).forEach(function(opt) {
                opt.selected = selectedLabels_skills_radar.includes(opt.value);
            });
        }

        updateRadarChart_skills_radar();
    }

    window.updateRadarChart_skills_radar = function() {
        // Get selected scenario
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_skills_radar');
            if (scenarioSelect) {
                selectedScenario_skills_radar = scenarioSelect.value;
            }
        }

        // Get selected variables
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_skills_radar');
            if (varSelect) {
                selectedVariables_skills_radar = Array.from(varSelect.selectedOptions).map(opt => opt.value);

                if (selectedVariables_skills_radar.length < 3) {
                    document.getElementById('radar_skills_radar').innerHTML =
                        '<p style="color: orange;">Please select at least 3 variables to display a radar chart.</p>';
                    return;
                }
            }
        }

        // Get selected labels
        const labelSelect = document.getElementById('label_select_skills_radar');
        if (labelSelect) {
            selectedLabels_skills_radar = Array.from(labelSelect.selectedOptions).map(opt => opt.value);

            if (selectedLabels_skills_radar.length === 0) {
                document.getElementById('radar_skills_radar').innerHTML =
                    '<p style="color: orange;">Please select at least one item to display.</p>';
                return;
            }
        }

        renderRadarChart_skills_radar(selectedVariables_skills_radar, selectedLabels_skills_radar, selectedScenario_skills_radar);
    }

    function renderRadarChart_skills_radar(variables, labels, scenario) {
        const data = radarData_skills_radar;
        const container = document.getElementById('radar_skills_radar');
        if (!container) return;

        container.innerHTML = '';

        // Filter data by labels and scenario
        let filteredData = data.filter(d => labels.includes(d[LABEL_COL]));

        if (SCENARIO_COL && scenario) {
            filteredData = filteredData.filter(d => d[SCENARIO_COL] === scenario);
        }

        if (filteredData.length === 0) {
            container.innerHTML = '<p>No data matches the selected filters.</p>';
            return;
        }

        // Calculate max value per variable (respecting variable_limits)
        const maxValues = {};
        variables.forEach(function(v) {
            if (VARIABLE_LIMITS.hasOwnProperty(v)) {
                maxValues[v] = VARIABLE_LIMITS[v];
            } else if (MAX_VALUE) {
                maxValues[v] = MAX_VALUE;
            } else {
                // Auto-calculate from data
                let maxVal = 0;
                filteredData.forEach(function(d) {
                    const val = parseFloat(d[v]);
                    if (!isNaN(val) && val > maxVal) {
                        maxVal = val;
                    }
                });
                maxValues[v] = Math.ceil(maxVal * 1.1);
            }
        });

        // Group variables by group_mapping
        const groupedVars = {};
        const ungroupedVars = [];

        variables.forEach(function(v) {
            if (GROUP_MAPPING.hasOwnProperty(v)) {
                const group = GROUP_MAPPING[v];
                if (!groupedVars[group]) {
                    groupedVars[group] = [];
                }
                groupedVars[group].push(v);
            } else {
                ungroupedVars.push(v);
            }
        });

        // Create ordered list of axes with groups
        const axes = [];
        const groupBoundaries = [];  // Track where each group starts and ends
        let currentIndex = 0;

        // Sort groups for consistent ordering
        const sortedGroups = Object.keys(groupedVars).sort();

        sortedGroups.forEach(function(group) {
            const startIdx = currentIndex;
            groupedVars[group].forEach(function(v) {
                axes.push({ name: v, group: group, maxValue: maxValues[v] });
                currentIndex++;
            });
            const endIdx = currentIndex - 1;
            groupBoundaries.push({ group: group, startIdx: startIdx, endIdx: endIdx });
        });

        ungroupedVars.forEach(function(v) {
            axes.push({ name: v, group: null, maxValue: maxValues[v] });
            currentIndex++;
        });

        // Create color mapping
        const colorMap = {};
        if (COLOR_COL) {
            const uniqueColors = [...new Set(filteredData.map(d => d[COLOR_COL]))];
            // D3 v3 API: use d3.scale.category10()
            const colorScale = d3.scale.category10();
            uniqueColors.forEach(function(c, i) {
                colorMap[c] = colorScale(i);
            });
        }

        // Calculate layout
        const numCharts = filteredData.length;
        const chartsPerRow = Math.ceil(Math.sqrt(numCharts));
        const chartSize = Math.min(450, Math.max(350, Math.floor((container.offsetWidth || 800) / chartsPerRow)));

        // Create SVG container
        const svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', Math.ceil(numCharts / chartsPerRow) * chartSize);

        // Draw each radar chart
        filteredData.forEach(function(d, idx) {
            const row = Math.floor(idx / chartsPerRow);
            const col = idx % chartsPerRow;
            const x = col * chartSize;
            const y = row * chartSize;

            const color = COLOR_COL ? (colorMap[d[COLOR_COL]] || DEFAULT_COLOR) : DEFAULT_COLOR;

            drawSingleRadar_skills_radar(svg, d, axes, groupBoundaries, x, y, chartSize, color);
        });

        // Add legend
        if (SHOW_LEGEND && COLOR_COL) {
            addLegend_skills_radar(container, colorMap);
        }
    }

    function drawSingleRadar_skills_radar(svg, dataPoint, axes, groupBoundaries, offsetX, offsetY, size, color) {
        const margin = 60;
        const radius = (size - 2 * margin) / 2;
        const centerX = offsetX + size / 2;
        const centerY = offsetY + size / 2;

        const g = svg.append('g')
            .attr('transform', 'translate(' + centerX + ',' + centerY + ')');

        // Determine overall max for grid (use the max of all variable maxes for consistent grid)
        let gridMax = 0;
        axes.forEach(function(axis) {
            if (axis.maxValue > gridMax) gridMax = axis.maxValue;
        });

        // Draw grid circles
        const levels = 5;
        for (let i = 1; i <= levels; i++) {
            const r = radius * i / levels;
            g.append('circle')
                .attr('r', r)
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);

            if (SHOW_GRID_LABELS && i === levels) {
                g.append('text')
                    .attr('x', 5)
                    .attr('y', -r)
                    .attr('font-size', '10px')
                    .attr('fill', '#666')
                    .text(gridMax.toFixed(1));
            }
        }

        // Draw axes
        const angleSlice = Math.PI * 2 / axes.length;

        axes.forEach(function(axis, i) {
            const angle = angleSlice * i - Math.PI / 2;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            // Draw axis line
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', x)
                .attr('y2', y)
                .attr('stroke', '#999')
                .attr('stroke-width', 1);

            // Draw axis label
            const labelRadius = radius + 15;
            const labelX = labelRadius * Math.cos(angle);
            const labelY = labelRadius * Math.sin(angle);

            g.append('text')
                .attr('x', labelX)
                .attr('y', labelY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(axis.name.replace(/_/g, ' '));
        });

        // Draw group labels using boundaries
        groupBoundaries.forEach(function(boundary) {
            const startAngle = angleSlice * boundary.startIdx - Math.PI / 2;
            const endAngle = angleSlice * (boundary.endIdx + 1) - Math.PI / 2;
            const midAngle = (startAngle + endAngle) / 2;
            const labelRadius = radius + 40;
            const x = labelRadius * Math.cos(midAngle);
            const y = labelRadius * Math.sin(midAngle);

            g.append('text')
                .attr('x', x)
                .attr('y', y)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', '#0066cc')
                .text(boundary.group);
        });

        // Draw data polygon
        const points = [];
        axes.forEach(function(axis, i) {
            const value = parseFloat(dataPoint[axis.name]) || 0;
            // Clamp value to axis max, then normalize by grid max for consistent display
            const clampedValue = Math.min(value, axis.maxValue);
            const normalizedValue = Math.min(Math.max(clampedValue / gridMax, 0), 1);
            const angle = angleSlice * i - Math.PI / 2;
            const r = radius * normalizedValue;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push([x, y]);
        });

        // Close the polygon
        if (points.length > 0) {
            const pathData = 'M' + points.map(p => p.join(',')).join('L') + 'Z';

            g.append('path')
                .attr('d', pathData)
                .attr('fill', color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', color)
                .attr('stroke-width', 2);

            // Draw points
            points.forEach(function(p) {
                g.append('circle')
                    .attr('cx', p[0])
                    .attr('cy', p[1])
                    .attr('r', 3)
                    .attr('fill', color);
            });
        }

        // Add title
        g.append('text')
            .attr('x', 0)
            .attr('y', -radius - 45)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .text(dataPoint[LABEL_COL]);
    }

    function addLegend_skills_radar(container, colorMap) {
        const legendDiv = document.createElement('div');
        legendDiv.style.marginTop = '20px';
        legendDiv.innerHTML = '<strong>Legend:</strong>';

        const legendItems = document.createElement('div');
        legendItems.style.display = 'flex';
        legendItems.style.flexWrap = 'wrap';
        legendItems.style.gap = '15px';
        legendItems.style.marginTop = '10px';

        Object.keys(colorMap).forEach(function(key) {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '5px';

            const colorBox = document.createElement('div');
            colorBox.style.width = '20px';
            colorBox.style.height = '20px';
            colorBox.style.backgroundColor = colorMap[key];
            colorBox.style.border = '1px solid #ccc';

            const label = document.createElement('span');
            label.textContent = key;

            item.appendChild(colorBox);
            item.appendChild(label);
            legendItems.appendChild(item);
        });

        legendDiv.appendChild(legendItems);
        container.appendChild(legendDiv);
    }
})();
(function() {
    let radarData_universities_radar = null;
    let selectedVariables_universities_radar = ["Academic_Reputation","Research_Output","Faculty_Quality","Industry_Connections","International_Outlook","Student_Satisfaction"];
    let selectedLabels_universities_radar = [];
    let selectedScenario_universities_radar = null;

    const VALUE_COLS = ["Academic_Reputation","Research_Output","Faculty_Quality","Industry_Connections","International_Outlook","Student_Satisfaction"];
    const LABEL_COL = "label";
    const GROUP_MAPPING = {};
    const VARIABLE_LIMITS = {};
    const SCENARIO_COL = "scenario";
    const COLOR_COL = "region";
    const DEFAULT_COLOR = "#1f77b4";
    const MAX_VALUE = 100.0;
    const MAX_VARIABLES = null;
    const SHOW_LEGEND = true;
    const SHOW_GRID_LABELS = true;
    const VARIABLE_SELECTOR = false;

    // Load data
    loadDataset('universities_data').then(function(data) {
        radarData_universities_radar = data;
        initializeRadarChart_universities_radar();
    }).catch(function(error) {
        console.error('Error loading data:', error);
        document.getElementById('radar_universities_radar').innerHTML =
            '<p style="color: red;">Error loading data: ' + error.message + '</p>';
    });

    function initializeRadarChart_universities_radar() {
        const data = radarData_universities_radar;
        if (!data || data.length === 0) {
            document.getElementById('radar_universities_radar').innerHTML = '<p>No data available</p>';
            return;
        }

        // Populate scenario selector
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_universities_radar');
            if (scenarioSelect) {
                const uniqueScenarios = [...new Set(data.map(d => d[SCENARIO_COL]))].filter(s => s);
                scenarioSelect.innerHTML = '';
                uniqueScenarios.forEach(function(scenario, idx) {
                    const option = document.createElement('option');
                    option.value = scenario;
                    option.text = scenario;
                    if (idx === 0) {
                        option.selected = true;
                        selectedScenario_universities_radar = scenario;
                    }
                    scenarioSelect.appendChild(option);
                });
            }
        }

        // Populate variable selector
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_universities_radar');
            if (varSelect) {
                varSelect.innerHTML = '';
                VALUE_COLS.forEach(function(col) {
                    const option = document.createElement('option');
                    option.value = col;
                    option.text = col.replace(/_/g, ' ');
                    option.selected = selectedVariables_universities_radar.includes(col);
                    varSelect.appendChild(option);
                });
            }
        } else {
            selectedVariables_universities_radar = VALUE_COLS;
        }

        // Populate label selector
        const labelSelect = document.getElementById('label_select_universities_radar');
        if (labelSelect) {
            // Filter by scenario if applicable
            let scenarioData = data;
            if (SCENARIO_COL && selectedScenario_universities_radar) {
                scenarioData = data.filter(d => d[SCENARIO_COL] === selectedScenario_universities_radar);
            }

            const uniqueLabels = [...new Set(scenarioData.map(d => d[LABEL_COL]))].filter(l => l);
            labelSelect.innerHTML = '';
            uniqueLabels.forEach(function(label) {
                const option = document.createElement('option');
                option.value = label;
                option.text = label;
                option.selected = true;
                labelSelect.appendChild(option);
            });
            const maxToSelect = MAX_VARIABLES || uniqueLabels.length;
            selectedLabels_universities_radar = uniqueLabels.slice(0, maxToSelect);

            // Set selected options
            Array.from(labelSelect.options).forEach(function(opt) {
                opt.selected = selectedLabels_universities_radar.includes(opt.value);
            });
        }

        updateRadarChart_universities_radar();
    }

    window.updateRadarChart_universities_radar = function() {
        // Get selected scenario
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_universities_radar');
            if (scenarioSelect) {
                selectedScenario_universities_radar = scenarioSelect.value;
            }
        }

        // Get selected variables
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_universities_radar');
            if (varSelect) {
                selectedVariables_universities_radar = Array.from(varSelect.selectedOptions).map(opt => opt.value);

                if (selectedVariables_universities_radar.length < 3) {
                    document.getElementById('radar_universities_radar').innerHTML =
                        '<p style="color: orange;">Please select at least 3 variables to display a radar chart.</p>';
                    return;
                }
            }
        }

        // Get selected labels
        const labelSelect = document.getElementById('label_select_universities_radar');
        if (labelSelect) {
            selectedLabels_universities_radar = Array.from(labelSelect.selectedOptions).map(opt => opt.value);

            if (selectedLabels_universities_radar.length === 0) {
                document.getElementById('radar_universities_radar').innerHTML =
                    '<p style="color: orange;">Please select at least one item to display.</p>';
                return;
            }
        }

        renderRadarChart_universities_radar(selectedVariables_universities_radar, selectedLabels_universities_radar, selectedScenario_universities_radar);
    }

    function renderRadarChart_universities_radar(variables, labels, scenario) {
        const data = radarData_universities_radar;
        const container = document.getElementById('radar_universities_radar');
        if (!container) return;

        container.innerHTML = '';

        // Filter data by labels and scenario
        let filteredData = data.filter(d => labels.includes(d[LABEL_COL]));

        if (SCENARIO_COL && scenario) {
            filteredData = filteredData.filter(d => d[SCENARIO_COL] === scenario);
        }

        if (filteredData.length === 0) {
            container.innerHTML = '<p>No data matches the selected filters.</p>';
            return;
        }

        // Calculate max value per variable (respecting variable_limits)
        const maxValues = {};
        variables.forEach(function(v) {
            if (VARIABLE_LIMITS.hasOwnProperty(v)) {
                maxValues[v] = VARIABLE_LIMITS[v];
            } else if (MAX_VALUE) {
                maxValues[v] = MAX_VALUE;
            } else {
                // Auto-calculate from data
                let maxVal = 0;
                filteredData.forEach(function(d) {
                    const val = parseFloat(d[v]);
                    if (!isNaN(val) && val > maxVal) {
                        maxVal = val;
                    }
                });
                maxValues[v] = Math.ceil(maxVal * 1.1);
            }
        });

        // Group variables by group_mapping
        const groupedVars = {};
        const ungroupedVars = [];

        variables.forEach(function(v) {
            if (GROUP_MAPPING.hasOwnProperty(v)) {
                const group = GROUP_MAPPING[v];
                if (!groupedVars[group]) {
                    groupedVars[group] = [];
                }
                groupedVars[group].push(v);
            } else {
                ungroupedVars.push(v);
            }
        });

        // Create ordered list of axes with groups
        const axes = [];
        const groupBoundaries = [];  // Track where each group starts and ends
        let currentIndex = 0;

        // Sort groups for consistent ordering
        const sortedGroups = Object.keys(groupedVars).sort();

        sortedGroups.forEach(function(group) {
            const startIdx = currentIndex;
            groupedVars[group].forEach(function(v) {
                axes.push({ name: v, group: group, maxValue: maxValues[v] });
                currentIndex++;
            });
            const endIdx = currentIndex - 1;
            groupBoundaries.push({ group: group, startIdx: startIdx, endIdx: endIdx });
        });

        ungroupedVars.forEach(function(v) {
            axes.push({ name: v, group: null, maxValue: maxValues[v] });
            currentIndex++;
        });

        // Create color mapping
        const colorMap = {};
        if (COLOR_COL) {
            const uniqueColors = [...new Set(filteredData.map(d => d[COLOR_COL]))];
            // D3 v3 API: use d3.scale.category10()
            const colorScale = d3.scale.category10();
            uniqueColors.forEach(function(c, i) {
                colorMap[c] = colorScale(i);
            });
        }

        // Calculate layout
        const numCharts = filteredData.length;
        const chartsPerRow = Math.ceil(Math.sqrt(numCharts));
        const chartSize = Math.min(450, Math.max(350, Math.floor((container.offsetWidth || 800) / chartsPerRow)));

        // Create SVG container
        const svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', Math.ceil(numCharts / chartsPerRow) * chartSize);

        // Draw each radar chart
        filteredData.forEach(function(d, idx) {
            const row = Math.floor(idx / chartsPerRow);
            const col = idx % chartsPerRow;
            const x = col * chartSize;
            const y = row * chartSize;

            const color = COLOR_COL ? (colorMap[d[COLOR_COL]] || DEFAULT_COLOR) : DEFAULT_COLOR;

            drawSingleRadar_universities_radar(svg, d, axes, groupBoundaries, x, y, chartSize, color);
        });

        // Add legend
        if (SHOW_LEGEND && COLOR_COL) {
            addLegend_universities_radar(container, colorMap);
        }
    }

    function drawSingleRadar_universities_radar(svg, dataPoint, axes, groupBoundaries, offsetX, offsetY, size, color) {
        const margin = 60;
        const radius = (size - 2 * margin) / 2;
        const centerX = offsetX + size / 2;
        const centerY = offsetY + size / 2;

        const g = svg.append('g')
            .attr('transform', 'translate(' + centerX + ',' + centerY + ')');

        // Determine overall max for grid (use the max of all variable maxes for consistent grid)
        let gridMax = 0;
        axes.forEach(function(axis) {
            if (axis.maxValue > gridMax) gridMax = axis.maxValue;
        });

        // Draw grid circles
        const levels = 5;
        for (let i = 1; i <= levels; i++) {
            const r = radius * i / levels;
            g.append('circle')
                .attr('r', r)
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);

            if (SHOW_GRID_LABELS && i === levels) {
                g.append('text')
                    .attr('x', 5)
                    .attr('y', -r)
                    .attr('font-size', '10px')
                    .attr('fill', '#666')
                    .text(gridMax.toFixed(1));
            }
        }

        // Draw axes
        const angleSlice = Math.PI * 2 / axes.length;

        axes.forEach(function(axis, i) {
            const angle = angleSlice * i - Math.PI / 2;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            // Draw axis line
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', x)
                .attr('y2', y)
                .attr('stroke', '#999')
                .attr('stroke-width', 1);

            // Draw axis label
            const labelRadius = radius + 15;
            const labelX = labelRadius * Math.cos(angle);
            const labelY = labelRadius * Math.sin(angle);

            g.append('text')
                .attr('x', labelX)
                .attr('y', labelY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(axis.name.replace(/_/g, ' '));
        });

        // Draw group labels using boundaries
        groupBoundaries.forEach(function(boundary) {
            const startAngle = angleSlice * boundary.startIdx - Math.PI / 2;
            const endAngle = angleSlice * (boundary.endIdx + 1) - Math.PI / 2;
            const midAngle = (startAngle + endAngle) / 2;
            const labelRadius = radius + 40;
            const x = labelRadius * Math.cos(midAngle);
            const y = labelRadius * Math.sin(midAngle);

            g.append('text')
                .attr('x', x)
                .attr('y', y)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', '#0066cc')
                .text(boundary.group);
        });

        // Draw data polygon
        const points = [];
        axes.forEach(function(axis, i) {
            const value = parseFloat(dataPoint[axis.name]) || 0;
            // Clamp value to axis max, then normalize by grid max for consistent display
            const clampedValue = Math.min(value, axis.maxValue);
            const normalizedValue = Math.min(Math.max(clampedValue / gridMax, 0), 1);
            const angle = angleSlice * i - Math.PI / 2;
            const r = radius * normalizedValue;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push([x, y]);
        });

        // Close the polygon
        if (points.length > 0) {
            const pathData = 'M' + points.map(p => p.join(',')).join('L') + 'Z';

            g.append('path')
                .attr('d', pathData)
                .attr('fill', color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', color)
                .attr('stroke-width', 2);

            // Draw points
            points.forEach(function(p) {
                g.append('circle')
                    .attr('cx', p[0])
                    .attr('cy', p[1])
                    .attr('r', 3)
                    .attr('fill', color);
            });
        }

        // Add title
        g.append('text')
            .attr('x', 0)
            .attr('y', -radius - 45)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .text(dataPoint[LABEL_COL]);
    }

    function addLegend_universities_radar(container, colorMap) {
        const legendDiv = document.createElement('div');
        legendDiv.style.marginTop = '20px';
        legendDiv.innerHTML = '<strong>Legend:</strong>';

        const legendItems = document.createElement('div');
        legendItems.style.display = 'flex';
        legendItems.style.flexWrap = 'wrap';
        legendItems.style.gap = '15px';
        legendItems.style.marginTop = '10px';

        Object.keys(colorMap).forEach(function(key) {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '5px';

            const colorBox = document.createElement('div');
            colorBox.style.width = '20px';
            colorBox.style.height = '20px';
            colorBox.style.backgroundColor = colorMap[key];
            colorBox.style.border = '1px solid #ccc';

            const label = document.createElement('span');
            label.textContent = key;

            item.appendChild(colorBox);
            item.appendChild(label);
            legendItems.appendChild(item);
        });

        legendDiv.appendChild(legendItems);
        container.appendChild(legendDiv);
    }
})();
(function() {
    let radarData_investments_radar = null;
    let selectedVariables_investments_radar = ["Expected_Return","Risk_Adjusted_Return","Liquidity","Diversification","Tax_Efficiency","Inflation_Protection"];
    let selectedLabels_investments_radar = [];
    let selectedScenario_investments_radar = null;

    const VALUE_COLS = ["Expected_Return","Risk_Adjusted_Return","Liquidity","Diversification","Tax_Efficiency","Inflation_Protection"];
    const LABEL_COL = "label";
    const GROUP_MAPPING = {};
    const VARIABLE_LIMITS = {};
    const SCENARIO_COL = null;
    const COLOR_COL = "asset_class";
    const DEFAULT_COLOR = "#1f77b4";
    const MAX_VALUE = 10.0;
    const MAX_VARIABLES = null;
    const SHOW_LEGEND = true;
    const SHOW_GRID_LABELS = true;
    const VARIABLE_SELECTOR = false;

    // Load data
    loadDataset('investments_data').then(function(data) {
        radarData_investments_radar = data;
        initializeRadarChart_investments_radar();
    }).catch(function(error) {
        console.error('Error loading data:', error);
        document.getElementById('radar_investments_radar').innerHTML =
            '<p style="color: red;">Error loading data: ' + error.message + '</p>';
    });

    function initializeRadarChart_investments_radar() {
        const data = radarData_investments_radar;
        if (!data || data.length === 0) {
            document.getElementById('radar_investments_radar').innerHTML = '<p>No data available</p>';
            return;
        }

        // Populate scenario selector
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_investments_radar');
            if (scenarioSelect) {
                const uniqueScenarios = [...new Set(data.map(d => d[SCENARIO_COL]))].filter(s => s);
                scenarioSelect.innerHTML = '';
                uniqueScenarios.forEach(function(scenario, idx) {
                    const option = document.createElement('option');
                    option.value = scenario;
                    option.text = scenario;
                    if (idx === 0) {
                        option.selected = true;
                        selectedScenario_investments_radar = scenario;
                    }
                    scenarioSelect.appendChild(option);
                });
            }
        }

        // Populate variable selector
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_investments_radar');
            if (varSelect) {
                varSelect.innerHTML = '';
                VALUE_COLS.forEach(function(col) {
                    const option = document.createElement('option');
                    option.value = col;
                    option.text = col.replace(/_/g, ' ');
                    option.selected = selectedVariables_investments_radar.includes(col);
                    varSelect.appendChild(option);
                });
            }
        } else {
            selectedVariables_investments_radar = VALUE_COLS;
        }

        // Populate label selector
        const labelSelect = document.getElementById('label_select_investments_radar');
        if (labelSelect) {
            // Filter by scenario if applicable
            let scenarioData = data;
            if (SCENARIO_COL && selectedScenario_investments_radar) {
                scenarioData = data.filter(d => d[SCENARIO_COL] === selectedScenario_investments_radar);
            }

            const uniqueLabels = [...new Set(scenarioData.map(d => d[LABEL_COL]))].filter(l => l);
            labelSelect.innerHTML = '';
            uniqueLabels.forEach(function(label) {
                const option = document.createElement('option');
                option.value = label;
                option.text = label;
                option.selected = true;
                labelSelect.appendChild(option);
            });
            const maxToSelect = MAX_VARIABLES || uniqueLabels.length;
            selectedLabels_investments_radar = uniqueLabels.slice(0, maxToSelect);

            // Set selected options
            Array.from(labelSelect.options).forEach(function(opt) {
                opt.selected = selectedLabels_investments_radar.includes(opt.value);
            });
        }

        updateRadarChart_investments_radar();
    }

    window.updateRadarChart_investments_radar = function() {
        // Get selected scenario
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_investments_radar');
            if (scenarioSelect) {
                selectedScenario_investments_radar = scenarioSelect.value;
            }
        }

        // Get selected variables
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_investments_radar');
            if (varSelect) {
                selectedVariables_investments_radar = Array.from(varSelect.selectedOptions).map(opt => opt.value);

                if (selectedVariables_investments_radar.length < 3) {
                    document.getElementById('radar_investments_radar').innerHTML =
                        '<p style="color: orange;">Please select at least 3 variables to display a radar chart.</p>';
                    return;
                }
            }
        }

        // Get selected labels
        const labelSelect = document.getElementById('label_select_investments_radar');
        if (labelSelect) {
            selectedLabels_investments_radar = Array.from(labelSelect.selectedOptions).map(opt => opt.value);

            if (selectedLabels_investments_radar.length === 0) {
                document.getElementById('radar_investments_radar').innerHTML =
                    '<p style="color: orange;">Please select at least one item to display.</p>';
                return;
            }
        }

        renderRadarChart_investments_radar(selectedVariables_investments_radar, selectedLabels_investments_radar, selectedScenario_investments_radar);
    }

    function renderRadarChart_investments_radar(variables, labels, scenario) {
        const data = radarData_investments_radar;
        const container = document.getElementById('radar_investments_radar');
        if (!container) return;

        container.innerHTML = '';

        // Filter data by labels and scenario
        let filteredData = data.filter(d => labels.includes(d[LABEL_COL]));

        if (SCENARIO_COL && scenario) {
            filteredData = filteredData.filter(d => d[SCENARIO_COL] === scenario);
        }

        if (filteredData.length === 0) {
            container.innerHTML = '<p>No data matches the selected filters.</p>';
            return;
        }

        // Calculate max value per variable (respecting variable_limits)
        const maxValues = {};
        variables.forEach(function(v) {
            if (VARIABLE_LIMITS.hasOwnProperty(v)) {
                maxValues[v] = VARIABLE_LIMITS[v];
            } else if (MAX_VALUE) {
                maxValues[v] = MAX_VALUE;
            } else {
                // Auto-calculate from data
                let maxVal = 0;
                filteredData.forEach(function(d) {
                    const val = parseFloat(d[v]);
                    if (!isNaN(val) && val > maxVal) {
                        maxVal = val;
                    }
                });
                maxValues[v] = Math.ceil(maxVal * 1.1);
            }
        });

        // Group variables by group_mapping
        const groupedVars = {};
        const ungroupedVars = [];

        variables.forEach(function(v) {
            if (GROUP_MAPPING.hasOwnProperty(v)) {
                const group = GROUP_MAPPING[v];
                if (!groupedVars[group]) {
                    groupedVars[group] = [];
                }
                groupedVars[group].push(v);
            } else {
                ungroupedVars.push(v);
            }
        });

        // Create ordered list of axes with groups
        const axes = [];
        const groupBoundaries = [];  // Track where each group starts and ends
        let currentIndex = 0;

        // Sort groups for consistent ordering
        const sortedGroups = Object.keys(groupedVars).sort();

        sortedGroups.forEach(function(group) {
            const startIdx = currentIndex;
            groupedVars[group].forEach(function(v) {
                axes.push({ name: v, group: group, maxValue: maxValues[v] });
                currentIndex++;
            });
            const endIdx = currentIndex - 1;
            groupBoundaries.push({ group: group, startIdx: startIdx, endIdx: endIdx });
        });

        ungroupedVars.forEach(function(v) {
            axes.push({ name: v, group: null, maxValue: maxValues[v] });
            currentIndex++;
        });

        // Create color mapping
        const colorMap = {};
        if (COLOR_COL) {
            const uniqueColors = [...new Set(filteredData.map(d => d[COLOR_COL]))];
            // D3 v3 API: use d3.scale.category10()
            const colorScale = d3.scale.category10();
            uniqueColors.forEach(function(c, i) {
                colorMap[c] = colorScale(i);
            });
        }

        // Calculate layout
        const numCharts = filteredData.length;
        const chartsPerRow = Math.ceil(Math.sqrt(numCharts));
        const chartSize = Math.min(450, Math.max(350, Math.floor((container.offsetWidth || 800) / chartsPerRow)));

        // Create SVG container
        const svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', Math.ceil(numCharts / chartsPerRow) * chartSize);

        // Draw each radar chart
        filteredData.forEach(function(d, idx) {
            const row = Math.floor(idx / chartsPerRow);
            const col = idx % chartsPerRow;
            const x = col * chartSize;
            const y = row * chartSize;

            const color = COLOR_COL ? (colorMap[d[COLOR_COL]] || DEFAULT_COLOR) : DEFAULT_COLOR;

            drawSingleRadar_investments_radar(svg, d, axes, groupBoundaries, x, y, chartSize, color);
        });

        // Add legend
        if (SHOW_LEGEND && COLOR_COL) {
            addLegend_investments_radar(container, colorMap);
        }
    }

    function drawSingleRadar_investments_radar(svg, dataPoint, axes, groupBoundaries, offsetX, offsetY, size, color) {
        const margin = 60;
        const radius = (size - 2 * margin) / 2;
        const centerX = offsetX + size / 2;
        const centerY = offsetY + size / 2;

        const g = svg.append('g')
            .attr('transform', 'translate(' + centerX + ',' + centerY + ')');

        // Determine overall max for grid (use the max of all variable maxes for consistent grid)
        let gridMax = 0;
        axes.forEach(function(axis) {
            if (axis.maxValue > gridMax) gridMax = axis.maxValue;
        });

        // Draw grid circles
        const levels = 5;
        for (let i = 1; i <= levels; i++) {
            const r = radius * i / levels;
            g.append('circle')
                .attr('r', r)
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);

            if (SHOW_GRID_LABELS && i === levels) {
                g.append('text')
                    .attr('x', 5)
                    .attr('y', -r)
                    .attr('font-size', '10px')
                    .attr('fill', '#666')
                    .text(gridMax.toFixed(1));
            }
        }

        // Draw axes
        const angleSlice = Math.PI * 2 / axes.length;

        axes.forEach(function(axis, i) {
            const angle = angleSlice * i - Math.PI / 2;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            // Draw axis line
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', x)
                .attr('y2', y)
                .attr('stroke', '#999')
                .attr('stroke-width', 1);

            // Draw axis label
            const labelRadius = radius + 15;
            const labelX = labelRadius * Math.cos(angle);
            const labelY = labelRadius * Math.sin(angle);

            g.append('text')
                .attr('x', labelX)
                .attr('y', labelY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(axis.name.replace(/_/g, ' '));
        });

        // Draw group labels using boundaries
        groupBoundaries.forEach(function(boundary) {
            const startAngle = angleSlice * boundary.startIdx - Math.PI / 2;
            const endAngle = angleSlice * (boundary.endIdx + 1) - Math.PI / 2;
            const midAngle = (startAngle + endAngle) / 2;
            const labelRadius = radius + 40;
            const x = labelRadius * Math.cos(midAngle);
            const y = labelRadius * Math.sin(midAngle);

            g.append('text')
                .attr('x', x)
                .attr('y', y)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', '#0066cc')
                .text(boundary.group);
        });

        // Draw data polygon
        const points = [];
        axes.forEach(function(axis, i) {
            const value = parseFloat(dataPoint[axis.name]) || 0;
            // Clamp value to axis max, then normalize by grid max for consistent display
            const clampedValue = Math.min(value, axis.maxValue);
            const normalizedValue = Math.min(Math.max(clampedValue / gridMax, 0), 1);
            const angle = angleSlice * i - Math.PI / 2;
            const r = radius * normalizedValue;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push([x, y]);
        });

        // Close the polygon
        if (points.length > 0) {
            const pathData = 'M' + points.map(p => p.join(',')).join('L') + 'Z';

            g.append('path')
                .attr('d', pathData)
                .attr('fill', color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', color)
                .attr('stroke-width', 2);

            // Draw points
            points.forEach(function(p) {
                g.append('circle')
                    .attr('cx', p[0])
                    .attr('cy', p[1])
                    .attr('r', 3)
                    .attr('fill', color);
            });
        }

        // Add title
        g.append('text')
            .attr('x', 0)
            .attr('y', -radius - 45)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .text(dataPoint[LABEL_COL]);
    }

    function addLegend_investments_radar(container, colorMap) {
        const legendDiv = document.createElement('div');
        legendDiv.style.marginTop = '20px';
        legendDiv.innerHTML = '<strong>Legend:</strong>';

        const legendItems = document.createElement('div');
        legendItems.style.display = 'flex';
        legendItems.style.flexWrap = 'wrap';
        legendItems.style.gap = '15px';
        legendItems.style.marginTop = '10px';

        Object.keys(colorMap).forEach(function(key) {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '5px';

            const colorBox = document.createElement('div');
            colorBox.style.width = '20px';
            colorBox.style.height = '20px';
            colorBox.style.backgroundColor = colorMap[key];
            colorBox.style.border = '1px solid #ccc';

            const label = document.createElement('span');
            label.textContent = key;

            item.appendChild(colorBox);
            item.appendChild(label);
            legendItems.appendChild(item);
        });

        legendDiv.appendChild(legendItems);
        container.appendChild(legendDiv);
    }
})();
(function() {
    let radarData_cars_radar = null;
    let selectedVariables_cars_radar = ["Performance","Efficiency","Interior_Quality","Technology","Safety","Value"];
    let selectedLabels_cars_radar = [];
    let selectedScenario_cars_radar = null;

    const VALUE_COLS = ["Performance","Efficiency","Interior_Quality","Technology","Safety","Value"];
    const LABEL_COL = "label";
    const GROUP_MAPPING = {};
    const VARIABLE_LIMITS = {};
    const SCENARIO_COL = null;
    const COLOR_COL = "category";
    const DEFAULT_COLOR = "#1f77b4";
    const MAX_VALUE = 100.0;
    const MAX_VARIABLES = null;
    const SHOW_LEGEND = true;
    const SHOW_GRID_LABELS = true;
    const VARIABLE_SELECTOR = false;

    // Load data
    loadDataset('cars.specifications').then(function(data) {
        radarData_cars_radar = data;
        initializeRadarChart_cars_radar();
    }).catch(function(error) {
        console.error('Error loading data:', error);
        document.getElementById('radar_cars_radar').innerHTML =
            '<p style="color: red;">Error loading data: ' + error.message + '</p>';
    });

    function initializeRadarChart_cars_radar() {
        const data = radarData_cars_radar;
        if (!data || data.length === 0) {
            document.getElementById('radar_cars_radar').innerHTML = '<p>No data available</p>';
            return;
        }

        // Populate scenario selector
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_cars_radar');
            if (scenarioSelect) {
                const uniqueScenarios = [...new Set(data.map(d => d[SCENARIO_COL]))].filter(s => s);
                scenarioSelect.innerHTML = '';
                uniqueScenarios.forEach(function(scenario, idx) {
                    const option = document.createElement('option');
                    option.value = scenario;
                    option.text = scenario;
                    if (idx === 0) {
                        option.selected = true;
                        selectedScenario_cars_radar = scenario;
                    }
                    scenarioSelect.appendChild(option);
                });
            }
        }

        // Populate variable selector
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_cars_radar');
            if (varSelect) {
                varSelect.innerHTML = '';
                VALUE_COLS.forEach(function(col) {
                    const option = document.createElement('option');
                    option.value = col;
                    option.text = col.replace(/_/g, ' ');
                    option.selected = selectedVariables_cars_radar.includes(col);
                    varSelect.appendChild(option);
                });
            }
        } else {
            selectedVariables_cars_radar = VALUE_COLS;
        }

        // Populate label selector
        const labelSelect = document.getElementById('label_select_cars_radar');
        if (labelSelect) {
            // Filter by scenario if applicable
            let scenarioData = data;
            if (SCENARIO_COL && selectedScenario_cars_radar) {
                scenarioData = data.filter(d => d[SCENARIO_COL] === selectedScenario_cars_radar);
            }

            const uniqueLabels = [...new Set(scenarioData.map(d => d[LABEL_COL]))].filter(l => l);
            labelSelect.innerHTML = '';
            uniqueLabels.forEach(function(label) {
                const option = document.createElement('option');
                option.value = label;
                option.text = label;
                option.selected = true;
                labelSelect.appendChild(option);
            });
            const maxToSelect = MAX_VARIABLES || uniqueLabels.length;
            selectedLabels_cars_radar = uniqueLabels.slice(0, maxToSelect);

            // Set selected options
            Array.from(labelSelect.options).forEach(function(opt) {
                opt.selected = selectedLabels_cars_radar.includes(opt.value);
            });
        }

        updateRadarChart_cars_radar();
    }

    window.updateRadarChart_cars_radar = function() {
        // Get selected scenario
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_cars_radar');
            if (scenarioSelect) {
                selectedScenario_cars_radar = scenarioSelect.value;
            }
        }

        // Get selected variables
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_cars_radar');
            if (varSelect) {
                selectedVariables_cars_radar = Array.from(varSelect.selectedOptions).map(opt => opt.value);

                if (selectedVariables_cars_radar.length < 3) {
                    document.getElementById('radar_cars_radar').innerHTML =
                        '<p style="color: orange;">Please select at least 3 variables to display a radar chart.</p>';
                    return;
                }
            }
        }

        // Get selected labels
        const labelSelect = document.getElementById('label_select_cars_radar');
        if (labelSelect) {
            selectedLabels_cars_radar = Array.from(labelSelect.selectedOptions).map(opt => opt.value);

            if (selectedLabels_cars_radar.length === 0) {
                document.getElementById('radar_cars_radar').innerHTML =
                    '<p style="color: orange;">Please select at least one item to display.</p>';
                return;
            }
        }

        renderRadarChart_cars_radar(selectedVariables_cars_radar, selectedLabels_cars_radar, selectedScenario_cars_radar);
    }

    function renderRadarChart_cars_radar(variables, labels, scenario) {
        const data = radarData_cars_radar;
        const container = document.getElementById('radar_cars_radar');
        if (!container) return;

        container.innerHTML = '';

        // Filter data by labels and scenario
        let filteredData = data.filter(d => labels.includes(d[LABEL_COL]));

        if (SCENARIO_COL && scenario) {
            filteredData = filteredData.filter(d => d[SCENARIO_COL] === scenario);
        }

        if (filteredData.length === 0) {
            container.innerHTML = '<p>No data matches the selected filters.</p>';
            return;
        }

        // Calculate max value per variable (respecting variable_limits)
        const maxValues = {};
        variables.forEach(function(v) {
            if (VARIABLE_LIMITS.hasOwnProperty(v)) {
                maxValues[v] = VARIABLE_LIMITS[v];
            } else if (MAX_VALUE) {
                maxValues[v] = MAX_VALUE;
            } else {
                // Auto-calculate from data
                let maxVal = 0;
                filteredData.forEach(function(d) {
                    const val = parseFloat(d[v]);
                    if (!isNaN(val) && val > maxVal) {
                        maxVal = val;
                    }
                });
                maxValues[v] = Math.ceil(maxVal * 1.1);
            }
        });

        // Group variables by group_mapping
        const groupedVars = {};
        const ungroupedVars = [];

        variables.forEach(function(v) {
            if (GROUP_MAPPING.hasOwnProperty(v)) {
                const group = GROUP_MAPPING[v];
                if (!groupedVars[group]) {
                    groupedVars[group] = [];
                }
                groupedVars[group].push(v);
            } else {
                ungroupedVars.push(v);
            }
        });

        // Create ordered list of axes with groups
        const axes = [];
        const groupBoundaries = [];  // Track where each group starts and ends
        let currentIndex = 0;

        // Sort groups for consistent ordering
        const sortedGroups = Object.keys(groupedVars).sort();

        sortedGroups.forEach(function(group) {
            const startIdx = currentIndex;
            groupedVars[group].forEach(function(v) {
                axes.push({ name: v, group: group, maxValue: maxValues[v] });
                currentIndex++;
            });
            const endIdx = currentIndex - 1;
            groupBoundaries.push({ group: group, startIdx: startIdx, endIdx: endIdx });
        });

        ungroupedVars.forEach(function(v) {
            axes.push({ name: v, group: null, maxValue: maxValues[v] });
            currentIndex++;
        });

        // Create color mapping
        const colorMap = {};
        if (COLOR_COL) {
            const uniqueColors = [...new Set(filteredData.map(d => d[COLOR_COL]))];
            // D3 v3 API: use d3.scale.category10()
            const colorScale = d3.scale.category10();
            uniqueColors.forEach(function(c, i) {
                colorMap[c] = colorScale(i);
            });
        }

        // Calculate layout
        const numCharts = filteredData.length;
        const chartsPerRow = Math.ceil(Math.sqrt(numCharts));
        const chartSize = Math.min(450, Math.max(350, Math.floor((container.offsetWidth || 800) / chartsPerRow)));

        // Create SVG container
        const svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', Math.ceil(numCharts / chartsPerRow) * chartSize);

        // Draw each radar chart
        filteredData.forEach(function(d, idx) {
            const row = Math.floor(idx / chartsPerRow);
            const col = idx % chartsPerRow;
            const x = col * chartSize;
            const y = row * chartSize;

            const color = COLOR_COL ? (colorMap[d[COLOR_COL]] || DEFAULT_COLOR) : DEFAULT_COLOR;

            drawSingleRadar_cars_radar(svg, d, axes, groupBoundaries, x, y, chartSize, color);
        });

        // Add legend
        if (SHOW_LEGEND && COLOR_COL) {
            addLegend_cars_radar(container, colorMap);
        }
    }

    function drawSingleRadar_cars_radar(svg, dataPoint, axes, groupBoundaries, offsetX, offsetY, size, color) {
        const margin = 60;
        const radius = (size - 2 * margin) / 2;
        const centerX = offsetX + size / 2;
        const centerY = offsetY + size / 2;

        const g = svg.append('g')
            .attr('transform', 'translate(' + centerX + ',' + centerY + ')');

        // Determine overall max for grid (use the max of all variable maxes for consistent grid)
        let gridMax = 0;
        axes.forEach(function(axis) {
            if (axis.maxValue > gridMax) gridMax = axis.maxValue;
        });

        // Draw grid circles
        const levels = 5;
        for (let i = 1; i <= levels; i++) {
            const r = radius * i / levels;
            g.append('circle')
                .attr('r', r)
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);

            if (SHOW_GRID_LABELS && i === levels) {
                g.append('text')
                    .attr('x', 5)
                    .attr('y', -r)
                    .attr('font-size', '10px')
                    .attr('fill', '#666')
                    .text(gridMax.toFixed(1));
            }
        }

        // Draw axes
        const angleSlice = Math.PI * 2 / axes.length;

        axes.forEach(function(axis, i) {
            const angle = angleSlice * i - Math.PI / 2;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            // Draw axis line
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', x)
                .attr('y2', y)
                .attr('stroke', '#999')
                .attr('stroke-width', 1);

            // Draw axis label
            const labelRadius = radius + 15;
            const labelX = labelRadius * Math.cos(angle);
            const labelY = labelRadius * Math.sin(angle);

            g.append('text')
                .attr('x', labelX)
                .attr('y', labelY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(axis.name.replace(/_/g, ' '));
        });

        // Draw group labels using boundaries
        groupBoundaries.forEach(function(boundary) {
            const startAngle = angleSlice * boundary.startIdx - Math.PI / 2;
            const endAngle = angleSlice * (boundary.endIdx + 1) - Math.PI / 2;
            const midAngle = (startAngle + endAngle) / 2;
            const labelRadius = radius + 40;
            const x = labelRadius * Math.cos(midAngle);
            const y = labelRadius * Math.sin(midAngle);

            g.append('text')
                .attr('x', x)
                .attr('y', y)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', '#0066cc')
                .text(boundary.group);
        });

        // Draw data polygon
        const points = [];
        axes.forEach(function(axis, i) {
            const value = parseFloat(dataPoint[axis.name]) || 0;
            // Clamp value to axis max, then normalize by grid max for consistent display
            const clampedValue = Math.min(value, axis.maxValue);
            const normalizedValue = Math.min(Math.max(clampedValue / gridMax, 0), 1);
            const angle = angleSlice * i - Math.PI / 2;
            const r = radius * normalizedValue;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push([x, y]);
        });

        // Close the polygon
        if (points.length > 0) {
            const pathData = 'M' + points.map(p => p.join(',')).join('L') + 'Z';

            g.append('path')
                .attr('d', pathData)
                .attr('fill', color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', color)
                .attr('stroke-width', 2);

            // Draw points
            points.forEach(function(p) {
                g.append('circle')
                    .attr('cx', p[0])
                    .attr('cy', p[1])
                    .attr('r', 3)
                    .attr('fill', color);
            });
        }

        // Add title
        g.append('text')
            .attr('x', 0)
            .attr('y', -radius - 45)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .text(dataPoint[LABEL_COL]);
    }

    function addLegend_cars_radar(container, colorMap) {
        const legendDiv = document.createElement('div');
        legendDiv.style.marginTop = '20px';
        legendDiv.innerHTML = '<strong>Legend:</strong>';

        const legendItems = document.createElement('div');
        legendItems.style.display = 'flex';
        legendItems.style.flexWrap = 'wrap';
        legendItems.style.gap = '15px';
        legendItems.style.marginTop = '10px';

        Object.keys(colorMap).forEach(function(key) {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '5px';

            const colorBox = document.createElement('div');
            colorBox.style.width = '20px';
            colorBox.style.height = '20px';
            colorBox.style.backgroundColor = colorMap[key];
            colorBox.style.border = '1px solid #ccc';

            const label = document.createElement('span');
            label.textContent = key;

            item.appendChild(colorBox);
            item.appendChild(label);
            legendItems.appendChild(item);
        });

        legendDiv.appendChild(legendItems);
        container.appendChild(legendDiv);
    }
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="investments_data" data-format="csv_embedded" data-src="">
label,asset_class,Expected_Return,Risk_Adjusted_Return,Liquidity,Diversification,Tax_Efficiency,Inflation_Protection
US Stocks,Equity,8.0,6.5,9.5,8.0,6.0,7.0
International Stocks,Equity,7.5,6.0,9.0,9.0,5.5,7.5
Bonds,Fixed Income,3.5,3.0,8.0,6.0,7.0,3.0
Real Estate,Alternative,6.0,5.5,4.0,7.0,8.0,8.0
Commodities,Alternative,5.0,4.0,7.0,8.5,6.5,9.0
Cash,Cash,1.5,1.5,10.0,0.0,9.0,1.0

</script><script type="text/plain" id="phones_data" data-format="csv_embedded" data-src="">
label,Battery,Camera,Performance,Display,Price_Value,Build_Quality
iPhone 15 Pro,85.0,95.0,98.0,92.0,70.0,95.0
Samsung S24 Ultra,95.0,98.0,96.0,98.0,65.0,93.0
Google Pixel 8 Pro,80.0,92.0,90.0,90.0,85.0,88.0
OnePlus 12,90.0,88.0,94.0,95.0,90.0,90.0

</script><script type="text/plain" id="universities_data" data-format="csv_embedded" data-src="">
label,region,scenario,Academic_Reputation,Research_Output,Faculty_Quality,Industry_Connections,International_Outlook,Student_Satisfaction
MIT,North America,Overall Rankings,92.0,95.0,92.0,89.0,80.0,92.0
Stanford,North America,Overall Rankings,96.0,94.0,93.0,89.0,90.0,95.0
Harvard,North America,Overall Rankings,92.0,92.0,96.0,87.0,79.0,88.0
Berkeley,North America,Overall Rankings,90.0,92.0,88.0,85.0,83.0,87.0
Caltech,North America,Overall Rankings,94.0,92.0,93.0,93.0,81.0,87.0
Oxford,Europe,Overall Rankings,94.0,91.0,91.0,89.0,78.0,91.0
Cambridge,Europe,Overall Rankings,94.0,90.0,89.0,92.0,87.0,85.0
ETH Zurich,Europe,Overall Rankings,91.0,90.0,92.0,80.0,79.0,85.0
Tokyo,Asia,Overall Rankings,87.0,87.0,86.0,78.0,95.0,80.0
NUS,Asia,Overall Rankings,84.0,85.0,88.0,78.0,95.0,84.0
MIT,North America,Research Focus,98.0,102.0,100.0,87.0,93.0,89.0
Stanford,North America,Research Focus,92.0,95.0,94.0,87.0,89.0,87.0
Harvard,North America,Research Focus,89.0,87.0,89.0,75.0,82.0,85.0
Berkeley,North America,Research Focus,91.0,94.0,92.0,83.0,81.0,83.0
Caltech,North America,Research Focus,99.0,99.0,98.0,84.0,91.0,95.0
Oxford,Europe,Research Focus,94.0,95.0,93.0,80.0,88.0,84.0
Cambridge,Europe,Research Focus,94.0,95.0,94.0,81.0,84.0,83.0
ETH Zurich,Europe,Research Focus,93.0,95.0,95.0,80.0,89.0,94.0
Tokyo,Asia,Research Focus,87.0,88.0,87.0,81.0,95.0,82.0
NUS,Asia,Research Focus,88.0,88.0,85.0,80.0,95.0,78.0

</script><script type="text/plain" id="cars.specifications" data-format="csv_embedded" data-src="">
label,category,Performance,Efficiency,Interior_Quality,Technology,Safety,Value
Tesla Model 3,Electric,92.0,95.0,78.0,95.0,92.0,85.0
BMW 3 Series,Gasoline,85.0,65.0,90.0,85.0,88.0,72.0
Mercedes C-Class,Gasoline,82.0,62.0,92.0,88.0,90.0,70.0
Audi A4,Gasoline,84.0,68.0,88.0,86.0,87.0,75.0

</script><script type="text/plain" id="cars.pricing" data-format="csv_embedded" data-src="">
model,base_price,as_tested
Tesla Model 3,42000,52000
BMW 3 Series,45000,58000
Mercedes C-Class,47000,62000
Audi A4,44000,56000

</script><script type="text/plain" id="foods_data" data-format="csv_embedded" data-src="">
label,category,Vitamin_C,Fiber,Antioxidants,Sweetness,Aroma,Acidity,Juiciness,Firmness,Smoothness,Affordability,Price,Yield,CO2e,Water_use,Pesticides,Biodiversity
Organic Apple,Fruit,8.0,4.0,7.5,8.0,7.0,6.0,8.5,7.0,9.0,5.0,4.0,6.0,8.0,7.0,9.0,8.5
Conventional Apple,Fruit,6.0,4.0,5.0,7.5,6.0,6.5,8.0,6.5,8.5,8.0,7.0,7.0,6.0,5.0,3.0,4.0
Organic Banana,Fruit,10.0,3.0,6.0,9.0,6.5,2.0,4.0,4.0,8.0,6.0,5.0,7.0,7.0,6.0,8.5,8.0
Conventional Banana,Fruit,9.0,2.6,4.5,8.5,6.0,2.5,4.5,4.5,7.5,9.0,8.0,8.0,5.0,4.0,2.5,3.5
Organic Broccoli,Vegetable,95.0,5.0,9.0,2.0,5.0,3.0,3.0,8.0,4.0,4.0,3.0,5.0,9.0,8.0,9.5,9.0
Conventional Broccoli,Vegetable,85.0,4.5,7.0,2.5,4.5,3.5,3.0,7.5,4.5,7.0,6.0,6.0,7.0,6.0,3.5,4.5

</script><script type="text/plain" id="skills_data" data-format="csv_embedded" data-src="">
label,department,Programming,System_Design,Data_Analysis,Communication,Presentation,Negotiation,Leadership,Project_Management,Team_Building,Product_Knowledge,Market_Knowledge,Technical_Writing
Alice (Eng),Engineering,95.0,85.0,75.0,70.0,65.0,50.0,60.0,75.0,65.0,80.0,40.0,85.0
Bob (Eng),Engineering,90.0,80.0,85.0,65.0,60.0,55.0,55.0,70.0,70.0,75.0,35.0,80.0
Carol (Marketing),Marketing,30.0,25.0,60.0,95.0,90.0,75.0,80.0,85.0,90.0,85.0,90.0,70.0
Dave (Sales),Sales,20.0,15.0,55.0,90.0,95.0,95.0,75.0,65.0,80.0,90.0,95.0,40.0
Eve (Product),Product,60.0,70.0,80.0,85.0,80.0,70.0,85.0,90.0,85.0,95.0,85.0,75.0

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/radarchart_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>RadarChart - Multi-Dimensional Data Visualization</h1>
<p>The RadarChart (also known as spider chart or web chart) displays multivariate data on axes starting from the same point.
Each axis represents a different variable, and values are plotted as a polygon.</p>
<p><strong>Use cases:</strong></p>
<ul>
    <li><strong>Product comparison:</strong> Compare products across multiple features</li>
    <li><strong>Performance evaluation:</strong> Show strengths and weaknesses across different metrics</li>
    <li><strong>Nutritional analysis:</strong> Display nutritional content of foods</li>
    <li><strong>Skills assessment:</strong> Visualize competency levels across different skills</li>
    <li><strong>Portfolio analysis:</strong> Compare investment options across multiple criteria</li>
</ul>
<p><strong>Interactive features:</strong></p>
<ul>
    <li>Select specific items to display</li>
    <li>Filter variables to show</li>
    <li>Group related variables together</li>
    <li>Color by category</li>
    <li>Facet for comparison</li>
</ul>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 1: Smartphone Comparison</h2>
<p>Compare different smartphone models across key specifications.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Basic radar chart with multiple axes</li>
    <li>Multiple items displayed</li>
    <li>Item selector to choose which phones to compare</li>
</ul>
<p><strong>Try this:</strong> Select different phones to compare their specifications.</p>

    </div>
<br>
<hr>
<br>
<div class="chart-container" id="container_phones_radar">
    <h3>Smartphone Specifications Comparison</h3>
    <p>Scores normalized to 0-100 scale. Higher values indicate better performance.</p>
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        <div style="flex: 0 0 auto; min-width: 200px;">

<div style="margin-bottom: 15px;">
    <label for="label_select_phones_radar"><strong>Select items to display:</strong></label>
    <select id="label_select_phones_radar" multiple size="6" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_phones_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

        </div>
        <div style="flex: 1 1 auto; min-width: 400px;">
            <div id="radar_phones_radar" style="width: 100%;"></div>
        </div>
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: phones_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 2: Food Nutritional Profile with Grouped Axes</h2>
<p>Analyze nutritional content of different foods with axes grouped by category (similar to the image in the request).</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Grouped axes (Nutrition, Sensory, Economics, Sustainability)</li>
    <li>Multiple food items</li>
    <li>Category-based coloring</li>
</ul>
<p><strong>Try this:</strong> Select different foods to see their nutritional and sustainability profiles.</p>

    </div>
<br>
<hr>
<br>
<div class="chart-container" id="container_foods_radar">
    <h3>Food Nutritional and Sustainability Profile</h3>
    <p>Axes are grouped by category: Nutrition (blue labels), Sensory, Economics, and Sustainability. Variable limits are set to prevent outliers from dominating the scale (e.g., Vitamin C capped at 20). Higher values are better.</p>
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        <div style="flex: 0 0 auto; min-width: 200px;">

<div style="margin-bottom: 15px;">
    <label for="label_select_foods_radar"><strong>Select items to display:</strong></label>
    <select id="label_select_foods_radar" multiple size="6" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_foods_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

        </div>
        <div style="flex: 1 1 auto; min-width: 400px;">
            <div id="radar_foods_radar" style="width: 100%;"></div>
        </div>
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: foods_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 3: Skills Assessment with Variable Selector</h2>
<p>Evaluate employee skills across different competencies with the ability to select which skills to display.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Variable selector for choosing which axes to display</li>
    <li>Many variables available (only subset shown at once)</li>
    <li>Department-based coloring</li>
</ul>
<p><strong>Try this:</strong> Use the variable selector to choose which skills to compare. You need to select at least 3 variables.</p>

    </div>
<br>
<hr>
<br>
<div class="chart-container" id="container_skills_radar">
    <h3>Employee Skills Assessment</h3>
    <p>Select which skills to compare. Colored by department.</p>
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        <div style="flex: 0 0 auto; min-width: 200px;">

<div style="margin-bottom: 15px;">
    <label for="var_select_skills_radar"><strong>Select variables:</strong></label>
    <select id="var_select_skills_radar" multiple size="8" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_skills_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

<div style="margin-bottom: 15px;">
    <label for="label_select_skills_radar"><strong>Select items to display:</strong></label>
    <select id="label_select_skills_radar" multiple size="6" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_skills_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

        </div>
        <div style="flex: 1 1 auto; min-width: 400px;">
            <div id="radar_skills_radar" style="width: 100%;"></div>
        </div>
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: skills_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 4: University Rankings with Scenarios</h2>
<p>Compare universities across different ranking systems using scenario selection.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Scenario selector to switch between different ranking methodologies</li>
    <li>Multiple universities displayed simultaneously</li>
    <li>Color-coded by region</li>
</ul>
<p><strong>Try this:</strong> Switch between "Overall Rankings" and "Research Focus" scenarios to see how university scores change based on different criteria.</p>

    </div>
<br>
<hr>
<br>
<div class="chart-container" id="container_universities_radar">
    <h3>University Rankings Comparison</h3>
    <p>Compare top universities across key metrics with two ranking methodologies. Switch scenarios to see how different ranking systems affect scores. 'Overall Rankings' provides a balanced view, while 'Research Focus' emphasizes research output and faculty quality.</p>
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        <div style="flex: 0 0 auto; min-width: 200px;">

<div style="margin-bottom: 15px;">
    <label for="scenario_select_universities_radar"><strong>Scenario:</strong></label>
    <select id="scenario_select_universities_radar" onchange="updateRadarChart_universities_radar()">
        <!-- Options will be populated dynamically -->
    </select>
</div>

<div style="margin-bottom: 15px;">
    <label for="label_select_universities_radar"><strong>Select items to display:</strong></label>
    <select id="label_select_universities_radar" multiple size="6" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_universities_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

        </div>
        <div style="flex: 1 1 auto; min-width: 400px;">
            <div id="radar_universities_radar" style="width: 100%;"></div>
        </div>
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: universities_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 5: Investment Portfolio Analysis</h2>
<p>Analyze different investment options across risk, return, and other factors.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Financial metrics visualization</li>
    <li>Risk/return tradeoffs</li>
    <li>Asset class coloring</li>
</ul>
<p><strong>Try this:</strong> Compare different investment options to understand their risk/return profiles.</p>

    </div>
<br>
<hr>
<br>
<div class="chart-container" id="container_investments_radar">
    <h3>Investment Options Analysis</h3>
    <p>Compare investment options across multiple criteria. Higher values are better.</p>
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        <div style="flex: 0 0 auto; min-width: 200px;">

<div style="margin-bottom: 15px;">
    <label for="label_select_investments_radar"><strong>Select items to display:</strong></label>
    <select id="label_select_investments_radar" multiple size="6" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_investments_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

        </div>
        <div style="flex: 1 1 auto; min-width: 400px;">
            <div id="radar_investments_radar" style="width: 100%;"></div>
        </div>
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: investments_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 6: Car Comparison from Struct Data Source</h2>
<p>Compare different car models using data stored in a struct.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Using a struct containing DataFrames as data source</li>
    <li>Referencing struct fields via dot notation</li>
    <li>Multiple DataFrames in one struct (specs and pricing)</li>
</ul>

    </div>
<br>
<hr>
<br>
<div class="chart-container" id="container_cars_radar">
    <h3>Car Comparison from Struct Data Source</h3>
    <p>This radar chart references data from a CarData struct containing specifications and pricing DataFrames. Charts access struct fields via Symbol("cars.specifications").</p>
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        <div style="flex: 0 0 auto; min-width: 200px;">

<div style="margin-bottom: 15px;">
    <label for="label_select_cars_radar"><strong>Select items to display:</strong></label>
    <select id="label_select_cars_radar" multiple size="6" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_cars_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

        </div>
        <div style="flex: 1 1 auto; min-width: 400px;">
            <div id="radar_cars_radar" style="width: 100%;"></div>
        </div>
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: cars.specifications</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary</h2>
<p>The RadarChart provides powerful multi-dimensional visualization with these key capabilities:</p>

<h3>Data Requirements</h3>
<ul>
    <li><strong>Row structure:</strong> Each row represents one item (product, person, entity)</li>
    <li><strong>Value columns:</strong> Numeric columns that become radar axes</li>
    <li><strong>Label column:</strong> Identifies each item</li>
    <li><strong>Optional categorical columns:</strong> For coloring and faceting</li>
</ul>

<h3>Key Features</h3>
<ul>
    <li><strong>Grouped axes:</strong> Group related metrics together with labels</li>
    <li><strong>Variable limits:</strong> Set maximum values per variable to prevent outliers from dominating</li>
    <li><strong>Scenarios:</strong> Switch between different data scenarios</li>
    <li><strong>Variable selector:</strong> Choose which axes to display</li>
    <li><strong>Item selector:</strong> Choose which items to compare</li>
    <li><strong>Color coding:</strong> Color items by category</li>
    <li><strong>Flexible scaling:</strong> Auto-scale or specify maximum value</li>
</ul>

<h3>Best Practices</h3>
<ul>
    <li><strong>3-12 axes:</strong> Too few is uninformative, too many is cluttered</li>
    <li><strong>Similar scales:</strong> Works best when all metrics are on similar scales</li>
    <li><strong>Normalized data:</strong> Consider normalizing to 0-100 or 0-10 for clarity</li>
    <li><strong>Limited items:</strong> Show 1-4 items per chart for readability</li>
    <li><strong>Meaningful grouping:</strong> Group related axes together</li>
</ul>

<h3>Use Cases</h3>
<ul>
    <li>Product comparison and competitive analysis</li>
    <li>Performance evaluation and skill assessment</li>
    <li>Nutritional analysis and food comparison</li>
    <li>Investment portfolio analysis</li>
    <li>Survey results visualization</li>
    <li>Quality metrics and KPI tracking</li>
</ul>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.5.2.</small></p>
</body>
</html>
