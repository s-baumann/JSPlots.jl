<!DOCTYPE html>
<html>
<head>
    <title>PieChart Examples</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->


<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['revenue', 'units'];
    const COLOR_COLS = ['company'];
    const COLOR_MAPS = {'company': {'Company E': '#FFA15A', 'Company D': '#ab63fa', 'Company C': '#00cc96', 'Company B': '#EF553B', 'Company A': '#636efa'}};
    const DEFAULT_VALUE_COL = 'revenue';
    const DEFAULT_COLOR_COL = 'company';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_market_share = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_market_share');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_market_share');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_market_share');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_market_share' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'market_share',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_market_share');
        const facet2Select = document.getElementById('facet2_select_market_share');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('market_share', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('market_share', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('market_share', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('market_data').then(function(data) {
        allData = data;
        window.updateChart_market_share();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('market_share');
    }).catch(function(error) {
        console.error('Error loading data for chart market_share:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['amount'];
    const COLOR_COLS = ['category'];
    const COLOR_MAPS = {'category': {'Salaries': '#636efa', 'R&D': '#00cc96', 'Operations': '#ab63fa', 'Other': '#19d3f3', 'Marketing': '#EF553B', 'Infrastructure': '#FFA15A'}};
    const DEFAULT_VALUE_COL = 'amount';
    const DEFAULT_COLOR_COL = 'category';
    const HOLE = 0.4;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_budget_donut = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_budget_donut');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_budget_donut');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_budget_donut');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_budget_donut' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'budget_donut',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_budget_donut');
        const facet2Select = document.getElementById('facet2_select_budget_donut');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('budget_donut', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('budget_donut', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('budget_donut', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('budget_data').then(function(data) {
        allData = data;
        window.updateChart_budget_donut();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('budget_donut');
    }).catch(function(error) {
        console.error('Error loading data for chart budget_donut:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['region'];
    const CONTINUOUS_FILTERS = ['year'];
    const VALUE_COLS = ['sales'];
    const COLOR_COLS = ['product'];
    const COLOR_MAPS = {'product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product B': '#EF553B'}};
    const DEFAULT_VALUE_COL = 'sales';
    const DEFAULT_COLOR_COL = 'product';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_sales_filtered = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_sales_filtered');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_sales_filtered');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_sales_filtered');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_sales_filtered' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'sales_filtered',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_sales_filtered');
        const facet2Select = document.getElementById('facet2_select_sales_filtered');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('sales_filtered', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('sales_filtered', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('sales_filtered', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updateChart_sales_filtered();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('sales_filtered');
    }).catch(function(error) {
        console.error('Error loading data for chart sales_filtered:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = ['year'];
    const VALUE_COLS = ['sales'];
    const COLOR_COLS = ['product'];
    const COLOR_MAPS = {'product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product B': '#EF553B'}};
    const DEFAULT_VALUE_COL = 'sales';
    const DEFAULT_COLOR_COL = 'product';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_sales_by_region = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_sales_by_region');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_sales_by_region');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_sales_by_region');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_sales_by_region' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'sales_by_region',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_sales_by_region');
        const facet2Select = document.getElementById('facet2_select_sales_by_region');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('sales_by_region', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('sales_by_region', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('sales_by_region', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updateChart_sales_by_region();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('sales_by_region');
    }).catch(function(error) {
        console.error('Error loading data for chart sales_by_region:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['count'];
    const COLOR_COLS = ['preference'];
    const COLOR_MAPS = {'preference': {'Mobile': '#636efa', 'Desktop': '#EF553B', 'Tablet': '#00cc96'}};
    const DEFAULT_VALUE_COL = 'count';
    const DEFAULT_COLOR_COL = 'preference';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_demographics_grid = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_demographics_grid');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_demographics_grid');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_demographics_grid');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_demographics_grid' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'demographics_grid',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_demographics_grid');
        const facet2Select = document.getElementById('facet2_select_demographics_grid');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('demographics_grid', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('demographics_grid', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('demographics_grid', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('demo_data').then(function(data) {
        allData = data;
        window.updateChart_demographics_grid();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('demographics_grid');
    }).catch(function(error) {
        console.error('Error loading data for chart demographics_grid:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['quarter'];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['amount'];
    const COLOR_COLS = ['expense_type', 'department'];
    const COLOR_MAPS = {'expense_type': {'Salaries': '#636efa', 'Training': '#ab63fa', 'Equipment': '#EF553B', 'Travel': '#00cc96', 'Supplies': '#FFA15A'}, 'department': {'HR': '#FFA15A', 'Engineering': '#636efa', 'Sales': '#EF553B', 'Operations': '#ab63fa', 'Marketing': '#00cc96'}};
    const DEFAULT_VALUE_COL = 'amount';
    const DEFAULT_COLOR_COL = 'expense_type';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_dept_expenses = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_dept_expenses');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_dept_expenses');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_dept_expenses');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_dept_expenses' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'dept_expenses',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_dept_expenses');
        const facet2Select = document.getElementById('facet2_select_dept_expenses');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('dept_expenses', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('dept_expenses', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('dept_expenses', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('expense_data').then(function(data) {
        allData = data;
        window.updateChart_dept_expenses();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('dept_expenses');
    }).catch(function(error) {
        console.error('Error loading data for chart dept_expenses:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['revenue_contribution'];
    const COLOR_COLS = ['segment'];
    const COLOR_MAPS = {'segment': {'Enterprise': '#636efa', 'Individual': '#FFA15A', 'Mid-Market': '#EF553B', 'Small Business': '#00cc96', 'Startup': '#ab63fa'}};
    const DEFAULT_VALUE_COL = 'revenue_contribution';
    const DEFAULT_COLOR_COL = 'segment';
    const HOLE = 0.3;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_customer_segments = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_customer_segments');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_customer_segments');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_customer_segments');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_customer_segments' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'customer_segments',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_customer_segments');
        const facet2Select = document.getElementById('facet2_select_customer_segments');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('customer_segments', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('customer_segments', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('customer_segments', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('segment_data').then(function(data) {
        allData = data;
        window.updateChart_customer_segments();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('customer_segments');
    }).catch(function(error) {
        console.error('Error loading data for chart customer_segments:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['sales'];
    const COLOR_COLS = ['category'];
    const COLOR_MAPS = {'category': {'Food': '#ab63fa', 'Home & Garden': '#00cc96', 'Clothing': '#EF553B', 'Electronics': '#636efa', 'Books': '#FFA15A'}};
    const DEFAULT_VALUE_COL = 'sales';
    const DEFAULT_COLOR_COL = 'category';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_store_comparison = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_store_comparison');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_store_comparison');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_store_comparison');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_store_comparison' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'store_comparison',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_store_comparison');
        const facet2Select = document.getElementById('facet2_select_store_comparison');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('store_comparison', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('store_comparison', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('store_comparison', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('store_data').then(function(data) {
        allData = data;
        window.updateChart_store_comparison();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('store_comparison');
    }).catch(function(error) {
        console.error('Error loading data for chart store_comparison:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['visitors'];
    const COLOR_COLS = ['browser', 'device'];
    const COLOR_MAPS = {'browser': {'Safari': '#00cc96', 'Chrome': '#636efa', 'Edge': '#ab63fa', 'Firefox': '#EF553B'}, 'device': {'Mobile': '#EF553B', 'Desktop': '#636efa', 'Tablet': '#00cc96'}};
    const DEFAULT_VALUE_COL = 'visitors';
    const DEFAULT_COLOR_COL = 'browser';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_traffic_analysis = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_traffic_analysis');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_traffic_analysis');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_traffic_analysis');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_traffic_analysis' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'traffic_analysis',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_traffic_analysis');
        const facet2Select = document.getElementById('facet2_select_traffic_analysis');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('traffic_analysis', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('traffic_analysis', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('traffic_analysis', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('traffic_data').then(function(data) {
        allData = data;
        window.updateChart_traffic_analysis();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('traffic_analysis');
    }).catch(function(error) {
        console.error('Error loading data for chart traffic_analysis:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['quarter'];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['revenue', 'units_sold', 'profit', 'customer_count'];
    const COLOR_COLS = ['product', 'channel', 'region'];
    const COLOR_MAPS = {'channel': {'Retail': '#EF553B', 'Online': '#636efa', 'Wholesale': '#00cc96'}, 'region': {'Asia': '#00cc96', 'Europe': '#EF553B', 'North America': '#636efa', 'South America': '#ab63fa'}, 'product': {'Monitor': '#FFA15A', 'Phone': '#EF553B', 'Headphones': '#ab63fa', 'Laptop': '#636efa', 'Tablet': '#00cc96'}};
    const DEFAULT_VALUE_COL = 'revenue';
    const DEFAULT_COLOR_COL = 'product';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_comprehensive_sales = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_comprehensive_sales');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_comprehensive_sales');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_comprehensive_sales');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_comprehensive_sales' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'comprehensive_sales',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_comprehensive_sales');
        const facet2Select = document.getElementById('facet2_select_comprehensive_sales');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('comprehensive_sales', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('comprehensive_sales', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('comprehensive_sales', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('comprehensive_data').then(function(data) {
        allData = data;
        window.updateChart_comprehensive_sales();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('comprehensive_sales');
    }).catch(function(error) {
        console.error('Error loading data for chart comprehensive_sales:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['amount'];
    const COLOR_COLS = ['source'];
    const COLOR_MAPS = {'source': {'Hardware': '#ab63fa', 'Licensing': '#EF553B', 'Services': '#00cc96', 'Other': '#FFA15A', 'Subscriptions': '#636efa'}};
    const DEFAULT_VALUE_COL = 'amount';
    const DEFAULT_COLOR_COL = 'source';
    const HOLE = 0.35;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_struct_pie = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_struct_pie');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_struct_pie');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_struct_pie');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_struct_pie' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'struct_pie',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_struct_pie');
        const facet2Select = document.getElementById('facet2_select_struct_pie');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('struct_pie', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('struct_pie', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('struct_pie', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('company.revenue').then(function(data) {
        allData = data;
        window.updateChart_struct_pie();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('struct_pie');
    }).catch(function(error) {
        console.error('Error loading data for chart struct_pie:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="sales_data" data-format="csv_embedded" data-src="">
region,product,year,sales
North,Product A,2022,8102.962800882591
North,Product A,2023,7901.40031794131
North,Product A,2024,10643.21075882189
North,Product B,2022,9635.276106214944
North,Product B,2023,13048.153533973087
North,Product B,2024,10821.400848820935
North,Product C,2022,5843.981119807669
North,Product C,2023,7835.022842615828
North,Product C,2024,12344.825714625853
South,Product A,2022,11346.876569487073
South,Product A,2023,9953.025546460993
South,Product A,2024,15366.36415445368
South,Product B,2022,11354.675096369561
South,Product B,2023,15176.473040365709
South,Product B,2024,5985.938294945294
South,Product C,2022,12586.062506059447
South,Product C,2023,11790.456429682477
South,Product C,2024,11995.288157059456
East,Product A,2022,17924.37890941082
East,Product A,2023,7584.644925504896
East,Product A,2024,10930.674875815374
East,Product B,2022,4126.696819049719
East,Product B,2023,9275.339563287285
East,Product B,2024,10044.956124578985
East,Product C,2022,9708.694971377936
East,Product C,2023,10392.388748683428
East,Product C,2024,12982.56833149248
West,Product A,2022,4034.0949756822192
West,Product A,2023,11193.07381086299
West,Product A,2024,9131.376773362295
West,Product B,2022,476.8089254636143
West,Product B,2023,10944.25533512773
West,Product B,2024,10653.878312647235
West,Product C,2022,10057.213844931634
West,Product C,2023,7580.147397755023
West,Product C,2024,8882.59971414583

</script><script type="text/plain" id="comprehensive_data" data-format="csv_embedded" data-src="">
product,region,channel,quarter,revenue,units_sold,profit,customer_count
Laptop,North America,Online,Q1-2024,33745.167330604374,281,9458.635502871777,156
Laptop,North America,Online,Q2-2024,47071.1615114921,572,18123.959171208677,359
Laptop,North America,Online,Q3-2024,76870.93103859646,489,12469.346821580608,74
Laptop,North America,Online,Q4-2024,61069.74499398178,363,13815.926854844613,462
Laptop,North America,Retail,Q1-2024,64935.173618037756,793,18416.732517326007,459
Laptop,North America,Retail,Q2-2024,40612.65620064497,462,10268.372207453498,459
Laptop,North America,Retail,Q3-2024,44310.90740628081,924,5541.4546176153835,243
Laptop,North America,Retail,Q4-2024,15633.12073884641,779,21851.021749850217,443
Laptop,North America,Wholesale,Q1-2024,36123.939690558625,854,14189.946839471086,188
Laptop,North America,Wholesale,Q2-2024,61920.70748219723,381,2092.7136050977842,368
Laptop,North America,Wholesale,Q3-2024,60101.79477557461,783,15722.610769937623,466
Laptop,North America,Wholesale,Q4-2024,35166.58895449675,759,32212.547450600567,193
Laptop,Europe,Online,Q1-2024,46255.36645386718,795,27449.439915372182,264
Laptop,Europe,Online,Q2-2024,33679.5386361556,728,19596.680515174314,335
Laptop,Europe,Online,Q3-2024,42692.03419752038,515,1610.676939661933,168
Laptop,Europe,Online,Q4-2024,45549.81725740522,853,9694.210208698845,231
Laptop,Europe,Retail,Q1-2024,81021.96578527571,520,28329.1640886653,83
Laptop,Europe,Retail,Q2-2024,53044.994978537616,173,17727.160191279298,59
Laptop,Europe,Retail,Q3-2024,37530.42692447925,306,18715.791662022726,348
Laptop,Europe,Retail,Q4-2024,82361.9442944462,263,7651.1277566147455,90
Laptop,Europe,Wholesale,Q1-2024,47209.250391213034,198,2991.166603430447,100
Laptop,Europe,Wholesale,Q2-2024,47722.41167361592,343,32216.176738111386,258
Laptop,Europe,Wholesale,Q3-2024,60731.282165699755,542,6112.821651500441,328
Laptop,Europe,Wholesale,Q4-2024,37791.57710632551,843,19923.329541606094,358
Laptop,Asia,Online,Q1-2024,53994.96417475733,149,14244.791383158845,257
Laptop,Asia,Online,Q2-2024,47859.833833727105,611,24026.33028372891,266
Laptop,Asia,Online,Q3-2024,74338.93097953273,426,22085.06691329544,357
Laptop,Asia,Online,Q4-2024,40410.49710448268,864,4295.863821827108,122
Laptop,Asia,Retail,Q1-2024,84927.2275246169,296,17619.981477998976,80
Laptop,Asia,Retail,Q2-2024,47128.50676888674,781,11207.603231885521,162
Laptop,Asia,Retail,Q3-2024,42865.403722404626,461,5728.7581966897305,124
Laptop,Asia,Retail,Q4-2024,53909.967131790065,340,15653.831752750519,426
Laptop,Asia,Wholesale,Q1-2024,61967.0482273104,491,17408.2317386938,347
Laptop,Asia,Wholesale,Q2-2024,70360.20322205084,384,7574.84114355874,192
Laptop,Asia,Wholesale,Q3-2024,61989.40901274113,242,14031.026390508467,168
Laptop,Asia,Wholesale,Q4-2024,45060.273629908894,914,15417.876830930561,191
Laptop,South America,Online,Q1-2024,66032.033902704,623,13853.336508798197,67
Laptop,South America,Online,Q2-2024,50871.348497223116,793,21454.630828837813,209
Laptop,South America,Online,Q3-2024,71012.77817174114,496,16163.485563096676,429
Laptop,South America,Online,Q4-2024,58779.87807611949,901,7322.4239403769625,317
Laptop,South America,Retail,Q1-2024,32983.00705285756,143,15472.9409682049,99
Laptop,South America,Retail,Q2-2024,54922.19675540888,989,6978.972778703046,412
Laptop,South America,Retail,Q3-2024,33176.856762588504,705,16740.190020467075,322
Laptop,South America,Retail,Q4-2024,43486.681557404045,649,25498.772310363944,230
Laptop,South America,Wholesale,Q1-2024,58361.883263281394,805,25008.49965450308,344
Laptop,South America,Wholesale,Q2-2024,58663.38037689359,314,9429.77250313948,319
Laptop,South America,Wholesale,Q3-2024,42723.930240732196,198,8848.320025590445,152
Laptop,South America,Wholesale,Q4-2024,79234.55579374883,877,19479.354461244395,131
Phone,North America,Online,Q1-2024,55142.26111618459,225,14606.642636454233,157
Phone,North America,Online,Q2-2024,32457.802934651652,540,13789.854435630396,257
Phone,North America,Online,Q3-2024,47231.48439682906,349,3518.6545805000787,333
Phone,North America,Online,Q4-2024,67079.39548456247,137,3698.0633317713655,392
Phone,North America,Retail,Q1-2024,58504.38932668627,204,9218.436305784331,349
Phone,North America,Retail,Q2-2024,22389.38836903203,531,12260.37577398483,298
Phone,North America,Retail,Q3-2024,33071.05328694425,703,5787.348778754873,118
Phone,North America,Retail,Q4-2024,54336.11797229077,171,13308.574647575246,100
Phone,North America,Wholesale,Q1-2024,62202.5643806765,717,3194.670154598258,305
Phone,North America,Wholesale,Q2-2024,25452.497617979658,452,25585.82127370644,412
Phone,North America,Wholesale,Q3-2024,39316.54284323589,269,18670.335159800947,273
Phone,North America,Wholesale,Q4-2024,60662.194310444735,607,23076.880432563194,445
Phone,Europe,Online,Q1-2024,58268.18983250522,697,6833.759538203171,278
Phone,Europe,Online,Q2-2024,14133.532149847,476,17263.844838355748,445
Phone,Europe,Online,Q3-2024,5590.405679726391,929,22973.948535534895,439
Phone,Europe,Online,Q4-2024,64046.955796882816,527,6177.08093034044,86
Phone,Europe,Retail,Q1-2024,69001.54470258934,744,11998.335245919247,78
Phone,Europe,Retail,Q2-2024,16723.438573097017,855,9357.516494873269,323
Phone,Europe,Retail,Q3-2024,44288.60304606471,405,18277.459435073986,190
Phone,Europe,Retail,Q4-2024,17102.488295944757,761,19241.536060828206,273
Phone,Europe,Wholesale,Q1-2024,68155.56479821245,296,16178.219373893475,86
Phone,Europe,Wholesale,Q2-2024,31940.723730716385,648,10967.30763160701,106
Phone,Europe,Wholesale,Q3-2024,54247.94873354026,169,4822.343780939716,373
Phone,Europe,Wholesale,Q4-2024,20449.01929349995,181,8626.432365696179,328
Phone,Asia,Online,Q1-2024,47354.46433318505,258,18496.36804987456,403
Phone,Asia,Online,Q2-2024,51610.74467138127,780,18879.537505512028,277
Phone,Asia,Online,Q3-2024,91175.55533790257,619,8539.236705075533,119
Phone,Asia,Online,Q4-2024,31616.32106930613,266,18098.283336923556,345
Phone,Asia,Retail,Q1-2024,47997.64490939372,660,21467.63257887421,160
Phone,Asia,Retail,Q2-2024,58650.16466800054,487,17815.326145538147,384
Phone,Asia,Retail,Q3-2024,79272.41049891354,486,15584.415258041972,449
Phone,Asia,Retail,Q4-2024,9026.941768186836,631,16476.70615565241,214
Phone,Asia,Wholesale,Q1-2024,41417.028852629395,365,12754.92008943011,57
Phone,Asia,Wholesale,Q2-2024,82814.16934401331,876,17404.35039227268,469
Phone,Asia,Wholesale,Q3-2024,38678.20339464118,192,17867.921299156886,145
Phone,Asia,Wholesale,Q4-2024,40007.991775643124,661,30646.8437006085,455
Phone,South America,Online,Q1-2024,42674.57155007842,311,3020.3688100443687,186
Phone,South America,Online,Q2-2024,82960.25945225473,754,23388.23621992327,304
Phone,South America,Online,Q3-2024,83457.31864496155,226,24429.740819521357,423
Phone,South America,Online,Q4-2024,59056.83405320321,227,3197.426060780326,94
Phone,South America,Retail,Q1-2024,53802.69134766829,887,14882.795343169104,334
Phone,South America,Retail,Q2-2024,56779.16336269182,627,7117.181873876546,386
Phone,South America,Retail,Q3-2024,57951.24472115234,169,11733.768459068706,309
Phone,South America,Retail,Q4-2024,21564.32511536899,419,9287.237416995922,157
Phone,South America,Wholesale,Q1-2024,48278.04666471524,533,14100.467992611002,257
Phone,South America,Wholesale,Q2-2024,84095.39250171027,321,9347.456443611085,302
Phone,South America,Wholesale,Q3-2024,92771.42790764343,698,13549.521484830468,479
Phone,South America,Wholesale,Q4-2024,48043.026740508496,161,4593.696954871373,396
Tablet,North America,Online,Q1-2024,69605.90238982295,336,16377.776271760722,240
Tablet,North America,Online,Q2-2024,18229.714369049456,963,34468.05294549021,498
Tablet,North America,Online,Q3-2024,42355.920687549486,204,11662.864110235125,387
Tablet,North America,Online,Q4-2024,72832.36356468186,699,16093.03668894093,361
Tablet,North America,Retail,Q1-2024,35431.039233224685,570,14146.443785283926,273
Tablet,North America,Retail,Q2-2024,54429.946473306394,546,4544.15745061867,486
Tablet,North America,Retail,Q3-2024,47708.869489630684,159,16490.939638397216,451
Tablet,North America,Retail,Q4-2024,6045.031800074779,454,10664.377704997576,289
Tablet,North America,Wholesale,Q1-2024,56516.71135107528,191,15885.237672768995,466
Tablet,North America,Wholesale,Q2-2024,43393.09107207876,813,14759.377116330665,316
Tablet,North America,Wholesale,Q3-2024,59909.62396031399,398,19876.897814201642,412
Tablet,North America,Wholesale,Q4-2024,67605.79748255323,626,15855.167817369078,378
Tablet,Europe,Online,Q1-2024,71316.7099800513,795,19622.364562986895,243
Tablet,Europe,Online,Q2-2024,68252.24304980459,298,23624.546740279715,108
Tablet,Europe,Online,Q3-2024,71163.6477251224,698,20986.95102489844,328
Tablet,Europe,Online,Q4-2024,70896.9886915651,174,10366.7635833268,59
Tablet,Europe,Retail,Q1-2024,20075.164130309746,361,14467.144743977373,491
Tablet,Europe,Retail,Q2-2024,33494.45116658752,652,2368.967329493502,97
Tablet,Europe,Retail,Q3-2024,57081.87780052553,423,4978.092680620808,306
Tablet,Europe,Retail,Q4-2024,40076.8886505244,915,16195.12828370663,499
Tablet,Europe,Wholesale,Q1-2024,63412.23968035002,824,5352.344661584428,448
Tablet,Europe,Wholesale,Q2-2024,44305.69126618595,118,20004.934961528168,364
Tablet,Europe,Wholesale,Q3-2024,57302.09558231334,744,12271.577892981293,395
Tablet,Europe,Wholesale,Q4-2024,6380.943263353474,469,9452.524759236538,459
Tablet,Asia,Online,Q1-2024,68726.02203907151,538,14721.458926346679,438
Tablet,Asia,Online,Q2-2024,73565.67429855524,691,6510.954596331174,205
Tablet,Asia,Online,Q3-2024,58021.365687303725,185,15850.771359330993,386
Tablet,Asia,Online,Q4-2024,41709.36517392799,772,22624.12021413913,266
Tablet,Asia,Retail,Q1-2024,62502.96718081674,130,26764.999194753174,182
Tablet,Asia,Retail,Q2-2024,50261.31446612635,677,11235.418817293634,265
Tablet,Asia,Retail,Q3-2024,29590.803479091344,516,10757.478607450237,125
Tablet,Asia,Retail,Q4-2024,10765.241705371736,191,13188.170319309635,177
Tablet,Asia,Wholesale,Q1-2024,41841.756872229336,211,15597.878843652588,483
Tablet,Asia,Wholesale,Q2-2024,26713.20550773783,404,13134.959801925103,415
Tablet,Asia,Wholesale,Q3-2024,45656.041258080855,813,19469.405979415453,86
Tablet,Asia,Wholesale,Q4-2024,38507.94719489856,669,19925.717112109538,252
Tablet,South America,Online,Q1-2024,41608.20366308068,878,25320.656440912346,70
Tablet,South America,Online,Q2-2024,29952.12383571731,615,18254.6775699826,60
Tablet,South America,Online,Q3-2024,69106.42169497299,928,14275.122993519148,418
Tablet,South America,Online,Q4-2024,35786.18442556691,875,10208.997214653067,292
Tablet,South America,Retail,Q1-2024,56585.94324789553,370,7877.623901913152,133
Tablet,South America,Retail,Q2-2024,23512.538956879504,540,12336.231895335353,379
Tablet,South America,Retail,Q3-2024,54236.69863757565,202,14339.35178261032,203
Tablet,South America,Retail,Q4-2024,41654.5939887094,308,10566.999546506931,337
Tablet,South America,Wholesale,Q1-2024,45916.95628827519,856,21397.870479802234,71
Tablet,South America,Wholesale,Q2-2024,44357.2918289427,408,8388.547887966786,383
Tablet,South America,Wholesale,Q3-2024,21460.035500685837,638,34108.499106665186,189
Tablet,South America,Wholesale,Q4-2024,66946.38014407735,447,3472.8300664941817,470
Headphones,North America,Online,Q1-2024,56215.7110740662,973,7778.461769907661,322
Headphones,North America,Online,Q2-2024,60597.02388336782,228,9807.561691751049,141
Headphones,North America,Online,Q3-2024,73973.28849466903,395,1010.7668890108598,194
Headphones,North America,Online,Q4-2024,32587.545904354214,635,3260.103913947345,105
Headphones,North America,Retail,Q1-2024,45887.901648393534,401,15496.095127710785,383
Headphones,North America,Retail,Q2-2024,45639.53567174534,340,29832.902049106047,251
Headphones,North America,Retail,Q3-2024,57664.57978638663,844,9358.57911362217,79
Headphones,North America,Retail,Q4-2024,52086.0706157951,493,14532.41583155934,107
Headphones,North America,Wholesale,Q1-2024,65552.32899943877,338,25070.3633891388,95
Headphones,North America,Wholesale,Q2-2024,25485.45779366873,520,22599.014482706072,380
Headphones,North America,Wholesale,Q3-2024,44813.2491665985,264,7976.141474585875,119
Headphones,North America,Wholesale,Q4-2024,59570.35519515335,919,12202.377129736127,245
Headphones,Europe,Online,Q1-2024,34345.98986746524,616,7608.9903954051115,324
Headphones,Europe,Online,Q2-2024,20650.67283467965,613,14407.06723653171,409
Headphones,Europe,Online,Q3-2024,37172.34848537262,894,12420.51897507179,253
Headphones,Europe,Online,Q4-2024,55408.09943713452,292,19470.010093829536,444
Headphones,Europe,Retail,Q1-2024,39330.88152742996,675,15314.705852896048,223
Headphones,Europe,Retail,Q2-2024,74629.07672546113,371,13422.441904114225,463
Headphones,Europe,Retail,Q3-2024,54268.51971171856,472,17886.283317406604,240
Headphones,Europe,Retail,Q4-2024,75701.56833191641,118,13478.158249259199,158
Headphones,Europe,Wholesale,Q1-2024,37036.152317828215,574,16438.87439000913,471
Headphones,Europe,Wholesale,Q2-2024,39521.07042878958,690,13599.45498775412,420
Headphones,Europe,Wholesale,Q3-2024,56039.969585217295,283,19111.63219450294,223
Headphones,Europe,Wholesale,Q4-2024,38725.0257485826,408,7217.8171028438865,86
Headphones,Asia,Online,Q1-2024,65566.01690684316,353,17827.805218498863,166
Headphones,Asia,Online,Q2-2024,79375.291201035,624,34187.83614787965,275
Headphones,Asia,Online,Q3-2024,14918.101073381142,525,920.6959090179316,369
Headphones,Asia,Online,Q4-2024,50344.625541065616,796,20718.602056742326,56
Headphones,Asia,Retail,Q1-2024,30006.546796431314,902,12505.75987021088,446
Headphones,Asia,Retail,Q2-2024,66710.99957236978,494,1088.7254718564163,121
Headphones,Asia,Retail,Q3-2024,69956.09335746434,842,28800.33793402909,163
Headphones,Asia,Retail,Q4-2024,56854.49027464419,111,7664.886732616801,214
Headphones,Asia,Wholesale,Q1-2024,70233.51429818026,956,24340.71679724745,384
Headphones,Asia,Wholesale,Q2-2024,60617.15111232996,986,14267.326101005094,58
Headphones,Asia,Wholesale,Q3-2024,56530.29110782491,881,9601.461111861388,54
Headphones,Asia,Wholesale,Q4-2024,51681.32271640488,646,13934.337569922562,267
Headphones,South America,Online,Q1-2024,53470.44926380633,371,11981.005964947057,129
Headphones,South America,Online,Q2-2024,43961.057996893964,446,17098.82051522175,483
Headphones,South America,Online,Q3-2024,72713.11183689756,202,20497.95419830933,227
Headphones,South America,Online,Q4-2024,42192.004083928,632,26636.580716720047,281
Headphones,South America,Retail,Q1-2024,50676.155217700434,662,23246.29613186162,101
Headphones,South America,Retail,Q2-2024,38672.73317934634,902,23246.833983496363,239
Headphones,South America,Retail,Q3-2024,48427.833014713004,537,954.0613688361082,329
Headphones,South America,Retail,Q4-2024,17683.04558571059,773,19973.828827089183,482
Headphones,South America,Wholesale,Q1-2024,60948.95836132687,327,18198.466804977357,77
Headphones,South America,Wholesale,Q2-2024,55568.2870278242,571,9296.995675194867,384
Headphones,South America,Wholesale,Q3-2024,26568.80082406198,891,7446.418944394933,112
Headphones,South America,Wholesale,Q4-2024,49896.804578199604,337,15596.852408624542,340
Monitor,North America,Online,Q1-2024,68453.47090027711,800,22795.0990659839,277
Monitor,North America,Online,Q2-2024,79351.90262826416,815,15055.63530506468,80
Monitor,North America,Online,Q3-2024,18042.419747500564,100,17695.26104207865,115
Monitor,North America,Online,Q4-2024,76818.45937253152,667,9138.476596799312,434
Monitor,North America,Retail,Q1-2024,84974.60906288058,327,14598.089383825385,171
Monitor,North America,Retail,Q2-2024,34268.076502940676,806,7030.972488015316,366
Monitor,North America,Retail,Q3-2024,29286.863451007095,894,2672.706290207918,265
Monitor,North America,Retail,Q4-2024,10833.472398511542,787,12537.46703895707,402
Monitor,North America,Wholesale,Q1-2024,31973.59168345829,962,20824.52809557884,356
Monitor,North America,Wholesale,Q2-2024,66537.43590071665,899,12589.83148654186,338
Monitor,North America,Wholesale,Q3-2024,30738.122516467345,288,11263.279665781098,98
Monitor,North America,Wholesale,Q4-2024,63059.9818599663,268,15818.782730914449,362
Monitor,Europe,Online,Q1-2024,32375.384794549314,996,143.21777731323164,268
Monitor,Europe,Online,Q2-2024,7960.168504286179,434,9700.233501471415,71
Monitor,Europe,Online,Q3-2024,40411.37962958292,812,6262.057060128664,174
Monitor,Europe,Online,Q4-2024,39897.886259701045,702,13613.644952067209,77
Monitor,Europe,Retail,Q1-2024,71945.02351791339,808,16104.365034433707,294
Monitor,Europe,Retail,Q2-2024,71482.62976599688,683,3865.2100851883224,194
Monitor,Europe,Retail,Q3-2024,30441.70372751915,305,8801.912023717061,102
Monitor,Europe,Retail,Q4-2024,24692.442642929487,819,13767.786943590816,83
Monitor,Europe,Wholesale,Q1-2024,47926.544258020615,229,15760.57375294805,426
Monitor,Europe,Wholesale,Q2-2024,44021.19162486136,228,14116.146461144928,376
Monitor,Europe,Wholesale,Q3-2024,71106.84920352274,629,13830.910087971919,179
Monitor,Europe,Wholesale,Q4-2024,73802.11092286627,744,16917.360021167737,108
Monitor,Asia,Online,Q1-2024,60477.150367687835,237,27849.161985155286,457
Monitor,Asia,Online,Q2-2024,27250.423188202774,864,27470.791649631115,260
Monitor,Asia,Online,Q3-2024,66080.20184161312,151,19023.587500410962,194
Monitor,Asia,Online,Q4-2024,36992.71969741074,463,7399.232019868943,203
Monitor,Asia,Retail,Q1-2024,29335.911526648237,305,9865.901490563938,128
Monitor,Asia,Retail,Q2-2024,28131.975201442758,929,23266.15444900334,174
Monitor,Asia,Retail,Q3-2024,64322.08702457512,217,26208.909618972062,123
Monitor,Asia,Retail,Q4-2024,47912.727484525036,360,9497.7277272533,422
Monitor,Asia,Wholesale,Q1-2024,12293.157775650805,131,15608.232396208183,443
Monitor,Asia,Wholesale,Q2-2024,68009.75726236995,714,5325.649481264509,242
Monitor,Asia,Wholesale,Q3-2024,37388.6488111503,915,17233.625860478947,68
Monitor,Asia,Wholesale,Q4-2024,82863.7620388646,900,19542.42371001772,267
Monitor,South America,Online,Q1-2024,23417.913274360046,329,26110.698278833628,284
Monitor,South America,Online,Q2-2024,29425.788897044455,892,2920.378148323807,93
Monitor,South America,Online,Q3-2024,50369.50743923924,797,12899.53548459995,135
Monitor,South America,Online,Q4-2024,41772.26165584376,512,11827.7981740865,337
Monitor,South America,Retail,Q1-2024,40144.357449511066,431,13633.206326149611,243
Monitor,South America,Retail,Q2-2024,56246.6539975878,301,19577.18794902048,299
Monitor,South America,Retail,Q3-2024,49570.4740792012,817,14078.865384027018,415
Monitor,South America,Retail,Q4-2024,54172.861996392916,409,13150.386907333403,455
Monitor,South America,Wholesale,Q1-2024,35113.5189962576,603,20988.406643828177,138
Monitor,South America,Wholesale,Q2-2024,81465.67673116425,934,19912.394911474963,56
Monitor,South America,Wholesale,Q3-2024,42366.707394912024,661,21942.90191358965,161
Monitor,South America,Wholesale,Q4-2024,62185.92015046987,795,27608.060829357837,447

</script><script type="text/plain" id="budget_data" data-format="csv_embedded" data-src="">
category,amount
Salaries,250000
Marketing,80000
R&D,120000
Operations,65000
Infrastructure,45000
Other,20000

</script><script type="text/plain" id="traffic_data" data-format="csv_embedded" data-src="">
country,browser,device,visitors
USA,Chrome,Desktop,1586
USA,Chrome,Mobile,1309
USA,Chrome,Tablet,5248
USA,Firefox,Desktop,3053
USA,Firefox,Mobile,3151
USA,Firefox,Tablet,7157
USA,Safari,Desktop,8855
USA,Safari,Mobile,7556
USA,Safari,Tablet,6921
USA,Edge,Desktop,8988
USA,Edge,Mobile,1687
USA,Edge,Tablet,7429
UK,Chrome,Desktop,9144
UK,Chrome,Mobile,1412
UK,Chrome,Tablet,4208
UK,Firefox,Desktop,1457
UK,Firefox,Mobile,3069
UK,Firefox,Tablet,2654
UK,Safari,Desktop,7242
UK,Safari,Mobile,4826
UK,Safari,Tablet,3799
UK,Edge,Desktop,7107
UK,Edge,Mobile,9210
UK,Edge,Tablet,1022
Germany,Chrome,Desktop,6565
Germany,Chrome,Mobile,6464
Germany,Chrome,Tablet,3772
Germany,Firefox,Desktop,3993
Germany,Firefox,Mobile,6025
Germany,Firefox,Tablet,8476
Germany,Safari,Desktop,8226
Germany,Safari,Mobile,1237
Germany,Safari,Tablet,7363
Germany,Edge,Desktop,4920
Germany,Edge,Mobile,2633
Germany,Edge,Tablet,3690
France,Chrome,Desktop,8512
France,Chrome,Mobile,4339
France,Chrome,Tablet,7565
France,Firefox,Desktop,5165
France,Firefox,Mobile,4929
France,Firefox,Tablet,4207
France,Safari,Desktop,8471
France,Safari,Mobile,4772
France,Safari,Tablet,9359
France,Edge,Desktop,8058
France,Edge,Mobile,5212
France,Edge,Tablet,1542

</script><script type="text/plain" id="demo_data" data-format="csv_embedded" data-src="">
age_group,gender,preference,count
18-25,Male,Mobile,134
18-25,Male,Desktop,104
18-25,Male,Tablet,139
18-25,Female,Mobile,82
18-25,Female,Desktop,162
18-25,Female,Tablet,121
26-35,Male,Mobile,155
26-35,Male,Desktop,168
26-35,Male,Tablet,148
26-35,Female,Mobile,147
26-35,Female,Desktop,159
26-35,Female,Tablet,162
36-45,Male,Mobile,196
36-45,Male,Desktop,119
36-45,Male,Tablet,127
36-45,Female,Mobile,71
36-45,Female,Desktop,80
36-45,Female,Tablet,199
46+,Male,Mobile,147
46+,Male,Desktop,192
46+,Male,Tablet,92
46+,Female,Mobile,97
46+,Female,Desktop,54
46+,Female,Tablet,102

</script><script type="text/plain" id="store_data" data-format="csv_embedded" data-src="">
store,category,sales
Store A,Electronics,18503.529218776108
Store A,Clothing,16482.954269989918
Store A,Home & Garden,16883.363721299334
Store A,Food,7668.551204104807
Store A,Books,13389.257357856586
Store B,Electronics,23043.87269911539
Store B,Clothing,12790.478040064156
Store B,Home & Garden,17729.132632187535
Store B,Food,14799.819201036862
Store B,Books,10734.938033551165
Store C,Electronics,21526.291282007398
Store C,Clothing,21969.250623874497
Store C,Home & Garden,16755.652790402903
Store C,Food,19426.0497238476
Store C,Books,11918.705181170277

</script><script type="text/plain" id="expense_data" data-format="csv_embedded" data-src="">
department,expense_type,quarter,amount
Engineering,Salaries,Q1,5939.978434715181
Engineering,Salaries,Q2,4410.0471830587985
Engineering,Salaries,Q3,2387.9488889797417
Engineering,Salaries,Q4,8460.600267246235
Engineering,Equipment,Q1,5910.8165832073
Engineering,Equipment,Q2,6833.682873485809
Engineering,Equipment,Q3,5653.389147283398
Engineering,Equipment,Q4,6286.298419367933
Engineering,Travel,Q1,10575.83771153543
Engineering,Travel,Q2,6677.045854153072
Engineering,Travel,Q3,2735.8972817935373
Engineering,Travel,Q4,4292.139191268671
Engineering,Training,Q1,4256.092278727306
Engineering,Training,Q2,5208.550100303516
Engineering,Training,Q3,5349.625546675648
Engineering,Training,Q4,6106.840208834793
Engineering,Supplies,Q1,4147.450047440216
Engineering,Supplies,Q2,992.0222282464229
Engineering,Supplies,Q3,4284.434802401282
Engineering,Supplies,Q4,2858.0315975658787
Sales,Salaries,Q1,8267.471679044906
Sales,Salaries,Q2,6195.859057678204
Sales,Salaries,Q3,3482.8732890329543
Sales,Salaries,Q4,6024.4953997627745
Sales,Equipment,Q1,4686.170442049062
Sales,Equipment,Q2,7084.369540107865
Sales,Equipment,Q3,7162.651051812538
Sales,Equipment,Q4,1832.3605492705979
Sales,Travel,Q1,5410.651614653536
Sales,Travel,Q2,7944.13391781821
Sales,Travel,Q3,5675.76113946239
Sales,Travel,Q4,3964.7967921365102
Sales,Training,Q1,6038.328130161985
Sales,Training,Q2,2374.911366091249
Sales,Training,Q3,3168.1525700880293
Sales,Training,Q4,3913.2998349887384
Sales,Supplies,Q1,5773.9929877486065
Sales,Supplies,Q2,6789.8755738510445
Sales,Supplies,Q3,9367.31149612241
Sales,Supplies,Q4,6418.270084534872
Marketing,Salaries,Q1,1228.9170051736824
Marketing,Salaries,Q2,7046.84323585579
Marketing,Salaries,Q3,6432.630813451842
Marketing,Salaries,Q4,7081.351142469832
Marketing,Equipment,Q1,3791.6771958798945
Marketing,Equipment,Q2,5087.147958545756
Marketing,Equipment,Q3,6403.511294605207
Marketing,Equipment,Q4,2653.412031598319
Marketing,Travel,Q1,6724.6605963654365
Marketing,Travel,Q2,3413.5985785774255
Marketing,Travel,Q3,4596.041769761954
Marketing,Travel,Q4,3468.3479387666257
Marketing,Training,Q1,7710.420860682644
Marketing,Training,Q2,5622.612053719645
Marketing,Training,Q3,6118.387639362843
Marketing,Training,Q4,6395.3750610064835
Marketing,Supplies,Q1,8416.521394463862
Marketing,Supplies,Q2,4457.002593769017
Marketing,Supplies,Q3,1597.3847737801048
Marketing,Supplies,Q4,3534.3134471872736
Operations,Salaries,Q1,2430.0154097426926
Operations,Salaries,Q2,5349.383611769229
Operations,Salaries,Q3,5289.604351524745
Operations,Salaries,Q4,4462.870853714386
Operations,Equipment,Q1,5915.0952032846635
Operations,Equipment,Q2,2300.0722653511425
Operations,Equipment,Q3,4127.745286754856
Operations,Equipment,Q4,6539.030664399912
Operations,Travel,Q1,6439.559410135892
Operations,Travel,Q2,2461.392228733153
Operations,Travel,Q3,6960.8238011529975
Operations,Travel,Q4,6043.893720098054
Operations,Training,Q1,4098.020801132082
Operations,Training,Q2,5094.465622347089
Operations,Training,Q3,3268.5896996041606
Operations,Training,Q4,2979.3053948016404
Operations,Supplies,Q1,2736.602784486981
Operations,Supplies,Q2,2841.2181437555823
Operations,Supplies,Q3,6955.8554167754155
Operations,Supplies,Q4,3531.46758918422
HR,Salaries,Q1,4711.0788695449555
HR,Salaries,Q2,7856.089552887057
HR,Salaries,Q3,6311.508037968025
HR,Salaries,Q4,4167.188025955025
HR,Equipment,Q1,5282.470064611541
HR,Equipment,Q2,2632.2357765757265
HR,Equipment,Q3,4490.772887526044
HR,Equipment,Q4,6281.50546359416
HR,Travel,Q1,5134.006348309657
HR,Travel,Q2,4348.058024337754
HR,Travel,Q3,5052.409308164372
HR,Travel,Q4,5508.792340866988
HR,Training,Q1,2172.0267506784467
HR,Training,Q2,7439.826789374884
HR,Training,Q3,6589.2279700843055
HR,Training,Q4,4250.87104667212
HR,Supplies,Q1,7926.95889636187
HR,Supplies,Q2,2091.298391884226
HR,Supplies,Q3,6117.948941533342
HR,Supplies,Q4,5700.249523367627

</script><script type="text/plain" id="company.employees" data-format="csv_embedded" data-src="">
department,headcount
Engineering,120
Sales,80
Marketing,45
Support,60
Admin,25

</script><script type="text/plain" id="segment_data" data-format="csv_embedded" data-src="">
segment,revenue_contribution
Enterprise,55
Mid-Market,25
Small Business,12
Startup,6
Individual,2

</script><script type="text/plain" id="company.revenue" data-format="csv_embedded" data-src="">
source,amount
Subscriptions,45000
Licensing,28000
Services,18000
Hardware,7000
Other,2000

</script><script type="text/plain" id="market_data" data-format="csv_embedded" data-src="">
company,revenue,units
Company A,45000,1200
Company B,32000,900
Company C,18000,600
Company D,12000,400
Company E,8000,250

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/piechart_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>PieChart Examples</h1>
<p>This page demonstrates the key features of PieChart plots in JSPlots.</p>
<ul>
    <li><strong>Basic pie chart:</strong> Simple proportional visualization</li>
    <li><strong>Donut charts:</strong> Pie charts with hollow centers</li>
    <li><strong>Interactive filters:</strong> Dropdown menus to filter data dynamically</li>
    <li><strong>Faceting:</strong> Facet wrap (1 variable) and facet grid (2 variables)</li>
    <li><strong>Aggregation:</strong> Automatic aggregation of values by label</li>
    <li><strong>Color consistency:</strong> Same labels always get same colors</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Example 1: Market Share by Revenue</h2>
<p>Basic pie chart showing relative market share. Toggle between revenue and units sold using the dropdown.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="value_col_select_market_share">Slice size: </label>
                <select id="value_col_select_market_share" onchange="updateChart_market_share()">
                <option value="revenue" selected>revenue</option>
                <option value="units">units</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="value_col_select_market_share_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="market_share_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="market_share_aspect_ratio_label">0.4</span>
    <input type="range" id="market_share_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="market_share"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: market_data</p><br>
<hr>
<br>
<h2>Example 2: Budget Allocation (Donut Chart)</h2>
<p>Donut chart (hole=0.4) showing budget distribution across categories</p>



<!-- Chart -->
<div id="budget_donut"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: budget_data</p><br>
<hr>
<br>
<h2>Example 3: Product Sales with Filters</h2>
<p>Interactive filters allow you to select different regions and years. Try selecting multiple options!</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="sales_filtered_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="region_select_sales_filtered">region: </label>
                <select id="region_select_sales_filtered" multiple onchange="updateChart_sales_filtered()">
                <option value="East" selected>East</option>
                <option value="North" selected>North</option>
                <option value="South" selected>South</option>
                <option value="West" selected>West</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="region_select_sales_filtered_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 10px; display: flex; align-items: flex-start;">
    <div style="flex: 0 0 70%;">
        <label style="display: block; margin-bottom: 5px; font-weight: bold;">year: </label>
        <span id="year_range_sales_filtered_display" style="display: inline-block; min-width: 200px; font-size: 0.9em; color: #666;">2022 - 2024</span>
        <div id="year_range_sales_filtered_slider" style="margin: 10px 5px; width: 90%;"></div>
    </div>
    <div style="flex: 0 0 30%; text-align: right; padding-right: 10px; padding-top: 25px;">
        <span id="year_range_sales_filtered_obs_count" style="font-size: 0.9em; color: #666;"></span>
    </div>
    <script>
        $(function() {
            // Value formatter function
            function formatValue_year_range_sales_filtered(x) {
    return Math.round(x).toString();
}

            // Initialize jQuery UI range slider
            $("#year_range_sales_filtered_slider").slider({
                range: true,
                min: 2022.0,
                max: 2024.0,
                step: 1.0,  // Integer steps for integers, smooth for others
                values: [2022.0, 2024.0],
                slide: function(event, ui) {
                    // Update display during sliding
                    const minVal = ui.values[0];
                    const maxVal = ui.values[1];
                    $("#year_range_sales_filtered_display").text(formatValue_year_range_sales_filtered(minVal) + " - " + formatValue_year_range_sales_filtered(maxVal));
                },
                change: function(event, ui) {
                    // Update display and trigger chart update
                    const minVal = ui.values[0];
                    const maxVal = ui.values[1];
                    $("#year_range_sales_filtered_display").text(formatValue_year_range_sales_filtered(minVal) + " - " + formatValue_year_range_sales_filtered(maxVal));

                    // Store values for easy access
                    $("#year_range_sales_filtered_slider").data('minValue', minVal);
                    $("#year_range_sales_filtered_slider").data('maxValue', maxVal);

                    // Call the update function
                    updateChart_sales_filtered()
                }
            });

            // Store initial values
            $("#year_range_sales_filtered_slider").data('minValue', 2022.0);
            $("#year_range_sales_filtered_slider").data('maxValue', 2024.0);
        });

        // Helper functions to get slider values
        function getyear_range_sales_filteredMin() {
            return $("#year_range_sales_filtered_slider").slider("values", 0);
        }

        function getyear_range_sales_filteredMax() {
            return $("#year_range_sales_filtered_slider").slider("values", 1);
        }
    </script>
</div>

</div>


<!-- Chart -->
<div id="sales_filtered"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data</p><br>
<hr>
<br>
<h2>Example 4: Product Sales Faceted by Region</h2>
<p>Facet wrap creates a grid of pie charts, one for each region. Note single facet dropdown!</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="sales_by_region_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
    <div style="margin: 15px 10px; display: flex; align-items: flex-start;">
    <div style="flex: 0 0 70%;">
        <label style="display: block; margin-bottom: 5px; font-weight: bold;">year: </label>
        <span id="year_range_sales_by_region_display" style="display: inline-block; min-width: 200px; font-size: 0.9em; color: #666;">2022 - 2024</span>
        <div id="year_range_sales_by_region_slider" style="margin: 10px 5px; width: 90%;"></div>
    </div>
    <div style="flex: 0 0 30%; text-align: right; padding-right: 10px; padding-top: 25px;">
        <span id="year_range_sales_by_region_obs_count" style="font-size: 0.9em; color: #666;"></span>
    </div>
    <script>
        $(function() {
            // Value formatter function
            function formatValue_year_range_sales_by_region(x) {
    return Math.round(x).toString();
}

            // Initialize jQuery UI range slider
            $("#year_range_sales_by_region_slider").slider({
                range: true,
                min: 2022.0,
                max: 2024.0,
                step: 1.0,  // Integer steps for integers, smooth for others
                values: [2022.0, 2024.0],
                slide: function(event, ui) {
                    // Update display during sliding
                    const minVal = ui.values[0];
                    const maxVal = ui.values[1];
                    $("#year_range_sales_by_region_display").text(formatValue_year_range_sales_by_region(minVal) + " - " + formatValue_year_range_sales_by_region(maxVal));
                },
                change: function(event, ui) {
                    // Update display and trigger chart update
                    const minVal = ui.values[0];
                    const maxVal = ui.values[1];
                    $("#year_range_sales_by_region_display").text(formatValue_year_range_sales_by_region(minVal) + " - " + formatValue_year_range_sales_by_region(maxVal));

                    // Store values for easy access
                    $("#year_range_sales_by_region_slider").data('minValue', minVal);
                    $("#year_range_sales_by_region_slider").data('maxValue', maxVal);

                    // Call the update function
                    updateChart_sales_by_region()
                }
            });

            // Store initial values
            $("#year_range_sales_by_region_slider").data('minValue', 2022.0);
            $("#year_range_sales_by_region_slider").data('maxValue', 2024.0);
        });

        // Helper functions to get slider values
        function getyear_range_sales_by_regionMin() {
            return $("#year_range_sales_by_region_slider").slider("values", 0);
        }

        function getyear_range_sales_by_regionMax() {
            return $("#year_range_sales_by_region_slider").slider("values", 1);
        }
    </script>
</div>

</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0;">
    <label for="facet1_select_sales_by_region">Facet by: </label>
    <select id="facet1_select_sales_by_region" onchange="updateChart_sales_by_region()">
        <option value="None">None</option>
<option value="region" selected>region</option>
    </select>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="sales_by_region_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="sales_by_region_aspect_ratio_label">0.4</span>
    <input type="range" id="sales_by_region_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="sales_by_region"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data</p><br>
<hr>
<br>
<h2>Example 5: Device Preference by Age and Gender (Facet Grid)</h2>
<p>2D facet grid showing device preferences across age groups (rows) and gender (columns)</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="facet1_select_demographics_grid">Facet 1: </label>
        <select id="facet1_select_demographics_grid" style="padding: 5px 10px;" onchange="updateChart_demographics_grid()">
            <option value="None">None</option>
<option value="age_group" selected>age_group</option>
<option value="gender">gender</option>
        </select>
    </div>
    <div>
        <label for="facet2_select_demographics_grid">Facet 2: </label>
        <select id="facet2_select_demographics_grid" style="padding: 5px 10px;" onchange="updateChart_demographics_grid()">
            <option value="None">None</option>
<option value="age_group">age_group</option>
<option value="gender" selected>gender</option>
        </select>
    </div>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="demographics_grid_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="demographics_grid_aspect_ratio_label">0.4</span>
    <input type="range" id="demographics_grid_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="demographics_grid"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: demo_data</p><br>
<hr>
<br>
<h2>Example 6: Department Expenses by Type</h2>
<p>Expenses broken down by type for each department. Try switching slice grouping to see department distribution!</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="dept_expenses_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="quarter_select_dept_expenses">quarter: </label>
                <select id="quarter_select_dept_expenses" multiple onchange="updateChart_dept_expenses()">
                <option value="Q1" selected>Q1</option>
                <option value="Q2">Q2</option>
                <option value="Q3">Q3</option>
                <option value="Q4">Q4</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="quarter_select_dept_expenses_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_dept_expenses">Slice grouping: </label>
                <select id="color_col_select_dept_expenses" onchange="updateChart_dept_expenses()">
                <option value="expense_type" selected>expense_type</option>
                <option value="department">department</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_dept_expenses_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0;">
    <label for="facet1_select_dept_expenses">Facet by: </label>
    <select id="facet1_select_dept_expenses" onchange="updateChart_dept_expenses()">
        <option value="None">None</option>
<option value="department" selected>department</option>
    </select>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="dept_expenses_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="dept_expenses_aspect_ratio_label">0.4</span>
    <input type="range" id="dept_expenses_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="dept_expenses"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: expense_data</p><br>
<hr>
<br>
<h2>Example 7: Revenue Contribution by Customer Segment (%)</h2>
<p>Donut chart showing percentage revenue contribution from different customer segments</p>



<!-- Chart -->
<div id="customer_segments"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: segment_data</p><br>
<hr>
<br>
<h2>Example 8: Category Sales by Store</h2>
<p>Compare product category distribution across different store locations (single facet variable)</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0;">
    <label for="facet1_select_store_comparison">Facet by: </label>
    <select id="facet1_select_store_comparison" onchange="updateChart_store_comparison()">
        <option value="None">None</option>
<option value="store" selected>store</option>
    </select>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="store_comparison_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="store_comparison_aspect_ratio_label">0.4</span>
    <input type="range" id="store_comparison_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="store_comparison"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: store_data</p><br>
<hr>
<br>
<h2>Example 9: Website Traffic Analysis - Dynamic Faceting</h2>
<p>Use the facet dropdowns to explore traffic patterns. Try: no faceting, facet by country only, or facet by both. Also try switching slice grouping!</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_traffic_analysis">Slice grouping: </label>
                <select id="color_col_select_traffic_analysis" onchange="updateChart_traffic_analysis()">
                <option value="browser" selected>browser</option>
                <option value="device">device</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_traffic_analysis_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="facet1_select_traffic_analysis">Facet 1: </label>
        <select id="facet1_select_traffic_analysis" style="padding: 5px 10px;" onchange="updateChart_traffic_analysis()">
            <option value="None" selected>None</option>
<option value="country">country</option>
<option value="device">device</option>
        </select>
    </div>
    <div>
        <label for="facet2_select_traffic_analysis">Facet 2: </label>
        <select id="facet2_select_traffic_analysis" style="padding: 5px 10px;" onchange="updateChart_traffic_analysis()">
            <option value="None" selected>None</option>
<option value="country">country</option>
<option value="device">device</option>
        </select>
    </div>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="traffic_analysis_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="traffic_analysis_aspect_ratio_label">0.4</span>
    <input type="range" id="traffic_analysis_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="traffic_analysis"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: traffic_data</p><br>
<hr>
<br>
<h2>Example 10: Comprehensive Sales Analysis - All Features Combined</h2>
<p>This example demonstrates ALL PieChart features: (1) Multiple slice size options (revenue, units, profit, customers), (2) Multiple grouping options (by product, channel, or region), (3) Flexible faceting (choose 0, 1, or 2 facet variables), (4) Interactive filters (select quarters). Try different combinations!</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="comprehensive_sales_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="quarter_select_comprehensive_sales">quarter: </label>
                <select id="quarter_select_comprehensive_sales" multiple onchange="updateChart_comprehensive_sales()">
                <option value="Q1-2024">Q1-2024</option>
                <option value="Q2-2024">Q2-2024</option>
                <option value="Q3-2024">Q3-2024</option>
                <option value="Q4-2024" selected>Q4-2024</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="quarter_select_comprehensive_sales_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="value_col_select_comprehensive_sales">Slice size: </label>
                <select id="value_col_select_comprehensive_sales" onchange="updateChart_comprehensive_sales()">
                <option value="revenue" selected>revenue</option>
                <option value="units_sold">units_sold</option>
                <option value="profit">profit</option>
                <option value="customer_count">customer_count</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="value_col_select_comprehensive_sales_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_comprehensive_sales">Slice grouping: </label>
                <select id="color_col_select_comprehensive_sales" onchange="updateChart_comprehensive_sales()">
                <option value="product" selected>product</option>
                <option value="channel">channel</option>
                <option value="region">region</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_comprehensive_sales_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="facet1_select_comprehensive_sales">Facet 1: </label>
        <select id="facet1_select_comprehensive_sales" style="padding: 5px 10px;" onchange="updateChart_comprehensive_sales()">
            <option value="None" selected>None</option>
<option value="region">region</option>
<option value="channel">channel</option>
<option value="quarter">quarter</option>
        </select>
    </div>
    <div>
        <label for="facet2_select_comprehensive_sales">Facet 2: </label>
        <select id="facet2_select_comprehensive_sales" style="padding: 5px 10px;" onchange="updateChart_comprehensive_sales()">
            <option value="None" selected>None</option>
<option value="region">region</option>
<option value="channel">channel</option>
<option value="quarter">quarter</option>
        </select>
    </div>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="comprehensive_sales_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="comprehensive_sales_aspect_ratio_label">0.4</span>
    <input type="range" id="comprehensive_sales_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="comprehensive_sales"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: comprehensive_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Struct Data Source Example</h2>
<p>This pie chart uses data from a struct containing multiple DataFrames.
The <code>CompanyData</code> struct holds both revenue and employees data.
Charts reference the revenue DataFrame using <code>Symbol("company.revenue")</code>.</p>

    </div>
<br>
<hr>
<br>
<h2>Example 11: Revenue Sources from Struct Data Source</h2>
<p>This example shows how to use a struct as a data source. The CompanyData struct contains revenue and employees DataFrames. Access struct fields via dot notation.</p>



<!-- Chart -->
<div id="struct_pie"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: company.revenue</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Key Features Summary</h2>
<ul>
    <li><strong>Automatic aggregation:</strong> Values are automatically summed by label</li>
    <li><strong>Donut charts:</strong> Set hole parameter (0 = pie, >0 = donut)</li>
    <li><strong>Color consistency:</strong> Same labels always get the same colors across facets</li>
    <li><strong>Interactive filters:</strong> Multi-select dropdowns for dynamic data filtering</li>
    <li><strong>Variable selection:</strong> Choose which columns to use for slice sizes and groupings</li>
    <li><strong>Faceting support:</strong> Create small multiples with 1 or 2 faceting variables</li>
    <li><strong>Smart facet controls:</strong> Single dropdown when only one facet variable is available</li>
    <li><strong>Flexible layout:</strong> Facet wrap automatically arranges charts in a grid</li>
    <li><strong>Hover details:</strong> See exact values and percentages on hover</li>
</ul>
<p><strong>Tip:</strong> Hover over slices to see exact values and percentages. Use faceting to compare distributions across categories. Try switching between different value and label columns!</p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.4.2.</small></p>
</body>
</html>
