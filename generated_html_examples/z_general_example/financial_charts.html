<!DOCTYPE html>
<html>
<head>
    <title>Financial Charts</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const TIME_FROM_COL = 'time_from';
    const TIME_TO_COL = 'time_to';
    const SYMBOL_COL = 'symbol';
    const OPEN_COL = 'open';
    const HIGH_COL = 'high';
    const LOW_COL = 'low';
    const CLOSE_COL = 'close';
    const VOLUME_COL = 'volume';
    const HAS_VOLUME = true;
    const CATEGORICAL_FILTERS = ['sector'];
    const CONTINUOUS_FILTERS = [];

    let allData = [];
    let firstBarOpenPrices = {};  // Store first bar open prices for renormalization

    // Make it global so inline onchange can see it
    window.updateChart_financial_candlestick = function() {
        // Get current control values
        const renormalizeCheckbox = document.getElementById('renormalize_checkbox_financial_candlestick');
        const RENORMALIZE = renormalizeCheckbox ? renormalizeCheckbox.checked : false;

        const showVolumeCheckbox = document.getElementById('show_volume_checkbox_financial_candlestick');
        const SHOW_VOLUME = HAS_VOLUME && showVolumeCheckbox ? showVolumeCheckbox.checked : false;

        const logVolumeCheckbox = document.getElementById('log_volume_checkbox_financial_candlestick');
        const LOG_VOLUME = SHOW_VOLUME && logVolumeCheckbox ? logVolumeCheckbox.checked : false;

        const chartTypeSelect = document.getElementById('chart_type_select_financial_candlestick');
        const CHART_TYPE = chartTypeSelect ? chartTypeSelect.value : 'candlestick';

        const displayModeSelect = document.getElementById('display_mode_select_financial_candlestick');
        const DISPLAY_MODE = displayModeSelect ? displayModeSelect.value : 'Overlay';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_financial_candlestick');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_financial_candlestick' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting
        const filteredData = applyFiltersWithCounting(
            allData,
            'financial_candlestick',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Group data by symbol
        const symbolData = {};
        filteredData.forEach(row => {
            const symbol = String(row[SYMBOL_COL]);
            if (!symbolData[symbol]) {
                symbolData[symbol] = [];
            }
            symbolData[symbol].push(row);
        });

        // Sort each symbol's data by time
        for (let symbol in symbolData) {
            symbolData[symbol].sort((a, b) => {
                const aTime = a[TIME_FROM_COL];
                const bTime = b[TIME_FROM_COL];
                if (aTime instanceof Date && bTime instanceof Date) {
                    return aTime - bTime;
                }
                return aTime < bTime ? -1 : (aTime > bTime ? 1 : 0);
            });
        }

        // Calculate first bar open prices for renormalization (only once)
        if (Object.keys(firstBarOpenPrices).length === 0 || !RENORMALIZE) {
            firstBarOpenPrices = {};
            for (let symbol in symbolData) {
                if (symbolData[symbol].length > 0) {
                    firstBarOpenPrices[symbol] = symbolData[symbol][0][OPEN_COL];
                }
            }
        }

        // Route to appropriate rendering function
        if (DISPLAY_MODE === 'Overlay') {
            renderOverlay(symbolData, RENORMALIZE, SHOW_VOLUME, LOG_VOLUME, CHART_TYPE);
        } else {
            renderFaceted(symbolData, RENORMALIZE, SHOW_VOLUME, LOG_VOLUME, CHART_TYPE);
        }
    };

    // Render overlay mode (all symbols on same chart)
    function renderOverlay(symbolData, renormalize, showVolume, logVolume, chartType) {
        const traces = [];
        const symbols = Object.keys(symbolData).sort();
        const colorPalette = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A',
                             '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];

        symbols.forEach((symbol, idx) => {
            const data = symbolData[symbol];
            const color = colorPalette[idx % colorPalette.length];

            // Prepare Candlestick data
            const x = data.map(row => row[TIME_FROM_COL]);
            let open = data.map(row => row[OPEN_COL]);
            let high = data.map(row => row[HIGH_COL]);
            let low = data.map(row => row[LOW_COL]);
            let close = data.map(row => row[CLOSE_COL]);

            // Apply renormalization if enabled
            if (renormalize && firstBarOpenPrices[symbol] && firstBarOpenPrices[symbol] !== 0) {
                const base = firstBarOpenPrices[symbol];
                open = open.map(v => v / base);
                high = high.map(v => v / base);
                low = low.map(v => v / base);
                close = close.map(v => v / base);
            }

            // Candlestick trace
            const candlestickTrace = {
                x: x,
                open: open,
                high: high,
                low: low,
                close: close,
                type: chartType,
                name: symbol,
                xaxis: 'x',
                yaxis: 'y',
                increasing: {line: {color: color}},
                decreasing: {line: {color: color}}
            };
            traces.push(candlestickTrace);

            // Volume trace if enabled
            if (showVolume && HAS_VOLUME) {
                let volumes = data.map(row => row[VOLUME_COL]);
                if (logVolume) {
                    volumes = volumes.map(v => Math.log(v + 1));
                }

                const volumeTrace = {
                    x: x,
                    y: volumes,
                    type: 'bar',
                    name: symbol + ' Volume',
                    xaxis: 'x',
                    yaxis: 'y2',
                    marker: {color: color},
                    showlegend: false
                };
                traces.push(volumeTrace);
            }
        });

        // Layout configuration
        const layout = {
            xaxis: {
                title: TIME_FROM_COL,
                anchor: 'y'
            },
            hovermode: 'closest',
            showlegend: true
        };

        if (showVolume && HAS_VOLUME) {
            // Two subplots: Candlestick on top, volume on bottom
            layout.yaxis = {
                title: renormalize ? 'Normalized Price' : 'Price',
                domain: [0.3, 1]
            };
            layout.yaxis2 = {
                title: logVolume ? 'log(Volume)' : 'Volume',
                domain: [0, 0.25],
                anchor: 'x'
            };
            layout.barmode = 'group';  // Dodge volume bars
        } else {
            // Single plot: Candlestick only
            layout.yaxis = {
                title: renormalize ? 'Normalized Price' : 'Price'
            };
        }

        Plotly.newPlot('financial_candlestick', traces, layout, {responsive: true});
    }

    // Render faceted mode (one subplot per symbol)
    function renderFaceted(symbolData, renormalize, showVolume, logVolume, chartType) {
        const symbols = Object.keys(symbolData).sort();
        const nSymbols = symbols.length;

        // Calculate grid dimensions (prefer wider grids)
        const nCols = Math.ceil(Math.sqrt(nSymbols * 1.5));
        const nRows = Math.ceil(nSymbols / nCols);

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: false,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        if (showVolume && HAS_VOLUME) {
            layout.barmode = 'group';
        }

        symbols.forEach((symbol, idx) => {
            const data = symbolData[symbol];

            // Prepare Candlestick data
            const x = data.map(row => row[TIME_FROM_COL]);
            let open = data.map(row => row[OPEN_COL]);
            let high = data.map(row => row[HIGH_COL]);
            let low = data.map(row => row[LOW_COL]);
            let close = data.map(row => row[CLOSE_COL]);

            // Apply renormalization if enabled
            if (renormalize && firstBarOpenPrices[symbol] && firstBarOpenPrices[symbol] !== 0) {
                const base = firstBarOpenPrices[symbol];
                open = open.map(v => v / base);
                high = high.map(v => v / base);
                low = low.map(v => v / base);
                close = close.map(v => v / base);
            }

            const row = Math.floor(idx / nCols) + 1;
            const col = (idx % nCols) + 1;
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

            // Candlestick trace
            const candlestickTrace = {
                x: x,
                open: open,
                high: high,
                low: low,
                close: close,
                type: chartType,
                name: symbol,
                xaxis: xaxis,
                yaxis: yaxis
            };
            traces.push(candlestickTrace);

            // Volume trace if enabled
            if (showVolume && HAS_VOLUME) {
                let volumes = data.map(row => row[VOLUME_COL]);
                if (logVolume) {
                    volumes = volumes.map(v => Math.log(v + 1));
                }

                const yaxis_vol = idx === 0 ? 'y' + (nSymbols + 1) : 'y' + (nSymbols + idx + 1);

                const volumeTrace = {
                    x: x,
                    y: volumes,
                    type: 'bar',
                    name: symbol + ' Volume',
                    xaxis: xaxis,
                    yaxis: yaxis_vol,
                    showlegend: false
                };
                traces.push(volumeTrace);

                // Configure volume yaxis
                layout[yaxis_vol] = {
                    title: row === nRows ? (logVolume ? 'log(Vol)' : 'Vol') : '',
                    anchor: xaxis
                };
            }

            // Add axis configuration
            layout[xaxis] = {
                title: row === nRows ? TIME_FROM_COL : '',
                anchor: yaxis
            };
            layout[yaxis] = {
                title: col === 1 ? (renormalize ? 'Norm Price' : 'Price') : '',
                anchor: xaxis
            };

            // Add annotation for symbol label
            if (!layout.annotations) layout.annotations = [];
            layout.annotations.push({
                text: symbol,
                showarrow: false,
                xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                x: 0.5,
                y: 1.05,
                xanchor: 'center',
                yanchor: 'bottom',
                font: {size: 10}
            });
        });

        Plotly.newPlot('financial_candlestick', traces, layout, {responsive: true});
    }

    // Load and parse CSV data using centralized parser
    loadDataset('candlestick_data').then(function(data) {
        allData = data;
        window.updateChart_financial_candlestick();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('financial_candlestick');
    }).catch(function(error) {
        console.error('Error loading data for chart financial_candlestick:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="rankings_data" data-format="parquet" data-src="data/rankings_data.parquet"></script><script type="text/plain" id="sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="sankey_data" data-format="parquet" data-src="data/sankey_data.parquet"></script><script type="text/plain" id="stock_corr_data" data-format="parquet" data-src="data/stock_corr_data.parquet"></script><script type="text/plain" id="tsne_stock_data" data-format="parquet" data-src="data/tsne_stock_data.parquet"></script><script type="text/plain" id="daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="boxwhiskers_data" data-format="parquet" data-src="data/boxwhiskers_data.parquet"></script><script type="text/plain" id="waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script><script type="text/plain" id="radar_data" data-format="parquet" data-src="data/radar_data.parquet"></script><script type="text/plain" id="candlestick_data" data-format="parquet" data-src="data/candlestick_data.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>Financial Charts</h1>
<p>This shows examples of financial market visualization charts. CandlestickChart displays candlestick patterns for technical analysis with volume, renormalization, and time range controls.</p>

    <div class="textblock-content">
        <h1>Financial Charts</h1>
    </div>
<br>
<hr>
<br>
<h2>Stock Price Analysis - Q1 2024</h2>
<p>An Candlestick (Open-High-Low-Close) chart displays financial market data with candlesticks showing price movements. This example tracks AAPL, MSFT, and GOOGL through Q1 2024. <strong>Key Features:</strong> Time range sliders to zoom into specific date ranges (drag the handles to adjust), Renormalize toggle to compare stocks at different price levels (divides all prices by first bar's open price, setting it to 1.0), Display mode dropdown to switch between Overlay (all symbols on same chart) and Faceted (one subplot per symbol), Volume bars at bottom with Show/Hide toggle and Log scale option (useful when volume varies greatly), Chart type selector to switch between candlestick (filled bars) and Candlestick (line bars) styles, Filter controls to select which stocks and sectors to display. The volume bars use a dodged (grouped) layout and align perfectly with the Candlestick bars above. This visualization is essential for technical analysis, allowing traders to identify patterns, trends, and volume spikes. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/candlestickchart_examples.html" style="color: blue; font-weight: bold;">See here for CandlestickChart examples</a></p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="financial_candlestick_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="sector_select_financial_candlestick">sector: </label>
                <select id="sector_select_financial_candlestick" multiple onchange="updateChart_financial_candlestick()">
                <option value="Technology" selected>Technology</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="sector_select_financial_candlestick_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="chart_type_select_financial_candlestick">Chart Type: </label>
                <select id="chart_type_select_financial_candlestick" onchange="updateChart_financial_candlestick()">
                <option value="candlestick" selected>candlestick</option>
                <option value="ohlc">ohlc</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="chart_type_select_financial_candlestick_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="display_mode_select_financial_candlestick">Display Mode: </label>
                <select id="display_mode_select_financial_candlestick" onchange="updateChart_financial_candlestick()">
                <option value="Overlay" selected>Overlay</option>
                <option value="Faceted">Faceted</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="display_mode_select_financial_candlestick_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
            <div style="margin: 10px; display: flex; flex-direction: column;">
        <div style="margin: 5px 0;">
            <input type="checkbox" id="renormalize_checkbox_financial_candlestick" onchange="updateChart_financial_candlestick()">
            <label for="renormalize_checkbox_financial_candlestick">Renormalize (first bar open = 1)</label>
        </div>
    <div style="margin: 5px 0;">
        <input type="checkbox" id="show_volume_checkbox_financial_candlestick" checked onchange="updateChart_financial_candlestick()">
        <label for="show_volume_checkbox_financial_candlestick">Show Volume</label>
    </div>
    <div style="margin: 5px 0;">
        <input type="checkbox" id="log_volume_checkbox_financial_candlestick" onchange="updateChart_financial_candlestick()">
        <label for="log_volume_checkbox_financial_candlestick">Log Volume</label>
    </div>
    </div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="financial_candlestick_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="financial_candlestick_aspect_ratio_label">0.6</span>
    <input type="range" id="financial_candlestick_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="financial_candlestick"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: candlestick_data.parquet</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.4.2.</small></p>
</body>
</html>
