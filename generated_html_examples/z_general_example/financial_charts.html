<!DOCTYPE html>
<html>
<head>
    <title>Financial Charts</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const TIME_FROM_COL = 'time_from';
    const TIME_TO_COL = 'time_to';
    const SYMBOL_COL = 'symbol';
    const OPEN_COL = 'open';
    const HIGH_COL = 'high';
    const LOW_COL = 'low';
    const CLOSE_COL = 'close';
    const VOLUME_COL = 'volume';
    const HAS_VOLUME = true;
    const CATEGORICAL_FILTERS = ['sector'];
    const CONTINUOUS_FILTERS = [];

    let allData = [];
    let firstBarOpenPrices = {};  // Store first bar open prices for renormalization

    // Make it global so inline onchange can see it
    window.updateChart_financial_ohlc = function() {
        // Get current control values
        const renormalizeCheckbox = document.getElementById('renormalize_checkbox_financial_ohlc');
        const RENORMALIZE = renormalizeCheckbox ? renormalizeCheckbox.checked : false;

        const showVolumeCheckbox = document.getElementById('show_volume_checkbox_financial_ohlc');
        const SHOW_VOLUME = HAS_VOLUME && showVolumeCheckbox ? showVolumeCheckbox.checked : false;

        const logVolumeCheckbox = document.getElementById('log_volume_checkbox_financial_ohlc');
        const LOG_VOLUME = SHOW_VOLUME && logVolumeCheckbox ? logVolumeCheckbox.checked : false;

        const chartTypeSelect = document.getElementById('chart_type_select_financial_ohlc');
        const CHART_TYPE = chartTypeSelect ? chartTypeSelect.value : 'candlestick';

        const displayModeSelect = document.getElementById('display_mode_select_financial_ohlc');
        const DISPLAY_MODE = displayModeSelect ? displayModeSelect.value : 'Overlay';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_financial_ohlc');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_financial_ohlc' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting
        const filteredData = applyFiltersWithCounting(
            allData,
            'financial_ohlc',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Group data by symbol
        const symbolData = {};
        filteredData.forEach(row => {
            const symbol = String(row[SYMBOL_COL]);
            if (!symbolData[symbol]) {
                symbolData[symbol] = [];
            }
            symbolData[symbol].push(row);
        });

        // Sort each symbol's data by time
        for (let symbol in symbolData) {
            symbolData[symbol].sort((a, b) => {
                const aTime = a[TIME_FROM_COL];
                const bTime = b[TIME_FROM_COL];
                if (aTime instanceof Date && bTime instanceof Date) {
                    return aTime - bTime;
                }
                return aTime < bTime ? -1 : (aTime > bTime ? 1 : 0);
            });
        }

        // Calculate first bar open prices for renormalization (only once)
        if (Object.keys(firstBarOpenPrices).length === 0 || !RENORMALIZE) {
            firstBarOpenPrices = {};
            for (let symbol in symbolData) {
                if (symbolData[symbol].length > 0) {
                    firstBarOpenPrices[symbol] = symbolData[symbol][0][OPEN_COL];
                }
            }
        }

        // Route to appropriate rendering function
        if (DISPLAY_MODE === 'Overlay') {
            renderOverlay(symbolData, RENORMALIZE, SHOW_VOLUME, LOG_VOLUME, CHART_TYPE);
        } else {
            renderFaceted(symbolData, RENORMALIZE, SHOW_VOLUME, LOG_VOLUME, CHART_TYPE);
        }
    };

    // Render overlay mode (all symbols on same chart)
    function renderOverlay(symbolData, renormalize, showVolume, logVolume, chartType) {
        const traces = [];
        const symbols = Object.keys(symbolData).sort();
        const colorPalette = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A',
                             '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];

        symbols.forEach((symbol, idx) => {
            const data = symbolData[symbol];
            const color = colorPalette[idx % colorPalette.length];

            // Prepare OHLC data
            const x = data.map(row => row[TIME_FROM_COL]);
            let open = data.map(row => row[OPEN_COL]);
            let high = data.map(row => row[HIGH_COL]);
            let low = data.map(row => row[LOW_COL]);
            let close = data.map(row => row[CLOSE_COL]);

            // Apply renormalization if enabled
            if (renormalize && firstBarOpenPrices[symbol] && firstBarOpenPrices[symbol] !== 0) {
                const base = firstBarOpenPrices[symbol];
                open = open.map(v => v / base);
                high = high.map(v => v / base);
                low = low.map(v => v / base);
                close = close.map(v => v / base);
            }

            // OHLC trace
            const ohlcTrace = {
                x: x,
                open: open,
                high: high,
                low: low,
                close: close,
                type: chartType,
                name: symbol,
                xaxis: 'x',
                yaxis: 'y',
                increasing: {line: {color: color}},
                decreasing: {line: {color: color}}
            };
            traces.push(ohlcTrace);

            // Volume trace if enabled
            if (showVolume && HAS_VOLUME) {
                let volumes = data.map(row => row[VOLUME_COL]);
                if (logVolume) {
                    volumes = volumes.map(v => Math.log(v + 1));
                }

                const volumeTrace = {
                    x: x,
                    y: volumes,
                    type: 'bar',
                    name: symbol + ' Volume',
                    xaxis: 'x',
                    yaxis: 'y2',
                    marker: {color: color},
                    showlegend: false
                };
                traces.push(volumeTrace);
            }
        });

        // Layout configuration
        const layout = {
            xaxis: {
                title: TIME_FROM_COL,
                anchor: 'y'
            },
            hovermode: 'closest',
            showlegend: true
        };

        if (showVolume && HAS_VOLUME) {
            // Two subplots: OHLC on top, volume on bottom
            layout.yaxis = {
                title: renormalize ? 'Normalized Price' : 'Price',
                domain: [0.3, 1]
            };
            layout.yaxis2 = {
                title: logVolume ? 'log(Volume)' : 'Volume',
                domain: [0, 0.25],
                anchor: 'x'
            };
            layout.barmode = 'group';  // Dodge volume bars
        } else {
            // Single plot: OHLC only
            layout.yaxis = {
                title: renormalize ? 'Normalized Price' : 'Price'
            };
        }

        Plotly.newPlot('financial_ohlc', traces, layout, {responsive: true});
    }

    // Render faceted mode (one subplot per symbol)
    function renderFaceted(symbolData, renormalize, showVolume, logVolume, chartType) {
        const symbols = Object.keys(symbolData).sort();
        const nSymbols = symbols.length;

        // Calculate grid dimensions (prefer wider grids)
        const nCols = Math.ceil(Math.sqrt(nSymbols * 1.5));
        const nRows = Math.ceil(nSymbols / nCols);

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: false,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        if (showVolume && HAS_VOLUME) {
            layout.barmode = 'group';
        }

        symbols.forEach((symbol, idx) => {
            const data = symbolData[symbol];

            // Prepare OHLC data
            const x = data.map(row => row[TIME_FROM_COL]);
            let open = data.map(row => row[OPEN_COL]);
            let high = data.map(row => row[HIGH_COL]);
            let low = data.map(row => row[LOW_COL]);
            let close = data.map(row => row[CLOSE_COL]);

            // Apply renormalization if enabled
            if (renormalize && firstBarOpenPrices[symbol] && firstBarOpenPrices[symbol] !== 0) {
                const base = firstBarOpenPrices[symbol];
                open = open.map(v => v / base);
                high = high.map(v => v / base);
                low = low.map(v => v / base);
                close = close.map(v => v / base);
            }

            const row = Math.floor(idx / nCols) + 1;
            const col = (idx % nCols) + 1;
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

            // OHLC trace
            const ohlcTrace = {
                x: x,
                open: open,
                high: high,
                low: low,
                close: close,
                type: chartType,
                name: symbol,
                xaxis: xaxis,
                yaxis: yaxis
            };
            traces.push(ohlcTrace);

            // Volume trace if enabled
            if (showVolume && HAS_VOLUME) {
                let volumes = data.map(row => row[VOLUME_COL]);
                if (logVolume) {
                    volumes = volumes.map(v => Math.log(v + 1));
                }

                const yaxis_vol = idx === 0 ? 'y' + (nSymbols + 1) : 'y' + (nSymbols + idx + 1);

                const volumeTrace = {
                    x: x,
                    y: volumes,
                    type: 'bar',
                    name: symbol + ' Volume',
                    xaxis: xaxis,
                    yaxis: yaxis_vol,
                    showlegend: false
                };
                traces.push(volumeTrace);

                // Configure volume yaxis
                layout[yaxis_vol] = {
                    title: row === nRows ? (logVolume ? 'log(Vol)' : 'Vol') : '',
                    anchor: xaxis
                };
            }

            // Add axis configuration
            layout[xaxis] = {
                title: row === nRows ? TIME_FROM_COL : '',
                anchor: yaxis
            };
            layout[yaxis] = {
                title: col === 1 ? (renormalize ? 'Norm Price' : 'Price') : '',
                anchor: xaxis
            };

            // Add annotation for symbol label
            if (!layout.annotations) layout.annotations = [];
            layout.annotations.push({
                text: symbol,
                showarrow: false,
                xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                x: 0.5,
                y: 1.05,
                xanchor: 'center',
                yanchor: 'bottom',
                font: {size: 10}
            });
        });

        Plotly.newPlot('financial_ohlc', traces, layout, {responsive: true});
    }

    // Load and parse CSV data using centralized parser
    loadDataset('ohlc_data').then(function(data) {
        allData = data;
        window.updateChart_financial_ohlc();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('financial_ohlc');
    }).catch(function(error) {
        console.error('Error loading data for chart financial_ohlc:', error);
    });
})();
(function() {
    // Configuration
    const TIME_COL = 'time';
    const BID_COL = 'bid';
    const ASK_COL = 'ask';
    const TIME_FROM_COL = 'time_from';
    const TIME_TO_COL = 'time_to';
    const VOLUME_COL = 'volume';
    const FILL_TIME_COL = 'time';
    const QUANTITY_COL = 'quantity';
    const PRICE_COL = 'price';
    const EXECUTION_NAME_COL = 'execution_name';
    const ARRIVAL_PRICE_COL = 'arrival_price';
    const HAS_ARRIVAL = true;
    const SIDE_COL = 'side';
    const DESIRED_QUANTITY_COL = 'desired_quantity';
    const COLOR_COLS = ['venue', 'urgency'];
    const COLOR_MAPS = {'venue': {'NYSE': '#EF553B', 'ARCA': '#00cc96', 'BATS': '#ab63fa', 'NASDAQ': '#636efa'}, 'urgency': {'Low': '#EF553B', 'High': '#636efa'}};
    const COLOR_PALETTE = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A',
                           '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];

    let tobData = [];
    let volumeData = [];
    let fillsData = [];
    let metadataData = [];
    let deselectedFills = new Set();  // Track manually deselected fills

    window.updateChart_tutorial_execution = function() {
        // Get current controls
        const execSelect = document.getElementById('execution_select_tutorial_execution');
        const currentExecution = execSelect ? execSelect.value : 'Aggressive Strategy';

        const benchmarkSelect = document.getElementById('benchmark_select_tutorial_execution');
        const benchmark = benchmarkSelect ? benchmarkSelect.value : (HAS_ARRIVAL ? 'arrival' : 'first');

        const showVolumeCheckbox = document.getElementById('show_volume_checkbox_tutorial_execution');
        const showVolume = showVolumeCheckbox ? showVolumeCheckbox.checked : true;

        // Get data for current execution
        const execMetadata = metadataData.find(row => String(row[EXECUTION_NAME_COL]) === currentExecution);
        if (!execMetadata) {
            console.error('No metadata found for execution:', currentExecution);
            return;
        }

        const execFills = fillsData.filter(row => String(row[EXECUTION_NAME_COL]) === currentExecution);
        const side = execMetadata[SIDE_COL];
        const desiredQty = execMetadata[DESIRED_QUANTITY_COL];

        // Calculate benchmark price
        let benchmarkPrice;
        if (benchmark === 'arrival' && HAS_ARRIVAL) {
            benchmarkPrice = execMetadata[ARRIVAL_PRICE_COL];
        } else {
            // Use mid price right before first fill
            if (execFills.length > 0) {
                const firstFillTime = execFills[0][FILL_TIME_COL];
                const tobBeforeFirst = tobData.filter(row => row[TIME_COL] <= firstFillTime);
                if (tobBeforeFirst.length > 0) {
                    const lastTob = tobBeforeFirst[tobBeforeFirst.length - 1];
                    benchmarkPrice = (lastTob[BID_COL] + lastTob[ASK_COL]) / 2;
                } else {
                    benchmarkPrice = execMetadata[ARRIVAL_PRICE_COL] || 0;
                }
            } else {
                benchmarkPrice = execMetadata[ARRIVAL_PRICE_COL] || 0;
            }
        }

        // Render chart
        renderChart(execFills, benchmarkPrice, side, desiredQty, showVolume);

        // Render tables
        renderFillsTable(execFills, benchmarkPrice, side, desiredQty);
        renderSummaryTable(execFills, benchmarkPrice, side, desiredQty);
    };

    function renderChart(fills, benchmarkPrice, side, desiredQty, showVolume) {
        const traces = [];

        // Bid and ask lines
        const tobTimes = tobData.map(row => row[TIME_COL]);
        const bids = tobData.map(row => row[BID_COL]);
        const asks = tobData.map(row => row[ASK_COL]);

        traces.push({
            x: tobTimes,
            y: bids,
            type: 'scatter',
            mode: 'lines',
            name: 'Bid',
            line: {color: '#EF553B', width: 2},
            xaxis: 'x',
            yaxis: 'y'
        });

        traces.push({
            x: tobTimes,
            y: asks,
            type: 'scatter',
            mode: 'lines',
            name: 'Ask',
            line: {color: '#00cc96', width: 2},
            xaxis: 'x',
            yaxis: 'y'
        });

        // Volume bars if enabled
        if (showVolume) {
            const volTimes = volumeData.map(row => row[TIME_FROM_COL]);
            const volumes = volumeData.map(row => row[VOLUME_COL]);

            traces.push({
                x: volTimes,
                y: volumes,
                type: 'bar',
                name: 'Volume',
                marker: {color: '#636efa'},
                xaxis: 'x',
                yaxis: 'y2'
            });
        }

        // Fill points
        const activeFills = fills.filter((_, idx) => !deselectedFills.has(idx));

        if (COLOR_COLS.length > 0) {
            // Group by first color column
            const colorCol = COLOR_COLS[0];
            const fillsByColor = {};
            activeFills.forEach((fill, idx) => {
                const colorValue = String(fill[colorCol]);
                if (!fillsByColor[colorValue]) fillsByColor[colorValue] = [];
                fillsByColor[colorValue].push({fill, originalIdx: idx});
            });

            for (let colorValue in fillsByColor) {
                const items = fillsByColor[colorValue];
                const fillGroup = items.map(item => item.fill);
                const color = COLOR_MAPS[colorCol] && COLOR_MAPS[colorCol][colorValue] ?
                             COLOR_MAPS[colorCol][colorValue] :
                             COLOR_PALETTE[0];

                traces.push({
                    x: fillGroup.map(f => f[FILL_TIME_COL]),
                    y: fillGroup.map(f => f[PRICE_COL]),
                    type: 'scatter',
                    mode: 'markers',
                    name: colorValue,
                    marker: {
                        size: fillGroup.map(f => Math.max(5, 5 + Math.log(f[QUANTITY_COL] + 1) * 2)),
                        color: color
                    },
                    xaxis: 'x',
                    yaxis: 'y'
                });
            }
        } else {
            // No color grouping
            traces.push({
                x: activeFills.map(f => f[FILL_TIME_COL]),
                y: activeFills.map(f => f[PRICE_COL]),
                type: 'scatter',
                mode: 'markers',
                name: 'Fills',
                marker: {
                    size: activeFills.map(f => Math.max(5, 5 + Math.log(f[QUANTITY_COL] + 1) * 2)),
                    color: '#636efa'
                },
                xaxis: 'x',
                yaxis: 'y'
            });
        }

        const layout = {
            xaxis: {title: 'Time', anchor: showVolume ? 'y' : undefined},
            yaxis: {title: 'Price', domain: showVolume ? [0.3, 1] : [0, 1]},
            hovermode: 'closest',
            showlegend: true
        };

        if (showVolume) {
            layout.yaxis2 = {
                title: 'Volume',
                domain: [0, 0.25],
                anchor: 'x'
            };
        }

        Plotly.newPlot('tutorial_execution', traces, layout, {responsive: true});
    }

    function calculateVWAP(fills) {
        // Calculate VWAP for active (non-deselected) fills
        const activeFills = fills.filter((_, idx) => !deselectedFills.has(idx));
        if (activeFills.length === 0) return 0;

        let totalValue = 0;
        let totalQty = 0;
        activeFills.forEach(fill => {
            totalValue += fill[PRICE_COL] * fill[QUANTITY_COL];
            totalQty += fill[QUANTITY_COL];
        });
        return totalQty > 0 ? totalValue / totalQty : 0;
    }

    function getSpreadCrossing(fill, side) {
        // Find the bid/ask at the fill time
        const fillTime = fill[FILL_TIME_COL];
        const tobAtFill = tobData.filter(row => row[TIME_COL] <= fillTime);
        if (tobAtFill.length === 0) return null;

        const lastTob = tobAtFill[tobAtFill.length - 1];
        const bid = lastTob[BID_COL];
        const ask = lastTob[ASK_COL];
        const spread = ask - bid;

        if (spread <= 0) return null;

        const fillPrice = fill[PRICE_COL];
        if (side === 'buy') {
            // 0 = bought at bid (neartouch), 1 = bought at ask (fartouch)
            return Math.max(0, Math.min(1, (fillPrice - bid) / spread));
        } else {
            // 0 = sold at ask (neartouch), 1 = sold at bid (fartouch)
            return Math.max(0, Math.min(1, (ask - fillPrice) / spread));
        }
    }

    function renderFillsTable(fills, benchmarkPrice, side, desiredQty) {
        const container = document.getElementById('fills_table_tutorial_execution');
        if (!container) return;

        // Calculate VWAP once
        const vwap = calculateVWAP(fills);

        let html = '<h4>Fill Details</h4>';
        html += '<table id="fills_table_content_tutorial_execution" style="width:100%; border-collapse: collapse;">';
        html += '<thead><tr>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Time</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Price</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Quantity</th>';
        COLOR_COLS.forEach(col => {
            html += `<th style="border: 1px solid #ddd; padding: 8px;">${col}</th>`;
        });
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Imp. Shortfall</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">VWAP Shortfall</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Spread Cross %</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Remaining %</th>';
        html += '</tr></thead><tbody>';

        let cumQty = 0;
        let cumImpShortfall = 0;
        let cumVwapShortfall = 0;

        fills.forEach((fill, idx) => {
            const isDeselected = deselectedFills.has(idx);
            const qty = fill[QUANTITY_COL];
            const price = fill[PRICE_COL];
            const sideMultiplier = side === 'buy' ? 1 : -1;

            if (!isDeselected) {
                cumQty += qty;
            }

            const remaining = Math.max(0, (desiredQty - cumQty) / desiredQty * 100);
            const impShortfall = sideMultiplier * (price - benchmarkPrice) * qty;
            const vwapShortfall = sideMultiplier * (price - vwap) * qty;
            const spreadCrossing = getSpreadCrossing(fill, side);

            if (!isDeselected) {
                cumImpShortfall += impShortfall;
                cumVwapShortfall += vwapShortfall;
            }

            const bgColor = isDeselected ? '#f0f0f0' : 'white';

            html += `<tr id="fill_row_${idx}_tutorial_execution"
                         style="background-color: ${bgColor}; cursor: pointer; transition: background-color 0.2s;"
                         onclick="toggleFill_tutorial_execution(${idx})"
                         onmouseover="highlightFill_tutorial_execution(${idx}, true)"
                         onmouseout="highlightFill_tutorial_execution(${idx}, false)">`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${fill[FILL_TIME_COL]}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${price.toFixed(2)}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${qty}</td>`;
            COLOR_COLS.forEach(col => {
                html += `<td style="border: 1px solid #ddd; padding: 8px;">${fill[col]}</td>`;
            });
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${cumImpShortfall.toFixed(2)}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${cumVwapShortfall.toFixed(2)}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${spreadCrossing !== null ? (spreadCrossing * 100).toFixed(1) + '%' : 'N/A'}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${remaining.toFixed(1)}%</td>`;
            html += '</tr>';
        });

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    function renderSummaryTable(fills, benchmarkPrice, side, desiredQty) {
        const container = document.getElementById('summary_table_tutorial_execution');
        if (!container) return;

        // Calculate VWAP
        const vwap = calculateVWAP(fills);

        // Get active fills only
        const activeFills = fills.filter((_, idx) => !deselectedFills.has(idx));

        let html = '<h4>Summary by Category</h4>';

        if (COLOR_COLS.length === 0) {
            // No color columns, just show overall summary
            html += '<p>No categories to aggregate by. Add color_cols for detailed breakdown.</p>';
            container.innerHTML = html;
            return;
        }

        // Use first color column for aggregation
        const colorCol = COLOR_COLS[0];
        const categories = {};

        const sideMultiplier = side === 'buy' ? 1 : -1;

        activeFills.forEach(fill => {
            const category = String(fill[colorCol]);
            if (!categories[category]) {
                categories[category] = {
                    totalImpShortfall: 0,
                    totalVwapShortfall: 0,
                    spreadCrossings: [],
                    count: 0,
                    totalQty: 0
                };
            }

            const qty = fill[QUANTITY_COL];
            const price = fill[PRICE_COL];
            const impShortfall = sideMultiplier * (price - benchmarkPrice) * qty;
            const vwapShortfall = sideMultiplier * (price - vwap) * qty;
            const spreadCrossing = getSpreadCrossing(fill, side);

            categories[category].totalImpShortfall += impShortfall;
            categories[category].totalVwapShortfall += vwapShortfall;
            if (spreadCrossing !== null) {
                categories[category].spreadCrossings.push(spreadCrossing);
            }
            categories[category].count += 1;
            categories[category].totalQty += qty;
        });

        // Calculate overall totals
        let overallImpShortfall = 0;
        let overallVwapShortfall = 0;
        let overallSpreadCrossings = [];
        let overallCount = 0;
        let overallQty = 0;

        for (let cat in categories) {
            overallImpShortfall += categories[cat].totalImpShortfall;
            overallVwapShortfall += categories[cat].totalVwapShortfall;
            overallSpreadCrossings.push(...categories[cat].spreadCrossings);
            overallCount += categories[cat].count;
            overallQty += categories[cat].totalQty;
        }

        html += '<table style="width:100%; border-collapse: collapse;">';
        html += '<thead><tr>';
        html += `<th style="border: 1px solid #ddd; padding: 8px;">${colorCol}</th>`;
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Fills</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Quantity</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Imp. Shortfall</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">VWAP Shortfall</th>';
        html += '<th style="border: 1px solid #ddd; padding: 8px;">Avg Spread Cross %</th>';
        html += '</tr></thead><tbody>';

        // Sort categories alphabetically
        const sortedCategories = Object.keys(categories).sort();

        sortedCategories.forEach(category => {
            const data = categories[category];
            const avgSpreadCrossing = data.spreadCrossings.length > 0 ?
                data.spreadCrossings.reduce((a, b) => a + b, 0) / data.spreadCrossings.length : null;

            html += '<tr>';
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${category}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${data.count}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${data.totalQty}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${data.totalImpShortfall.toFixed(2)}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${data.totalVwapShortfall.toFixed(2)}</td>`;
            html += `<td style="border: 1px solid #ddd; padding: 8px;">${avgSpreadCrossing !== null ? (avgSpreadCrossing * 100).toFixed(1) + '%' : 'N/A'}</td>`;
            html += '</tr>';
        });

        // Add overall row
        const overallAvgSpreadCrossing = overallSpreadCrossings.length > 0 ?
            overallSpreadCrossings.reduce((a, b) => a + b, 0) / overallSpreadCrossings.length : null;

        html += '<tr style="font-weight: bold; background-color: #f9f9f9;">';
        html += '<td style="border: 1px solid #ddd; padding: 8px;">Overall</td>';
        html += `<td style="border: 1px solid #ddd; padding: 8px;">${overallCount}</td>`;
        html += `<td style="border: 1px solid #ddd; padding: 8px;">${overallQty}</td>`;
        html += `<td style="border: 1px solid #ddd; padding: 8px;">${overallImpShortfall.toFixed(2)}</td>`;
        html += `<td style="border: 1px solid #ddd; padding: 8px;">${overallVwapShortfall.toFixed(2)}</td>`;
        html += `<td style="border: 1px solid #ddd; padding: 8px;">${overallAvgSpreadCrossing !== null ? (overallAvgSpreadCrossing * 100).toFixed(1) + '%' : 'N/A'}</td>`;
        html += '</tr>';

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    window.toggleFill_tutorial_execution = function(idx) {
        if (deselectedFills.has(idx)) {
            deselectedFills.delete(idx);
        } else {
            deselectedFills.add(idx);
        }
        updateChart_tutorial_execution();
    };

    window.highlightFill_tutorial_execution = function(idx, isHighlighted) {
        // Get the chart element
        const chartDiv = document.getElementById('tutorial_execution');
        if (!chartDiv || !chartDiv.data) return;

        // Find which trace contains this fill
        const execSelect = document.getElementById('execution_select_tutorial_execution');
        const currentExecution = execSelect ? execSelect.value : 'Aggressive Strategy';
        const execFills = fillsData.filter(row => String(row[EXECUTION_NAME_COL]) === currentExecution);
        const fill = execFills[idx];
        if (!fill) return;

        // Find the trace and point index
        const fillTime = fill[FILL_TIME_COL];
        const fillPrice = fill[PRICE_COL];

        // Iterate through traces to find the matching fill point
        chartDiv.data.forEach((trace, traceIdx) => {
            if (trace.mode === 'markers' || trace.mode === 'markers+lines') {
                trace.x.forEach((x, pointIdx) => {
                    if (x === fillTime && Math.abs(trace.y[pointIdx] - fillPrice) < 0.01) {
                        // Found the point, update its marker
                        const update = {};
                        if (isHighlighted) {
                            // Increase size and add border
                            const currentSize = trace.marker.size[pointIdx] || trace.marker.size || 8;
                            update['marker.size'] = trace.marker.size.map((s, i) =>
                                i === pointIdx ? s * 1.5 : s
                            );
                            update['marker.line'] = {
                                color: 'black',
                                width: trace.marker.size.map((s, i) => i === pointIdx ? 2 : 0)
                            };
                        } else {
                            // Reset to original size
                            const originalSize = Math.max(5, 5 + Math.log(fill[QUANTITY_COL] + 1) * 2);
                            update['marker.size'] = trace.marker.size.map((s, i) =>
                                i === pointIdx ? originalSize : s
                            );
                            update['marker.line'] = {width: 0};
                        }
                        Plotly.restyle(chartDiv, update, [traceIdx]);
                    }
                });
            }
        });
    };

    // Load data
    Promise.all([
        loadDataset('exec_tob_data'),
        loadDataset('exec_volume_data'),
        loadDataset('exec_fills_data'),
        loadDataset('exec_metadata')
    ]).then(function([tob, vol, fills, metadata]) {
        tobData = tob;
        volumeData = vol;
        fillsData = fills;
        metadataData = metadata;

        updateChart_tutorial_execution();
    }).catch(function(error) {
        console.error('Error loading data for chart tutorial_execution:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="rankings_data" data-format="parquet" data-src="data/rankings_data.parquet"></script><script type="text/plain" id="sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="ohlc_data" data-format="parquet" data-src="data/ohlc_data.parquet"></script><script type="text/plain" id="exec_tob_data" data-format="parquet" data-src="data/exec_tob_data.parquet"></script><script type="text/plain" id="product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="sankey_data" data-format="parquet" data-src="data/sankey_data.parquet"></script><script type="text/plain" id="stock_corr_data" data-format="parquet" data-src="data/stock_corr_data.parquet"></script><script type="text/plain" id="daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="exec_fills_data" data-format="parquet" data-src="data/exec_fills_data.parquet"></script><script type="text/plain" id="boxwhiskers_data" data-format="parquet" data-src="data/boxwhiskers_data.parquet"></script><script type="text/plain" id="waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script><script type="text/plain" id="exec_volume_data" data-format="parquet" data-src="data/exec_volume_data.parquet"></script><script type="text/plain" id="radar_data" data-format="parquet" data-src="data/radar_data.parquet"></script><script type="text/plain" id="exec_metadata" data-format="parquet" data-src="data/exec_metadata.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>Financial Charts</h1>
<p>This shows examples of financial market visualization charts. OHLCChart displays candlestick patterns for technical analysis with volume, renormalization, and time range controls. ExecutionPlot analyzes trade execution quality with implementation shortfall calculations, VWAP comparison, spread crossing metrics, and interactive fills table for transaction cost analysis.</p>

    <div class="textblock-content">
        <h1>Financial Charts</h1>
    </div>
<br>
<hr>
<br>
<h2>Stock Price Analysis - Q1 2024</h2>
<p>An OHLC (Open-High-Low-Close) chart displays financial market data with candlesticks showing price movements. This example tracks AAPL, MSFT, and GOOGL through Q1 2024. <strong>Key Features:</strong> Time range sliders to zoom into specific date ranges (drag the handles to adjust), Renormalize toggle to compare stocks at different price levels (divides all prices by first bar's open price, setting it to 1.0), Display mode dropdown to switch between Overlay (all symbols on same chart) and Faceted (one subplot per symbol), Volume bars at bottom with Show/Hide toggle and Log scale option (useful when volume varies greatly), Chart type selector to switch between candlestick (filled bars) and OHLC (line bars) styles, Filter controls to select which stocks and sectors to display. The volume bars use a dodged (grouped) layout and align perfectly with the OHLC bars above. This visualization is essential for technical analysis, allowing traders to identify patterns, trends, and volume spikes. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/ohlcchart_examples.html" style="color: blue; font-weight: bold;">See here for OHLCChart examples</a></p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="financial_ohlc_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="sector_select_financial_ohlc">sector: </label>
                <select id="sector_select_financial_ohlc" multiple onchange="updateChart_financial_ohlc()">
                <option value="Technology" selected>Technology</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="sector_select_financial_ohlc_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="chart_type_select_financial_ohlc">Chart Type: </label>
                <select id="chart_type_select_financial_ohlc" onchange="updateChart_financial_ohlc()">
                <option value="candlestick" selected>candlestick</option>
                <option value="ohlc">ohlc</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="chart_type_select_financial_ohlc_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="display_mode_select_financial_ohlc">Display Mode: </label>
                <select id="display_mode_select_financial_ohlc" onchange="updateChart_financial_ohlc()">
                <option value="Overlay" selected>Overlay</option>
                <option value="Faceted">Faceted</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="display_mode_select_financial_ohlc_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
            <div style="margin: 10px; display: flex; flex-direction: column;">
        <div style="margin: 5px 0;">
            <input type="checkbox" id="renormalize_checkbox_financial_ohlc" onchange="updateChart_financial_ohlc()">
            <label for="renormalize_checkbox_financial_ohlc">Renormalize (first bar open = 1)</label>
        </div>
    <div style="margin: 5px 0;">
        <input type="checkbox" id="show_volume_checkbox_financial_ohlc" checked onchange="updateChart_financial_ohlc()">
        <label for="show_volume_checkbox_financial_ohlc">Show Volume</label>
    </div>
    <div style="margin: 5px 0;">
        <input type="checkbox" id="log_volume_checkbox_financial_ohlc" onchange="updateChart_financial_ohlc()">
        <label for="log_volume_checkbox_financial_ohlc">Log Volume</label>
    </div>
    </div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="financial_ohlc_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="financial_ohlc_aspect_ratio_label">0.6</span>
    <input type="range" id="financial_ohlc_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="financial_ohlc"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: ohlc_data.parquet</p><br>
<hr>
<br>
<div style="padding: 20px;">
    <h2>Trade Execution Analysis - Comparing Strategies</h2>
    <p>An ExecutionPlot chart analyzes trade execution quality by comparing fill prices against benchmarks. This example compares two strategies for buying the same stock. <strong>Key Features:</strong> Execution selector dropdown to switch between different executions (Aggressive vs Patient strategy), Benchmark selector to choose between Arrival Price (price when order started) and First Fill Mid (mid-price at first fill), Show Volume checkbox to toggle market volume bars at the bottom of the chart, Bid/Ask lines showing the top of book prices over time, Fill points sized by quantity (larger circles = larger fills) and colored by category (venue or urgency), Interactive fills table with Time, Price, Quantity, and category columns, Running Implementation Shortfall showing cumulative cost vs benchmark (negative is worse), VWAP Shortfall showing cost vs volume-weighted average price of execution, Spread Crossing percentage showing how aggressive each fill was (0%=bought at bid, 100%=bought at ask), Remaining percentage showing how much of desired quantity is left to execute, Summary table aggregating metrics by category (e.g., by venue or urgency level), showing total implementation shortfall, VWAP shortfall, and average spread crossing for each category. Users can click fills in the table to exclude them from calculations, and hover over table rows to highlight corresponding points in the chart. This visualization is essential for transaction cost analysis (TCA) and evaluating execution algorithms. The aggressive strategy completes faster but typically has higher implementation shortfall, while the patient strategy takes longer but may achieve better prices. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/executionplot_examples.html" style="color: blue; font-weight: bold;">See here for ExecutionPlot examples</a></p>

    <div style="margin: 20px 0;">
        <label for="execution_select_tutorial_execution">Execution: </label>
        <select id="execution_select_tutorial_execution" onchange="updateChart_tutorial_execution()">
                    <option value="Aggressive Strategy" selected>Aggressive Strategy</option>
                    <option value="Patient Strategy">Patient Strategy</option>
        </select>

        <label for="benchmark_select_tutorial_execution" style="margin-left: 20px;">Benchmark: </label>
        <select id="benchmark_select_tutorial_execution" onchange="updateChart_tutorial_execution()">
        <option value="arrival" selected>Arrival</option>
        <option value="first">First Fill Mid</option>
        </select>

        <label style="margin-left: 20px;">
            <input type="checkbox" id="show_volume_checkbox_tutorial_execution" checked onchange="updateChart_tutorial_execution()">
            Show Volume
        </label>
    </div>

    <div id="tutorial_execution" style="width: 100%; height: 600px;"></div>

    <div style="display: flex; margin-top: 20px;">
        <div id="fills_table_tutorial_execution" style="flex: 1; margin-right: 20px;"></div>
        <div id="summary_table_tutorial_execution" style="flex: 1;"></div>
    </div>
</div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.4.0.</small></p>
</body>
</html>
