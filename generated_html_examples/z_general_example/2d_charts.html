<!DOCTYPE html>
<html>
<head>
    <title>2D Charts</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\\d{4}-\\d{2}-\\d{2}\$/;  // YYYY-MM-DD
    var datetimePattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;  // YYYY-MM-DDTHH:MM:SS

    // Check first row to identify date columns
    var firstRow = data[0];
    var dateColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                }
            }
        }
    }

    // If no date columns found, return data unchanged
    if (dateColumns.length === 0) return data;

    // Convert date strings to Date objects in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['date', 'quarter'];
    const Y_COLS = ['sales', 'quantity', 'profit', 'customers', 'satisfaction'];
    const COLOR_COLS = ['product', 'region', 'segment'];
    const COLOR_MAPS = {'segment': {'SMB': '#636efa', 'Enterprise': '#00cc96', 'Consumer': '#EF553B'}, 'region': {'West': '#00cc96', 'North': '#636efa', 'South': '#EF553B'}, 'product': {'Phone': '#00cc96', 'Laptop': '#636efa', 'Tablet': '#EF553B'}};
    const DEFAULT_X_COL = 'date';
    const DEFAULT_Y_COL = 'sales';
    const DEFAULT_COLOR_COL = 'product';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare as ISO strings
                    return String(a).localeCompare(String(b));
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_LineChart = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_LineChart');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_LineChart');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_LineChart');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_LineChart' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_LineChart');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_LineChart');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_LineChart');
        const facet2Select = document.getElementById('facet2_select_LineChart');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support both categorical and continuous filters)
        const filteredData = allData.filter(row => {
            // Check categorical filters (dropdowns)
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            // Check continuous filters (range sliders)
            for (let col in rangeFilters) {
                const value = parseFloat(row[col]);
                const range = rangeFilters[col];
                if (value < range.min || value > range.max) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Check if values look like dates (ISO format: YYYY-MM-DD)
                    const datePattern = /^\d{4}-\d{2}-\d{2}/;
                    if (datePattern.test(aStr) && datePattern.test(bStr)) {
                        return aStr.localeCompare(bStr);
                    }

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('LineChart', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Check if values look like dates (ISO format: YYYY-MM-DD)
                        const datePattern = /^\d{4}-\d{2}-\d{2}/;
                        if (datePattern.test(aStr) && datePattern.test(bStr)) {
                            return aStr.localeCompare(bStr);
                        }

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('LineChart', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Check if values look like dates (ISO format: YYYY-MM-DD)
                            const datePattern = /^\d{4}-\d{2}-\d{2}/;
                            if (datePattern.test(aStr) && datePattern.test(bStr)) {
                                return aStr.localeCompare(bStr);
                            }

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('LineChart', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updateChart_LineChart();
    }).catch(function(error) {
        console.error('Error loading data for chart LineChart:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['segment', 'region', 'product'];
    const X_COLS = ['date', 'quarter'];
    const Y_COLS = ['sales', 'quantity', 'cost', 'customers', 'satisfaction'];
    const COLOR_COLS = ['product', 'segment', 'region'];
    const COLOR_MAPS = {'segment': {'SMB': '#636efa', 'Enterprise': '#00cc96', 'Consumer': '#EF553B'}, 'region': {'West': '#00cc96', 'North': '#636efa', 'South': '#EF553B'}, 'product': {'Phone': '#00cc96', 'Laptop': '#636efa', 'Tablet': '#EF553B'}};
    const GROUP_ORDER = {'segment': ['SMB', 'Consumer', 'Enterprise'], 'region': ['North', 'South', 'West'], 'product': ['Laptop', 'Tablet', 'Phone']};
    const DEFAULT_X_COL = 'date';
    const DEFAULT_Y_COL = 'sales';
    const DEFAULT_COLOR_COL = 'product';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_AreaChart = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_AreaChart');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_AreaChart');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_AreaChart');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_AreaChart');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_AreaChart');
        const facet2Select = document.getElementById('facet2_select_AreaChart');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('AreaChart', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('AreaChart', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('AreaChart', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updatePlot_AreaChart();
    }).catch(function(error) {
        console.error('Error loading data for chart AreaChart:', error);
    });
})();
    (function() {
    const FILTER_COLS = [];
    window.showDensity_scatter = true;
    const POINT_SYMBOLS = ["circle","square","diamond","cross","x","triangle-up","triangle-down","triangle-left","triangle-right","pentagon","hexagon","star"];
    const DEFAULT_X_COL = 'profit';
    const DEFAULT_Y_COL = 'sales';
    const DEFAULT_COLOR_COL = 'product';

    const getCol = (id, def) => { const el = document.getElementById(id); return el ? el.value : def; };
    const buildSymbolMap = (data, col) => {
        const uniqueVals = [...new Set(data.map(row => row[col]))].sort();
        return Object.fromEntries(uniqueVals.map((val, i) => [val, POINT_SYMBOLS[i % POINT_SYMBOLS.length]]));
    };

    function createTraces(data, X_COL, Y_COL, COLOR_COL, xaxis='x', yaxis='y', showlegend=true) {
        const symbolMap = buildSymbolMap(data, COLOR_COL);
        const groups = {};
        data.forEach(row => {
            const key = row[COLOR_COL];
            if (!groups[key]) groups[key] = [];
            groups[key].push(row);
        });

        return Object.entries(groups).map(([key, groupData]) => ({
            x: groupData.map(d => d[X_COL]),
            y: groupData.map(d => d[Y_COL]),
            mode: 'markers',
            name: key,
            legendgroup: key,
            showlegend: showlegend,
            xaxis: xaxis,
            yaxis: yaxis,
            marker: {
                size: 4,
                opacity: 0.6,
                symbol: groupData.map(d => symbolMap[d[COLOR_COL]])
            },
            type: 'scatter'
        }));
    }

    function renderNoFacets(data, X_COL, Y_COL, COLOR_COL) {
        const traces = createTraces(data, X_COL, Y_COL, COLOR_COL);

        if (window.showDensity_scatter) {
            traces.push({
                x: data.map(d => d[X_COL]), y: data.map(d => d[Y_COL]),
                name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                showscale: false, type: 'histogram2dcontour', showlegend: false
            });
        }

        traces.push(
            { x: data.map(d => d[X_COL]), name: 'x density', marker: {color: 'rgba(128, 128, 128, 0.5)'}, yaxis: 'y2', type: 'histogram', showlegend: false },
            { y: data.map(d => d[Y_COL]), name: 'y density', marker: {color: 'rgba(128, 128, 128, 0.5)'}, xaxis: 'x2', type: 'histogram', showlegend: false }
        );

        Plotly.newPlot('scatter', traces, {
            title: 'Scatter Plot', showlegend: true, autosize: true, hovermode: 'closest',
            xaxis: { title: X_COL, domain: [0, 0.85], showgrid: true, zeroline: true },
            yaxis: { title: Y_COL, domain: [0, 0.85], showgrid: true, zeroline: true },
            xaxis2: { domain: [0.85, 1], showgrid: false, zeroline: false },
            yaxis2: { domain: [0.85, 1], showgrid: false, zeroline: false },
            margin: {t: 100, r: 100, b: 100, l: 100}
        }, {responsive: true});
    }

    function renderFacetWrap(data, X_COL, Y_COL, COLOR_COL, FACET_COL) {
        const facetValues = [...new Set(data.map(row => row[FACET_COL]))].sort();
        const nFacets = facetValues.length, cols = Math.ceil(Math.sqrt(nFacets)), rows = Math.ceil(nFacets / cols);
        const traces = [];

        facetValues.forEach((facetVal, idx) => {
            const facetData = data.filter(row => row[FACET_COL] === facetVal);
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);
            traces.push(...createTraces(facetData, X_COL, Y_COL, COLOR_COL, xaxis, yaxis, idx === 0));

            if (window.showDensity_scatter) {
                traces.push({
                    x: facetData.map(d => d[X_COL]), y: facetData.map(d => d[Y_COL]),
                    name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                    showscale: false, type: 'histogram2dcontour', showlegend: false, xaxis: xaxis, yaxis: yaxis
                });
            }
        });

        const layout = {
            title: 'Scatter Plot', showlegend: true, grid: {rows: rows, columns: cols, pattern: 'independent'},
            annotations: facetValues.map((val, idx) => ({
                text: FACET_COL + ': ' + val, showarrow: false,
                xref: (idx === 0 ? 'x' : 'x' + (idx + 1)) + ' domain',
                yref: (idx === 0 ? 'y' : 'y' + (idx + 1)) + ' domain',
                x: 0.5, y: 1.1, xanchor: 'center', yanchor: 'bottom'
            })),
            margin: {t: 100, r: 50, b: 50, l: 50}
        };
        facetValues.forEach((val, idx) => {
            const ax = idx === 0 ? '' : (idx + 1);
            layout['xaxis' + ax] = {title: X_COL};
            layout['yaxis' + ax] = {title: Y_COL};
        });
        Plotly.newPlot('scatter', traces, layout, {responsive: true});
    }

    function renderFacetGrid(data, X_COL, Y_COL, COLOR_COL, FACET1_COL, FACET2_COL) {
        const facet1Values = [...new Set(data.map(row => row[FACET1_COL]))].sort();
        const facet2Values = [...new Set(data.map(row => row[FACET2_COL]))].sort();
        const rows = facet1Values.length, cols = facet2Values.length;
        const traces = [];

        facet1Values.forEach((facet1Val, rowIdx) => {
            facet2Values.forEach((facet2Val, colIdx) => {
                const facetData = data.filter(row => row[FACET1_COL] === facet1Val && row[FACET2_COL] === facet2Val);
                if (facetData.length === 0) return;

                const idx = rowIdx * cols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);
                traces.push(...createTraces(facetData, X_COL, Y_COL, COLOR_COL, xaxis, yaxis, idx === 0));

                if (window.showDensity_scatter) {
                    traces.push({
                        x: facetData.map(d => d[X_COL]), y: facetData.map(d => d[Y_COL]),
                        name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                        showscale: false, type: 'histogram2dcontour', showlegend: false, xaxis: xaxis, yaxis: yaxis
                    });
                }
            });
        });

        const layout = {
            title: 'Scatter Plot', showlegend: true, grid: {rows: rows, columns: cols, pattern: 'independent'},
            annotations: [
                ...facet2Values.map((val, colIdx) => ({
                    text: FACET2_COL + ': ' + val, showarrow: false,
                    xref: (colIdx === 0 ? 'x' : 'x' + (colIdx + 1)) + ' domain',
                    yref: (colIdx === 0 ? 'y' : 'y' + (colIdx + 1)) + ' domain',
                    x: 0.5, y: 1.1, xanchor: 'center', yanchor: 'bottom'
                })),
                ...facet1Values.map((val, rowIdx) => ({
                    text: FACET1_COL + ': ' + val, showarrow: false,
                    xref: (rowIdx * cols === 0 ? 'x' : 'x' + (rowIdx * cols + 1)) + ' domain',
                    yref: (rowIdx * cols === 0 ? 'y' : 'y' + (rowIdx * cols + 1)) + ' domain',
                    x: -0.15, y: 0.5, xanchor: 'center', yanchor: 'middle', textangle: -90
                }))
            ],
            margin: {t: 100, r: 50, b: 50, l: 50}
        };
        facet1Values.forEach((v1, rowIdx) => {
            facet2Values.forEach((v2, colIdx) => {
                const idx = rowIdx * cols + colIdx, ax = idx === 0 ? '' : (idx + 1);
                layout['xaxis' + ax] = {title: X_COL};
                layout['yaxis' + ax] = {title: Y_COL};
            });
        });
        Plotly.newPlot('scatter', traces, layout, {responsive: true});
    }

    function updatePlot_scatter(data) {
        const X_COL = getCol('x_col_select_scatter', DEFAULT_X_COL);
        const Y_COL = getCol('y_col_select_scatter', DEFAULT_Y_COL);
        const COLOR_COL = getCol('color_col_select_scatter', DEFAULT_COLOR_COL);

        let FACET1 = getCol('facet1_select_scatter', null);
        let FACET2 = getCol('facet2_select_scatter', null);
        if (FACET1 === 'None') FACET1 = null;
        if (FACET2 === 'None') FACET2 = null;

        if (FACET1 && FACET2) {
            renderFacetGrid(data, X_COL, Y_COL, COLOR_COL, FACET1, FACET2);
        } else if (FACET1) {
            renderFacetWrap(data, X_COL, Y_COL, COLOR_COL, FACET1);
        } else {
            renderNoFacets(data, X_COL, Y_COL, COLOR_COL);
        }
    }

    window.updateChart_scatter = () => updatePlotWithFilters_scatter();

    // Filter and update function
    window.updatePlotWithFilters_scatter = function() {
        // Get filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_scatter');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = window.allData_scatter.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Update plot with filtered data
        updatePlot_scatter(filteredData);
    };

    loadDataset('sales_data').then(data => {
        window.allData_scatter = data;
        $(function() {
            const densityBtn = document.getElementById('scatter_density_toggle');
            if (densityBtn) {
                densityBtn.addEventListener('click', function() {
                    window.showDensity_scatter = !window.showDensity_scatter;
                    this.textContent = window.showDensity_scatter ? 'Hide Density Contours' : 'Show Density Contours';
                    updatePlotWithFilters_scatter();
                });
            }
            updatePlotWithFilters_scatter();
        });
    }).catch(error => console.error('Error loading data for chart scatter:', error));
    })();
(function() {
    // Configuration
    const FILTER_COLS = ['Product', 'Region', 'Segment'];
    const X_COLS = ['Cost', 'Profit', 'Sales'];
    const Y_COLS = ['Profit', 'Sales', 'Cost'];
    const COLOR_COLS = ['Product', 'Region', 'Segment'];
    const COLOR_MAPS = {'Product': {'Doohickey': '#00cc96', 'Widget': '#636efa', 'Gadget': '#EF553B'}, 'Segment': {'Government': '#00cc96', 'Enterprise': '#EF553B', 'Consumer': '#636efa'}, 'Region': {'East': '#00cc96', 'West': '#ab63fa', 'North': '#636efa', 'South': '#EF553B'}};
    const DEFAULT_X_COL = 'Cost';
    const DEFAULT_Y_COL = 'Profit';
    const DEFAULT_COLOR_COL = 'Product';
    const ORDER_COL = 'Month';
    const USE_ALPHARANGE = true;

    // Global state for arrow/line toggle
    window.showArrows_path = true;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_path = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_path');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_path');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_path');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_path');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_path');
        const facet2Select = document.getElementById('facet2_select_path');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                const xValues = group.data.map(row => row[X_COL]);
                const yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 8,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_path) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 2,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 2
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 2
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Path Chart',
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('path', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Path Chart',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    const xValues = group.data.map(row => row[X_COL]);
                    const yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 8,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_path) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 2,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 2
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 2
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('path', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Path Chart',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        const xValues = group.data.map(row => row[X_COL]);
                        const yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 8,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_path) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 2,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 2
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 2
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('path', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('path_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_path = !window.showArrows_path;
            arrowToggleBtn.textContent = window.showArrows_path ? 'Show Lines' : 'Show Arrows';
            window.updateChart_path();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('business_path_data').then(function(data) {
        allData = data;
        window.updateChart_path();
    }).catch(function(error) {
        console.error('Error loading data for chart path:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script><script type="text/plain" id="sankey_data" data-format="parquet" data-src="data/sankey_data.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>2D Charts</h1>
<p>This shows examples of LinePlot, AreaChart, ScatterPlot, and Path.</p>

    <div class="textblock-content">
        <h1>Two-Dimensional Plots</h1>
    </div>
<br>
<hr>
<br>
<h2>Line Chart</h2>
<p>A linechart. There are optional controls to change the variables on the x and or y axis. It is also possible to change the faceting, the grouping variable, the aggregation variable (if there are multiple y values per x value) as well as filters. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linechart_examples.html" style="color: blue; font-weight: bold;">See here for LineChart examples</a></p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="x_col_select_LineChart">X dimension: </label>
            <select id="x_col_select_LineChart" onchange="updateChart_LineChart()">
                <option value="date" selected>date</option>
                <option value="quarter">quarter</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="y_col_select_LineChart">Y dimension: </label>
            <select id="y_col_select_LineChart" onchange="updateChart_LineChart()">
                <option value="sales" selected>sales</option>
                <option value="quantity">quantity</option>
                <option value="profit">profit</option>
                <option value="customers">customers</option>
                <option value="satisfaction">satisfaction</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="color_col_select_LineChart">Color by: </label>
            <select id="color_col_select_LineChart" onchange="updateChart_LineChart()">
                <option value="product" selected>product</option>
                <option value="region">region</option>
                <option value="segment">segment</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="aggregator_select_LineChart">Aggregator: </label>
            <select id="aggregator_select_LineChart" onchange="updateChart_LineChart()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px;">
            <label for="facet1_select_LineChart">Facet 1: </label>
            <select id="facet1_select_LineChart" onchange="updateChart_LineChart()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="segment">segment</option>
                <option value="product">product</option>
                <option value="month">month</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_LineChart">Facet 2: </label>
            <select id="facet2_select_LineChart" onchange="updateChart_LineChart()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="segment">segment</option>
                <option value="product">product</option>
                <option value="month">month</option>
            </select>
        </div>
        
</div>

<!-- Chart -->
<div id="LineChart"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p><br>
<hr>
<br>
<h2>Area Chart</h2>
<p>Stacked Trends. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/areachart_examples.html" style="color: blue; font-weight: bold;">See here for AreaChart examples</a></p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0;">Filters</h4>
            <div style="margin: 10px;">
            <label for="segment_select_AreaChart">segment: </label>
            <select id="segment_select_AreaChart" multiple onchange="updatePlot_AreaChart()">
                <option value="Consumer" selected>Consumer</option>
                <option value="Enterprise" selected>Enterprise</option>
                <option value="SMB" selected>SMB</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="region_select_AreaChart">region: </label>
            <select id="region_select_AreaChart" multiple onchange="updatePlot_AreaChart()">
                <option value="North" selected>North</option>
                <option value="South" selected>South</option>
                <option value="West" selected>West</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="product_select_AreaChart">product: </label>
            <select id="product_select_AreaChart" multiple onchange="updatePlot_AreaChart()">
                <option value="Laptop" selected>Laptop</option>
                <option value="Phone" selected>Phone</option>
                <option value="Tablet" selected>Tablet</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="x_col_select_AreaChart">X dimension: </label>
            <select id="x_col_select_AreaChart" onchange="updatePlot_AreaChart()">
                <option value="date" selected>date</option>
                <option value="quarter">quarter</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="y_col_select_AreaChart">Y dimension: </label>
            <select id="y_col_select_AreaChart" onchange="updatePlot_AreaChart()">
                <option value="sales" selected>sales</option>
                <option value="quantity">quantity</option>
                <option value="cost">cost</option>
                <option value="customers">customers</option>
                <option value="satisfaction">satisfaction</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="color_col_select_AreaChart">Color by: </label>
            <select id="color_col_select_AreaChart" onchange="updatePlot_AreaChart()">
                <option value="product" selected>product</option>
                <option value="segment">segment</option>
                <option value="region">region</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="stack_mode_select_AreaChart">Stack mode: </label>
            <select id="stack_mode_select_AreaChart" onchange="updatePlot_AreaChart()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px;">
            <label for="facet1_select_AreaChart">Facet 1: </label>
            <select id="facet1_select_AreaChart" onchange="updatePlot_AreaChart()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="product">product</option>
                <option value="segment">segment</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_AreaChart">Facet 2: </label>
            <select id="facet2_select_AreaChart" onchange="updatePlot_AreaChart()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="product">product</option>
                <option value="segment">segment</option>
            </select>
        </div>
        
</div>

<!-- Chart -->
<div id="AreaChart"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p><br>
<hr>
<br>
<h2>Scatter Plot</h2>
<p>Scatter plots show x vs y. There is a density colouring that can be applied or not depending on a slider. In addition the marginal distributions appear on the edges of the plot in cases when you do not apply faceting. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatterplot_examples.html" style="color: blue; font-weight: bold;">See here for ScatterPlot examples</a></p>

<!-- Filters (for data filtering) -->

<!-- Plot Attributes -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <div style="margin: 10px 0;">
    <button id="scatter_density_toggle" style="padding: 5px 15px; cursor: pointer;">
        Hide Density Contours
    </button>
</div>
<div style="margin: 10px 0; display: flex; gap: 20px; align-items: center;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="x_col_select_scatter">X:</label>
                    <select id="x_col_select_scatter" onchange="updateChart_scatter()">
                    <option value="profit" selected>profit</option>
                    <option value="sales">sales</option>
                    <option value="quantity">quantity</option>
                    <option value="customers">customers</option>
                    <option value="cost">cost</option>
                    <option value="satisfaction">satisfaction</option>                </select>
                </div>
                            <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="y_col_select_scatter">Y:</label>
                    <select id="y_col_select_scatter" onchange="updateChart_scatter()">
                    <option value="profit">profit</option>
                    <option value="sales" selected>sales</option>
                    <option value="quantity">quantity</option>
                    <option value="customers">customers</option>
                    <option value="cost">cost</option>
                    <option value="satisfaction">satisfaction</option>                </select>
                </div>
                    </div>
<div style="margin: 10px 0; display: flex; gap: 20px; align-items: center;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="color_col_select_scatter">Color/Point type:</label>
                    <select id="color_col_select_scatter" onchange="updateChart_scatter()">
                    <option value="product" selected>product</option>
                    <option value="region">region</option>
                    <option value="segment">segment</option>
                    <option value="month">month</option>                </select>
                </div>
                    </div>

</div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
                <div style="margin: 10px 0; display: flex; gap: 20px; align-items: center;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="facet1_select_scatter">Facet 1:</label>
                    <select id="facet1_select_scatter" onchange="updateChart_scatter()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="product">product</option>
                <option value="segment">segment</option>                </select>
                </div>
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="facet2_select_scatter">Facet 2:</label>
                    <select id="facet2_select_scatter" onchange="updateChart_scatter()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="product">product</option>
                <option value="segment">segment</option>                </select>
                </div>
            </div>
            
</div>

<!-- Chart -->
<div id="scatter"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p><br>
<hr>
<br>
<h2>Path Chart</h2>
<p>A Path chart shows trajectories through metric space over time. This example uses business data (Sales/Cost/Profit by Product/Region/Segment over 12 months) - the same dataset that will be used later in the Slides examples. Each path traces how a product's metrics evolve month-by-month. By default, it shows the North region and Consumer segment, with paths colored by Product. Use the filters to explore different regions and segments. The arrows and alpha gradient show the direction of time progression. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/path_examples.html" style="color: blue; font-weight: bold;">See here for Path examples</a></p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0;">Filters</h4>
            <div style="margin: 10px;">
            <label for="Product_select_path">Product: </label>
            <select id="Product_select_path" multiple onchange="updateChart_path()">
                <option value="Doohickey" selected>Doohickey</option>
                <option value="Gadget" selected>Gadget</option>
                <option value="Widget" selected>Widget</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="Region_select_path">Region: </label>
            <select id="Region_select_path" multiple onchange="updateChart_path()">
                <option value="East">East</option>
                <option value="North" selected>North</option>
                <option value="South">South</option>
                <option value="West">West</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="Segment_select_path">Segment: </label>
            <select id="Segment_select_path" multiple onchange="updateChart_path()">
                <option value="Consumer" selected>Consumer</option>
                <option value="Enterprise">Enterprise</option>
                <option value="Government">Government</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="x_col_select_path">X dimension: </label>
            <select id="x_col_select_path" onchange="updateChart_path()">
                <option value="Cost" selected>Cost</option>
                <option value="Profit">Profit</option>
                <option value="Sales">Sales</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="y_col_select_path">Y dimension: </label>
            <select id="y_col_select_path" onchange="updateChart_path()">
                <option value="Profit" selected>Profit</option>
                <option value="Sales">Sales</option>
                <option value="Cost">Cost</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="color_col_select_path">Path grouping: </label>
            <select id="color_col_select_path" onchange="updateChart_path()">
                <option value="Product" selected>Product</option>
                <option value="Region">Region</option>
                <option value="Segment">Segment</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="path"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: business_path_data.parquet</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
