<!DOCTYPE html>
<html>
<head>
    <title>2D Charts</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->
<script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
<script type="module">
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';
await parquet.default();
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts various date formats to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
// Handles: ISO strings, Date objects (from Arrow/Parquet), timestamps, and day counts
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Timestamp range for reasonable dates (1970-01-01 to 2100-01-01 in milliseconds)
    var MIN_TIMESTAMP_MS = 0;
    var MAX_TIMESTAMP_MS = 4102444800000;  // 2100-01-01

    // Day count range (for dates stored as days since epoch, e.g., from some Parquet files)
    // Reasonable range: 0 (1970-01-01) to ~47500 (~2100-01-01)
    var MIN_DAYS = 0;
    var MAX_DAYS = 50000;
    var MS_PER_DAY = 86400000;

    // Scan multiple rows to better detect column types (some rows might have missing values)
    var rowsToCheck = Math.min(10, data.length);
    var dateColumns = [];
    var timeColumns = [];
    var timestampColumns = [];
    var dayCountColumns = [];
    var alreadyDateColumns = [];

    // Helper to check if a numeric value looks like a timestamp (milliseconds since epoch)
    function looksLikeTimestamp(value) {
        return typeof value === 'number' && value >= MIN_TIMESTAMP_MS && value <= MAX_TIMESTAMP_MS && value > MAX_DAYS;
    }

    // Helper to check if a numeric value looks like a day count since epoch
    function looksLikeDayCount(value) {
        return typeof value === 'number' && value >= MIN_DAYS && value <= MAX_DAYS && Number.isInteger(value);
    }

    // Build list of keys from first row
    var keys = Object.keys(data[0]);

    // Check each column across multiple rows
    keys.forEach(function(key) {
        var stringDateCount = 0;
        var timeCount = 0;
        var timestampCount = 0;
        var dayCountCount = 0;
        var alreadyDateCount = 0;
        var nonNullCount = 0;

        for (var i = 0; i < rowsToCheck; i++) {
            var value = data[i][key];
            if (value === null || value === undefined) continue;
            nonNullCount++;

            if (value instanceof Date) {
                alreadyDateCount++;
            } else if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    stringDateCount++;
                } else if (timePattern.test(value)) {
                    timeCount++;
                }
            } else if (typeof value === 'number') {
                if (looksLikeTimestamp(value)) {
                    timestampCount++;
                } else if (looksLikeDayCount(value)) {
                    dayCountCount++;
                }
            }
        }

        // Classify column if majority of non-null values match a pattern
        var threshold = nonNullCount * 0.5;
        if (alreadyDateCount > threshold) {
            alreadyDateColumns.push(key);
        } else if (stringDateCount > threshold) {
            dateColumns.push(key);
        } else if (timeCount > threshold) {
            timeColumns.push(key);
        } else if (timestampCount > threshold) {
            timestampColumns.push(key);
        } else if (dayCountCount > threshold && dayCountCount >= 3) {
            // Be more conservative with day counts - require at least 3 matches
            dayCountColumns.push(key);
        }
    });

    // If no date/time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0 &&
        timestampColumns.length === 0 && dayCountColumns.length === 0 &&
        alreadyDateColumns.length === 0) {
        return data;
    }

    // Convert values in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                var value = row[key];

                if (alreadyDateColumns.indexOf(key) !== -1) {
                    // Already a Date object - keep as is
                    newRow[key] = value;
                } else if (dateColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // ISO date string - convert to Date
                    newRow[key] = new Date(value);
                } else if (timeColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = value.split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else if (timestampColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Timestamp in milliseconds - convert to Date
                    newRow[key] = new Date(value);
                } else if (dayCountColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Day count since epoch - convert to Date
                    newRow[key] = new Date(value * MS_PER_DAY);
                } else {
                    newRow[key] = value;
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['date', 'quarter'];
    const Y_COLS = ['sales', 'quantity', 'profit', 'customers', 'satisfaction'];
    const COLOR_COLS = ['product', 'region', 'segment'];
    const COLOR_MAPS = {'segment': {'SMB': '#636efa', 'Enterprise': '#00cc96', 'Consumer': '#EF553B'}, 'region': {'West': '#00cc96', 'North': '#636efa', 'South': '#EF553B'}, 'product': {'Phone': '#00cc96', 'Laptop': '#636efa', 'Tablet': '#EF553B'}};
    const DEFAULT_X_COL = 'date';
    const DEFAULT_Y_COL = 'sales';
    const DEFAULT_COLOR_COL = 'product';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_LineChart = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_LineChart');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_LineChart');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_LineChart');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_LineChart');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_LineChart');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_LineChart' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_LineChart');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_LineChart');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_LineChart');
        const facet2Select = document.getElementById('facet2_select_LineChart');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'LineChart',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                let xValues = result.xValues;
                let yValues = result.yValues;

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('LineChart', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    let xValues = result.xValues;
                    let yValues = result.yValues;

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('LineChart', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        let xValues = result.xValues;
                        let yValues = result.yValues;

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('LineChart', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updateChart_LineChart();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('LineChart');
    }).catch(function(error) {
        console.error('Error loading data for chart LineChart:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['segment', 'region', 'product'];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['date', 'quarter'];
    const Y_COLS = ['sales', 'quantity', 'cost', 'customers', 'satisfaction'];
    const COLOR_COLS = ['product', 'segment', 'region'];
    const COLOR_MAPS = {'segment': {'SMB': '#636efa', 'Enterprise': '#00cc96', 'Consumer': '#EF553B'}, 'region': {'West': '#00cc96', 'North': '#636efa', 'South': '#EF553B'}, 'product': {'Phone': '#00cc96', 'Laptop': '#636efa', 'Tablet': '#EF553B'}};
    const GROUP_ORDER = {'segment': ['SMB', 'Consumer', 'Enterprise'], 'region': ['North', 'South', 'West'], 'product': ['Laptop', 'Tablet', 'Phone']};
    const DEFAULT_X_COL = 'date';
    const DEFAULT_Y_COL = 'sales';
    const DEFAULT_COLOR_COL = 'product';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_AreaChart = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_AreaChart');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_AreaChart');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_AreaChart');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_AreaChart');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_AreaChart');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_AreaChart' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('color_col_select_AreaChart');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_AreaChart');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_AreaChart');
        const facet2Select = document.getElementById('facet2_select_AreaChart');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'AreaChart',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                let xValues = groupData.map(row => row[X_COL]);
                let yValues = groupData.map(row => row[Y_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                } else if (STACK_MODE === 'dodge') {
                    if (discrete) {
                        trace.type = 'bar';
                    }
                    // For continuous x, dodge doesn't make sense, so we treat it like unstack
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ?
                        getAxisLabel(Y_COL, Y_TRANSFORM) + ' (%)' :
                        getAxisLabel(Y_COL, Y_TRANSFORM)
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' :
                         STACK_MODE === 'dodge' ? 'group' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('AreaChart', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' :
                         STACK_MODE === 'dodge' ? 'group' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    let xValues = groupData.map(row => row[X_COL]);
                    let yValues = groupData.map(row => row[Y_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    } else if (STACK_MODE === 'dodge') {
                        // For continuous x, dodge doesn't make sense, so we treat it like unstack
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ?
                        (STACK_MODE === 'normalised_stack' ?
                            getAxisLabel(Y_COL, Y_TRANSFORM) + ' (%)' :
                            getAxisLabel(Y_COL, Y_TRANSFORM)) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('AreaChart', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' :
                         STACK_MODE === 'dodge' ? 'group' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        let xValues = groupData.map(row => row[X_COL]);
                        let yValues = groupData.map(row => row[Y_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        } else if (STACK_MODE === 'dodge') {
                            // For continuous x, dodge doesn't make sense, so we treat it like unstack
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ?
                            (STACK_MODE === 'normalised_stack' ?
                                getAxisLabel(Y_COL, Y_TRANSFORM) + ' (%)' :
                                getAxisLabel(Y_COL, Y_TRANSFORM)) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('AreaChart', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updatePlot_AreaChart();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('AreaChart');
    }).catch(function(error) {
        console.error('Error loading data for chart AreaChart:', error);
    });
})();
    (function() {
    // Filter configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];

    window.showDensity_scatter = true;
    const POINT_SYMBOLS = ["circle","square","diamond","cross","x","triangle-up","triangle-down","triangle-left","triangle-right","pentagon","hexagon","star"];
    const DEFAULT_X_COL = 'profit';
    const DEFAULT_Y_COL = 'sales';
    const DEFAULT_COLOR_COL = 'product';

    const getCol = (id, def) => { const el = document.getElementById(id); return el ? el.value : def; };
    const buildSymbolMap = (data, col) => {
        const uniqueVals = [...new Set(data.map(row => row[col]))].sort();
        return Object.fromEntries(uniqueVals.map((val, i) => [val, POINT_SYMBOLS[i % POINT_SYMBOLS.length]]));
    };

    function createTraces(data, X_COL, Y_COL, COLOR_COL, X_TRANSFORM, Y_TRANSFORM, xaxis='x', yaxis='y', showlegend=true) {
        const symbolMap = buildSymbolMap(data, COLOR_COL);
        const groups = {};
        data.forEach(row => {
            const key = row[COLOR_COL];
            if (!groups[key]) groups[key] = [];
            groups[key].push(row);
        });

        return Object.entries(groups).map(([key, groupData]) => {
            let xValues = groupData.map(d => d[X_COL]);
            let yValues = groupData.map(d => d[Y_COL]);

            // Apply axis transformations
            xValues = applyAxisTransform(xValues, X_TRANSFORM);
            yValues = applyAxisTransform(yValues, Y_TRANSFORM);

            return {
            x: xValues,
            y: yValues,
            mode: 'markers',
            name: key,
            legendgroup: key,
            showlegend: showlegend,
            xaxis: xaxis,
            yaxis: yaxis,
            marker: {
                size: 4,
                opacity: 0.6,
                symbol: groupData.map(d => symbolMap[d[COLOR_COL]])
            },
            type: 'scatter'
            };
        });
    }

    function renderNoFacets(data, X_COL, Y_COL, COLOR_COL, X_TRANSFORM, Y_TRANSFORM) {
        const traces = createTraces(data, X_COL, Y_COL, COLOR_COL, X_TRANSFORM, Y_TRANSFORM);

        if (window.showDensity_scatter) {
            let xDensityValues = data.map(d => d[X_COL]);
            let yDensityValues = data.map(d => d[Y_COL]);
            xDensityValues = applyAxisTransform(xDensityValues, X_TRANSFORM);
            yDensityValues = applyAxisTransform(yDensityValues, Y_TRANSFORM);

            traces.push({
                x: xDensityValues, y: yDensityValues,
                name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                showscale: false, type: 'histogram2dcontour', showlegend: false
            });
        }

        let xHistValues = data.map(d => d[X_COL]);
        let yHistValues = data.map(d => d[Y_COL]);
        xHistValues = applyAxisTransform(xHistValues, X_TRANSFORM);
        yHistValues = applyAxisTransform(yHistValues, Y_TRANSFORM);

        traces.push(
            { x: xHistValues, name: 'x density', marker: {color: 'rgba(128, 128, 128, 0.5)'}, yaxis: 'y2', type: 'histogram', showlegend: false },
            { y: yHistValues, name: 'y density', marker: {color: 'rgba(128, 128, 128, 0.5)'}, xaxis: 'x2', type: 'histogram', showlegend: false }
        );

        Plotly.newPlot('scatter', traces, {
            title: 'Scatter Plot', showlegend: true, autosize: true, hovermode: 'closest',
            xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM), domain: [0, 0.85], showgrid: true, zeroline: true },
            yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM), domain: [0, 0.85], showgrid: true, zeroline: true },
            xaxis2: { domain: [0.85, 1], showgrid: false, zeroline: false },
            yaxis2: { domain: [0.85, 1], showgrid: false, zeroline: false },
            margin: {t: 100, r: 100, b: 100, l: 100}
        }, {responsive: true});
    }

    function renderFacetWrap(data, X_COL, Y_COL, COLOR_COL, FACET_COL, X_TRANSFORM, Y_TRANSFORM) {
        const facetValues = [...new Set(data.map(row => row[FACET_COL]))].sort();
        const nFacets = facetValues.length, cols = Math.ceil(Math.sqrt(nFacets)), rows = Math.ceil(nFacets / cols);
        const traces = [];

        facetValues.forEach((facetVal, idx) => {
            const facetData = data.filter(row => row[FACET_COL] === facetVal);
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);
            traces.push(...createTraces(facetData, X_COL, Y_COL, COLOR_COL, X_TRANSFORM, Y_TRANSFORM, xaxis, yaxis, idx === 0));

            if (window.showDensity_scatter) {
                let xDensityValues = facetData.map(d => d[X_COL]);
                let yDensityValues = facetData.map(d => d[Y_COL]);
                xDensityValues = applyAxisTransform(xDensityValues, X_TRANSFORM);
                yDensityValues = applyAxisTransform(yDensityValues, Y_TRANSFORM);

                traces.push({
                    x: xDensityValues, y: yDensityValues,
                    name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                    showscale: false, type: 'histogram2dcontour', showlegend: false, xaxis: xaxis, yaxis: yaxis
                });
            }
        });

        const layout = {
            title: 'Scatter Plot', showlegend: true, grid: {rows: rows, columns: cols, pattern: 'independent'},
            annotations: facetValues.map((val, idx) => ({
                text: FACET_COL + ': ' + val, showarrow: false,
                xref: (idx === 0 ? 'x' : 'x' + (idx + 1)) + ' domain',
                yref: (idx === 0 ? 'y' : 'y' + (idx + 1)) + ' domain',
                x: 0.5, y: 1.1, xanchor: 'center', yanchor: 'bottom'
            })),
            margin: {t: 100, r: 50, b: 50, l: 50}
        };
        facetValues.forEach((val, idx) => {
            const ax = idx === 0 ? '' : (idx + 1);
            layout['xaxis' + ax] = {title: getAxisLabel(X_COL, X_TRANSFORM)};
            layout['yaxis' + ax] = {title: getAxisLabel(Y_COL, Y_TRANSFORM)};
        });
        Plotly.newPlot('scatter', traces, layout, {responsive: true});
    }

    function renderFacetGrid(data, X_COL, Y_COL, COLOR_COL, FACET1_COL, FACET2_COL, X_TRANSFORM, Y_TRANSFORM) {
        const facet1Values = [...new Set(data.map(row => row[FACET1_COL]))].sort();
        const facet2Values = [...new Set(data.map(row => row[FACET2_COL]))].sort();
        const rows = facet1Values.length, cols = facet2Values.length;
        const traces = [];

        facet1Values.forEach((facet1Val, rowIdx) => {
            facet2Values.forEach((facet2Val, colIdx) => {
                const facetData = data.filter(row => row[FACET1_COL] === facet1Val && row[FACET2_COL] === facet2Val);
                if (facetData.length === 0) return;

                const idx = rowIdx * cols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);
                traces.push(...createTraces(facetData, X_COL, Y_COL, COLOR_COL, X_TRANSFORM, Y_TRANSFORM, xaxis, yaxis, idx === 0));

                if (window.showDensity_scatter) {
                    let xDensityValues = facetData.map(d => d[X_COL]);
                    let yDensityValues = facetData.map(d => d[Y_COL]);
                    xDensityValues = applyAxisTransform(xDensityValues, X_TRANSFORM);
                    yDensityValues = applyAxisTransform(yDensityValues, Y_TRANSFORM);

                    traces.push({
                        x: xDensityValues, y: yDensityValues,
                        name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                        showscale: false, type: 'histogram2dcontour', showlegend: false, xaxis: xaxis, yaxis: yaxis
                    });
                }
            });
        });

        const layout = {
            title: 'Scatter Plot', showlegend: true, grid: {rows: rows, columns: cols, pattern: 'independent'},
            annotations: [
                ...facet2Values.map((val, colIdx) => ({
                    text: FACET2_COL + ': ' + val, showarrow: false,
                    xref: (colIdx === 0 ? 'x' : 'x' + (colIdx + 1)) + ' domain',
                    yref: (colIdx === 0 ? 'y' : 'y' + (colIdx + 1)) + ' domain',
                    x: 0.5, y: 1.1, xanchor: 'center', yanchor: 'bottom'
                })),
                ...facet1Values.map((val, rowIdx) => ({
                    text: FACET1_COL + ': ' + val, showarrow: false,
                    xref: (rowIdx * cols === 0 ? 'x' : 'x' + (rowIdx * cols + 1)) + ' domain',
                    yref: (rowIdx * cols === 0 ? 'y' : 'y' + (rowIdx * cols + 1)) + ' domain',
                    x: -0.15, y: 0.5, xanchor: 'center', yanchor: 'middle', textangle: -90
                }))
            ],
            margin: {t: 100, r: 50, b: 50, l: 50}
        };
        facet1Values.forEach((v1, rowIdx) => {
            facet2Values.forEach((v2, colIdx) => {
                const idx = rowIdx * cols + colIdx, ax = idx === 0 ? '' : (idx + 1);
                layout['xaxis' + ax] = {title: getAxisLabel(X_COL, X_TRANSFORM)};
                layout['yaxis' + ax] = {title: getAxisLabel(Y_COL, Y_TRANSFORM)};
            });
        });
        Plotly.newPlot('scatter', traces, layout, {responsive: true});
    }

    function updatePlot_scatter(data) {
        const X_COL = getCol('x_col_select_scatter', DEFAULT_X_COL);
        const Y_COL = getCol('y_col_select_scatter', DEFAULT_Y_COL);
        const COLOR_COL = getCol('color_col_select_scatter', DEFAULT_COLOR_COL);

        // Get current axis transformations
        const X_TRANSFORM = getCol('x_transform_select_scatter', 'identity');
        const Y_TRANSFORM = getCol('y_transform_select_scatter', 'identity');

        let FACET1 = getCol('facet1_select_scatter', null);
        let FACET2 = getCol('facet2_select_scatter', null);
        if (FACET1 === 'None') FACET1 = null;
        if (FACET2 === 'None') FACET2 = null;

        if (FACET1 && FACET2) {
            renderFacetGrid(data, X_COL, Y_COL, COLOR_COL, FACET1, FACET2, X_TRANSFORM, Y_TRANSFORM);
        } else if (FACET1) {
            renderFacetWrap(data, X_COL, Y_COL, COLOR_COL, FACET1, X_TRANSFORM, Y_TRANSFORM);
        } else {
            renderNoFacets(data, X_COL, Y_COL, COLOR_COL, X_TRANSFORM, Y_TRANSFORM);
        }
    }

    window.updateChart_scatter = () => updatePlotWithFilters_scatter();

    // Filter and update function
    window.updatePlotWithFilters_scatter = function() {
        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_scatter');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_scatter' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            window.allData_scatter,
            'scatter',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Update plot with filtered data
        updatePlot_scatter(filteredData);
    };

    loadDataset('sales_data').then(data => {
        window.allData_scatter = data;
        $(function() {
            const densityBtn = document.getElementById('scatter_density_toggle');
            if (densityBtn) {
                densityBtn.addEventListener('click', function() {
                    window.showDensity_scatter = !window.showDensity_scatter;
                    this.textContent = window.showDensity_scatter ? 'Hide Density Contours' : 'Show Density Contours';
                    updatePlotWithFilters_scatter();
                });
            }
            updatePlotWithFilters_scatter();

            // Setup aspect ratio control after initial render
            setupAspectRatioControl('scatter');
        });
    }).catch(error => console.error('Error loading data for chart scatter:', error));
    })();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['Product', 'Region', 'Segment'];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['Cost', 'Profit', 'Sales'];
    const Y_COLS = ['Profit', 'Sales', 'Cost'];
    const COLOR_COLS = ['Product', 'Region', 'Segment'];
    const COLOR_MAPS = {'Product': {'Doohickey': '#00cc96', 'Widget': '#636efa', 'Gadget': '#EF553B'}, 'Segment': {'Government': '#00cc96', 'Enterprise': '#EF553B', 'Consumer': '#636efa'}, 'Region': {'East': '#00cc96', 'West': '#ab63fa', 'North': '#636efa', 'South': '#EF553B'}};
    const DEFAULT_X_COL = 'Cost';
    const DEFAULT_Y_COL = 'Profit';
    const DEFAULT_COLOR_COL = 'Product';
    const ORDER_COL = 'Month';
    const USE_ALPHARANGE = true;

    // Global state for arrow/line toggle
    window.showArrows_path = true;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_path = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_path');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_path');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_path');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_path');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_path');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_path' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_path');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_path');
        const facet2Select = document.getElementById('facet2_select_path');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'path',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 8,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_path) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 2,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 2
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 2
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Path Chart',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('path', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Path Chart',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 8,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_path) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 2,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 2
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 2
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('path', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Path Chart',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 8,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_path) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 2,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 2
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 2
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('path', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('path_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_path = !window.showArrows_path;
            arrowToggleBtn.textContent = window.showArrows_path ? 'Show Lines' : 'Show Arrows';
            window.updateChart_path();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('business_path_data').then(function(data) {
        allData = data;
        window.updateChart_path();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('path');
    }).catch(function(error) {
        console.error('Error loading data for chart path:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="countries_geo_data" data-format="parquet" data-src="data/countries_geo_data.parquet"></script><script type="text/plain" id="product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="sankey_data" data-format="parquet" data-src="data/sankey_data.parquet"></script><script type="text/plain" id="stock_corr_data" data-format="parquet" data-src="data/stock_corr_data.parquet"></script><script type="text/plain" id="exec_data.tob" data-format="parquet" data-src="data/exec_data/tob.parquet"></script><script type="text/plain" id="exec_data.summary_usd" data-format="parquet" data-src="data/exec_data/summary_usd.parquet"></script><script type="text/plain" id="exec_data.fill_returns" data-format="parquet" data-src="data/exec_data/fill_returns.parquet"></script><script type="text/plain" id="surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script><script type="text/plain" id="exec_data.summary_bps" data-format="parquet" data-src="data/exec_data/summary_bps.parquet"></script><script type="text/plain" id="radar_data" data-format="parquet" data-src="data/radar_data.parquet"></script><script type="text/plain" id="cities_geo_data" data-format="parquet" data-src="data/cities_geo_data.parquet"></script><script type="text/plain" id="rankings_data" data-format="parquet" data-src="data/rankings_data.parquet"></script><script type="text/plain" id="exec_data.summary_pct" data-format="parquet" data-src="data/exec_data/summary_pct.parquet"></script><script type="text/plain" id="exec_data.fills" data-format="parquet" data-src="data/exec_data/fills.parquet"></script><script type="text/plain" id="sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="exec_data.volume" data-format="parquet" data-src="data/exec_data/volume.parquet"></script><script type="text/plain" id="tsne_stock_data" data-format="parquet" data-src="data/tsne_stock_data.parquet"></script><script type="text/plain" id="daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="boxwhiskers_data" data-format="parquet" data-src="data/boxwhiskers_data.parquet"></script><script type="text/plain" id="waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="candlestick_data" data-format="parquet" data-src="data/candlestick_data.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>2D Charts</h1>
<p>This shows examples of LinePlot, AreaChart, ScatterPlot and Path.</p>

    <div class="textblock-content">
        <h1>Two-Dimensional Plots</h1>
    </div>
<br>
<hr>
<br>
<h2>Line Chart</h2>
<p>A linechart. There are optional controls to change the variables on the x and or y axis. It is also possible to change the faceting, the grouping variable, the aggregation variable (if there are multiple y values per x value) as well as filters. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linechart_examples.html" style="color: blue; font-weight: bold;">See here for LineChart examples</a></p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_LineChart">Color by: </label>
                <select id="color_col_select_LineChart" onchange="updateChart_LineChart()">
                <option value="product" selected>product</option>
                <option value="region">region</option>
                <option value="segment">segment</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_LineChart_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_LineChart">Aggregator: </label>
                <select id="aggregator_select_LineChart" onchange="updateChart_LineChart()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_LineChart_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_LineChart">X: </label>
        <select id="x_col_select_LineChart" style="padding: 5px 10px;" onchange="updateChart_LineChart()">
            <option value="date" selected>date</option>
<option value="quarter">quarter</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_LineChart">X Transform: </label>
        <select id="x_transform_select_LineChart" style="padding: 5px 10px;" onchange="updateChart_LineChart()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_LineChart">Y: </label>
        <select id="y_col_select_LineChart" style="padding: 5px 10px;" onchange="updateChart_LineChart()">
            <option value="sales" selected>sales</option>
<option value="quantity">quantity</option>
<option value="profit">profit</option>
<option value="customers">customers</option>
<option value="satisfaction">satisfaction</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_LineChart">Y Transform: </label>
        <select id="y_transform_select_LineChart" style="padding: 5px 10px;" onchange="updateChart_LineChart()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="facet1_select_LineChart">Facet 1: </label>
        <select id="facet1_select_LineChart" style="padding: 5px 10px;" onchange="updateChart_LineChart()">
            <option value="None" selected>None</option>
<option value="region">region</option>
<option value="segment">segment</option>
<option value="product">product</option>
<option value="month">month</option>
        </select>
    </div>
    <div>
        <label for="facet2_select_LineChart">Facet 2: </label>
        <select id="facet2_select_LineChart" style="padding: 5px 10px;" onchange="updateChart_LineChart()">
            <option value="None" selected>None</option>
<option value="region">region</option>
<option value="segment">segment</option>
<option value="product">product</option>
<option value="month">month</option>
        </select>
    </div>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="LineChart_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="LineChart_aspect_ratio_label">0.4</span>
    <input type="range" id="LineChart_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="LineChart"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p><br>
<hr>
<br>
<h2>Area Chart</h2>
<p>Stacked Trends. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/areachart_examples.html" style="color: blue; font-weight: bold;">See here for AreaChart examples</a></p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="AreaChart_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="segment_select_AreaChart">segment: </label>
                <select id="segment_select_AreaChart" multiple onchange="updatePlot_AreaChart()">
                <option value="Consumer" selected>Consumer</option>
                <option value="Enterprise" selected>Enterprise</option>
                <option value="SMB" selected>SMB</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="segment_select_AreaChart_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="region_select_AreaChart">region: </label>
                <select id="region_select_AreaChart" multiple onchange="updatePlot_AreaChart()">
                <option value="North" selected>North</option>
                <option value="South" selected>South</option>
                <option value="West" selected>West</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="region_select_AreaChart_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="product_select_AreaChart">product: </label>
                <select id="product_select_AreaChart" multiple onchange="updatePlot_AreaChart()">
                <option value="Laptop" selected>Laptop</option>
                <option value="Phone" selected>Phone</option>
                <option value="Tablet" selected>Tablet</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="product_select_AreaChart_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_AreaChart">Color by: </label>
                <select id="color_col_select_AreaChart" onchange="updatePlot_AreaChart()">
                <option value="product" selected>product</option>
                <option value="segment">segment</option>
                <option value="region">region</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_AreaChart_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="stack_mode_select_AreaChart">Stack mode: </label>
                <select id="stack_mode_select_AreaChart" onchange="updatePlot_AreaChart()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
                <option value="dodge">dodge</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="stack_mode_select_AreaChart_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_AreaChart">X: </label>
        <select id="x_col_select_AreaChart" style="padding: 5px 10px;" onchange="updatePlot_AreaChart()">
            <option value="date" selected>date</option>
<option value="quarter">quarter</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_AreaChart">X Transform: </label>
        <select id="x_transform_select_AreaChart" style="padding: 5px 10px;" onchange="updatePlot_AreaChart()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_AreaChart">Y: </label>
        <select id="y_col_select_AreaChart" style="padding: 5px 10px;" onchange="updatePlot_AreaChart()">
            <option value="sales" selected>sales</option>
<option value="quantity">quantity</option>
<option value="cost">cost</option>
<option value="customers">customers</option>
<option value="satisfaction">satisfaction</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_AreaChart">Y Transform: </label>
        <select id="y_transform_select_AreaChart" style="padding: 5px 10px;" onchange="updatePlot_AreaChart()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="facet1_select_AreaChart">Facet 1: </label>
        <select id="facet1_select_AreaChart" style="padding: 5px 10px;" onchange="updatePlot_AreaChart()">
            <option value="None" selected>None</option>
<option value="region">region</option>
<option value="product">product</option>
<option value="segment">segment</option>
        </select>
    </div>
    <div>
        <label for="facet2_select_AreaChart">Facet 2: </label>
        <select id="facet2_select_AreaChart" style="padding: 5px 10px;" onchange="updatePlot_AreaChart()">
            <option value="None" selected>None</option>
<option value="region">region</option>
<option value="product">product</option>
<option value="segment">segment</option>
        </select>
    </div>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="AreaChart_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="AreaChart_aspect_ratio_label">0.4</span>
    <input type="range" id="AreaChart_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="AreaChart"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p><br>
<hr>
<br>
<h2>Scatter Plot</h2>
<p>Scatter plots show x vs y. There is a density colouring that can be applied or not depending on a slider. In addition the marginal distributions appear on the edges of the plot in cases when you do not apply faceting. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatterplot_examples.html" style="color: blue; font-weight: bold;">See here for ScatterPlot examples</a></p>

<!-- Filters (for data filtering) -->

<!-- Plot Attributes -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <div style="margin: 10px 0;">
    <button id="scatter_density_toggle" style="padding: 5px 15px; cursor: pointer;">
        Hide Density Contours
    </button>
</div>
<div style="margin: 10px 0; display: flex; gap: 20px; align-items: center;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="color_col_select_scatter">Color/Point type:</label>
                    <select id="color_col_select_scatter" onchange="updateChart_scatter()">
                    <option value="product" selected>product</option>
                    <option value="region">region</option>
                    <option value="segment">segment</option>
                    <option value="month">month</option>                </select>
                </div>
                    </div>
<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_scatter">X: </label>
        <select id="x_col_select_scatter" style="padding: 5px 10px;" onchange="updateChart_scatter()">
            <option value="profit" selected>profit</option>
<option value="sales">sales</option>
<option value="quantity">quantity</option>
<option value="customers">customers</option>
<option value="cost">cost</option>
<option value="satisfaction">satisfaction</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_scatter">X Transform: </label>
        <select id="x_transform_select_scatter" style="padding: 5px 10px;" onchange="updateChart_scatter()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_scatter">Y: </label>
        <select id="y_col_select_scatter" style="padding: 5px 10px;" onchange="updateChart_scatter()">
            <option value="profit">profit</option>
<option value="sales" selected>sales</option>
<option value="quantity">quantity</option>
<option value="customers">customers</option>
<option value="cost">cost</option>
<option value="satisfaction">satisfaction</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_scatter">Y Transform: </label>
        <select id="y_transform_select_scatter" style="padding: 5px 10px;" onchange="updateChart_scatter()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
            <div style="margin: 10px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <div>
                    <label for="facet1_select_scatter">Facet 1: </label>
                    <select id="facet1_select_scatter" style="padding: 5px 10px;" onchange="updateChart_scatter()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="product">product</option>
                <option value="segment">segment</option>                </select>
                </div>
                <div>
                    <label for="facet2_select_scatter">Facet 2: </label>
                    <select id="facet2_select_scatter" style="padding: 5px 10px;" onchange="updateChart_scatter()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="product">product</option>
                <option value="segment">segment</option>                </select>
                </div>
            </div>
            
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="scatter_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="scatter_aspect_ratio_label">1.0</span>
    <input type="range" id="scatter_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="0.0"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="scatter"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p><br>
<hr>
<br>
<h2>Path Chart</h2>
<p>A Path chart shows trajectories through metric space over time. This example uses business data (Sales/Cost/Profit by Product/Region/Segment over 12 months) - the same dataset that will be used later in the Slides examples. Each path traces how a product's metrics evolve month-by-month. By default, it shows the North region and Consumer segment, with paths colored by Product. Use the filters to explore different regions and segments. The arrows and alpha gradient show the direction of time progression. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/path_examples.html" style="color: blue; font-weight: bold;">See here for Path examples</a></p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="path_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="Product_select_path">Product: </label>
                <select id="Product_select_path" multiple onchange="updateChart_path()">
                <option value="Doohickey" selected>Doohickey</option>
                <option value="Gadget" selected>Gadget</option>
                <option value="Widget" selected>Widget</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="Product_select_path_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="Region_select_path">Region: </label>
                <select id="Region_select_path" multiple onchange="updateChart_path()">
                <option value="East">East</option>
                <option value="North" selected>North</option>
                <option value="South">South</option>
                <option value="West">West</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="Region_select_path_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="Segment_select_path">Segment: </label>
                <select id="Segment_select_path" multiple onchange="updateChart_path()">
                <option value="Consumer" selected>Consumer</option>
                <option value="Enterprise">Enterprise</option>
                <option value="Government">Government</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="Segment_select_path_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_path">Path grouping: </label>
                <select id="color_col_select_path" onchange="updateChart_path()">
                <option value="Product" selected>Product</option>
                <option value="Region">Region</option>
                <option value="Segment">Segment</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_path_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_path">X: </label>
        <select id="x_col_select_path" style="padding: 5px 10px;" onchange="updateChart_path()">
            <option value="Cost" selected>Cost</option>
<option value="Profit">Profit</option>
<option value="Sales">Sales</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_path">X Transform: </label>
        <select id="x_transform_select_path" style="padding: 5px 10px;" onchange="updateChart_path()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_path">Y: </label>
        <select id="y_col_select_path" style="padding: 5px 10px;" onchange="updateChart_path()">
            <option value="Profit" selected>Profit</option>
<option value="Sales">Sales</option>
<option value="Cost">Cost</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_path">Y Transform: </label>
        <select id="y_transform_select_path" style="padding: 5px 10px;" onchange="updateChart_path()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="path_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="path_aspect_ratio_label">0.4</span>
    <input type="range" id="path_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="path"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: business_path_data.parquet</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.5.0.</small></p>
</body>
</html>
