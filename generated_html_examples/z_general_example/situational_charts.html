<!DOCTYPE html>
<html>
<head>
    <title>Situational Charts</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
    

    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

    <!-- libgif.js for GIF frame control -->
    <script src="https://unpkg.com/libgif-js@0.0.3/libgif.js"></script>
</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                resolve(results.data);
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                resolve(data);
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        resolve(results.data);
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['category'];
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = false;

    // Store data globally
    let allData = [];
    let removedCategories = {};  // Map from facet_key to Set of removed categories

    function getFacetKey_waterfall() {
        const facet1Select = document.getElementById('facet1_select_waterfall');
        const facet2Select = document.getElementById('facet2_select_waterfall');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;
        return (facet1 || 'none') + '|' + (facet2 || 'none');
    }

    function getRemovedSet_waterfall() {
        const key = getFacetKey_waterfall();
        if (!removedCategories[key]) {
            removedCategories[key] = new Set();
        }
        return removedCategories[key];
    }

    function calculateWaterfall_waterfall(data) {
        const removed = getRemovedSet_waterfall();
        const activeData = data.filter(row => !removed.has(String(row[CATEGORY_COL])));

        let runningTotal = 0;
        const processed = [];

        for (const row of activeData) {
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            processed.push({
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing'
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total'
            });
        }

        return processed;
    }

    function updateTable_waterfall(processedData, allCategories) {
        if (!SHOW_TABLE) return;

        const tbody = document.getElementById('waterfall_tbody_waterfall');
        if (!tbody) return;

        const removed = getRemovedSet_waterfall();
        tbody.innerHTML = '';

        // Build a map for quick lookup
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.category] = item;
        }

        // Show all original categories (including removed ones)
        for (const cat of allCategories) {
            const row = document.createElement('tr');
            const isRemoved = removed.has(cat);
            const item = dataMap[cat];

            if (isRemoved) {
                row.classList.add('removed');
            } else if (item) {
                if (item.type === 'increasing') {
                    row.classList.add('positive');
                } else if (item.type === 'decreasing') {
                    row.classList.add('negative');
                } else if (item.type === 'total') {
                    row.classList.add('total');
                }
            }

            row.dataset.category = cat;
            row.onclick = function() {
                if (cat !== 'Total') {
                    toggleCategory_waterfall(cat);
                }
            };

            const categoryCell = document.createElement('td');
            categoryCell.textContent = cat;
            row.appendChild(categoryCell);

            const valueCell = document.createElement('td');
            if (item) {
                valueCell.textContent = item.value.toFixed(2);
                valueCell.style.textAlign = 'right';
            } else {
                valueCell.textContent = '-';
            }
            row.appendChild(valueCell);

            const totalCell = document.createElement('td');
            if (item) {
                totalCell.textContent = item.end.toFixed(2);
                totalCell.style.textAlign = 'right';
            } else {
                totalCell.textContent = '-';
            }
            row.appendChild(totalCell);

            tbody.appendChild(row);
        }
    }

    function toggleCategory_waterfall(category) {
        const removed = getRemovedSet_waterfall();
        if (removed.has(category)) {
            removed.delete(category);
        } else {
            removed.add(category);
        }
        window.updateChart_waterfall();
    }

    window.resetWaterfall_waterfall = function() {
        const key = getFacetKey_waterfall();
        removedCategories[key] = new Set();
        window.updateChart_waterfall();
    };

    // Make it global so inline onchange can see it
    window.updateChart_waterfall = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update color column if dropdown exists
        const colorColSelect = document.getElementById('color_col_select_waterfall');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_waterfall');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get all categories for table (before removal)
        const allCategories = [...new Set(filteredData.map(row => String(row[CATEGORY_COL])))];

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_waterfall');
        const facet2Select = document.getElementById('facet2_select_waterfall');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single waterfall chart
            const processed = calculateWaterfall_waterfall(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('waterfall', [trace], layout, {responsive: true});

            // Add click handler
            document.getElementById('waterfall').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_waterfall(clickedCategory);
                }
            });

            // Update table
            updateTable_waterfall(processed, allCategories);

        } else {
            // Faceting not implemented for waterfall yet
            // (could be added in future enhancement)
            const processed = calculateWaterfall_waterfall(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('waterfall', [trace], layout, {responsive: true});

            document.getElementById('waterfall').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_waterfall(clickedCategory);
                }
            });

            updateTable_waterfall(processed, allCategories);
        }
    };

    // Load and parse data
    loadDataset('waterfall_data').then(function(data) {
        allData = data;
        window.updateChart_waterfall();
    }).catch(function(error) {
        console.error('Error loading data for chart waterfall:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>Situational Charts</h1>
<p>This shows examples of Waterfall and RibbonPlot.</p>

<h2>Profit & Loss Waterfall</h2>
<p>A Waterfall chart visualizes how an initial value is affected by a series of positive and negative values. This example shows a profit & loss statement, breaking down revenue into net income through various cost components. The chart automatically calculates cumulative totals. Click on any bar to temporarily remove it and see the impact on the final value. The side-by-side table shows exact values and running totals. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/waterfall_examples.html" style="color: blue; font-weight: bold;">See here for Waterfall examples</a></p>




<!-- Chart -->
<div id="waterfall"></div>
<style>
    .waterfall-layout-waterfall {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-waterfall {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-waterfall {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-waterfall {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-waterfall th,
    .waterfall-table-waterfall td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-waterfall th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-waterfall tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-waterfall tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-waterfall tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-waterfall tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-waterfall tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-waterfall {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-waterfall:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-waterfall">
    <div class="waterfall-chart-section-waterfall">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-waterfall">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on rows or chart bars to exclude from calculation</p>
                <table class="waterfall-table-waterfall" id="waterfall_table_waterfall">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Change</th>
                            <th>Running Total</th>
                        </tr>
                    </thead>
                    <tbody id="waterfall_tbody_waterfall">
                    </tbody>
                </table>
                <button class="waterfall-reset-btn-waterfall" onclick="resetWaterfall_waterfall()">ðŸ”„ Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: waterfall_data.parquet</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
