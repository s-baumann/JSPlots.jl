<!DOCTYPE html>
<html>
<head>
    <title>Path Chart Examples</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->


<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['volatility', 'Sharpe', 'returns'];
    const Y_COLS = ['Sharpe', 'returns', 'max_drawdown'];
    const COLOR_COLS = ['strategy'];
    const COLOR_MAPS = {'strategy': {'momentum': '#636efa', 'carry': '#EF553B', 'value': '#00cc96'}};
    const DEFAULT_X_COL = 'volatility';
    const DEFAULT_Y_COL = 'Sharpe';
    const DEFAULT_COLOR_COL = 'strategy';
    const ORDER_COL = 'year';
    const USE_ALPHARANGE = false;

    // Global state for arrow/line toggle
    window.showArrows_strategy_evolution_arrows = true;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_strategy_evolution_arrows = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_strategy_evolution_arrows');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_strategy_evolution_arrows');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_strategy_evolution_arrows');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_strategy_evolution_arrows');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_strategy_evolution_arrows');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_strategy_evolution_arrows' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_strategy_evolution_arrows');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_strategy_evolution_arrows');
        const facet2Select = document.getElementById('facet2_select_strategy_evolution_arrows');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'strategy_evolution_arrows',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 8,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_strategy_evolution_arrows) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 2,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 2
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 2
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Trading Strategy Evolution (2015-2024) - With Arrows',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('strategy_evolution_arrows', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Trading Strategy Evolution (2015-2024) - With Arrows',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 8,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_strategy_evolution_arrows) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 2,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 2
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 2
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('strategy_evolution_arrows', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Trading Strategy Evolution (2015-2024) - With Arrows',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 8,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_strategy_evolution_arrows) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 2,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 2
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 2
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('strategy_evolution_arrows', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('strategy_evolution_arrows_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_strategy_evolution_arrows = !window.showArrows_strategy_evolution_arrows;
            arrowToggleBtn.textContent = window.showArrows_strategy_evolution_arrows ? 'Show Lines' : 'Show Arrows';
            window.updateChart_strategy_evolution_arrows();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('strategy_data').then(function(data) {
        allData = data;
        window.updateChart_strategy_evolution_arrows();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('strategy_evolution_arrows');
    }).catch(function(error) {
        console.error('Error loading data for chart strategy_evolution_arrows:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['volatility', 'Sharpe', 'returns'];
    const Y_COLS = ['Sharpe', 'returns', 'max_drawdown'];
    const COLOR_COLS = ['strategy'];
    const COLOR_MAPS = {'strategy': {'momentum': '#636efa', 'carry': '#EF553B', 'value': '#00cc96'}};
    const DEFAULT_X_COL = 'volatility';
    const DEFAULT_Y_COL = 'Sharpe';
    const DEFAULT_COLOR_COL = 'strategy';
    const ORDER_COL = 'year';
    const USE_ALPHARANGE = true;

    // Global state for arrow/line toggle
    window.showArrows_strategy_evolution_alpha = false;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_strategy_evolution_alpha = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_strategy_evolution_alpha');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_strategy_evolution_alpha');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_strategy_evolution_alpha');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_strategy_evolution_alpha');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_strategy_evolution_alpha');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_strategy_evolution_alpha' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_strategy_evolution_alpha');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_strategy_evolution_alpha');
        const facet2Select = document.getElementById('facet2_select_strategy_evolution_alpha');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'strategy_evolution_alpha',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 8,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_strategy_evolution_alpha) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 2,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 2
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 2
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Trading Strategy Evolution (2015-2024) - With Alpha Gradient',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('strategy_evolution_alpha', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Trading Strategy Evolution (2015-2024) - With Alpha Gradient',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 8,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_strategy_evolution_alpha) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 2,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 2
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 2
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('strategy_evolution_alpha', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Trading Strategy Evolution (2015-2024) - With Alpha Gradient',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 8,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_strategy_evolution_alpha) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 2,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 2
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 2
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('strategy_evolution_alpha', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('strategy_evolution_alpha_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_strategy_evolution_alpha = !window.showArrows_strategy_evolution_alpha;
            arrowToggleBtn.textContent = window.showArrows_strategy_evolution_alpha ? 'Show Lines' : 'Show Arrows';
            window.updateChart_strategy_evolution_alpha();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('strategy_data').then(function(data) {
        allData = data;
        window.updateChart_strategy_evolution_alpha();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('strategy_evolution_alpha');
    }).catch(function(error) {
        console.error('Error loading data for chart strategy_evolution_alpha:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['region'];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['volatility', 'Sharpe', 'winrate'];
    const Y_COLS = ['Sharpe', 'drawdown', 'winrate'];
    const COLOR_COLS = ['strategy', 'region'];
    const COLOR_MAPS = {'strategy': {'momentum': '#636efa', 'carry': '#EF553B', 'value': '#00cc96'}, 'region': {'Asia': '#00cc96', 'Europe': '#EF553B', 'US': '#636efa'}};
    const DEFAULT_X_COL = 'volatility';
    const DEFAULT_Y_COL = 'Sharpe';
    const DEFAULT_COLOR_COL = 'strategy';
    const ORDER_COL = 'year';
    const USE_ALPHARANGE = true;

    // Global state for arrow/line toggle
    window.showArrows_regional_paths = false;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_regional_paths = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_regional_paths');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_regional_paths');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_regional_paths');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_regional_paths');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_regional_paths');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_regional_paths' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_regional_paths');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_regional_paths');
        const facet2Select = document.getElementById('facet2_select_regional_paths');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'regional_paths',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 7,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_regional_paths) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 2,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 2
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 2
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Regional Strategy Analysis (2015-2024)',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('regional_paths', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Regional Strategy Analysis (2015-2024)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 7,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_regional_paths) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 2,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 2
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 2
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('regional_paths', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Regional Strategy Analysis (2015-2024)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 7,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_regional_paths) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 2,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 2
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 2
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('regional_paths', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('regional_paths_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_regional_paths = !window.showArrows_regional_paths;
            arrowToggleBtn.textContent = window.showArrows_regional_paths ? 'Show Lines' : 'Show Arrows';
            window.updateChart_regional_paths();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('regional_data').then(function(data) {
        allData = data;
        window.updateChart_regional_paths();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('regional_paths');
    }).catch(function(error) {
        console.error('Error loading data for chart regional_paths:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['volatility', 'Sharpe'];
    const Y_COLS = ['returns', 'Sharpe'];
    const COLOR_COLS = ['asset_class'];
    const COLOR_MAPS = {'asset_class': {'Equity': '#636efa', 'Bonds': '#EF553B', 'Commodities': '#00cc96'}};
    const DEFAULT_X_COL = 'volatility';
    const DEFAULT_Y_COL = 'returns';
    const DEFAULT_COLOR_COL = 'asset_class';
    const ORDER_COL = 'year';
    const USE_ALPHARANGE = true;

    // Global state for arrow/line toggle
    window.showArrows_asset_performance = false;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_asset_performance = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_asset_performance');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_asset_performance');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_asset_performance');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_asset_performance');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_asset_performance');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_asset_performance' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_asset_performance');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_asset_performance');
        const facet2Select = document.getElementById('facet2_select_asset_performance');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'asset_performance',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 8,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_asset_performance) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 3,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 3
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 3
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Asset Class Risk-Return Evolution (2016-2024)',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('asset_performance', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Asset Class Risk-Return Evolution (2016-2024)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 8,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_asset_performance) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 3,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 3
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 3
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('asset_performance', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Asset Class Risk-Return Evolution (2016-2024)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 8,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_asset_performance) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 3,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 3
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 3
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('asset_performance', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('asset_performance_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_asset_performance = !window.showArrows_asset_performance;
            arrowToggleBtn.textContent = window.showArrows_asset_performance ? 'Show Lines' : 'Show Arrows';
            window.updateChart_asset_performance();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('asset_data').then(function(data) {
        allData = data;
        window.updateChart_asset_performance();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('asset_performance');
    }).catch(function(error) {
        console.error('Error loading data for chart asset_performance:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['volatility', 'Sharpe'];
    const Y_COLS = ['Sharpe', 'drawdown'];
    const COLOR_COLS = ['strategy'];
    const COLOR_MAPS = {'strategy': {'momentum': '#636efa', 'carry': '#EF553B', 'value': '#00cc96'}};
    const DEFAULT_X_COL = 'volatility';
    const DEFAULT_Y_COL = 'Sharpe';
    const DEFAULT_COLOR_COL = 'strategy';
    const ORDER_COL = 'year';
    const USE_ALPHARANGE = false;

    // Global state for arrow/line toggle
    window.showArrows_facet_by_region = true;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_facet_by_region = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_by_region');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_by_region');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_facet_by_region');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_facet_by_region');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_facet_by_region');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_facet_by_region' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_facet_by_region');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_by_region');
        const facet2Select = document.getElementById('facet2_select_facet_by_region');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'facet_by_region',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 6,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_facet_by_region) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 2,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 2
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 2
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Strategy Performance by Region (Faceted)',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('facet_by_region', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Strategy Performance by Region (Faceted)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 6,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_facet_by_region) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 2,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 2
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 2
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_by_region', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Strategy Performance by Region (Faceted)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 6,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_facet_by_region) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 2,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 2
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 2
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_by_region', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('facet_by_region_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_facet_by_region = !window.showArrows_facet_by_region;
            arrowToggleBtn.textContent = window.showArrows_facet_by_region ? 'Show Lines' : 'Show Arrows';
            window.updateChart_facet_by_region();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('regional_data').then(function(data) {
        allData = data;
        window.updateChart_facet_by_region();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('facet_by_region');
    }).catch(function(error) {
        console.error('Error loading data for chart facet_by_region:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['development_cost', 'features_completed', 'bug_count'];
    const Y_COLS = ['user_satisfaction', 'features_completed', 'development_cost'];
    const COLOR_COLS = ['product'];
    const COLOR_MAPS = {'product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product B': '#EF553B'}};
    const DEFAULT_X_COL = 'development_cost';
    const DEFAULT_Y_COL = 'user_satisfaction';
    const DEFAULT_COLOR_COL = 'product';
    const ORDER_COL = 'quarter';
    const USE_ALPHARANGE = true;

    // Global state for arrow/line toggle
    window.showArrows_product_development = true;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_product_development = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_product_development');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_product_development');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_product_development');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_product_development');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_product_development');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_product_development' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_product_development');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_product_development');
        const facet2Select = document.getElementById('facet2_select_product_development');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'product_development',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 10,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_product_development) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 3,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 3
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 3
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Product Development Lifecycle (12 Quarters)',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('product_development', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Product Development Lifecycle (12 Quarters)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 10,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_product_development) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 3,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 3
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 3
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('product_development', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Product Development Lifecycle (12 Quarters)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 10,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_product_development) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 3,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 3
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 3
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('product_development', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('product_development_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_product_development = !window.showArrows_product_development;
            arrowToggleBtn.textContent = window.showArrows_product_development ? 'Show Lines' : 'Show Arrows';
            window.updateChart_product_development();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('product_data').then(function(data) {
        allData = data;
        window.updateChart_product_development();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('product_development');
    }).catch(function(error) {
        console.error('Error loading data for chart product_development:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['portfolio_risk', 'diversification', 'transaction_cost'];
    const Y_COLS = ['portfolio_return', 'portfolio_risk', 'diversification'];
    const COLOR_COLS = ['stage'];
    const COLOR_MAPS = {'stage': {'Initial': '#636efa', 'Refinement': '#EF553B', 'Final': '#00cc96'}};
    const DEFAULT_X_COL = 'portfolio_risk';
    const DEFAULT_Y_COL = 'portfolio_return';
    const DEFAULT_COLOR_COL = 'stage';
    const ORDER_COL = 'iteration';
    const USE_ALPHARANGE = true;

    // Global state for arrow/line toggle
    window.showArrows_optimization_path = false;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_optimization_path = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_optimization_path');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_optimization_path');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_optimization_path');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_optimization_path');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_optimization_path');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_optimization_path' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_optimization_path');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_optimization_path');
        const facet2Select = document.getElementById('facet2_select_optimization_path');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'optimization_path',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 7,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_optimization_path) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 2,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 2
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 2
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Portfolio Optimization Journey (30 Iterations)',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('optimization_path', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Portfolio Optimization Journey (30 Iterations)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 7,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_optimization_path) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 2,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 2
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 2
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('optimization_path', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Portfolio Optimization Journey (30 Iterations)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 7,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_optimization_path) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 2,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 2
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 2
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('optimization_path', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('optimization_path_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_optimization_path = !window.showArrows_optimization_path;
            arrowToggleBtn.textContent = window.showArrows_optimization_path ? 'Show Lines' : 'Show Arrows';
            window.updateChart_optimization_path();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('optimization_data').then(function(data) {
        allData = data;
        window.updateChart_optimization_path();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('optimization_path');
    }).catch(function(error) {
        console.error('Error loading data for chart optimization_path:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['customer_acquisition_cost', 'churn_rate', 'monthly_revenue'];
    const Y_COLS = ['customer_lifetime_value', 'monthly_revenue', 'customer_acquisition_cost'];
    const COLOR_COLS = ['company'];
    const COLOR_MAPS = {'company': {'Company': '#636efa'}};
    const DEFAULT_X_COL = 'customer_acquisition_cost';
    const DEFAULT_Y_COL = 'customer_lifetime_value';
    const DEFAULT_COLOR_COL = 'company';
    const ORDER_COL = 'date';
    const USE_ALPHARANGE = true;

    // Global state for arrow/line toggle
    window.showArrows_business_metrics = true;

    let allData = [];

    // Helper function to generate alpha values for path progression
    function getAlphaValues(length) {
        if (!USE_ALPHARANGE || length === 0) return undefined;
        if (length === 1) return [1.0];
        const alphaValues = [];
        for (let i = 0; i < length; i++) {
            // Linear interpolation from 0.3 to 1.0
            const alpha = 0.3 + (0.7 * i / (length - 1));
            alphaValues.push(alpha);
        }
        return alphaValues;
    }

    // Helper function to convert hex color to rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Make it global so inline onchange can see it
    window.updateChart_business_metrics = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_business_metrics');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_business_metrics');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_business_metrics');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_business_metrics');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_business_metrics');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_business_metrics' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_business_metrics');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_business_metrics');
        const facet2Select = document.getElementById('facet2_select_business_metrics');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'business_metrics',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            const annotations = [];

            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];

                // Sort by order column
                group.data.sort((a, b) => {
                    const aVal = a[ORDER_COL];
                    const bVal = b[ORDER_COL];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return aVal - bVal;
                    }
                    return String(aVal).localeCompare(String(bVal));
                });

                let xValues = group.data.map(row => row[X_COL]);
                let yValues = group.data.map(row => row[Y_COL]);
                const orderValues = group.data.map(row => row[ORDER_COL]);

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                const baseColor = COLOR_MAP[group.color] || '#000000';
                const markerOpacity = getAlphaValues(xValues.length);

                const markerConfig = {
                    size: 8,
                    color: baseColor
                };
                if (markerOpacity !== undefined) {
                    markerConfig.opacity = markerOpacity;
                }

                // Add markers trace
                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'markers',
                    name: group.color,
                    marker: markerConfig,
                    text: orderValues.map(v => ORDER_COL + ': ' + v),
                    hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>',
                    showlegend: true
                });

                // Add connections between points (arrows or lines)
                if (xValues.length > 1) {
                    if (window.showArrows_business_metrics) {
                        // Add arrow segments connecting points (each segment is an arrow)
                        for (let i = 0; i < xValues.length - 1; i++) {
                            const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                            const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                            annotations.push({
                                x: xValues[i + 1],
                                y: yValues[i + 1],
                                ax: xValues[i],
                                ay: yValues[i],
                                xref: 'x',
                                yref: 'y',
                                axref: 'x',
                                ayref: 'y',
                                showarrow: true,
                                arrowhead: 2,
                                arrowsize: 1.5,
                                arrowwidth: 2,
                                arrowcolor: arrowColor,
                                opacity: alpha
                            });
                        }
                    } else {
                        // Add line trace connecting points
                        if (USE_ALPHARANGE) {
                            // Create individual line segments with varying opacity
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                const lineColor = hexToRgba(baseColor, alpha);

                                traces.push({
                                    x: [xValues[i], xValues[i + 1]],
                                    y: [yValues[i], yValues[i + 1]],
                                    type: 'scatter',
                                    mode: 'lines',
                                    line: {
                                        color: lineColor,
                                        width: 2
                                    },
                                    showlegend: false,
                                    hoverinfo: 'skip'
                                });
                            }
                        } else {
                            // Simple continuous line
                            traces.push({
                                x: xValues,
                                y: yValues,
                                type: 'scatter',
                                mode: 'lines',
                                name: group.color + ' (path)',
                                line: {
                                    color: baseColor,
                                    width: 2
                                },
                                showlegend: false,
                                hoverinfo: 'skip'
                            });
                        }
                    }
                }
            }

            const layout = {
                title: 'Business Metrics Evolution (24 Months)',
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true,
                annotations: annotations
            };

            Plotly.newPlot('business_metrics', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                title: 'Business Metrics Evolution (24 Months)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];

                    // Sort by order column
                    group.data.sort((a, b) => {
                        const aVal = a[ORDER_COL];
                        const bVal = b[ORDER_COL];
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return aVal - bVal;
                        }
                        return String(aVal).localeCompare(String(bVal));
                    });

                    let xValues = group.data.map(row => row[X_COL]);
                    let yValues = group.data.map(row => row[Y_COL]);
                    const orderValues = group.data.map(row => row[ORDER_COL]);

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    const baseColor = COLOR_MAP[group.color] || '#000000';
                    const markerOpacity = getAlphaValues(xValues.length);

                    const markerConfig = {
                        size: 8,
                        color: baseColor
                    };
                    if (markerOpacity !== undefined) {
                        markerConfig.opacity = markerOpacity;
                    }

                    // Add markers trace
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        marker: markerConfig,
                        text: orderValues.map(v => ORDER_COL + ': ' + v),
                        hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                    });

                    // Add connections between points (arrows or lines)
                    if (xValues.length > 1) {
                        if (window.showArrows_business_metrics) {
                            // Add arrow segments connecting points (each segment is an arrow)
                            for (let i = 0; i < xValues.length - 1; i++) {
                                const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                layout.annotations.push({
                                    x: xValues[i + 1],
                                    y: yValues[i + 1],
                                    ax: xValues[i],
                                    ay: yValues[i],
                                    xref: xaxis === 'x' ? 'x' : xaxis,
                                    yref: yaxis === 'y' ? 'y' : yaxis,
                                    axref: xaxis === 'x' ? 'x' : xaxis,
                                    ayref: yaxis === 'y' ? 'y' : yaxis,
                                    showarrow: true,
                                    arrowhead: 2,
                                    arrowsize: 1.5,
                                    arrowwidth: 2,
                                    arrowcolor: arrowColor,
                                    opacity: alpha
                                });
                            }
                        } else {
                            // Add line trace connecting points
                            if (USE_ALPHARANGE) {
                                // Create individual line segments with varying opacity
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                    const lineColor = hexToRgba(baseColor, alpha);

                                    traces.push({
                                        x: [xValues[i], xValues[i + 1]],
                                        y: [yValues[i], yValues[i + 1]],
                                        type: 'scatter',
                                        mode: 'lines',
                                        line: {
                                            color: lineColor,
                                            width: 2
                                        },
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        hoverinfo: 'skip'
                                    });
                                }
                            } else {
                                // Simple continuous line
                                traces.push({
                                    x: xValues,
                                    y: yValues,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: group.color + ' (path)',
                                    legendgroup: legendGroup,
                                    showlegend: false,
                                    xaxis: xaxis,
                                    yaxis: yaxis,
                                    line: {
                                        color: baseColor,
                                        width: 2
                                    },
                                    hoverinfo: 'skip'
                                });
                            }
                        }
                    }
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('business_metrics', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                title: 'Business Metrics Evolution (24 Months)',
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                annotations: []
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];

                        // Sort by order column
                        group.data.sort((a, b) => {
                            const aVal = a[ORDER_COL];
                            const bVal = b[ORDER_COL];
                            if (typeof aVal === 'number' && typeof bVal === 'number') {
                                return aVal - bVal;
                            }
                            return String(aVal).localeCompare(String(bVal));
                        });

                        let xValues = group.data.map(row => row[X_COL]);
                        let yValues = group.data.map(row => row[Y_COL]);
                        const orderValues = group.data.map(row => row[ORDER_COL]);

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        const baseColor = COLOR_MAP[group.color] || '#000000';
                        const markerOpacity = getAlphaValues(xValues.length);

                        const markerConfig = {
                            size: 8,
                            color: baseColor
                        };
                        if (markerOpacity !== undefined) {
                            markerConfig.opacity = markerOpacity;
                        }

                        // Add markers trace
                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            marker: markerConfig,
                            text: orderValues.map(v => ORDER_COL + ': ' + v),
                            hovertemplate: '%{text}<br>' + X_COL + ': %{x}<br>' + Y_COL + ': %{y}<extra></extra>'
                        });

                        // Add connections between points (arrows or lines)
                        if (xValues.length > 1) {
                            if (window.showArrows_business_metrics) {
                                // Add arrow segments connecting points (each segment is an arrow)
                                for (let i = 0; i < xValues.length - 1; i++) {
                                    const alpha = USE_ALPHARANGE ? 0.3 + (0.7 * i / (xValues.length - 1)) : 1.0;
                                    const arrowColor = USE_ALPHARANGE ? hexToRgba(baseColor, alpha) : baseColor;

                                    layout.annotations.push({
                                        x: xValues[i + 1],
                                        y: yValues[i + 1],
                                        ax: xValues[i],
                                        ay: yValues[i],
                                        xref: xaxis === 'x' ? 'x' : xaxis,
                                        yref: yaxis === 'y' ? 'y' : yaxis,
                                        axref: xaxis === 'x' ? 'x' : xaxis,
                                        ayref: yaxis === 'y' ? 'y' : yaxis,
                                        showarrow: true,
                                        arrowhead: 2,
                                        arrowsize: 1.5,
                                        arrowwidth: 2,
                                        arrowcolor: arrowColor,
                                        opacity: alpha
                                    });
                                }
                            } else {
                                // Add line trace connecting points
                                if (USE_ALPHARANGE) {
                                    // Create individual line segments with varying opacity
                                    for (let i = 0; i < xValues.length - 1; i++) {
                                        const alpha = 0.3 + (0.7 * i / (xValues.length - 1));
                                        const lineColor = hexToRgba(baseColor, alpha);

                                        traces.push({
                                            x: [xValues[i], xValues[i + 1]],
                                            y: [yValues[i], yValues[i + 1]],
                                            type: 'scatter',
                                            mode: 'lines',
                                            line: {
                                                color: lineColor,
                                                width: 2
                                            },
                                            legendgroup: legendGroup,
                                            showlegend: false,
                                            xaxis: xaxis,
                                            yaxis: yaxis,
                                            hoverinfo: 'skip'
                                        });
                                    }
                                } else {
                                    // Simple continuous line
                                    traces.push({
                                        x: xValues,
                                        y: yValues,
                                        type: 'scatter',
                                        mode: 'lines',
                                        name: group.color + ' (path)',
                                        legendgroup: legendGroup,
                                        showlegend: false,
                                        xaxis: xaxis,
                                        yaxis: yaxis,
                                        line: {
                                            color: baseColor,
                                            width: 2
                                        },
                                        hoverinfo: 'skip'
                                    });
                                }
                            }
                        }
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('business_metrics', traces, layout, {responsive: true});
        }
    };

    // Arrow/line toggle button handler
    const arrowToggleBtn = document.getElementById('business_metrics_arrow_toggle');
    if (arrowToggleBtn) {
        arrowToggleBtn.addEventListener('click', function() {
            window.showArrows_business_metrics = !window.showArrows_business_metrics;
            arrowToggleBtn.textContent = window.showArrows_business_metrics ? 'Show Lines' : 'Show Arrows';
            window.updateChart_business_metrics();
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('business_data').then(function(data) {
        allData = data;
        window.updateChart_business_metrics();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('business_metrics');
    }).catch(function(error) {
        console.error('Error loading data for chart business_metrics:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="strategy_data" data-format="csv_embedded" data-src="">
strategy,year,Sharpe,volatility,max_drawdown,returns
momentum,2015,0.44482043372464286,0.10939919569522001,0.1503587646711654,5.640958487179665
momentum,2016,0.6703927687193942,0.11866321037982888,0.1645960593733665,18.86724643930465
momentum,2017,0.7520360974064548,0.11960333739749077,0.15520099893282777,15.403539800388637
momentum,2018,1.061018238012566,0.15553754471891276,0.16088188882999405,13.393170021655003
momentum,2019,0.7855005044401682,0.13168190816758557,0.08995592855072394,8.797118916861043
momentum,2020,0.6812943420942653,0.12219112749481364,0.15816388301925177,7.827672537763925
momentum,2021,0.9303970013201631,0.1142274718208922,0.1045170210110675,13.664706349546927
momentum,2022,0.8041640906084356,0.09326561269587046,0.10227765700384572,16.056180046960705
momentum,2023,1.1078354728515627,0.0936933298619026,0.08358589195664957,17.723074882339063
momentum,2024,0.9703596885422907,0.1562033698989932,0.09942070100097516,18.77559780608714
carry,2015,0.7325055040106203,0.14563795523145712,0.08345686796582033,13.981639166919098
carry,2016,0.7513024187695542,0.1295627861671473,0.11296640883890849,11.7988864076459
carry,2017,0.7064096566357249,0.146885538528486,0.153056332625201,10.309386300146105
carry,2018,0.4811758807456837,0.13629370842257021,0.167870878240106,13.274530365574734
carry,2019,0.6495149649999935,0.13682840276153876,0.10156305703958365,11.081569511602327
carry,2020,0.7350301486566871,0.10769501354606818,0.08850399622264805,7.357636772198727
carry,2021,0.4711762161029738,0.12768568206282357,0.09970286371715494,6.44802002929551
carry,2022,0.6355419280764969,0.09024570423403497,0.11385538665274708,18.898067527655357
carry,2023,0.8534902457953044,0.09076394257542408,0.16651689741316378,13.962883004367484
carry,2024,0.7682969917450275,0.0827713622584454,0.05039591924199338,14.065127650588517
value,2015,0.5721066248960451,0.08710750670611611,0.09056356000297039,9.360358467825886
value,2016,0.41279731735656416,0.14776585857556596,0.17209279668416833,5.902703761774763
value,2017,0.6770974914341524,0.13438528122394583,0.1584419688207742,16.06396968532298
value,2018,0.8019158977734189,0.1576700389362053,0.1696843697279019,15.2494756708578
value,2019,0.7984977645288863,0.14842728867099964,0.09326920459287849,11.468495041487296
value,2020,0.8360645362450422,0.13107463363354468,0.11568812425380123,16.635928360874424
value,2021,0.663784879294677,0.1396138417421735,0.18356902949318066,7.0961990185267805
value,2022,0.9499806016741549,0.14852124496418334,0.17205462359675822,16.655945711427933
value,2023,1.0188641073178897,0.09217553559204232,0.07266960368243937,9.863035252320943
value,2024,1.1146469389004352,0.08739299094872424,0.09939270458087962,5.0845967035936965

</script><script type="text/plain" id="regional_data" data-format="csv_embedded" data-src="">
strategy,region,year,Sharpe,volatility,drawdown,winrate
momentum,US,2015,0.7377685071170699,0.12633323193733278,0.05978842878111511,0.5901412497097819
momentum,US,2016,0.5777844886946407,0.08448667940464612,0.14811835827019132,0.6007680569429155
momentum,US,2017,0.901012364632392,0.13213682055734277,0.13340515942822498,0.5779343449932156
momentum,US,2018,0.6147121399425178,0.1105514086202318,0.095305329150105,0.6586399832821148
momentum,US,2019,0.7749593666504893,0.1366029703845668,0.1489313229037608,0.6031184805438091
momentum,US,2020,0.9278654705256293,0.10622699898132026,0.06854496950877045,0.6635386319835875
momentum,US,2021,0.5080598128554994,0.08380697046110423,0.13303264981244595,0.663931732347607
momentum,US,2022,0.5707244654386132,0.09005817280447913,0.16204373340433725,0.5987613702969705
momentum,US,2023,1.0391099868710554,0.1048801792223684,0.14496642919856073,0.6530236768741688
momentum,US,2024,0.9820357456101706,0.12174831125119635,0.13498860267156676,0.5146809793353122
momentum,Europe,2015,0.9722318773728229,0.09369282281026997,0.14042314164663572,0.681725912591004
momentum,Europe,2016,0.8591422176192482,0.1333080322226649,0.12910101285685094,0.6272679558136838
momentum,Europe,2017,0.5459374883803924,0.0976996192253348,0.07360937264718673,0.5482964275422864
momentum,Europe,2018,0.5064803766451214,0.11825476241622362,0.11292709270517984,0.5780821267341484
momentum,Europe,2019,0.4897768398337096,0.08494222679194964,0.13411742722435094,0.6297337727371233
momentum,Europe,2020,0.5307510444881973,0.1047043078955473,0.05082663002966796,0.6083670618517524
momentum,Europe,2021,0.7681178376267481,0.11425343773666938,0.07947318393535054,0.5993474546490504
momentum,Europe,2022,0.5679850816919909,0.12365327395200229,0.10229318112983887,0.6822131391019638
momentum,Europe,2023,1.0313670799126746,0.08530214343088739,0.06997786636032947,0.6298792618683035
momentum,Europe,2024,0.5241382820506455,0.14086767178448129,0.09880069175158059,0.5496965841143054
momentum,Asia,2015,0.7164631808366668,0.112083275853639,0.10224796124729507,0.5079227796242137
momentum,Asia,2016,0.5361080363434676,0.15202785749892928,0.10276634766750298,0.6879810749355714
momentum,Asia,2017,0.6008422194893575,0.14984977880810427,0.12004287058640502,0.660288020199013
momentum,Asia,2018,0.9547514448330456,0.0861641933200062,0.09652447523466168,0.6013727545119714
momentum,Asia,2019,0.6503628092522454,0.11429260590717778,0.11031930401483457,0.5242483781966158
momentum,Asia,2020,0.7997843176837351,0.13108469498725858,0.06818462523089343,0.6948933250471869
momentum,Asia,2021,0.6257124583270166,0.13114609631494822,0.1557005811378641,0.6671432443969258
momentum,Asia,2022,0.5617390371594915,0.09663530013339287,0.0833210945135398,0.6184242617982895
momentum,Asia,2023,0.8096431799362839,0.12050514633393802,0.06960848772120334,0.5373197316084116
momentum,Asia,2024,0.5675708929821146,0.1435906448729384,0.06574808975675145,0.6604442407340696
carry,US,2015,0.5179978789289135,0.0928445684159203,0.1463168152050382,0.538297396174814
carry,US,2016,0.931521559421273,0.11848356195258868,0.06347459040664984,0.5041050148798271
carry,US,2017,0.4861883184457904,0.14010564925223296,0.10502415880980892,0.6384462177272042
carry,US,2018,0.9008691006006343,0.08197834848108514,0.08004597590545323,0.6042357709200661
carry,US,2019,0.9904966439756583,0.113904817960082,0.10867845763062894,0.6780088287057955
carry,US,2020,0.7776357530268847,0.10733608802002699,0.0722673757202334,0.597525912801592
carry,US,2021,1.0575087896719073,0.11657425781337612,0.14150559844808774,0.5905383576847794
carry,US,2022,0.6549625158061527,0.13799671457448434,0.11124958309060327,0.5384954594915331
carry,US,2023,0.5873107716413932,0.12437037344272076,0.12608750001809949,0.602674508092147
carry,US,2024,1.0489046064744358,0.1391540664737631,0.07566422182047865,0.5010330146029367
carry,Europe,2015,0.509856510290176,0.11378241880598239,0.11387057794411148,0.5818858585707763
carry,Europe,2016,0.7855441150490594,0.14750606195419266,0.12895876284367516,0.6659907351683352
carry,Europe,2017,0.7972850500336099,0.12262238063928976,0.1459709131592501,0.5690276038301685
carry,Europe,2018,0.7187450359412235,0.1256946126722297,0.1629122889759914,0.601997453867742
carry,Europe,2019,0.9691917155702535,0.1066872163425264,0.09497296954216305,0.5716402260243584
carry,Europe,2020,0.6749361511338778,0.08253363007069205,0.1332943707921596,0.6373753398415221
carry,Europe,2021,1.0197732914859299,0.08361962743043966,0.14175957277827228,0.6266042499005842
carry,Europe,2022,0.5308240025353721,0.08802090701876511,0.1396603514550944,0.6603201683161973
carry,Europe,2023,1.0231607615273055,0.09629389432790818,0.12752405529429178,0.6860275304811295
carry,Europe,2024,0.628490833486148,0.09779192263618577,0.1384306167078783,0.6778654221344415
carry,Asia,2015,0.5962887682885497,0.1550623846487721,0.12489033651368601,0.5775876613168913
carry,Asia,2016,0.9969890544045859,0.08444674029850949,0.13120143180815674,0.569758998687775
carry,Asia,2017,0.8254946729603911,0.10717128605405186,0.14185878941841784,0.5588652047065107
carry,Asia,2018,0.616125127001755,0.10897412316395615,0.05672722413643941,0.675389219942518
carry,Asia,2019,1.0262594269253205,0.1255500579505115,0.0980932311839224,0.6100849386249116
carry,Asia,2020,0.6812678398699278,0.12493398393424696,0.06847239613718192,0.5308328661287288
carry,Asia,2021,0.8369346955395207,0.09217626794504298,0.05311775151557229,0.5731119026253069
carry,Asia,2022,0.8036492011819916,0.08891537401105616,0.05015685270513052,0.6470104791190932
carry,Asia,2023,0.8325336719743271,0.11113618264723304,0.11260993181963933,0.6772757718854813
carry,Asia,2024,0.7075849962604851,0.09250636996825136,0.11205524670492266,0.52887450618136
value,US,2015,0.8535298844596928,0.0989625552702458,0.06839128578879702,0.5291586755178372
value,US,2016,0.5299651931694165,0.11622318451778556,0.0862264958435742,0.5074508431009492
value,US,2017,0.9168146320822617,0.11521727460870185,0.06113141724062466,0.5375379909965587
value,US,2018,0.8037241590146257,0.13542676133205075,0.07493556146464311,0.6617302394718209
value,US,2019,0.45363501490155816,0.12983527037209674,0.07816618325526302,0.6708806617422822
value,US,2020,0.56243974490963,0.10991735838031791,0.11713490922347909,0.5372103078121786
value,US,2021,0.701416621577627,0.09969856804308141,0.13849942720323277,0.615814582813195
value,US,2022,0.5302328780381316,0.0944959932653774,0.09729702751206057,0.6705664275498084
value,US,2023,0.957970202219037,0.15998244501406728,0.10894919772484718,0.6978183747093137
value,US,2024,0.7512235323823485,0.1421046383733163,0.13120376117213084,0.5846769983885645
value,Europe,2015,0.7610929829113997,0.14746973956055426,0.15949666764272286,0.6348435367880362
value,Europe,2016,0.8022382791035263,0.08991202637792607,0.1460703682456702,0.562738990498834
value,Europe,2017,0.819410461423439,0.11074163136260888,0.12882139759489064,0.6119366682469634
value,Europe,2018,0.9853154057489901,0.09656211916985069,0.1380504989586107,0.6490198706238555
value,Europe,2019,0.5041027975112977,0.10655382880204065,0.1494001455816844,0.5277301397377655
value,Europe,2020,0.7087996708929523,0.08318424691351985,0.05088337696099642,0.5782174762898686
value,Europe,2021,1.0129740148394282,0.1472753116580988,0.11091837835947875,0.5974810585226675
value,Europe,2022,1.0528873823901401,0.0912639457221944,0.08236967788487207,0.6809172954837495
value,Europe,2023,0.9703240607585449,0.09685309417536207,0.0759021357997087,0.6086233482813359
value,Europe,2024,0.8558691375508948,0.15993468773025063,0.13539418020696897,0.5520981940119138
value,Asia,2015,0.5356069972711318,0.13103031025277592,0.11474255046333094,0.5308654874388719
value,Asia,2016,0.5670358311723934,0.11430450957473616,0.12944963522282643,0.6067708860075115
value,Asia,2017,0.9599631284019028,0.12677136817353257,0.15523599093294663,0.6263439013639985
value,Asia,2018,0.6005359051725471,0.0964272531804703,0.09214828115808602,0.5947509806521831
value,Asia,2019,1.0192333263874178,0.1450823174933989,0.16392356166373956,0.5924859057755165
value,Asia,2020,0.5927710284471923,0.12276089419313829,0.16986256560397667,0.5722762340601378
value,Asia,2021,0.6490644796022382,0.09266500550258705,0.054851157431244545,0.5303564409682446
value,Asia,2022,0.8754047488412242,0.09516474820569597,0.08726296535372878,0.50726959919056
value,Asia,2023,0.9549519007730531,0.13163054686473352,0.05280636119658744,0.6731015552352309
value,Asia,2024,0.5473533643555275,0.14856434443301142,0.15756311315971755,0.6058530514718842

</script><script type="text/plain" id="asset_data" data-format="csv_embedded" data-src="">
asset_class,year,volatility,returns,Sharpe
Equity,2016,0.18101930088898008,0.13261271406611114,1.1625891609596097
Equity,2017,0.15341055884244667,0.13692616199131646,0.6030931726436497
Equity,2018,0.15802640132057338,0.1575939555202664,0.5911968265339306
Equity,2019,0.12062403484567358,0.13558757219164883,0.7791197235990102
Equity,2020,0.19786547277515668,0.15307870751482316,0.6968615554511796
Equity,2021,0.1528604388423939,0.13700157556242032,1.1415702204400704
Equity,2022,0.1689087601671888,0.06768056112224993,0.8307467205400948
Equity,2023,0.18099630633558614,0.15465397619808513,1.3350938101889884
Equity,2024,0.19250117550945756,0.11589842541398415,1.3219668710468107
Bonds,2016,0.06946388957179889,0.04900482488421271,0.5912740227653599
Bonds,2017,0.059570599648121544,0.046017008001190914,1.3096523148298533
Bonds,2018,0.05931675629809594,0.04472785381902811,0.5422926430131915
Bonds,2019,0.05155026647239899,0.029274896355304898,0.8075362558430723
Bonds,2020,0.07619844957380496,0.025856737635413837,1.2428457472623828
Bonds,2021,0.05297475971354996,0.049598849737765086,1.0238054683423705
Bonds,2022,0.04796517788615232,0.02637084038728365,1.074055529979995
Bonds,2023,0.07603614174796086,0.04933312095065763,1.3456638551027318
Bonds,2024,0.06300848554131616,0.03533543963806434,0.9811029217784527
Commodities,2016,0.22510190773156086,0.12978927702427456,0.8364214113957609
Commodities,2017,0.15412442893853232,0.13597167753226763,0.8874122977215957
Commodities,2018,0.17194009983416653,0.12855482774714028,0.7989411687004251
Commodities,2019,0.15788372930997688,0.10645659908739462,0.5737515548052767
Commodities,2020,0.16183889026903991,0.13247955618533358,1.27449692453522
Commodities,2021,0.16546364758746518,0.07911581032584002,0.6499928074817177
Commodities,2022,0.17702153501919893,0.04986293064529518,0.982759099412839
Commodities,2023,0.15914070255322685,0.04477479232479341,0.9989167797994921
Commodities,2024,0.23112521352801926,0.03206271060240436,0.9718573319560108

</script><script type="text/plain" id="product_data" data-format="csv_embedded" data-src="">
product,quarter,development_cost,features_completed,user_satisfaction,bug_count
Product A,1,124.90245465174576,3.7271324159608685,71.55286181885042,63.40001291213859
Product A,2,150.72179347768457,7.288272096168161,67.48500140022563,46.718535511337734
Product A,3,167.561160842033,12.549468096998368,76.51848341099816,50.24857908186884
Product A,4,191.97204689156308,14.234623897886731,74.79030453195901,55.12338756219031
Product A,5,224.26897941297864,19.034917258341565,75.08209964912643,52.62291520755665
Product A,6,248.0424150651218,22.873720496678814,84.69525784413092,35.34648184652154
Product A,7,240.7436011821439,25.777067028158537,82.33648470381767,48.354838529619734
Product A,8,262.85235012254947,25.707296566540887,92.93299686453472,45.16545502735594
Product A,9,300.07463636048317,31.290091310029098,92.32159965392871,35.42737392659802
Product A,10,340.0314139381621,32.28197508502284,93.8086890678157,30.069295890234727
Product A,11,345.36263676250445,34.61611267361506,96.08985750802579,18.505723659202932
Product A,12,387.6159113344608,40.777360920599726,102.34802851532817,24.579195277458307
Product B,1,133.10916899588574,7.51019386046911,71.26331632598603,54.15971714631091
Product B,2,146.63837586284984,7.188994155342194,69.25102304336026,55.42862129756346
Product B,3,180.35093503404454,13.170110913790978,78.0127739652718,44.52081763046632
Product B,4,184.67566620749022,15.943295979807626,80.35246049181573,43.93299262340273
Product B,5,203.4730516716931,17.77073816174002,76.22496002304356,47.89893400887061
Product B,6,234.1947921266463,22.771118759750223,82.86516982673338,47.53821952182014
Product B,7,275.9589472178139,24.10478909180827,81.95047498382867,29.05835080127975
Product B,8,261.6365721314294,24.475984946588813,84.7619246665785,26.42057022112413
Product B,9,301.67220875306384,30.323291793679502,87.66715118180736,38.25363127249435
Product B,10,302.58972552706217,32.42085705855573,91.9454633860923,38.43858669962399
Product B,11,320.58093028505584,37.50575558812398,99.33291131887714,30.366384922848905
Product B,12,355.98229463034323,37.31002196599597,100.55836626983816,21.725375614609135
Product C,1,121.61687171913053,5.182358592067917,66.91229728326111,63.48448192869635
Product C,2,176.2440030807611,9.416310708421008,69.66718896012347,50.80772044067984
Product C,3,206.5248415029693,9.587386008549808,77.40096971077989,55.67973669914487
Product C,4,208.02643341324293,14.211753813207888,76.62568746256213,57.78028412768637
Product C,5,218.73540899553447,19.8913393808448,81.83058188903641,38.34199781590736
Product C,6,227.51707630678303,19.65450812994677,85.28511803748599,46.82273088985791
Product C,7,244.7982815601745,23.772438884085787,83.86592882034033,39.96416851949958
Product C,8,305.19955666067216,27.083916751623747,85.96968382829151,45.450166583986025
Product C,9,329.4533178332762,28.334070409218683,88.99720839082055,26.404919988529933
Product C,10,325.12174855547465,32.05404527379932,91.47379764875012,25.258610581275626
Product C,11,333.2553545967444,36.77884660077861,93.41647296736652,25.443635977832997
Product C,12,345.73781747570365,39.02203690121489,96.74726383342161,30.355337430821407

</script><script type="text/plain" id="business_data" data-format="csv_embedded" data-src="">
date,customer_acquisition_cost,customer_lifetime_value,churn_rate,monthly_revenue,company
2023-01-01,50.41791706164911,335.5651265523867,0.10408139881487434,112.75253473438224,Company
2023-02-01,59.054184636476,309.45884804378375,0.11708647751841003,116.21152746258561,Company
2023-03-01,59.764913566835304,325.1773535578032,0.10885408786694163,133.8965737525047,Company
2023-04-01,64.00021920731163,321.2779572581164,0.10529831791800606,133.46196530833078,Company
2023-05-01,59.95491767255584,343.2285944306076,0.10170057589416459,148.13318052176436,Company
2023-06-01,60.98080152690799,336.05080623437766,0.09116256650417788,140.56181017498287,Company
2023-07-01,71.60441350932118,370.50730661793307,0.08915547169049648,148.16541325887118,Company
2023-08-01,71.38121834672044,375.2391114077788,0.09808873947824803,157.23339333147956,Company
2023-09-01,66.42886312958373,387.0900266897244,0.10188488878247455,169.01838176780205,Company
2023-10-01,77.61579987320235,356.8837631243217,0.08724831973315104,188.47830170268207,Company
2023-11-01,75.73678370350562,377.0577815121173,0.09662851559738372,194.4178963310889,Company
2023-12-01,75.28340326419891,395.19924431482934,0.08788868195987574,189.57307111764595,Company
2024-01-01,77.7536250637457,371.83510960188437,0.08217550331665253,215.13412998916857,Company
2024-02-01,85.64644330841456,397.03093151912327,0.07585924065992507,223.1687016331961,Company
2024-03-01,83.34356848660478,411.40951261687763,0.0766151354547656,229.65155393162016,Company
2024-04-01,88.119124192909,404.88275975133774,0.07600088623897594,231.28826317677783,Company
2024-05-01,88.14218554102798,421.89719902074455,0.0877301810319387,236.37758196292282,Company
2024-06-01,91.70094139397021,411.6389750571261,0.07242986936534128,252.36754035709575,Company
2024-07-01,91.49142846610593,438.7509538429349,0.06955687426900596,251.64435682043882,Company
2024-08-01,97.29055060347417,398.49048369814267,0.07966459240433921,261.1937841110238,Company
2024-09-01,90.78527213943129,411.8138947522327,0.07745564877611438,264.7025241101564,Company
2024-10-01,95.03656865006512,406.5666574454208,0.07724781619751526,278.74454162783286,Company
2024-11-01,97.10815131465152,423.1639432677414,0.06548080162351436,285.2125323861279,Company
2024-12-01,104.6544863254237,438.6982751647452,0.07031429998393397,302.8886353641653,Company

</script><script type="text/plain" id="optimization_data" data-format="csv_embedded" data-src="">
iteration,portfolio_risk,portfolio_return,diversification,transaction_cost,stage
1,0.20007554587681017,0.09141451909655106,0.35405862337209887,0.0147782344500886,Initial
2,0.1995708547319676,0.09073262343649026,0.3582090607559229,0.011602445164265876,Initial
3,0.2094141112284973,0.09129349571758999,0.37149843762499474,0.01108104983136947,Initial
4,0.20548043744179362,0.08939139173385886,0.3672150861343058,0.013007537556970207,Initial
5,0.19681530168156985,0.09247745979652808,0.42779235932007775,0.014021337602295045,Initial
6,0.19284149669962836,0.09196294060024424,0.4066388734567355,0.014872771621877886,Initial
7,0.17872755638363547,0.09750600771455492,0.4169463625887397,0.011677402969485402,Initial
8,0.19167897332812656,0.09873214120741404,0.46562939258620356,0.011501024018288453,Initial
9,0.1736278371194162,0.09837432758562951,0.48819652380707795,0.01010127362233272,Initial
10,0.18540130780799874,0.09963624714797517,0.48611606394471807,0.012472264220730568,Initial
11,0.1745751300783368,0.09945503147744907,0.5297861106058744,0.010357962973726424,Refinement
12,0.16996353725443197,0.10564345788426326,0.5353511605349333,0.012859843343688584,Refinement
13,0.16355231130299794,0.10698597148613258,0.562660638413628,0.010785594843783827,Refinement
14,0.1590262772625423,0.10622607046806477,0.5649754235579927,0.011943165913132651,Refinement
15,0.16821335606393745,0.1127959884387401,0.5513958612638945,0.014558018584365747,Refinement
16,0.1532333243252947,0.10783738560293114,0.589420586463063,0.014490260957839882,Refinement
17,0.1507406161091755,0.11295966668417486,0.6124388516593297,0.013808929999689948,Refinement
18,0.1560691399038401,0.11505130806455377,0.6041019017404122,0.012338920062348258,Refinement
19,0.15390119920407844,0.11216025821742164,0.6486680439733734,0.010461599219770001,Refinement
20,0.14744141517106,0.11378289075241375,0.6409663250808989,0.010679307181617576,Refinement
21,0.14793210833636064,0.12135554846328629,0.6695561373058009,0.014548484978922697,Final
22,0.1350785392007118,0.1228061431209245,0.6724388170526653,0.011395554417537349,Final
23,0.1320503428958664,0.1269103259933946,0.6835514473018267,0.01002623722041769,Final
24,0.1230533298478979,0.121200451596943,0.7466568005724957,0.012145207977475557,Final
25,0.13384049404976395,0.1225493674597209,0.7173053105992735,0.010967747236832293,Final
26,0.13262749168307264,0.12732146513500686,0.7638376310088499,0.013051916341838991,Final
27,0.11272813003219623,0.12901103189297808,0.7946247728077575,0.012678848659739474,Final
28,0.12298496347093042,0.12836918958085203,0.7698118260766382,0.014363042719939097,Final
29,0.11857162980048472,0.1327191645394868,0.7919343112574735,0.013754413827615664,Final
30,0.11057732306813725,0.13865202106075722,0.8268661441691814,0.011331958397222765,Final

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/path_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>Path Chart Examples</h1>
<p>This page demonstrates the key features of Path charts in JSPlots.</p>
<ul>
    <li><strong>Trajectory visualization:</strong> Show evolution of metrics over time or sequence</li>
    <li><strong>Direction indicators:</strong> Arrows or alpha gradients indicating path direction</li>
    <li><strong>Multiple paths:</strong> Compare different entities with color grouping</li>
    <li><strong>Interactive dimensions:</strong> Swap x and y axes dynamically from the HTML</li>
    <li><strong>Faceting:</strong> Facet wrap (1 variable) and facet grid (2 variables)</li>
    <li><strong>Order control:</strong> Connect points according to any ordering column</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Trading Strategy Evolution (2015-2024) - With Arrows</h2>
<p>Arrows show the direction of evolution over time. Swap dimensions using dropdowns.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_strategy_evolution_arrows">X: </label>
        <select id="x_col_select_strategy_evolution_arrows" style="padding: 5px 10px;" onchange="updateChart_strategy_evolution_arrows()">
            <option value="volatility" selected>volatility</option>
<option value="Sharpe">Sharpe</option>
<option value="returns">returns</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_strategy_evolution_arrows">X Transform: </label>
        <select id="x_transform_select_strategy_evolution_arrows" style="padding: 5px 10px;" onchange="updateChart_strategy_evolution_arrows()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_strategy_evolution_arrows">Y: </label>
        <select id="y_col_select_strategy_evolution_arrows" style="padding: 5px 10px;" onchange="updateChart_strategy_evolution_arrows()">
            <option value="Sharpe" selected>Sharpe</option>
<option value="returns">returns</option>
<option value="max_drawdown">max_drawdown</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_strategy_evolution_arrows">Y Transform: </label>
        <select id="y_transform_select_strategy_evolution_arrows" style="padding: 5px 10px;" onchange="updateChart_strategy_evolution_arrows()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="strategy_evolution_arrows_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="strategy_evolution_arrows_aspect_ratio_label">0.4</span>
    <input type="range" id="strategy_evolution_arrows_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="strategy_evolution_arrows"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: strategy_data</p><br>
<hr>
<br>
<h2>Trading Strategy Evolution (2015-2024) - With Alpha Gradient</h2>
<p>Transparency gradient from 0.3 (early years) to 1.0 (recent years) shows direction without arrows.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_strategy_evolution_alpha">X: </label>
        <select id="x_col_select_strategy_evolution_alpha" style="padding: 5px 10px;" onchange="updateChart_strategy_evolution_alpha()">
            <option value="volatility" selected>volatility</option>
<option value="Sharpe">Sharpe</option>
<option value="returns">returns</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_strategy_evolution_alpha">X Transform: </label>
        <select id="x_transform_select_strategy_evolution_alpha" style="padding: 5px 10px;" onchange="updateChart_strategy_evolution_alpha()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_strategy_evolution_alpha">Y: </label>
        <select id="y_col_select_strategy_evolution_alpha" style="padding: 5px 10px;" onchange="updateChart_strategy_evolution_alpha()">
            <option value="Sharpe" selected>Sharpe</option>
<option value="returns">returns</option>
<option value="max_drawdown">max_drawdown</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_strategy_evolution_alpha">Y Transform: </label>
        <select id="y_transform_select_strategy_evolution_alpha" style="padding: 5px 10px;" onchange="updateChart_strategy_evolution_alpha()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="strategy_evolution_alpha_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="strategy_evolution_alpha_aspect_ratio_label">0.4</span>
    <input type="range" id="strategy_evolution_alpha_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="strategy_evolution_alpha"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: strategy_data</p><br>
<hr>
<br>
<h2>Regional Strategy Analysis (2015-2024)</h2>
<p>Default shows 3 strategies in US region. Use filters to explore other regions. Alpha gradient shows time progression.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="regional_paths_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="region_select_regional_paths">region: </label>
                <select id="region_select_regional_paths" multiple onchange="updateChart_regional_paths()">
                <option value="Asia">Asia</option>
                <option value="Europe">Europe</option>
                <option value="US" selected>US</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="region_select_regional_paths_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_regional_paths">Path grouping: </label>
                <select id="color_col_select_regional_paths" onchange="updateChart_regional_paths()">
                <option value="strategy" selected>strategy</option>
                <option value="region">region</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_regional_paths_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_regional_paths">X: </label>
        <select id="x_col_select_regional_paths" style="padding: 5px 10px;" onchange="updateChart_regional_paths()">
            <option value="volatility" selected>volatility</option>
<option value="Sharpe">Sharpe</option>
<option value="winrate">winrate</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_regional_paths">X Transform: </label>
        <select id="x_transform_select_regional_paths" style="padding: 5px 10px;" onchange="updateChart_regional_paths()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_regional_paths">Y: </label>
        <select id="y_col_select_regional_paths" style="padding: 5px 10px;" onchange="updateChart_regional_paths()">
            <option value="Sharpe" selected>Sharpe</option>
<option value="drawdown">drawdown</option>
<option value="winrate">winrate</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_regional_paths">Y Transform: </label>
        <select id="y_transform_select_regional_paths" style="padding: 5px 10px;" onchange="updateChart_regional_paths()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="regional_paths_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="regional_paths_aspect_ratio_label">0.4</span>
    <input type="range" id="regional_paths_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="regional_paths"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: regional_data</p><br>
<hr>
<br>
<h2>Asset Class Risk-Return Evolution (2016-2024)</h2>
<p>Three major asset classes. Notice how bonds have lower volatility but also lower returns. Alpha gradient shows recent years are bolder.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_asset_performance">X: </label>
        <select id="x_col_select_asset_performance" style="padding: 5px 10px;" onchange="updateChart_asset_performance()">
            <option value="volatility" selected>volatility</option>
<option value="Sharpe">Sharpe</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_asset_performance">X Transform: </label>
        <select id="x_transform_select_asset_performance" style="padding: 5px 10px;" onchange="updateChart_asset_performance()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_asset_performance">Y: </label>
        <select id="y_col_select_asset_performance" style="padding: 5px 10px;" onchange="updateChart_asset_performance()">
            <option value="returns" selected>returns</option>
<option value="Sharpe">Sharpe</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_asset_performance">Y Transform: </label>
        <select id="y_transform_select_asset_performance" style="padding: 5px 10px;" onchange="updateChart_asset_performance()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="asset_performance_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="asset_performance_aspect_ratio_label">0.4</span>
    <input type="range" id="asset_performance_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="asset_performance"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: asset_data</p><br>
<hr>
<br>
<h2>Strategy Performance by Region (Faceted)</h2>
<p>Each panel shows one region with 3 strategies. Faceting allows clear comparison across regions. Arrows show direction.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_facet_by_region">X: </label>
        <select id="x_col_select_facet_by_region" style="padding: 5px 10px;" onchange="updateChart_facet_by_region()">
            <option value="volatility" selected>volatility</option>
<option value="Sharpe">Sharpe</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_facet_by_region">X Transform: </label>
        <select id="x_transform_select_facet_by_region" style="padding: 5px 10px;" onchange="updateChart_facet_by_region()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_facet_by_region">Y: </label>
        <select id="y_col_select_facet_by_region" style="padding: 5px 10px;" onchange="updateChart_facet_by_region()">
            <option value="Sharpe" selected>Sharpe</option>
<option value="drawdown">drawdown</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_facet_by_region">Y Transform: </label>
        <select id="y_transform_select_facet_by_region" style="padding: 5px 10px;" onchange="updateChart_facet_by_region()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="facet1_select_facet_by_region">Facet 1: </label>
        <select id="facet1_select_facet_by_region" style="padding: 5px 10px;" onchange="updateChart_facet_by_region()">
            <option value="None">None</option>
<option value="region" selected>region</option>
<option value="strategy">strategy</option>
        </select>
    </div>
    <div>
        <label for="facet2_select_facet_by_region">Facet 2: </label>
        <select id="facet2_select_facet_by_region" style="padding: 5px 10px;" onchange="updateChart_facet_by_region()">
            <option value="None" selected>None</option>
<option value="region">region</option>
<option value="strategy">strategy</option>
        </select>
    </div>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="facet_by_region_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="facet_by_region_aspect_ratio_label">0.4</span>
    <input type="range" id="facet_by_region_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="facet_by_region"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: regional_data</p><br>
<hr>
<br>
<h2>Product Development Lifecycle (12 Quarters)</h2>
<p>Track how products evolved. Combining arrows AND alpha gradient for maximum clarity.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_product_development">X: </label>
        <select id="x_col_select_product_development" style="padding: 5px 10px;" onchange="updateChart_product_development()">
            <option value="development_cost" selected>development_cost</option>
<option value="features_completed">features_completed</option>
<option value="bug_count">bug_count</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_product_development">X Transform: </label>
        <select id="x_transform_select_product_development" style="padding: 5px 10px;" onchange="updateChart_product_development()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_product_development">Y: </label>
        <select id="y_col_select_product_development" style="padding: 5px 10px;" onchange="updateChart_product_development()">
            <option value="user_satisfaction" selected>user_satisfaction</option>
<option value="features_completed">features_completed</option>
<option value="development_cost">development_cost</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_product_development">Y Transform: </label>
        <select id="y_transform_select_product_development" style="padding: 5px 10px;" onchange="updateChart_product_development()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="product_development_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="product_development_aspect_ratio_label">0.4</span>
    <input type="range" id="product_development_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="product_development"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: product_data</p><br>
<hr>
<br>
<h2>Portfolio Optimization Journey (30 Iterations)</h2>
<p>30 iterations of optimization. Alpha gradient shows progression from initial (faint) to final (bold).</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_optimization_path">X: </label>
        <select id="x_col_select_optimization_path" style="padding: 5px 10px;" onchange="updateChart_optimization_path()">
            <option value="portfolio_risk" selected>portfolio_risk</option>
<option value="diversification">diversification</option>
<option value="transaction_cost">transaction_cost</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_optimization_path">X Transform: </label>
        <select id="x_transform_select_optimization_path" style="padding: 5px 10px;" onchange="updateChart_optimization_path()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_optimization_path">Y: </label>
        <select id="y_col_select_optimization_path" style="padding: 5px 10px;" onchange="updateChart_optimization_path()">
            <option value="portfolio_return" selected>portfolio_return</option>
<option value="portfolio_risk">portfolio_risk</option>
<option value="diversification">diversification</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_optimization_path">Y Transform: </label>
        <select id="y_transform_select_optimization_path" style="padding: 5px 10px;" onchange="updateChart_optimization_path()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="optimization_path_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="optimization_path_aspect_ratio_label">0.4</span>
    <input type="range" id="optimization_path_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="optimization_path"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: optimization_data</p><br>
<hr>
<br>
<h2>Business Metrics Evolution (24 Months)</h2>
<p>Path ordered by date. Both arrows and alpha gradient enabled for clear directional visualization.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="x_col_select_business_metrics">X: </label>
        <select id="x_col_select_business_metrics" style="padding: 5px 10px;" onchange="updateChart_business_metrics()">
            <option value="customer_acquisition_cost" selected>customer_acquisition_cost</option>
<option value="churn_rate">churn_rate</option>
<option value="monthly_revenue">monthly_revenue</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_business_metrics">X Transform: </label>
        <select id="x_transform_select_business_metrics" style="padding: 5px 10px;" onchange="updateChart_business_metrics()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_business_metrics">Y: </label>
        <select id="y_col_select_business_metrics" style="padding: 5px 10px;" onchange="updateChart_business_metrics()">
            <option value="customer_lifetime_value" selected>customer_lifetime_value</option>
<option value="monthly_revenue">monthly_revenue</option>
<option value="customer_acquisition_cost">customer_acquisition_cost</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_business_metrics">Y Transform: </label>
        <select id="y_transform_select_business_metrics" style="padding: 5px 10px;" onchange="updateChart_business_metrics()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="business_metrics_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="business_metrics_aspect_ratio_label">0.4</span>
    <input type="range" id="business_metrics_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="business_metrics"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: business_data</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.4.2.</small></p>
</body>
</html>
