<!DOCTYPE html>
<html>
<head>
    <title>LineChart Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>
    <style>
        .picture-container {
            padding: 20px;
            margin: 10px 0;
            text-align: center;
        }

        .picture-container h2 {
            font-size: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .picture-container img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .picture-container svg {
            max-width: 100%;
            height: auto;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

    <!-- libgif.js for GIF frame control -->
    <script src="https://unpkg.com/libgif-js@0.0.3/libgif.js"></script>
</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                resolve(results.data);
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                resolve(data);
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        resolve(results.data);
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Date'];
    const Y_COLS = ['Revenue'];
    const COLOR_COLS = ['color'];
    const COLOR_MAPS = {'color': {'Revenue': '#636efa'}};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_COLOR_COL = 'color';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_revenue_trend = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_revenue_trend');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_revenue_trend');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_revenue_trend');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_revenue_trend');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_revenue_trend');
        const facet2Select = document.getElementById('facet2_select_revenue_trend');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        // Convert to string for consistent grouping
                        const xKey = String(xVal);
                        if (!xGroups[xKey]) xGroups[xKey] = [];
                        xGroups[xKey].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];

                    // Helper function to check if a string looks like a date
                    function looksLikeDate(str) {
                        // Check for common date formats: YYYY-MM-DD, ISO datetime, etc.
                        return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                               /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                               /^\d{2}\/\d{2}\/\d{4}/.test(str);
                    }

                    // Check if first key looks like a date to determine handling
                    const firstKey = Object.keys(xGroups)[0];
                    const isDateData = firstKey && looksLikeDate(firstKey);

                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        if (isDateData) {
                            // For dates, use string comparison (ISO format sorts correctly)
                            return String(a).localeCompare(String(b));
                        }
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xKey => {
                        const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // For dates, keep as string; for numbers, parse
                            if (isDateData) {
                                xValues.push(xKey);
                            } else {
                                const numVal = parseFloat(xKey);
                                xValues.push(isNaN(numVal) ? xKey : numVal);
                            }
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('revenue_trend', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            const xKey = String(xVal);
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];

                        // Helper function to check if a string looks like a date
                        function looksLikeDate(str) {
                            return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                   /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                   /^\d{2}\/\d{2}\/\d{4}/.test(str);
                        }

                        const firstKey = Object.keys(xGroups)[0];
                        const isDateData = firstKey && looksLikeDate(firstKey);

                        // Sort keys
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            if (isDateData) {
                                return String(a).localeCompare(String(b));
                            }
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xKey => {
                            const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                if (isDateData) {
                                    xValues.push(xKey);
                                } else {
                                    const numVal = parseFloat(xKey);
                                    xValues.push(isNaN(numVal) ? xKey : numVal);
                                }
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('revenue_trend', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                const xKey = String(xVal);
                                if (!xGroups[xKey]) xGroups[xKey] = [];
                                xGroups[xKey].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];

                            // Helper function to check if a string looks like a date
                            function looksLikeDate(str) {
                                return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                       /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                       /^\d{2}\/\d{2}\/\d{4}/.test(str);
                            }

                            const firstKey = Object.keys(xGroups)[0];
                            const isDateData = firstKey && looksLikeDate(firstKey);

                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                if (isDateData) {
                                    return String(a).localeCompare(String(b));
                                }
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xKey => {
                                const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    if (isDateData) {
                                        xValues.push(xKey);
                                    } else {
                                        const numVal = parseFloat(xKey);
                                        xValues.push(isNaN(numVal) ? xKey : numVal);
                                    }
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('revenue_trend', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('revenue_data').then(function(data) {
        allData = data;
        window.updateChart_revenue_trend();
    }).catch(function(error) {
        console.error('Error loading data for chart revenue_trend:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['Year'];
    const COLOR_MAPS = {'Year': {'2022': '#636efa', '2023': '#EF553B', '2024': '#00cc96'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'Year';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_multi_series = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_multi_series');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_multi_series');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_multi_series');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_multi_series');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_multi_series');
        const facet2Select = document.getElementById('facet2_select_multi_series');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        // Convert to string for consistent grouping
                        const xKey = String(xVal);
                        if (!xGroups[xKey]) xGroups[xKey] = [];
                        xGroups[xKey].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];

                    // Helper function to check if a string looks like a date
                    function looksLikeDate(str) {
                        // Check for common date formats: YYYY-MM-DD, ISO datetime, etc.
                        return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                               /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                               /^\d{2}\/\d{2}\/\d{4}/.test(str);
                    }

                    // Check if first key looks like a date to determine handling
                    const firstKey = Object.keys(xGroups)[0];
                    const isDateData = firstKey && looksLikeDate(firstKey);

                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        if (isDateData) {
                            // For dates, use string comparison (ISO format sorts correctly)
                            return String(a).localeCompare(String(b));
                        }
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xKey => {
                        const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // For dates, keep as string; for numbers, parse
                            if (isDateData) {
                                xValues.push(xKey);
                            } else {
                                const numVal = parseFloat(xKey);
                                xValues.push(isNaN(numVal) ? xKey : numVal);
                            }
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('multi_series', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            const xKey = String(xVal);
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];

                        // Helper function to check if a string looks like a date
                        function looksLikeDate(str) {
                            return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                   /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                   /^\d{2}\/\d{2}\/\d{4}/.test(str);
                        }

                        const firstKey = Object.keys(xGroups)[0];
                        const isDateData = firstKey && looksLikeDate(firstKey);

                        // Sort keys
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            if (isDateData) {
                                return String(a).localeCompare(String(b));
                            }
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xKey => {
                            const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                if (isDateData) {
                                    xValues.push(xKey);
                                } else {
                                    const numVal = parseFloat(xKey);
                                    xValues.push(isNaN(numVal) ? xKey : numVal);
                                }
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('multi_series', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                const xKey = String(xVal);
                                if (!xGroups[xKey]) xGroups[xKey] = [];
                                xGroups[xKey].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];

                            // Helper function to check if a string looks like a date
                            function looksLikeDate(str) {
                                return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                       /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                       /^\d{2}\/\d{2}\/\d{4}/.test(str);
                            }

                            const firstKey = Object.keys(xGroups)[0];
                            const isDateData = firstKey && looksLikeDate(firstKey);

                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                if (isDateData) {
                                    return String(a).localeCompare(String(b));
                                }
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xKey => {
                                const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    if (isDateData) {
                                        xValues.push(xKey);
                                    } else {
                                        const numVal = parseFloat(xKey);
                                        xValues.push(isNaN(numVal) ? xKey : numVal);
                                    }
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('multi_series', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updateChart_multi_series();
    }).catch(function(error) {
        console.error('Error loading data for chart multi_series:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['Department', 'Quarter'];
    const X_COLS = ['Month'];
    const Y_COLS = ['Productivity'];
    const COLOR_COLS = ['Metric'];
    const COLOR_MAPS = {'Metric': {'Productivity': '#636efa'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Productivity';
    const DEFAULT_COLOR_COL = 'Metric';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_filtered_metrics = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_filtered_metrics');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_filtered_metrics');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_filtered_metrics');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_filtered_metrics');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_filtered_metrics');
        const facet2Select = document.getElementById('facet2_select_filtered_metrics');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        // Convert to string for consistent grouping
                        const xKey = String(xVal);
                        if (!xGroups[xKey]) xGroups[xKey] = [];
                        xGroups[xKey].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];

                    // Helper function to check if a string looks like a date
                    function looksLikeDate(str) {
                        // Check for common date formats: YYYY-MM-DD, ISO datetime, etc.
                        return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                               /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                               /^\d{2}\/\d{2}\/\d{4}/.test(str);
                    }

                    // Check if first key looks like a date to determine handling
                    const firstKey = Object.keys(xGroups)[0];
                    const isDateData = firstKey && looksLikeDate(firstKey);

                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        if (isDateData) {
                            // For dates, use string comparison (ISO format sorts correctly)
                            return String(a).localeCompare(String(b));
                        }
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xKey => {
                        const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // For dates, keep as string; for numbers, parse
                            if (isDateData) {
                                xValues.push(xKey);
                            } else {
                                const numVal = parseFloat(xKey);
                                xValues.push(isNaN(numVal) ? xKey : numVal);
                            }
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('filtered_metrics', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            const xKey = String(xVal);
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];

                        // Helper function to check if a string looks like a date
                        function looksLikeDate(str) {
                            return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                   /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                   /^\d{2}\/\d{2}\/\d{4}/.test(str);
                        }

                        const firstKey = Object.keys(xGroups)[0];
                        const isDateData = firstKey && looksLikeDate(firstKey);

                        // Sort keys
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            if (isDateData) {
                                return String(a).localeCompare(String(b));
                            }
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xKey => {
                            const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                if (isDateData) {
                                    xValues.push(xKey);
                                } else {
                                    const numVal = parseFloat(xKey);
                                    xValues.push(isNaN(numVal) ? xKey : numVal);
                                }
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('filtered_metrics', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                const xKey = String(xVal);
                                if (!xGroups[xKey]) xGroups[xKey] = [];
                                xGroups[xKey].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];

                            // Helper function to check if a string looks like a date
                            function looksLikeDate(str) {
                                return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                       /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                       /^\d{2}\/\d{2}\/\d{4}/.test(str);
                            }

                            const firstKey = Object.keys(xGroups)[0];
                            const isDateData = firstKey && looksLikeDate(firstKey);

                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                if (isDateData) {
                                    return String(a).localeCompare(String(b));
                                }
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xKey => {
                                const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    if (isDateData) {
                                        xValues.push(xKey);
                                    } else {
                                        const numVal = parseFloat(xKey);
                                        xValues.push(isNaN(numVal) ? xKey : numVal);
                                    }
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('filtered_metrics', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('metrics').then(function(data) {
        allData = data;
        window.updateChart_filtered_metrics();
    }).catch(function(error) {
        console.error('Error loading data for chart filtered_metrics:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['color', 'Product'];
    const COLOR_MAPS = {'Product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product D': '#ab63fa', 'Product B': '#EF553B'}, 'color': {'East': '#00cc96', 'West': '#ab63fa', 'North': '#636efa', 'South': '#EF553B'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'color';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_facet_wrap_example = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_wrap_example');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_wrap_example');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_facet_wrap_example');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_facet_wrap_example');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_wrap_example');
        const facet2Select = document.getElementById('facet2_select_facet_wrap_example');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        // Convert to string for consistent grouping
                        const xKey = String(xVal);
                        if (!xGroups[xKey]) xGroups[xKey] = [];
                        xGroups[xKey].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];

                    // Helper function to check if a string looks like a date
                    function looksLikeDate(str) {
                        // Check for common date formats: YYYY-MM-DD, ISO datetime, etc.
                        return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                               /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                               /^\d{2}\/\d{2}\/\d{4}/.test(str);
                    }

                    // Check if first key looks like a date to determine handling
                    const firstKey = Object.keys(xGroups)[0];
                    const isDateData = firstKey && looksLikeDate(firstKey);

                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        if (isDateData) {
                            // For dates, use string comparison (ISO format sorts correctly)
                            return String(a).localeCompare(String(b));
                        }
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xKey => {
                        const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // For dates, keep as string; for numbers, parse
                            if (isDateData) {
                                xValues.push(xKey);
                            } else {
                                const numVal = parseFloat(xKey);
                                xValues.push(isNaN(numVal) ? xKey : numVal);
                            }
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('facet_wrap_example', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            const xKey = String(xVal);
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];

                        // Helper function to check if a string looks like a date
                        function looksLikeDate(str) {
                            return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                   /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                   /^\d{2}\/\d{2}\/\d{4}/.test(str);
                        }

                        const firstKey = Object.keys(xGroups)[0];
                        const isDateData = firstKey && looksLikeDate(firstKey);

                        // Sort keys
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            if (isDateData) {
                                return String(a).localeCompare(String(b));
                            }
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xKey => {
                            const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                if (isDateData) {
                                    xValues.push(xKey);
                                } else {
                                    const numVal = parseFloat(xKey);
                                    xValues.push(isNaN(numVal) ? xKey : numVal);
                                }
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_wrap_example', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                const xKey = String(xVal);
                                if (!xGroups[xKey]) xGroups[xKey] = [];
                                xGroups[xKey].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];

                            // Helper function to check if a string looks like a date
                            function looksLikeDate(str) {
                                return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                       /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                       /^\d{2}\/\d{2}\/\d{4}/.test(str);
                            }

                            const firstKey = Object.keys(xGroups)[0];
                            const isDateData = firstKey && looksLikeDate(firstKey);

                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                if (isDateData) {
                                    return String(a).localeCompare(String(b));
                                }
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xKey => {
                                const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    if (isDateData) {
                                        xValues.push(xKey);
                                    } else {
                                        const numVal = parseFloat(xKey);
                                        xValues.push(isNaN(numVal) ? xKey : numVal);
                                    }
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_wrap_example', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('facet_data').then(function(data) {
        allData = data;
        window.updateChart_facet_wrap_example();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_wrap_example:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['color'];
    const COLOR_MAPS = {'color': {'2023': '#636efa', '2024': '#EF553B'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'color';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_facet_grid_example = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_grid_example');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_grid_example');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_facet_grid_example');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_facet_grid_example');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_grid_example');
        const facet2Select = document.getElementById('facet2_select_facet_grid_example');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        // Convert to string for consistent grouping
                        const xKey = String(xVal);
                        if (!xGroups[xKey]) xGroups[xKey] = [];
                        xGroups[xKey].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];

                    // Helper function to check if a string looks like a date
                    function looksLikeDate(str) {
                        // Check for common date formats: YYYY-MM-DD, ISO datetime, etc.
                        return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                               /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                               /^\d{2}\/\d{2}\/\d{4}/.test(str);
                    }

                    // Check if first key looks like a date to determine handling
                    const firstKey = Object.keys(xGroups)[0];
                    const isDateData = firstKey && looksLikeDate(firstKey);

                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        if (isDateData) {
                            // For dates, use string comparison (ISO format sorts correctly)
                            return String(a).localeCompare(String(b));
                        }
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xKey => {
                        const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // For dates, keep as string; for numbers, parse
                            if (isDateData) {
                                xValues.push(xKey);
                            } else {
                                const numVal = parseFloat(xKey);
                                xValues.push(isNaN(numVal) ? xKey : numVal);
                            }
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('facet_grid_example', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            const xKey = String(xVal);
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];

                        // Helper function to check if a string looks like a date
                        function looksLikeDate(str) {
                            return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                   /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                   /^\d{2}\/\d{2}\/\d{4}/.test(str);
                        }

                        const firstKey = Object.keys(xGroups)[0];
                        const isDateData = firstKey && looksLikeDate(firstKey);

                        // Sort keys
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            if (isDateData) {
                                return String(a).localeCompare(String(b));
                            }
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xKey => {
                            const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                if (isDateData) {
                                    xValues.push(xKey);
                                } else {
                                    const numVal = parseFloat(xKey);
                                    xValues.push(isNaN(numVal) ? xKey : numVal);
                                }
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_grid_example', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                const xKey = String(xVal);
                                if (!xGroups[xKey]) xGroups[xKey] = [];
                                xGroups[xKey].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];

                            // Helper function to check if a string looks like a date
                            function looksLikeDate(str) {
                                return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                       /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                       /^\d{2}\/\d{2}\/\d{4}/.test(str);
                            }

                            const firstKey = Object.keys(xGroups)[0];
                            const isDateData = firstKey && looksLikeDate(firstKey);

                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                if (isDateData) {
                                    return String(a).localeCompare(String(b));
                                }
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xKey => {
                                const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    if (isDateData) {
                                        xValues.push(xKey);
                                    } else {
                                        const numVal = parseFloat(xKey);
                                        xValues.push(isNaN(numVal) ? xKey : numVal);
                                    }
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_grid_example', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('facet_grid_data').then(function(data) {
        allData = data;
        window.updateChart_facet_grid_example();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_grid_example:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Return'];
    const COLOR_COLS = ['Stock', 'Strategy', 'Region'];
    const COLOR_MAPS = {'Stock': {'GOOGL': '#EF553B', 'MSFT': '#00cc96', 'AAPL': '#636efa'}, 'Strategy': {'Hold': '#00cc96', 'Sell': '#EF553B', 'Buy': '#636efa'}, 'Region': {'EU': '#EF553B', 'ASIA': '#00cc96', 'US': '#636efa'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Return';
    const DEFAULT_COLOR_COL = 'Stock';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_dynamic_controls = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_dynamic_controls');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_dynamic_controls');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_dynamic_controls');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_dynamic_controls');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_dynamic_controls');
        const facet2Select = document.getElementById('facet2_select_dynamic_controls');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        // Convert to string for consistent grouping
                        const xKey = String(xVal);
                        if (!xGroups[xKey]) xGroups[xKey] = [];
                        xGroups[xKey].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];

                    // Helper function to check if a string looks like a date
                    function looksLikeDate(str) {
                        // Check for common date formats: YYYY-MM-DD, ISO datetime, etc.
                        return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                               /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                               /^\d{2}\/\d{2}\/\d{4}/.test(str);
                    }

                    // Check if first key looks like a date to determine handling
                    const firstKey = Object.keys(xGroups)[0];
                    const isDateData = firstKey && looksLikeDate(firstKey);

                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        if (isDateData) {
                            // For dates, use string comparison (ISO format sorts correctly)
                            return String(a).localeCompare(String(b));
                        }
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xKey => {
                        const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // For dates, keep as string; for numbers, parse
                            if (isDateData) {
                                xValues.push(xKey);
                            } else {
                                const numVal = parseFloat(xKey);
                                xValues.push(isNaN(numVal) ? xKey : numVal);
                            }
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('dynamic_controls', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            const xKey = String(xVal);
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];

                        // Helper function to check if a string looks like a date
                        function looksLikeDate(str) {
                            return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                   /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                   /^\d{2}\/\d{2}\/\d{4}/.test(str);
                        }

                        const firstKey = Object.keys(xGroups)[0];
                        const isDateData = firstKey && looksLikeDate(firstKey);

                        // Sort keys
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            if (isDateData) {
                                return String(a).localeCompare(String(b));
                            }
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xKey => {
                            const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                if (isDateData) {
                                    xValues.push(xKey);
                                } else {
                                    const numVal = parseFloat(xKey);
                                    xValues.push(isNaN(numVal) ? xKey : numVal);
                                }
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('dynamic_controls', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                const xKey = String(xVal);
                                if (!xGroups[xKey]) xGroups[xKey] = [];
                                xGroups[xKey].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];

                            // Helper function to check if a string looks like a date
                            function looksLikeDate(str) {
                                return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                       /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                       /^\d{2}\/\d{2}\/\d{4}/.test(str);
                            }

                            const firstKey = Object.keys(xGroups)[0];
                            const isDateData = firstKey && looksLikeDate(firstKey);

                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                if (isDateData) {
                                    return String(a).localeCompare(String(b));
                                }
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xKey => {
                                const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    if (isDateData) {
                                        xValues.push(xKey);
                                    } else {
                                        const numVal = parseFloat(xKey);
                                        xValues.push(isNaN(numVal) ? xKey : numVal);
                                    }
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('dynamic_controls', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('dynamic_data').then(function(data) {
        allData = data;
        window.updateChart_dynamic_controls();
    }).catch(function(error) {
        console.error('Error loading data for chart dynamic_controls:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['Product'];
    const COLOR_MAPS = {'Product': {'Product A': '#636efa', 'Product B': '#EF553B'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'Product';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_aggregation_demo = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_aggregation_demo');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_aggregation_demo');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_aggregation_demo');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_aggregation_demo');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_aggregation_demo');
        const facet2Select = document.getElementById('facet2_select_aggregation_demo');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        // Convert to string for consistent grouping
                        const xKey = String(xVal);
                        if (!xGroups[xKey]) xGroups[xKey] = [];
                        xGroups[xKey].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];

                    // Helper function to check if a string looks like a date
                    function looksLikeDate(str) {
                        // Check for common date formats: YYYY-MM-DD, ISO datetime, etc.
                        return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                               /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                               /^\d{2}\/\d{2}\/\d{4}/.test(str);
                    }

                    // Check if first key looks like a date to determine handling
                    const firstKey = Object.keys(xGroups)[0];
                    const isDateData = firstKey && looksLikeDate(firstKey);

                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        if (isDateData) {
                            // For dates, use string comparison (ISO format sorts correctly)
                            return String(a).localeCompare(String(b));
                        }
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xKey => {
                        const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // For dates, keep as string; for numbers, parse
                            if (isDateData) {
                                xValues.push(xKey);
                            } else {
                                const numVal = parseFloat(xKey);
                                xValues.push(isNaN(numVal) ? xKey : numVal);
                            }
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('aggregation_demo', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            const xKey = String(xVal);
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];

                        // Helper function to check if a string looks like a date
                        function looksLikeDate(str) {
                            return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                   /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                   /^\d{2}\/\d{2}\/\d{4}/.test(str);
                        }

                        const firstKey = Object.keys(xGroups)[0];
                        const isDateData = firstKey && looksLikeDate(firstKey);

                        // Sort keys
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            if (isDateData) {
                                return String(a).localeCompare(String(b));
                            }
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xKey => {
                            const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                if (isDateData) {
                                    xValues.push(xKey);
                                } else {
                                    const numVal = parseFloat(xKey);
                                    xValues.push(isNaN(numVal) ? xKey : numVal);
                                }
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('aggregation_demo', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                const xKey = String(xVal);
                                if (!xGroups[xKey]) xGroups[xKey] = [];
                                xGroups[xKey].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];

                            // Helper function to check if a string looks like a date
                            function looksLikeDate(str) {
                                return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                       /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                       /^\d{2}\/\d{2}\/\d{4}/.test(str);
                            }

                            const firstKey = Object.keys(xGroups)[0];
                            const isDateData = firstKey && looksLikeDate(firstKey);

                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                if (isDateData) {
                                    return String(a).localeCompare(String(b));
                                }
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xKey => {
                                const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    if (isDateData) {
                                        xValues.push(xKey);
                                    } else {
                                        const numVal = parseFloat(xKey);
                                        xValues.push(isNaN(numVal) ? xKey : numVal);
                                    }
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('aggregation_demo', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('agg_data').then(function(data) {
        allData = data;
        window.updateChart_aggregation_demo();
    }).catch(function(error) {
        console.error('Error loading data for chart aggregation_demo:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['time_hours', 'time_halfhours'];
    const Y_COLS = ['temperature_celsius', 'temperature_fahrenheit', 'humidity_percent', 'pressure_hpa'];
    const COLOR_COLS = ['color'];
    const COLOR_MAPS = {'color': {'default': '#636efa'}};
    const DEFAULT_X_COL = 'time_hours';
    const DEFAULT_Y_COL = 'temperature_celsius';
    const DEFAULT_COLOR_COL = 'color';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_multi_dimensions = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_multi_dimensions');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_multi_dimensions');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_multi_dimensions');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_multi_dimensions');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_multi_dimensions');
        const facet2Select = document.getElementById('facet2_select_multi_dimensions');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        // Convert to string for consistent grouping
                        const xKey = String(xVal);
                        if (!xGroups[xKey]) xGroups[xKey] = [];
                        xGroups[xKey].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];

                    // Helper function to check if a string looks like a date
                    function looksLikeDate(str) {
                        // Check for common date formats: YYYY-MM-DD, ISO datetime, etc.
                        return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                               /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                               /^\d{2}\/\d{2}\/\d{4}/.test(str);
                    }

                    // Check if first key looks like a date to determine handling
                    const firstKey = Object.keys(xGroups)[0];
                    const isDateData = firstKey && looksLikeDate(firstKey);

                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        if (isDateData) {
                            // For dates, use string comparison (ISO format sorts correctly)
                            return String(a).localeCompare(String(b));
                        }
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xKey => {
                        const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // For dates, keep as string; for numbers, parse
                            if (isDateData) {
                                xValues.push(xKey);
                            } else {
                                const numVal = parseFloat(xKey);
                                xValues.push(isNaN(numVal) ? xKey : numVal);
                            }
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('multi_dimensions', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            const xKey = String(xVal);
                            if (!xGroups[xKey]) xGroups[xKey] = [];
                            xGroups[xKey].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];

                        // Helper function to check if a string looks like a date
                        function looksLikeDate(str) {
                            return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                   /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                   /^\d{2}\/\d{2}\/\d{4}/.test(str);
                        }

                        const firstKey = Object.keys(xGroups)[0];
                        const isDateData = firstKey && looksLikeDate(firstKey);

                        // Sort keys
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            if (isDateData) {
                                return String(a).localeCompare(String(b));
                            }
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xKey => {
                            const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                if (isDateData) {
                                    xValues.push(xKey);
                                } else {
                                    const numVal = parseFloat(xKey);
                                    xValues.push(isNaN(numVal) ? xKey : numVal);
                                }
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('multi_dimensions', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                const xKey = String(xVal);
                                if (!xGroups[xKey]) xGroups[xKey] = [];
                                xGroups[xKey].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];

                            // Helper function to check if a string looks like a date
                            function looksLikeDate(str) {
                                return /^\d{4}-\d{2}-\d{2}/.test(str) ||
                                       /^\d{4}-\d{2}-\d{2}T/.test(str) ||
                                       /^\d{2}\/\d{2}\/\d{4}/.test(str);
                            }

                            const firstKey = Object.keys(xGroups)[0];
                            const isDateData = firstKey && looksLikeDate(firstKey);

                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                if (isDateData) {
                                    return String(a).localeCompare(String(b));
                                }
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xKey => {
                                const aggregated = aggregate(xGroups[xKey], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    if (isDateData) {
                                        xValues.push(xKey);
                                    } else {
                                        const numVal = parseFloat(xKey);
                                        xValues.push(isNaN(numVal) ? xKey : numVal);
                                    }
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('multi_dimensions', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('multi_data').then(function(data) {
        allData = data;
        window.updateChart_multi_dimensions();
    }).catch(function(error) {
        console.error('Error loading data for chart multi_dimensions:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="metrics" data-format="csv_embedded" data-src="">
Department,Quarter,Month,Productivity,Metric
Engineering,Q1,Jan,81.15015951422647,Productivity
Engineering,Q1,Feb,72.06440161139109,Productivity
Engineering,Q1,Mar,73.94866946214606,Productivity
Engineering,Q2,Apr,80.68804856981863,Productivity
Engineering,Q2,May,70.35208466746624,Productivity
Engineering,Q2,Jun,76.79519261381363,Productivity
Engineering,Q3,Jul,90.36262804539183,Productivity
Engineering,Q3,Aug,82.66703600120758,Productivity
Engineering,Q3,Sep,89.53824775082644,Productivity
Engineering,Q4,Oct,98.48803321940827,Productivity
Engineering,Q4,Nov,88.6012614185816,Productivity
Engineering,Q4,Dec,71.03480629431213,Productivity
Sales,Q1,Jan,77.6721646539922,Productivity
Sales,Q1,Feb,82.375837486151,Productivity
Sales,Q1,Mar,84.94144822346524,Productivity
Sales,Q2,Apr,95.19805204496987,Productivity
Sales,Q2,May,78.15387940253643,Productivity
Sales,Q2,Jun,83.26092032262822,Productivity
Sales,Q3,Jul,72.20574096933078,Productivity
Sales,Q3,Aug,98.53151907427915,Productivity
Sales,Q3,Sep,76.03823630062688,Productivity
Sales,Q4,Oct,74.91863747622888,Productivity
Sales,Q4,Nov,75.26504327100051,Productivity
Sales,Q4,Dec,90.76603834943938,Productivity
Marketing,Q1,Jan,90.2550555887226,Productivity
Marketing,Q1,Feb,94.78972567759112,Productivity
Marketing,Q1,Mar,89.35599573874492,Productivity
Marketing,Q2,Apr,79.95093579508499,Productivity
Marketing,Q2,May,74.21382750618032,Productivity
Marketing,Q2,Jun,88.37106923992917,Productivity
Marketing,Q3,Jul,71.57944310227796,Productivity
Marketing,Q3,Aug,70.65036724271832,Productivity
Marketing,Q3,Sep,72.39125856361235,Productivity
Marketing,Q4,Oct,76.45657377582312,Productivity
Marketing,Q4,Nov,93.04107176449553,Productivity
Marketing,Q4,Dec,71.23950463448377,Productivity
Operations,Q1,Jan,93.8067502840445,Productivity
Operations,Q1,Feb,96.67160747502341,Productivity
Operations,Q1,Mar,93.78749345413111,Productivity
Operations,Q2,Apr,77.71473612435409,Productivity
Operations,Q2,May,95.82268280678437,Productivity
Operations,Q2,Jun,81.49073345785973,Productivity
Operations,Q3,Jul,92.38036225134428,Productivity
Operations,Q3,Aug,82.41148713507962,Productivity
Operations,Q3,Sep,70.04428033915781,Productivity
Operations,Q4,Oct,71.82636139527746,Productivity
Operations,Q4,Nov,99.48116209867324,Productivity
Operations,Q4,Dec,96.94130156671466,Productivity

</script><script type="text/plain" id="revenue_data" data-format="csv_embedded" data-src="">
Date,Revenue,color
2024-01-01,50106.07409714178,Revenue
2024-01-02,98738.3876219232,Revenue
2024-01-03,149251.36343648838,Revenue
2024-01-04,199579.52094878757,Revenue
2024-01-05,250254.68785915623,Revenue
2024-01-06,300287.66918396874,Revenue
2024-01-07,350084.7376010176,Revenue
2024-01-08,401308.4851374823,Revenue
2024-01-09,448871.1737496773,Revenue
2024-01-10,498943.7452005574,Revenue
2024-01-11,548619.9400127963,Revenue
2024-01-12,597725.2858644207,Revenue
2024-01-13,648171.9001978489,Revenue
2024-01-14,698027.5039940801,Revenue
2024-01-15,748904.1026650455,Revenue
2024-01-16,798146.6880547409,Revenue
2024-01-17,850303.3402493482,Revenue
2024-01-18,901498.1069840179,Revenue
2024-01-19,951074.0326461018,Revenue
2024-01-20,1.0009268726437924e6,Revenue
2024-01-21,1.049258009036991e6,Revenue
2024-01-22,1.099682075851669e6,Revenue
2024-01-23,1.1517412174655425e6,Revenue
2024-01-24,1.2023072864558706e6,Revenue
2024-01-25,1.2525542361173525e6,Revenue
2024-01-26,1.3020220191119828e6,Revenue
2024-01-27,1.353187586151804e6,Revenue
2024-01-28,1.4030561636866087e6,Revenue
2024-01-29,1.4528585419068874e6,Revenue
2024-01-30,1.5047018382097944e6,Revenue
2024-01-31,1.5545931808982904e6,Revenue
2024-02-01,1.60379757264691e6,Revenue
2024-02-02,1.6532676177473445e6,Revenue
2024-02-03,1.7042078236244419e6,Revenue
2024-02-04,1.7557010724517535e6,Revenue
2024-02-05,1.8047084926113184e6,Revenue
2024-02-06,1.8560589036237604e6,Revenue
2024-02-07,1.9036703896593845e6,Revenue
2024-02-08,1.9530848530238064e6,Revenue
2024-02-09,2.003684767045065e6,Revenue
2024-02-10,2.052907287278041e6,Revenue
2024-02-11,2.1024520350713255e6,Revenue
2024-02-12,2.1545228050210266e6,Revenue
2024-02-13,2.2039904959156057e6,Revenue
2024-02-14,2.254482508685056e6,Revenue
2024-02-15,2.304988025557981e6,Revenue
2024-02-16,2.356353477744001e6,Revenue
2024-02-17,2.408548860426451e6,Revenue
2024-02-18,2.457974857938316e6,Revenue
2024-02-19,2.507130368504117e6,Revenue
2024-02-20,2.5601876921384847e6,Revenue
2024-02-21,2.6112231758243144e6,Revenue
2024-02-22,2.6616781911413446e6,Revenue
2024-02-23,2.7108516144195283e6,Revenue
2024-02-24,2.7601299129314926e6,Revenue
2024-02-25,2.809904356019943e6,Revenue
2024-02-26,2.8602686873363773e6,Revenue
2024-02-27,2.910299457179463e6,Revenue
2024-02-28,2.9603081802003365e6,Revenue
2024-02-29,3.0091761328190966e6,Revenue
2024-03-01,3.060036923763358e6,Revenue
2024-03-02,3.1099945638143313e6,Revenue
2024-03-03,3.1601080957859894e6,Revenue
2024-03-04,3.2087351972845765e6,Revenue
2024-03-05,3.258317288555919e6,Revenue
2024-03-06,3.307724092079262e6,Revenue
2024-03-07,3.3573715014530504e6,Revenue
2024-03-08,3.4078278882530127e6,Revenue
2024-03-09,3.457553124383756e6,Revenue
2024-03-10,3.5080225893486855e6,Revenue
2024-03-11,3.558584044705804e6,Revenue
2024-03-12,3.61015850948127e6,Revenue
2024-03-13,3.659955234209106e6,Revenue
2024-03-14,3.7125256320499126e6,Revenue
2024-03-15,3.7643847485242165e6,Revenue
2024-03-16,3.814166795742444e6,Revenue
2024-03-17,3.863492452774938e6,Revenue
2024-03-18,3.913188264410836e6,Revenue
2024-03-19,3.9605961418639934e6,Revenue
2024-03-20,4.0106099920711378e6,Revenue
2024-03-21,4.059236171613703e6,Revenue
2024-03-22,4.1087286696721846e6,Revenue
2024-03-23,4.158044732504266e6,Revenue
2024-03-24,4.209368979118943e6,Revenue
2024-03-25,4.258253884248836e6,Revenue
2024-03-26,4.308167158264061e6,Revenue
2024-03-27,4.35698479587641e6,Revenue
2024-03-28,4.408289617854437e6,Revenue
2024-03-29,4.461645842700757e6,Revenue
2024-03-30,4.513202205234524e6,Revenue
2024-03-31,4.563388631790946e6,Revenue
2024-04-01,4.612389652069148e6,Revenue
2024-04-02,4.665561046854467e6,Revenue
2024-04-03,4.715666250320447e6,Revenue
2024-04-04,4.7669488958464125e6,Revenue
2024-04-05,4.815654244194313e6,Revenue
2024-04-06,4.864836042973813e6,Revenue
2024-04-07,4.914209761690169e6,Revenue
2024-04-08,4.963516007109523e6,Revenue
2024-04-09,5.013060399098367e6,Revenue
2024-04-10,5.063192409239583e6,Revenue
2024-04-11,5.112448985081738e6,Revenue
2024-04-12,5.162536116580985e6,Revenue
2024-04-13,5.2118943895080425e6,Revenue
2024-04-14,5.26245665152036e6,Revenue
2024-04-15,5.313178667659867e6,Revenue
2024-04-16,5.362412276960632e6,Revenue
2024-04-17,5.413614660146007e6,Revenue
2024-04-18,5.46367088920191e6,Revenue
2024-04-19,5.512644024507612e6,Revenue
2024-04-20,5.563572238633154e6,Revenue
2024-04-21,5.6133425378349945e6,Revenue
2024-04-22,5.664089980096205e6,Revenue
2024-04-23,5.713050611274166e6,Revenue
2024-04-24,5.7627930794407595e6,Revenue
2024-04-25,5.812140047873549e6,Revenue
2024-04-26,5.863243898634743e6,Revenue
2024-04-27,5.911799421322245e6,Revenue
2024-04-28,5.961988009849178e6,Revenue
2024-04-29,6.011246586509014e6,Revenue
2024-04-30,6.061359276113679e6,Revenue
2024-05-01,6.111875764148457e6,Revenue
2024-05-02,6.162263019414672e6,Revenue
2024-05-03,6.210845688359279e6,Revenue
2024-05-04,6.259385909877e6,Revenue
2024-05-05,6.3091822663344685e6,Revenue
2024-05-06,6.360058695398869e6,Revenue
2024-05-07,6.409148160816906e6,Revenue
2024-05-08,6.457241995033685e6,Revenue
2024-05-09,6.50642110764095e6,Revenue
2024-05-10,6.556843192540955e6,Revenue
2024-05-11,6.607567826844377e6,Revenue
2024-05-12,6.658263846363135e6,Revenue
2024-05-13,6.709022234836625e6,Revenue
2024-05-14,6.760136521934718e6,Revenue
2024-05-15,6.809096771831026e6,Revenue
2024-05-16,6.859415847165924e6,Revenue
2024-05-17,6.909566384243818e6,Revenue
2024-05-18,6.9588338473374965e6,Revenue
2024-05-19,7.008415161634687e6,Revenue
2024-05-20,7.057212269595256e6,Revenue
2024-05-21,7.106992106839209e6,Revenue
2024-05-22,7.157809462739593e6,Revenue
2024-05-23,7.208377390702128e6,Revenue
2024-05-24,7.258679401689086e6,Revenue
2024-05-25,7.309791501161383e6,Revenue
2024-05-26,7.359458656391775e6,Revenue
2024-05-27,7.410080206799403e6,Revenue
2024-05-28,7.4592269343226645e6,Revenue
2024-05-29,7.50929190172085e6,Revenue
2024-05-30,7.558642724522786e6,Revenue
2024-05-31,7.607954740037404e6,Revenue
2024-06-01,7.658151243886611e6,Revenue
2024-06-02,7.708197310025824e6,Revenue
2024-06-03,7.758276322807017e6,Revenue
2024-06-04,7.808777802573653e6,Revenue
2024-06-05,7.860110606039362e6,Revenue
2024-06-06,7.910797857694078e6,Revenue
2024-06-07,7.961528430932136e6,Revenue
2024-06-08,8.010867313242206e6,Revenue
2024-06-09,8.059479662175169e6,Revenue
2024-06-10,8.109726521260852e6,Revenue
2024-06-11,8.159567556780469e6,Revenue
2024-06-12,8.209921350993421e6,Revenue
2024-06-13,8.258423003619059e6,Revenue
2024-06-14,8.30836748708942e6,Revenue
2024-06-15,8.358424186466312e6,Revenue
2024-06-16,8.408147898007534e6,Revenue
2024-06-17,8.458240090367455e6,Revenue
2024-06-18,8.509892089558411e6,Revenue
2024-06-19,8.561522901053134e6,Revenue
2024-06-20,8.611463092242062e6,Revenue
2024-06-21,8.66183891499682e6,Revenue
2024-06-22,8.712743932301385e6,Revenue
2024-06-23,8.762478716409367e6,Revenue
2024-06-24,8.812310911509354e6,Revenue
2024-06-25,8.862936148160823e6,Revenue
2024-06-26,8.913436107866019e6,Revenue
2024-06-27,8.962421416533988e6,Revenue
2024-06-28,9.011736095968649e6,Revenue
2024-06-29,9.062307353596196e6,Revenue
2024-06-30,9.110505881917203e6,Revenue

</script><script type="text/plain" id="sales_data" data-format="csv_embedded" data-src="">
Month,Sales,Year
Jan,120,2022
Feb,135,2022
Mar,150,2022
Apr,145,2022
May,160,2022
Jun,175,2022
Jul,190,2022
Aug,185,2022
Sep,200,2022
Oct,210,2022
Nov,230,2022
Dec,250,2022
Jan,130,2023
Feb,145,2023
Mar,165,2023
Apr,160,2023
May,180,2023
Jun,195,2023
Jul,210,2023
Aug,205,2023
Sep,220,2023
Oct,235,2023
Nov,255,2023
Dec,280,2023
Jan,145,2024
Feb,165,2024
Mar,185,2024
Apr,180,2024
May,200,2024
Jun,220,2024
Jul,240,2024
Aug,235,2024
Sep,250,2024
Oct,270,2024
Nov,290,2024
Dec,320,2024

</script><script type="text/plain" id="multi_data" data-format="csv_embedded" data-src="">
time_hours,time_halfhours,temperature_celsius,temperature_fahrenheit,humidity_percent,pressure_hpa,location,color
1,0.5,16.558892846228947,64.58603890895469,73.840864161764,1019.1450900253976,Station A,default
2,1.0,19.49529629860298,67.06937254648267,76.48766450941027,1018.3072609266364,Station A,default
3,1.5,20.46204524378271,68.45450092281114,79.2055443909148,1017.4480943667136,Station A,default
4,2.0,22.29492600228109,71.0535387731496,82.20415618624261,1019.5200681124115,Station A,default
5,2.5,21.658676403399873,70.46469318647421,71.35488899555824,1018.210014552157,Station A,default
6,3.0,20.48890072333171,70.97580099900925,61.70563456393611,1019.3063511175638,Station A,default
7,3.5,21.477345383603108,76.56638873626997,58.72195935708122,1017.7890145290701,Station A,default
8,4.0,23.128773059126598,75.2370332288558,48.591086363514904,1014.006351197778,Station A,default
9,4.5,19.83622311084175,65.31321922066526,52.65812236166809,1012.503923131249,Station A,default
10,5.0,19.509223385802667,65.5090806354326,42.81715541022529,1009.8901754193785,Station A,default
11,5.5,17.340964906702034,64.49425124099959,38.69752882724008,1008.870904057656,Station A,default
12,6.0,15.382478655141279,60.62258581255959,36.09983385366953,1008.315661935027,Station A,default
13,6.5,11.656993306724413,56.257950039458684,33.536188840513674,1008.0032784662285,Station A,default
14,7.0,11.703633001875513,51.91762758904792,47.44808453476969,1011.3747325752372,Station A,default
15,7.5,9.028678420161187,49.323434406929444,38.36017921226897,1011.8219538205924,Station A,default
16,8.0,8.442625183756157,47.75891794097288,45.79618897731477,1011.7458120182562,Station A,default
17,8.5,7.5361370495227895,45.099921567207595,53.193027315460725,1007.195033792864,Station A,default
18,9.0,6.590239552461511,44.34739759161643,61.31822151052557,1010.876039523652,Station A,default
19,9.5,7.884216281859065,46.72090559433098,64.08773769650593,1008.6142557263622,Station A,default
20,10.0,6.739870153369305,47.84794511746164,74.18612030793807,1008.9728096163285,Station A,default
21,10.5,10.938284883269674,48.66519823286515,69.22656949278523,1012.8804902415752,Station A,default
22,11.0,8.621287861014066,53.68058372422509,78.10870535816079,1013.5868215587337,Station A,default
23,11.5,13.522515172264777,57.07613057089968,84.78433958519103,1013.4290199691039,Station A,default
24,12.0,15.702267807407914,58.72272602889959,79.47311105710342,1018.4189232626481,Station A,default

</script><script type="text/plain" id="dynamic_data" data-format="csv_embedded" data-src="">
Month,Return,Stock,Strategy,Region
1,1.5948683141792794,AAPL,Buy,US
2,-4.34528144393598,AAPL,Buy,US
3,4.162633142683278,AAPL,Buy,US
4,10.150521156251484,AAPL,Buy,US
5,4.097694151269681,AAPL,Buy,US
6,5.66801379347099,AAPL,Buy,US
7,5.968479118806644,AAPL,Buy,US
8,9.090610373672817,AAPL,Buy,US
9,3.126105429964793,AAPL,Buy,US
10,5.94612819368338,AAPL,Buy,US
11,7.891139455217892,AAPL,Buy,US
12,8.93403999339301,AAPL,Buy,US
1,5.074941905718319,AAPL,Buy,EU
2,-0.7442483046405257,AAPL,Buy,EU
3,6.960167273970692,AAPL,Buy,EU
4,5.6870478157317415,AAPL,Buy,EU
5,6.041427336262811,AAPL,Buy,EU
6,2.594547232951304,AAPL,Buy,EU
7,2.893940693551921,AAPL,Buy,EU
8,0.9476879017870544,AAPL,Buy,EU
9,7.16816499460252,AAPL,Buy,EU
10,8.431921697170958,AAPL,Buy,EU
11,-0.7351729068652286,AAPL,Buy,EU
12,7.505323800242606,AAPL,Buy,EU
1,2.1973676113362717,AAPL,Buy,ASIA
2,-1.7260136387968747,AAPL,Buy,ASIA
3,7.456914730126636,AAPL,Buy,ASIA
4,3.3817814628376532,AAPL,Buy,ASIA
5,6.846575701234167,AAPL,Buy,ASIA
6,3.1073322705860655,AAPL,Buy,ASIA
7,0.5123912628620364,AAPL,Buy,ASIA
8,8.850388756736901,AAPL,Buy,ASIA
9,3.818557244308055,AAPL,Buy,ASIA
10,8.929070400908735,AAPL,Buy,ASIA
11,10.386339504409692,AAPL,Buy,ASIA
12,9.151390039600408,AAPL,Buy,ASIA
1,7.994470483844239,AAPL,Sell,US
2,0.8540745343238714,AAPL,Sell,US
3,3.5719076386999666,AAPL,Sell,US
4,7.454490140970513,AAPL,Sell,US
5,0.813764317270188,AAPL,Sell,US
6,9.599435038288032,AAPL,Sell,US
7,13.522750608058985,AAPL,Sell,US
8,2.1413123283369404,AAPL,Sell,US
9,10.271764313528315,AAPL,Sell,US
10,7.75063998246557,AAPL,Sell,US
11,8.15150671835411,AAPL,Sell,US
12,4.128504203557618,AAPL,Sell,US
1,3.642352623665083,AAPL,Sell,EU
2,3.8181486328043706,AAPL,Sell,EU
3,10.605402975824305,AAPL,Sell,EU
4,6.149895647916026,AAPL,Sell,EU
5,4.449600035436692,AAPL,Sell,EU
6,7.904877573697641,AAPL,Sell,EU
7,8.123259441576602,AAPL,Sell,EU
8,4.209878663880891,AAPL,Sell,EU
9,5.4180968178350355,AAPL,Sell,EU
10,10.41652688141875,AAPL,Sell,EU
11,6.420807334192945,AAPL,Sell,EU
12,5.230845805727026,AAPL,Sell,EU
1,2.1264172429219297,AAPL,Sell,ASIA
2,7.520123219855777,AAPL,Sell,ASIA
3,-1.1005425170340604,AAPL,Sell,ASIA
4,7.808757006813012,AAPL,Sell,ASIA
5,-2.6770609619920824,AAPL,Sell,ASIA
6,2.2587065836781512,AAPL,Sell,ASIA
7,8.129250583192524,AAPL,Sell,ASIA
8,11.551194806114133,AAPL,Sell,ASIA
9,5.978008783195023,AAPL,Sell,ASIA
10,6.976957088286104,AAPL,Sell,ASIA
11,2.9815628060625894,AAPL,Sell,ASIA
12,11.24135760310244,AAPL,Sell,ASIA
1,5.055452855996302,AAPL,Hold,US
2,5.028065005038316,AAPL,Hold,US
3,4.44515380070615,AAPL,Hold,US
4,7.100470405350461,AAPL,Hold,US
5,7.412157090253841,AAPL,Hold,US
6,2.571906733962643,AAPL,Hold,US
7,-2.8206086050461012,AAPL,Hold,US
8,7.529405185919823,AAPL,Hold,US
9,10.97892748102854,AAPL,Hold,US
10,8.424188521953862,AAPL,Hold,US
11,8.248439057954176,AAPL,Hold,US
12,5.95553714826853,AAPL,Hold,US
1,7.9397024367292275,AAPL,Hold,EU
2,1.784865252331772,AAPL,Hold,EU
3,3.2073538310452867,AAPL,Hold,EU
4,8.195174130743089,AAPL,Hold,EU
5,7.348405815959684,AAPL,Hold,EU
6,3.4356082052130277,AAPL,Hold,EU
7,2.9214395959075103,AAPL,Hold,EU
8,6.245701221112073,AAPL,Hold,EU
9,4.460271721647599,AAPL,Hold,EU
10,3.2458705571127817,AAPL,Hold,EU
11,6.289719345430279,AAPL,Hold,EU
12,9.753656937773812,AAPL,Hold,EU
1,-2.1783838788200596,AAPL,Hold,ASIA
2,1.1852002343549912,AAPL,Hold,ASIA
3,1.84669269943914,AAPL,Hold,ASIA
4,3.3791865984988516,AAPL,Hold,ASIA
5,3.035048980442906,AAPL,Hold,ASIA
6,4.522455670521169,AAPL,Hold,ASIA
7,8.63248919837574,AAPL,Hold,ASIA
8,15.165784457886467,AAPL,Hold,ASIA
9,6.393191686187018,AAPL,Hold,ASIA
10,2.522872440663906,AAPL,Hold,ASIA
11,6.643335394013538,AAPL,Hold,ASIA
12,2.539961080716008,AAPL,Hold,ASIA
1,4.748474759686887,GOOGL,Buy,US
2,6.740826677493444,GOOGL,Buy,US
3,7.361789894446536,GOOGL,Buy,US
4,1.985385973957381,GOOGL,Buy,US
5,5.628485947724766,GOOGL,Buy,US
6,6.4162094112734955,GOOGL,Buy,US
7,3.7438251622836423,GOOGL,Buy,US
8,4.957556295684142,GOOGL,Buy,US
9,5.14864456232808,GOOGL,Buy,US
10,10.030608074994685,GOOGL,Buy,US
11,4.900743509941794,GOOGL,Buy,US
12,9.849540316158258,GOOGL,Buy,US
1,9.170704944996803,GOOGL,Buy,EU
2,2.3650220892332516,GOOGL,Buy,EU
3,2.8608917309124102,GOOGL,Buy,EU
4,5.205725481215668,GOOGL,Buy,EU
5,4.703044608570553,GOOGL,Buy,EU
6,2.627794013238631,GOOGL,Buy,EU
7,7.568222862536962,GOOGL,Buy,EU
8,3.9820779953189507,GOOGL,Buy,EU
9,10.068936728330788,GOOGL,Buy,EU
10,3.679761673480603,GOOGL,Buy,EU
11,10.921392142708987,GOOGL,Buy,EU
12,9.050628273163856,GOOGL,Buy,EU
1,1.8560279241494868,GOOGL,Buy,ASIA
2,2.1273338617713025,GOOGL,Buy,ASIA
3,5.141101874516041,GOOGL,Buy,ASIA
4,4.013495114068556,GOOGL,Buy,ASIA
5,6.820679464137576,GOOGL,Buy,ASIA
6,6.0375284327005465,GOOGL,Buy,ASIA
7,4.7014058157172585,GOOGL,Buy,ASIA
8,4.202432890402375,GOOGL,Buy,ASIA
9,6.058850281586464,GOOGL,Buy,ASIA
10,6.6531197416857415,GOOGL,Buy,ASIA
11,9.738094287968622,GOOGL,Buy,ASIA
12,8.182892897721317,GOOGL,Buy,ASIA
1,0.8078075715224475,GOOGL,Sell,US
2,3.6352764034239193,GOOGL,Sell,US
3,0.4239570713874854,GOOGL,Sell,US
4,4.350594172599732,GOOGL,Sell,US
5,9.479116577825,GOOGL,Sell,US
6,7.393576500066467,GOOGL,Sell,US
7,4.845590508536986,GOOGL,Sell,US
8,6.513705028490672,GOOGL,Sell,US
9,6.29595253186249,GOOGL,Sell,US
10,8.182358356937364,GOOGL,Sell,US
11,5.08761130567483,GOOGL,Sell,US
12,13.034088150974721,GOOGL,Sell,US
1,-2.5961158361086394,GOOGL,Sell,EU
2,6.071243686114777,GOOGL,Sell,EU
3,4.287882442753821,GOOGL,Sell,EU
4,4.3308448746357975,GOOGL,Sell,EU
5,2.7144728624868586,GOOGL,Sell,EU
6,4.469438528078188,GOOGL,Sell,EU
7,4.733567550763581,GOOGL,Sell,EU
8,4.931751197163267,GOOGL,Sell,EU
9,7.652710536869115,GOOGL,Sell,EU
10,4.821181580173638,GOOGL,Sell,EU
11,1.878019751617293,GOOGL,Sell,EU
12,11.717461476265502,GOOGL,Sell,EU
1,3.948503360716944,GOOGL,Sell,ASIA
2,2.5209453263638206,GOOGL,Sell,ASIA
3,7.139836843578612,GOOGL,Sell,ASIA
4,6.294763829779881,GOOGL,Sell,ASIA
5,4.112009015568591,GOOGL,Sell,ASIA
6,8.6722620528998,GOOGL,Sell,ASIA
7,3.1647070899579965,GOOGL,Sell,ASIA
8,8.04404227308137,GOOGL,Sell,ASIA
9,3.3373197179320004,GOOGL,Sell,ASIA
10,10.701748717430165,GOOGL,Sell,ASIA
11,9.099727148902065,GOOGL,Sell,ASIA
12,5.249511808678705,GOOGL,Sell,ASIA
1,4.161343912725663,GOOGL,Hold,US
2,3.1970339880107277,GOOGL,Hold,US
3,5.53288079227276,GOOGL,Hold,US
4,9.65500411443167,GOOGL,Hold,US
5,2.308029849861955,GOOGL,Hold,US
6,8.686979686611265,GOOGL,Hold,US
7,6.147603187184958,GOOGL,Hold,US
8,7.6295437069789305,GOOGL,Hold,US
9,8.924580484911322,GOOGL,Hold,US
10,8.920421205002551,GOOGL,Hold,US
11,9.110847616564755,GOOGL,Hold,US
12,9.532613551804735,GOOGL,Hold,US
1,0.15015512641966833,GOOGL,Hold,EU
2,5.805511162085799,GOOGL,Hold,EU
3,2.6001519806843496,GOOGL,Hold,EU
4,4.2110082928933785,GOOGL,Hold,EU
5,3.6040056990617604,GOOGL,Hold,EU
6,6.5037583964105865,GOOGL,Hold,EU
7,5.619610117069893,GOOGL,Hold,EU
8,5.615534515911259,GOOGL,Hold,EU
9,6.988545172603631,GOOGL,Hold,EU
10,3.474093469930877,GOOGL,Hold,EU
11,9.60395178340204,GOOGL,Hold,EU
12,7.769942087144343,GOOGL,Hold,EU
1,5.127960388789075,GOOGL,Hold,ASIA
2,4.132531185471783,GOOGL,Hold,ASIA
3,4.393804006589438,GOOGL,Hold,ASIA
4,9.901713308974537,GOOGL,Hold,ASIA
5,3.906999432544249,GOOGL,Hold,ASIA
6,8.781618232126217,GOOGL,Hold,ASIA
7,4.859640650401968,GOOGL,Hold,ASIA
8,2.301168774235627,GOOGL,Hold,ASIA
9,8.008208401184913,GOOGL,Hold,ASIA
10,10.364535105501732,GOOGL,Hold,ASIA
11,9.364925811677672,GOOGL,Hold,ASIA
12,3.214039220487364,GOOGL,Hold,ASIA
1,7.151144773160025,MSFT,Buy,US
2,1.6838443292763385,MSFT,Buy,US
3,9.900695326456566,MSFT,Buy,US
4,-0.18590188837443156,MSFT,Buy,US
5,-0.42459604642883536,MSFT,Buy,US
6,6.051112607866601,MSFT,Buy,US
7,5.958080416762067,MSFT,Buy,US
8,5.350652837063106,MSFT,Buy,US
9,5.510783311166426,MSFT,Buy,US
10,1.4763512129341165,MSFT,Buy,US
11,3.2903165239987104,MSFT,Buy,US
12,7.307450161601431,MSFT,Buy,US
1,8.459051768101922,MSFT,Buy,EU
2,6.753237654337093,MSFT,Buy,EU
3,2.993195263942512,MSFT,Buy,EU
4,2.1650675027436037,MSFT,Buy,EU
5,-3.8668521350184664,MSFT,Buy,EU
6,3.1273088864900727,MSFT,Buy,EU
7,5.295378167105897,MSFT,Buy,EU
8,9.882946080429878,MSFT,Buy,EU
9,9.736348508737695,MSFT,Buy,EU
10,4.803969792264536,MSFT,Buy,EU
11,7.594803105358428,MSFT,Buy,EU
12,8.614553160184588,MSFT,Buy,EU
1,1.1112931102347265,MSFT,Buy,ASIA
2,2.2164008972604634,MSFT,Buy,ASIA
3,4.4361840707099205,MSFT,Buy,ASIA
4,5.910583800843131,MSFT,Buy,ASIA
5,-1.6503099496219147,MSFT,Buy,ASIA
6,6.911831934183083,MSFT,Buy,ASIA
7,3.631288921015302,MSFT,Buy,ASIA
8,8.049548233036798,MSFT,Buy,ASIA
9,9.758973746251426,MSFT,Buy,ASIA
10,9.593012338001241,MSFT,Buy,ASIA
11,4.557153586901062,MSFT,Buy,ASIA
12,6.344962822803871,MSFT,Buy,ASIA
1,1.1211322394644814,MSFT,Sell,US
2,2.7046284376458427,MSFT,Sell,US
3,5.397263080883318,MSFT,Sell,US
4,5.3125400476051565,MSFT,Sell,US
5,5.7754094681195545,MSFT,Sell,US
6,12.097824261208254,MSFT,Sell,US
7,5.472778422421081,MSFT,Sell,US
8,8.479106105263135,MSFT,Sell,US
9,12.166883971494114,MSFT,Sell,US
10,1.5564036488841555,MSFT,Sell,US
11,8.338633909500864,MSFT,Sell,US
12,6.965785108251604,MSFT,Sell,US
1,3.202519361107088,MSFT,Sell,EU
2,3.4460772045798214,MSFT,Sell,EU
3,3.856379569568014,MSFT,Sell,EU
4,1.388073534239897,MSFT,Sell,EU
5,1.0559766448598509,MSFT,Sell,EU
6,7.18885803930991,MSFT,Sell,EU
7,0.7637914880107808,MSFT,Sell,EU
8,7.637670907524962,MSFT,Sell,EU
9,9.658286839057117,MSFT,Sell,EU
10,9.328704195233112,MSFT,Sell,EU
11,2.2992468764501277,MSFT,Sell,EU
12,4.985685001410813,MSFT,Sell,EU
1,-0.6817738140318852,MSFT,Sell,ASIA
2,6.053563405407313,MSFT,Sell,ASIA
3,-3.5026631072424137,MSFT,Sell,ASIA
4,7.547184882503945,MSFT,Sell,ASIA
5,8.726612660082651,MSFT,Sell,ASIA
6,3.648661436188412,MSFT,Sell,ASIA
7,3.7534827040747567,MSFT,Sell,ASIA
8,5.449456830627516,MSFT,Sell,ASIA
9,11.436630123982924,MSFT,Sell,ASIA
10,9.46125128752493,MSFT,Sell,ASIA
11,16.09737322798437,MSFT,Sell,ASIA
12,6.343113885717525,MSFT,Sell,ASIA
1,1.5591965076734082,MSFT,Hold,US
2,4.9954992385480494,MSFT,Hold,US
3,8.078944058495443,MSFT,Hold,US
4,7.288809593902713,MSFT,Hold,US
5,8.3246399055053,MSFT,Hold,US
6,0.5415410412868367,MSFT,Hold,US
7,5.708730619045364,MSFT,Hold,US
8,7.665560273256144,MSFT,Hold,US
9,3.206884278001667,MSFT,Hold,US
10,7.477300562682101,MSFT,Hold,US
11,7.739913666184379,MSFT,Hold,US
12,16.690899566853982,MSFT,Hold,US
1,2.0432048012414645,MSFT,Hold,EU
2,5.499964987019754,MSFT,Hold,EU
3,2.111074528396304,MSFT,Hold,EU
4,6.039275143375217,MSFT,Hold,EU
5,6.4084345785108665,MSFT,Hold,EU
6,5.942561040653148,MSFT,Hold,EU
7,4.965202467859304,MSFT,Hold,EU
8,0.40514152751823695,MSFT,Hold,EU
9,2.5700378104647457,MSFT,Hold,EU
10,3.6673379969866007,MSFT,Hold,EU
11,9.236077747169025,MSFT,Hold,EU
12,9.440748100358498,MSFT,Hold,EU
1,3.1351918750884025,MSFT,Hold,ASIA
2,5.083212989480145,MSFT,Hold,ASIA
3,2.553433139371082,MSFT,Hold,ASIA
4,2.439427270380012,MSFT,Hold,ASIA
5,5.866510090203092,MSFT,Hold,ASIA
6,-1.7952601503199785,MSFT,Hold,ASIA
7,5.625923765176292,MSFT,Hold,ASIA
8,3.3782784786275286,MSFT,Hold,ASIA
9,7.388272214709318,MSFT,Hold,ASIA
10,6.883150205349698,MSFT,Hold,ASIA
11,10.753119350839665,MSFT,Hold,ASIA
12,6.951386420482113,MSFT,Hold,ASIA

</script><script type="text/plain" id="facet_data" data-format="csv_embedded" data-src="">
Month,Sales,Product,Region,color
1,114.05424270263717,Product A,North,North
2,128.99867188329893,Product A,North,North
3,156.0705743009495,Product A,North,North
4,115.97377240587029,Product A,North,North
5,147.29303917773805,Product A,North,North
6,146.17043986222075,Product A,North,North
7,163.4400102801454,Product A,North,North
8,144.01197881456025,Product A,North,North
9,175.37234674623696,Product A,North,North
10,164.57825058738416,Product A,North,North
11,155.2541947552851,Product A,North,North
12,175.17047401038386,Product A,North,North
1,108.30100889163715,Product A,South,South
2,115.62870743872442,Product A,South,South
3,136.8376319919806,Product A,South,South
4,118.36028340364169,Product A,South,South
5,157.61868304657924,Product A,South,South
6,133.2332779857544,Product A,South,South
7,135.45318521648505,Product A,South,South
8,164.84721966390728,Product A,South,South
9,167.8563366481693,Product A,South,South
10,176.08348262940143,Product A,South,South
11,160.31844221225873,Product A,South,South
12,202.65538804415166,Product A,South,South
1,146.6003627407424,Product A,East,East
2,132.77514337734533,Product A,East,East
3,130.52706827837144,Product A,East,East
4,125.36540381765204,Product A,East,East
5,125.32542567429508,Product A,East,East
6,143.10754957186825,Product A,East,East
7,156.0905880731382,Product A,East,East
8,153.2200900163981,Product A,East,East
9,186.7068365544228,Product A,East,East
10,176.6378996317787,Product A,East,East
11,196.02770990183214,Product A,East,East
12,162.0645875784832,Product A,East,East
1,146.49982377341107,Product A,West,West
2,136.6733824936437,Product A,West,West
3,134.31088737486266,Product A,West,West
4,153.10970735846325,Product A,West,West
5,143.22180398024412,Product A,West,West
6,140.21558498479445,Product A,West,West
7,156.62790579418504,Product A,West,West
8,155.83980712377496,Product A,West,West
9,168.50383489384498,Product A,West,West
10,192.66254286092823,Product A,West,West
11,164.2536299700858,Product A,West,West
12,170.53534155916907,Product A,West,West
1,131.52787571729758,Product B,North,North
2,116.55912641048778,Product B,North,North
3,140.0461374586831,Product B,North,North
4,115.23860275707716,Product B,North,North
5,125.89291730459901,Product B,North,North
6,147.1404243638114,Product B,North,North
7,161.273232210895,Product B,North,North
8,154.24581618603264,Product B,North,North
9,171.50169573000858,Product B,North,North
10,180.67882466789524,Product B,North,North
11,155.17567945527986,Product B,North,North
12,173.25290349526804,Product B,North,North
1,145.5541764779749,Product B,South,South
2,123.67972536613712,Product B,South,South
3,135.69130631209978,Product B,South,South
4,141.2614044083025,Product B,South,South
5,128.52599724221625,Product B,South,South
6,141.35391873368897,Product B,South,South
7,134.71842065787303,Product B,South,South
8,161.34360652254145,Product B,South,South
9,176.02194348100545,Product B,South,South
10,165.15260267030862,Product B,South,South
11,165.4936439983111,Product B,South,South
12,161.10644547655397,Product B,South,South
1,125.68047942579776,Product B,East,East
2,153.68615899947028,Product B,East,East
3,137.52106660268262,Product B,East,East
4,141.68600284023006,Product B,East,East
5,164.17321389602358,Product B,East,East
6,145.99936942403951,Product B,East,East
7,170.09115730475105,Product B,East,East
8,138.80761311452915,Product B,East,East
9,178.85741944204966,Product B,East,East
10,183.600420191446,Product B,East,East
11,183.5322803247189,Product B,East,East
12,156.17219506915544,Product B,East,East
1,148.62098662178323,Product B,West,West
2,149.37280926834916,Product B,West,West
3,155.90049061877323,Product B,West,West
4,154.2322996640471,Product B,West,West
5,127.37850789669899,Product B,West,West
6,130.0663415697831,Product B,West,West
7,147.2251623667747,Product B,West,West
8,163.52070637485744,Product B,West,West
9,142.77725900510555,Product B,West,West
10,159.6195144914313,Product B,West,West
11,161.6735183418319,Product B,West,West
12,193.2961464854406,Product B,West,West
1,139.60562531125402,Product C,North,North
2,150.96992469055925,Product C,North,North
3,126.16195068020492,Product C,North,North
4,138.66585706970505,Product C,North,North
5,126.1817297211987,Product C,North,North
6,163.44383866438736,Product C,North,North
7,157.8965772570027,Product C,North,North
8,156.97249944879744,Product C,North,North
9,168.28988540033342,Product C,North,North
10,166.57266431429906,Product C,North,North
11,191.4902141544136,Product C,North,North
12,182.4738649354209,Product C,North,North
1,142.4606954422117,Product C,South,South
2,143.80624854222611,Product C,South,South
3,122.90419147797134,Product C,South,South
4,152.8933983127263,Product C,South,South
5,132.7738536798908,Product C,South,South
6,153.2264650852094,Product C,South,South
7,148.08536122703381,Product C,South,South
8,156.5298038990059,Product C,South,South
9,158.2720442625956,Product C,South,South
10,168.90522995473108,Product C,South,South
11,193.8722565309046,Product C,South,South
12,203.81315830228473,Product C,South,South
1,129.31419447730943,Product C,East,East
2,139.23508249382576,Product C,East,East
3,128.3016522311094,Product C,East,East
4,164.78280014367695,Product C,East,East
5,120.8318529835885,Product C,East,East
6,133.0054727947629,Product C,East,East
7,175.01965451603797,Product C,East,East
8,156.98851333532937,Product C,East,East
9,187.978360072031,Product C,East,East
10,168.4790010428829,Product C,East,East
11,180.55002965016394,Product C,East,East
12,177.40719288240606,Product C,East,East
1,132.4617264978321,Product C,West,West
2,125.58372374505845,Product C,West,West
3,141.28702706518814,Product C,West,West
4,138.22228005603776,Product C,West,West
5,125.3235917386361,Product C,West,West
6,137.90444284923166,Product C,West,West
7,158.49089536873564,Product C,West,West
8,152.06431395420907,Product C,West,West
9,181.91704875577295,Product C,West,West
10,194.61453680920792,Product C,West,West
11,156.97001063064334,Product C,West,West
12,188.55966956989948,Product C,West,West
1,122.23988970902741,Product D,North,North
2,117.21773802306795,Product D,North,North
3,142.3501837634953,Product D,North,North
4,163.0431461480289,Product D,North,North
5,164.06752440126223,Product D,North,North
6,134.44420298542985,Product D,North,North
7,158.22581440103636,Product D,North,North
8,158.24930181935105,Product D,North,North
9,156.12059549896262,Product D,North,North
10,166.92536930701107,Product D,North,North
11,189.83798658361195,Product D,North,North
12,202.47067733263407,Product D,North,North
1,134.01637258057025,Product D,South,South
2,119.2702716144009,Product D,South,South
3,131.61319543228186,Product D,South,South
4,161.5233366230693,Product D,South,South
5,159.58512098052572,Product D,South,South
6,165.98444446629827,Product D,South,South
7,131.41668071555176,Product D,South,South
8,171.2524587682287,Product D,South,South
9,153.67626425858003,Product D,South,South
10,179.99107585071508,Product D,South,South
11,196.58319859070474,Product D,South,South
12,156.6063532528625,Product D,South,South
1,143.80637482331525,Product D,East,East
2,122.3622642643724,Product D,East,East
3,145.19005423598662,Product D,East,East
4,144.8986774698636,Product D,East,East
5,125.86860132538213,Product D,East,East
6,169.1305551446788,Product D,East,East
7,138.5050981833848,Product D,East,East
8,148.3436328427996,Product D,East,East
9,156.25014360281386,Product D,East,East
10,184.7860506504099,Product D,East,East
11,196.16307109378317,Product D,East,East
12,178.9411823820477,Product D,East,East
1,136.96115139734812,Product D,West,West
2,115.68964221500181,Product D,West,West
3,137.80166354262047,Product D,West,West
4,161.9070903599692,Product D,West,West
5,167.17870025571867,Product D,West,West
6,144.11783925384546,Product D,West,West
7,170.23876402794585,Product D,West,West
8,157.77071430871138,Product D,West,West
9,170.36458140809253,Product D,West,West
10,192.7652429562071,Product D,West,West
11,182.49995557784285,Product D,West,West
12,188.45734802444028,Product D,West,West

</script><script type="text/plain" id="agg_data" data-format="csv_embedded" data-src="">
Month,Sales,Product,color
1,108.5314115222597,Product A,Product A
1,132.14354811744198,Product A,Product A
1,149.5187304500759,Product A,Product A
1,130.9104280668248,Product A,Product A
1,112.4060315421751,Product A,Product A
2,122.80050055211277,Product A,Product A
2,143.96120488462816,Product A,Product A
2,132.68726526543753,Product A,Product A
2,143.82423826327266,Product A,Product A
2,134.12489220935393,Product A,Product A
3,148.15277692740105,Product A,Product A
3,137.67979781149467,Product A,Product A
3,121.76484442678681,Product A,Product A
3,157.67423006488633,Product A,Product A
3,160.68946727125143,Product A,Product A
4,133.98969662558875,Product A,Product A
4,168.5651268026696,Product A,Product A
4,121.71518906994852,Product A,Product A
4,136.34013644903825,Product A,Product A
4,159.85522460307507,Product A,Product A
5,141.7761814019391,Product A,Product A
5,138.57312339178173,Product A,Product A
5,162.01777385162282,Product A,Product A
5,139.40034420732502,Product A,Product A
5,162.18237520446345,Product A,Product A
6,174.4925985786357,Product A,Product A
6,151.10850988109155,Product A,Product A
6,142.0767597286291,Product A,Product A
6,138.08511271442333,Product A,Product A
6,148.68607571253196,Product A,Product A
7,154.99626313681284,Product A,Product A
7,155.0491607527926,Product A,Product A
7,159.02485103400846,Product A,Product A
7,182.8616632808556,Product A,Product A
7,163.15707475090701,Product A,Product A
8,187.25256772127995,Product A,Product A
8,163.9926187303298,Product A,Product A
8,150.35996301648203,Product A,Product A
8,165.58044918126944,Product A,Product A
8,170.40332331416823,Product A,Product A
9,146.35046768828383,Product A,Product A
9,148.0293297273343,Product A,Product A
9,153.14317208445175,Product A,Product A
9,189.48101868989588,Product A,Product A
9,154.9977010643896,Product A,Product A
10,186.78061632960242,Product A,Product A
10,159.04764095750534,Product A,Product A
10,165.73314133112757,Product A,Product A
10,162.52031713150225,Product A,Product A
10,165.52028858879342,Product A,Product A
11,161.72848537468528,Product A,Product A
11,203.70590383671745,Product A,Product A
11,204.52688449728169,Product A,Product A
11,175.3417662572007,Product A,Product A
11,186.12838360884297,Product A,Product A
12,160.48048665363524,Product A,Product A
12,200.04020123753645,Product A,Product A
12,191.89313834549372,Product A,Product A
12,181.08392743141388,Product A,Product A
12,187.88066892879507,Product A,Product A
1,118.91655754384318,Product B,Product B
1,120.43850290974602,Product B,Product B
1,140.47504999817576,Product B,Product B
1,140.71922076924605,Product B,Product B
1,138.63448740099716,Product B,Product B
2,123.93251808916689,Product B,Product B
2,125.36716392389226,Product B,Product B
2,118.29933055547797,Product B,Product B
2,145.29776552853116,Product B,Product B
2,117.43029113691257,Product B,Product B
3,124.0705126325843,Product B,Product B
3,129.8016780911963,Product B,Product B
3,120.9467276081999,Product B,Product B
3,127.23622855863783,Product B,Product B
3,144.28519895319297,Product B,Product B
4,167.51983655146012,Product B,Product B
4,128.67489732173834,Product B,Product B
4,151.01261343747456,Product B,Product B
4,143.970400387597,Product B,Product B
4,161.67447669198566,Product B,Product B
5,154.23093374137926,Product B,Product B
5,144.27877014868307,Product B,Product B
5,168.36163270545217,Product B,Product B
5,156.662580202742,Product B,Product B
5,142.16779074501721,Product B,Product B
6,149.90631537842899,Product B,Product B
6,136.692996739006,Product B,Product B
6,156.23909636700614,Product B,Product B
6,156.69304343105767,Product B,Product B
6,164.7346558617397,Product B,Product B
7,169.24074708563396,Product B,Product B
7,174.58654225961948,Product B,Product B
7,148.69161496154513,Product B,Product B
7,184.93082883748062,Product B,Product B
7,149.34773389881832,Product B,Product B
8,188.29358015425447,Product B,Product B
8,154.27084263187788,Product B,Product B
8,168.490569680778,Product B,Product B
8,146.38045562906956,Product B,Product B
8,143.9792076065787,Product B,Product B
9,153.71603452770057,Product B,Product B
9,192.335307161708,Product B,Product B
9,191.0550102581336,Product B,Product B
9,170.59049683953606,Product B,Product B
9,178.39813415384657,Product B,Product B
10,175.01952650419955,Product B,Product B
10,155.75492021780462,Product B,Product B
10,150.3553942966135,Product B,Product B
10,164.0456165629237,Product B,Product B
10,159.33404158127524,Product B,Product B
11,175.34954295975467,Product B,Product B
11,155.07591165622713,Product B,Product B
11,158.93225059087757,Product B,Product B
11,183.51461699840053,Product B,Product B
11,204.0817367638968,Product B,Product B
12,184.8256019711757,Product B,Product B
12,202.48326587102986,Product B,Product B
12,200.6349470117662,Product B,Product B
12,197.14088869626815,Product B,Product B
12,184.63197887764767,Product B,Product B

</script><script type="text/plain" id="facet_grid_data" data-format="csv_embedded" data-src="">
Month,Sales,Product,Region,Year,color
1,109.08652912617745,Product A,North,2023,2023
2,125.87242492326303,Product A,North,2023,2023
3,149.74411685755462,Product A,North,2023,2023
4,154.0834176537349,Product A,North,2023,2023
5,161.47076617495915,Product A,North,2023,2023
6,171.70665404317373,Product A,North,2023,2023
7,130.05154326345857,Product A,North,2023,2023
8,142.22821614197483,Product A,North,2023,2023
9,149.4794039806451,Product A,North,2023,2023
10,163.69405820126295,Product A,North,2023,2023
11,188.33672383801724,Product A,North,2023,2023
12,183.86293618930694,Product A,North,2023,2023
1,149.17023282559725,Product A,North,2024,2024
2,140.2138035966246,Product A,North,2024,2024
3,130.54660233232318,Product A,North,2024,2024
4,122.78933360060817,Product A,North,2024,2024
5,145.58888555147576,Product A,North,2024,2024
6,138.69309589437833,Product A,North,2024,2024
7,141.49357070454266,Product A,North,2024,2024
8,178.65799548208548,Product A,North,2024,2024
9,185.70038658434277,Product A,North,2024,2024
10,180.3236442046341,Product A,North,2024,2024
11,173.78057225144073,Product A,North,2024,2024
12,200.4814114327472,Product A,North,2024,2024
1,102.53810256623811,Product A,South,2023,2023
2,121.07288360044278,Product A,South,2023,2023
3,111.5692203225536,Product A,South,2023,2023
4,122.44300235997675,Product A,South,2023,2023
5,145.74861535733461,Product A,South,2023,2023
6,140.6376346060346,Product A,South,2023,2023
7,167.85601315368234,Product A,South,2023,2023
8,181.5494642314958,Product A,South,2023,2023
9,185.737046251929,Product A,South,2023,2023
10,156.07148106506196,Product A,South,2023,2023
11,180.27112860288963,Product A,South,2023,2023
12,193.84802080756793,Product A,South,2023,2023
1,141.00752085425847,Product A,South,2024,2024
2,114.08722526721917,Product A,South,2024,2024
3,112.03799370394844,Product A,South,2024,2024
4,122.99778570842507,Product A,South,2024,2024
5,124.49103649896894,Product A,South,2024,2024
6,159.9632541854918,Product A,South,2024,2024
7,145.63433524165416,Product A,South,2024,2024
8,177.9861804529088,Product A,South,2024,2024
9,165.54829952405447,Product A,South,2024,2024
10,170.76370501234703,Product A,South,2024,2024
11,163.6620608991382,Product A,South,2024,2024
12,172.28259499801302,Product A,South,2024,2024
1,126.5625870382897,Product B,North,2023,2023
2,108.11392133511846,Product B,North,2023,2023
3,146.02309300072767,Product B,North,2023,2023
4,120.50199998889767,Product B,North,2023,2023
5,123.29919084806129,Product B,North,2023,2023
6,150.97891882200798,Product B,North,2023,2023
7,158.5081140242035,Product B,North,2023,2023
8,145.11666094555545,Product B,North,2023,2023
9,169.1564400607353,Product B,North,2023,2023
10,159.45918588701383,Product B,North,2023,2023
11,176.94773232312752,Product B,North,2023,2023
12,158.46448058901902,Product B,North,2023,2023
1,122.28145436384014,Product B,North,2024,2024
2,140.1497384709465,Product B,North,2024,2024
3,117.45113352435942,Product B,North,2024,2024
4,133.69802634790662,Product B,North,2024,2024
5,137.41290653619848,Product B,North,2024,2024
6,168.52720341799548,Product B,North,2024,2024
7,130.21599475247575,Product B,North,2024,2024
8,139.69053145911795,Product B,North,2024,2024
9,149.94403300529189,Product B,North,2024,2024
10,154.6183592745715,Product B,North,2024,2024
11,152.25108219734352,Product B,North,2024,2024
12,178.7228345523314,Product B,North,2024,2024
1,118.67931394295204,Product B,South,2023,2023
2,129.57887965621143,Product B,South,2023,2023
3,148.937778143659,Product B,South,2023,2023
4,116.71451246602692,Product B,South,2023,2023
5,143.38325495471855,Product B,South,2023,2023
6,147.61406963081112,Product B,South,2023,2023
7,149.87175677752367,Product B,South,2023,2023
8,149.91881315149274,Product B,South,2023,2023
9,158.98467142434077,Product B,South,2023,2023
10,184.91714661934617,Product B,South,2023,2023
11,184.7985754056761,Product B,South,2023,2023
12,187.90506435069275,Product B,South,2023,2023
1,104.98309288234915,Product B,South,2024,2024
2,123.54956118066947,Product B,South,2024,2024
3,126.45060980022518,Product B,South,2024,2024
4,151.33618461151949,Product B,South,2024,2024
5,120.24890921499968,Product B,South,2024,2024
6,125.4534511547425,Product B,South,2024,2024
7,178.2738277455859,Product B,South,2024,2024
8,164.7872247898336,Product B,South,2024,2024
9,163.84446565843132,Product B,South,2024,2024
10,153.4348159404313,Product B,South,2024,2024
11,195.70955167032935,Product B,South,2024,2024
12,202.1428965829283,Product B,South,2024,2024

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/linechart_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>LineChart Examples</h1>
<p>This page demonstrates the key features of LineChart plots in JSPlots.</p>
<ul>
    <li><strong>Basic time series:</strong> Simple line chart with date axis</li>
    <li><strong>Multiple series:</strong> Comparing multiple lines with color dimension</li>
    <li><strong>Interactive filters:</strong> Dropdown menus to filter data dynamically</li>
    <li><strong>Dynamic controls:</strong> Change color, aggregation, and faceting on the fly</li>
    <li><strong>Aggregation:</strong> Handle multiple observations per x value</li>
    <li><strong>Faceting:</strong> Facet wrap (1 variable) and facet grid (2 variables)</li>
    <li><strong>Integration:</strong> Combining charts with images and text</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Daily Revenue Trend - H1 2024</h2>
<p>Basic time series showing 6-month revenue trend</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="aggregator_select_revenue_trend">Aggregator: </label>
            <select id="aggregator_select_revenue_trend" onchange="updateChart_revenue_trend()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="revenue_trend"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: revenue_data</p><br>
<hr>
<br>
<h2>Monthly Sales Comparison Across Years</h2>
<p>Multiple series chart demonstrating color dimension to compare years</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="aggregator_select_multi_series">Aggregator: </label>
            <select id="aggregator_select_multi_series" onchange="updateChart_multi_series()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="multi_series"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data</p><br>
<hr>
<br>
<h2>Department Productivity by Month</h2>
<p>Interactive filters allow you to select different departments and quarters</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0;">Filters</h4>
            <div style="margin: 10px;">
            <label for="Department_select_filtered_metrics">Department: </label>
            <select id="Department_select_filtered_metrics" multiple onchange="updateChart_filtered_metrics()">
                <option value="Engineering" selected>Engineering</option>
                <option value="Marketing">Marketing</option>
                <option value="Operations">Operations</option>
                <option value="Sales">Sales</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="Quarter_select_filtered_metrics">Quarter: </label>
            <select id="Quarter_select_filtered_metrics" multiple onchange="updateChart_filtered_metrics()">
                <option value="Q1" selected>Q1</option>
                <option value="Q2">Q2</option>
                <option value="Q3">Q3</option>
                <option value="Q4">Q4</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="aggregator_select_filtered_metrics">Aggregator: </label>
            <select id="aggregator_select_filtered_metrics" onchange="updateChart_filtered_metrics()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="filtered_metrics"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: metrics</p><br>
<hr>
<br>
    <div class="picture-container">
        <h2>example_visual</h2>
        <p>Example visualization image</p>
        <img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxITEhUSExIWFRUXGBUYFhcWGBcXGBkWFhYYFhcYGhYYHCgiGBomGxUVJjEhJSktLi4uFx8zODMtNyotLisBCgoKDg0OGxAQGyslHyU1MC0tLjYtLTUrMzAtLS8rLTcrMC0tKzcyLzAtLS0tLS0vKy8tLy0tLi0vNS8tLS0vLf/AABEIAPQAzgMBIgACEQEDEQH/xAAcAAEAAgIDAQAAAAAAAAAAAAAABgcFCAEDBAL/xABHEAABAwICBwQFCQYEBgMAAAABAAIDBBEFIQYHEjFBUWETInGRMkKBocEIFCNSYnKCorEkM5KywuFDY9HwFSU0c5OzVGR0/8QAGwEBAAIDAQEAAAAAAAAAAAAAAAQFAQIGAwf/xAAwEQEAAgEDAwAHBwUAAAAAAAAAAQIDBAUREiExEyJBUZGh0SMyM1JhgbEkQnHB4f/aAAwDAQACEQMRAD8AvFERAREQEREBERARFSWvPWE5hdhtK8g2/aXtOdiLiEHqD3vED6wQZjTzXNBSudBRtbUTDJzyfoWHlcZyEchYZ7+CpzGtYmKVJJkrJWj6kR7JoHK0drjxuosiyO6eqkedp73OPNziT5kr2UWkFZDYxVU8dvqSvb7gVjUQWVo5rpxGAgT7NVHxDwGPtyEjB73Byu/QzTyixJv0EmzKBd0MlmyAcSBfvN3Zi+8XtuWtuB4G2aMnisbNFNSTNkjc5j2G7HtNiCOIKwNzEUA1Uaw24lEYpbNq4xd4GQkbu7Ro4ZkAjgSOBCn6AiIgIiICIiAiIgIiICIiAiIgIiIMXpRjDaSknqnZ9lG5wB4utZjfa4ge1ab1VS+R75JHFz3uc97jvLnEucT4klbH/KErjHhYjH+NPGw/daHS/wA0bVrWgIhCLIIiIJTgmLNgiOeZWNxHGO1vtBYsRuIvYkL4QZHR/GZaOpjqYTZ8btociNzmnoWkg9CtwMAxeOrpoqmL0JWBw3XF97Tbi03B6grS5X/8nHGy+nqKNx/dObIy/wBSW4cB0Dm3/GsC4kREBERAREQEREBERAREQEREBERBT/yknfslKP8AOcfKM/6qlNH9HpqtxEYAaLbTnXsOgtvPRXT8pP8A6Wl/7z/5F5tCKemw7Bm4jVAvDs2RtyLnveQAeZy8AGnegrXF9EqijaXkNmi9cWIIHE24W+sDl4KKvAvlu4X5LZ/Q3SqixO8MlE2GUs22seGPa+PcSyQAXIuLggEXG/O1B6xtHxQ4jPTMB2A4Oi/7cgD2gc7XLfwoI4xhJAAJJIAA3kncAp9o5oC14BqHO2j6jCAB0LrZnw9679R2j8dTXvMzNpsMZcGm477nNaCRysXe5WnrF0+psI2IIqZkkz27WwLMYxl7BziBckkGwHIkkZXCBYhqsLWGahkcJG59lIQWvt6odYWP3rjqFVuJEF5Ox2brkPZa2y8ZHI7s+HBbIaGacR1zxT1FOKeZ7S6JzHbUcoAu7ZdYWeBc7JvkCbqptdujxpa8Py2Z2bdxxc07LsuBts+0lBXqtD5PE+zib23yfTyC3UPjcP0PmqvVi6hHWxdnWKYflv8ABZGziIiwCIiAiIgIiICIiAiIgIiICIiCoflIs/Y6Y8pyPON3+iiuPNfNopRuaLiGf6To0OniaT7XsH4lMflHM/5dAeVUwecM3+iiOpTSiIRT4dUsL4nhz2gtLmlrgGyRuHC+RHC5Od7Xxa0VjmfDMRMzxCLarsSkbiNExp3T3zO5j2OZJ4DZLipjrD0crcSxB9RAxsMbWtiY6R9jIGE3fstBLQS42BsbALPYLo1R05k7CItD9rNzi54YfVD94Hh5nepJALWAXMavfrRbpwRHHvn/AEnV0fEc3QzV3geIYdWMfM2OWJ47OR8brljXEEOIcASA4DcDkSoXr0ieMYmLvReyF0f3Oza3L8bXq7Bh0ZkE2wBJa20LgkWtnb0vasbpRovTVzA2dhJbfYe02ey++x3EdCCFth36azHpq8x74+nPf5NLaX8qk9XdZUPr6GBhLg2pieBxa0OvLY/V2Nu45XU3+UnO01FIwHvNjlJHRzmge9jvJTXQnRGhw1zpImSPmII7WVzXFrTvDQGtDb232v1sqT1o19TNiMr6iJ0Rs0RscQbRC+zZzbh1ztE2JzJHBXun1mDUfh2if5+CNfHavmESVg6iXf8AOIerJv8A1k/BV8ptqXl2cZpOpmb5wSAe+ylNG1aIiwCIiAiIgIiICIiAiIgIiICIiCt9f8G1hJNvQmhd4XJZ/Wq91d0DY6dr7d6TvOPEi5DR4AfqVaWuuHawaq5jsXeU8d/ddUXqyfPJM+FjyAyN0gacxcPYLeB2yoO4YL58PTSf+vfT5K0vzZcVKshTi5UZw/HG+jIxzXDI2BcL+zMeXtWWhxmLgXnwjk+LQuHyYb1txMStbWiY7JBuXRPK1oLnEADeTuWIlx5x9CE35yENHk25PuWNmL5CHSu2iNw3Mb4N+JuVtkp1ee0NK0l6qnE5HvBYdiMcCBtP8b+iOm/9FVmt+rD54R67Yzc/ZLzsi/iHeasxkbneiL9eCq/Wxg0kU8cxcXNkZYfZcw5t3brOB9ruSv8AaNFkrljLavERHb9UfVZadHRWeZQVZbRPE/m1bTVBNhHNG533A4bf5brK6ExwS7cErQS7Np4+xefSrRr5tZ7XXYTbPeF0yubegrlQvVDpEKzDYSTeSEdjLxO1GAGuJO/aZsG/MnkposAiIgIiICIiAiIgIiICIiAiLH47jMNJA+onfsRsFyeJPBrRxcTkAgg2vzGGw4W6G/fqHsY0cdljhK93h3APxhVrqKoS6eqlAyZC1h8ZJA4e6Jyi+mulFRitZ2habEiOnhbnstJs1oA9J7ja54k8gANidXGhow+hbC6xmee0nI3bZFg0Hk0WHU3PFBGcbwdzj2kWT+I5/wB1iRiEze65rh7CrCxGhLTcDJY8t6Ku1O3Ys9uqe0pOLU2pHHlF6eeV/oxnxIsPesvRYY45yG/2RuWbpaFz9wWdosLa3M700+2YMM9XHM/qZNVe8ceIeDD8HuM8gsLrG0J+d0EscYvKwdpCOb2X7o+83ab4uHJTsCy5VgjNJqOpdG8PYbOBuFl8e0mkqWNYWhoGZtxKkeuvRj5niDpGC0NTeVnIPv8ASs/iO1yAkA4Kv1sJ/qY0tFDXBkjrQVGzHITua+57J56Akg8LPJ4LaJaPLZPUpp2KynFJM79pgaACTnLEMg7Pe4ZB3sPE2wLOREQEREBERAREQEREBERB01lWyKN0sjgxjAXOc42AaBckrVrWhp5JidRZpLaWMnsY91zuMrxxceA9UZcyZFrx09NTKaCB30ETvpXA5Syt4dWMPm4E8GlVOAgun5P2hwc52JTNuGkspwfrbnyez0R1LuQV7LE6KYcyno4Kdm6ONjT1cB3j4l1z7VllgfEsQcLELx/8KZe9l7iV8NlzQcxRBu4L7RcFw5oOUXyZBzC6n1TRxQQPXnggqMMe8C8lO4TNta+x6Mg8Nl21+ALWNbk1cbZ2yRPzZIx8bh9l7S0+4rTqohcxzmOFnNJaR1abH3hZgda9eE4lLTTR1ELiySNwc0jmOB5gi4I4gkLyIsjbnV/ppDidP2rLNlbYTRXzY48RzYbGx6EbwVKFppotpDPQVLKmB1nNyc3PZew+kxw4tPuIBGYC210Wx+KupY6qE914zB3tcMnMd1BB8ciMiFgZZERAREQEREBERAUN1saTGgw6SRhtLJaKI8Q94N3DkWtDiOoCmSoD5R+LbVTTUoOUcbpHctqV2yARzAj/ADoKfjjLjYC5Xu0foZJqqGKMbT3SNsOGRuSTyABJPILmqZ2MYZ67xd3Rp3N9v6eKu3UHoaI4DiEze/NdsIPCIHN1vtOHk0Higsuggk3glo/3wWUYy3ElfSLA4IXTTx8Su9EBfDogeC+0QeSXD2nmF4J8LeM2m6zSII6x7mHMWVU66tBW7JxOlZa5/amN3An/ABgOp9K3Eh31irznp2uFiFjzRjvRPaHRvBa5pzDmuFiCORBKDT2BrHZOOyeDvVPjy8V81NK5hs4eB4EcwVmtOdG3UFdNS5lodtRE+tE/NhvxNsj1aV5YO43YlF4j5sJ9YfELYYlWfqI0uNLV/M5HfQ1JAbfc2fcw/i9E8zsclXNfSGJ5afYeBHAhdDHkEEEggggjIgjMEHgUG76KP6A6QfPqCCpNttzbSWytKzuvy4AuBI6EKQLAIiICIiAiIg4c4AXOQG9alaR4uK/E6irJ+i2i4b/3UY2WZHcS1oy5lXrrt0n+Z4e6NrrTVN4mcwy30rvY02vwL2rW1w2IBzlP5WW+JHkg9+jmFPxGvig3GaTvEerGO88j7rGm3gFt7S07I2NjY0NYxrWsaNzWtFmgdAAFSHycMEu+prXD0QIIz1Nnye23Z/xFXokgiIsDguXK6ZD3gu5AREQEREBcELlEFMfKIwhtqStsMnOgeeJBBkj8i2X+JVNW4gxzNlbEa6aLtcHqcs2dnIOmzI3a/KXLVhZgZh/0tKHetC7Z/Ac2/EexYdZjAs46hv2AfI/3WHWRd3ybsczqaFx3gTxjwtHLn/4suhV5rUvVTivzfFaV97Ne/sndRMOzF+gc5p9i20WAREQEREBcErlQDXbpC6kw14YbSVDhC0jeGuBMh/haR4uCCjdaulX/ABCvkka68Mf0UPIsaTd/4nXN+WyOCjuKu/dDgI2+8uK8kMRc4NG8rKaS0JidEDxibn1BcD8FkbJ6nMM7DCaYW70gdM7r2jiWn+DYHsU1XiwOkEVNBEMhHFEweDWBvwXtWoIiIOh/phd66fXXcgIiICIiAiIgj2sNl8Lrh/8AWnPkwn4LUFbgawDbDK7/APNUe+NwWn6zAzOB92Gof9lrR7ST8Fhll5T2dI1vGRxefAd0fpf2rELI+4ZXMc17TZzSHNPIg3B8wt2KKoEkbJBue1rh4OAI/VaSLcPQF5OGUJP/AMWn/wDU0LAzyIiAiIgKnvlJwE0lLJ6rZnNPi+Mke5jlcKienNRG8Mpi1rztNkNxfZ2TdhHJ1/06rw1Oorgxzkt7G+PHN7dMNYI9HK3Y7VtNNs7wQx1/G2+3Wy7ZpHVEFjnLDfLiWH0suYsD5rYZjBZQbWBop2gNXTDZnYLuDR+9aOBA3vHA8d3K1LpN+jJk6MteInxP1+qZl0XTXms8r2aMlyqS1Wa3AS2kxB4G4RTk5dGSk7uj/PmrtXQIAiIg6Ae+u9dFu+u9AREQEREBEWCx7H+xkbE0XcW7RJzABJAyvvNj5dV5Z81MNJvfxDalJvPEPBrYqezwisceMex/5HtZ/UtVaamDhdzwxvM5k+AG9bL6YD59RyU0r9hjtlznMHetG4P3E23tC1ge6/w8F5aTXYtVz6Pnt57e9tkxWx/eZiuMUpFpdkNAa0EZAAWGd11swCVwvGWvHQ5+RWKWRwKoeyUFrrDjyspjzeKohcwlr2lpG8HJbmaN0JgpKeA74oYoz4sY1p/Ra46P0H/EcQgb3ezhex87zu7MPBLepNreZ4LZ5rgRcG4O4haRes2msT3jzDPE8cuURFsw6K2sZEwvkdstHH4AcSsA7TOK/dikI52aPivNp44l0DPV77iOo2QPIE+axcUIA3Lndz3bLgyzjx+xYafS1vTqsytXpnl9HC7a4F5Fh1sN/hko/Th73ukkN3ONyT/vcvb2Q5L6DbKj1W45tRHF5TMeGmP7sOV8yNuF9ooD2UlrM0a7CX5xGPo5D3gNzX/6H9b8ws5qu1rvo9mlrC6SmFgx+bnwjgLb3xjlvA3X3Kf45hbKiF8TxcOH+7dfiAtecYw59PM+F+9pyPMcHDxC7TZtd6fH6O33q/OFRq8PRbqjxLc2jqmSsbJG9r2OF2uaQWkHiCN67lqfoBrAqcMk7pMlO4/SQOPdPNzD6j+oyPEHK2zejOkNPX07amnftMdkQcnMcN7Ht4OFx43BFwQVcojJlud19IiwCIiAiIg+JJQ3eoDpZIHVjSOMTPc9/wDZSnGHG6hmM/8AUM+4P5nKu3WP6af2SdJ+I+8SF4nNHrNI8xZa1SRlpLXCxBII5EZELZqdl2qAaSaEw1DzILxvO9zbEE8y07z4WVNtOspgm0X8Sm6rDOSImvmFRLvoqWSV7Yomlz3Gwa3ef7dVOqXVtn35yRyawNPmSf0U/wBGNHIKUWiZYn0nHNx8XHh0GSttRu+HHX1PWn5ImPR3tPrdoNCNGG0NPsmxlfZ0rhzG5oP1W3PtJPFWBofVFzZGE+g4EeD75ebXH2rCAZLIaMTBkzmnLtALfebew8ifJUm3am06yL3nvbmJ/fx8+EvUY49DMRHhLERF2CpRLTttjA7q8eeyf6SsZGclltYJ+ii59p/Q7+yw1L6IXF75XjUzPv4/hcaOfsodyIipUoREQcEKu9a2jfaRfOY29+P0rbyzefLf5qxV1zRhwIOYORUnS6i2nyxkr7HnlxxesxLV9WXqExySHEm0wJMdS17XN4B8bHSMf42a4fiSr1T1M08opHw7IO0I3uLHBp4jukFt8t9xlcbibA1W6qXUE3zuqkY+YBzY2R3LWbQs5xcQC52ySLAWFzvvl9Bw5q5ccXr4lR3rNZ4laiIi3aiIiAiIgxOMtVdz4rFPUnsnbQj+jcRu2wdpwB4gbQF+YKwOtzWi2Tao6F925iWdpyPNkRHDm/jwyzOM1ZstA3qXH8xHwVdus8aef8pOkj7RZwbcLyS0y9kO5fdlxsTxK3Y6OkXtiisuyy5SbTLAuuRl/guxFrE8DOYLjm1aOY2duDtwd0PJ36rPKv5wLZr7wrSzsCWTEuZbune4G+6/EWv4WXS7du0zxjzfH6/VAz6X+6nwd2m1UJJ44Qf3YLnfefaw8QBf8S80bbBR6GvL5nyP9JznE9Lnd7N3sWbjqgVR7llnLnm6Zgp0UiHpRfDZAvq6r3s5REWAXC5RBisSlkic2eI2ew5ciOII4g7vap5o/j0NXGHRuG2ANuO4L2E8CN9rg2PFQnFBdpVVaY9pERPDI+OSM5PY4tcA7I2c0332XSbHqprPo58Sg6zFEx1Nn0WtGCa6sThAbKY6lv8AmNs+3R8ZHmQVK6X5QDf8TDyOrJgfcYxbzXVcKtdiKlqj5QEYHcoHk/amDR7mFRrGteOIygtgZDTg7iGmR4/E/u/lQX9jmOU1HEZqmZsTBxccyd9mtGb3dACVr7rJ1sy1wdTUodDTHJxOUko4h1vQYfqjfxOdlXuKYpPUSGWeV8rz6z3Fxte9hfcM9wyC8iDhXJoNBsxRjk1t/G1z71T0LNpwbzIHmbK7dFyBZU+8W+ziE3RR60ymsW5fa64jkvu65GVm5XBK+HyALwVdcBxWYrMj3PmAXnlrQOKjlbjFuK9+D6OVlVZ1uyjPryAi4+yzefcOqm4dFfJPFYed8laR3K7FhzUj0O0aJvPUs9IWZG4ZgEglzhwOQsPFZnA9Eqens6xkkHrvzIP2W7m/r1WfXQ6La4wz137z7lfn1XVHFURxvQdkr3Swydk5xJc0jaYScyRndtz4+Cjdbo5Ww59n2jRxiO1+XJ3uVpIpGfbcGXvMcT+jzpqclOymm4kWnZddpG8HIj2FeqPFeqtOsoYpRaWNjxye0O/ULA1mgtE/0WOiPON5H5XXA8lVZdi/JKVXXR7YRSPEwvXFVtPFfVdq6lGcFSDybK0j87b/AMqjuIYXXU1zJC4tHrs77bcyW5tHiAq7NtGanfh711WO3tScPCOeAojS46DxXofjAtvVfOmvE8cPeLQyGJ1Isq50qa+Vro42Oke7INY0uccxuaMys5iuMCxzU51T6OPjDq2Zpa6VuzE07xESHFxHDaIbbo3qrzatHaLxaUTVZY6eFG0OrnFpRdtBMPvgRe6QhZOHU/jJ30rW+M0P9LytpUXUqpq5NqdxkbqZrvuzQ/1OC8U+qzGGb6F/4XxP/leVtgiDTas0Vr4r9pRVDAN5MMlv4rWWIItkd63gXhxLBqaoFp6eKUf5kbX+W0MkGmVF+8Z99v6hWvgFZaysPFtTmFSnaZG+nde+1C82v9yTaaB0ACqrF8PmoKh0EoIIJ2HcHsv3Xt5g+43HBV244ZyVhK0t+mVhU9eLb12urlA6XGOq9LsX6rm7aOeVnGSqS1WJdVh2vlqJBDC0ve7cBy4kngBzK8eGwz1kohgbtOO87mtH1nu4D9eFyrm0V0biootlvekdbtJCM3H4NHAfqblWOj27qnm3hGz6mKxxHljdF9B4qe0k1ppt9z6DD9hp3n7Rz5WUtRF0OPHXHHTWFba02nmRERbtRERAREQEREEexvQuiqSXPi2Hn/EiOw6/M2ycfvAqmNJcPFPP2LHvLb2u4gnf0AHuRFE1GKnHPHd7YrT45WToVoJRhjKl7XTPNiBKQ5jTzDAACfvXsp+iKTSsVjiHnaZme4iItmoiIgIiICx+M4LT1TOzqImyN4bW9p3Xa4ZtPUEIiCntPtCaei70L5c89lzmuA6Du3t4krq1eaJwVpvM+UAZ2Y5oB6G7SbeBC5RRZx19Jxw9uqelc+EYRBTR9nBE2NvG28nm5xzcepK9yIpURw8RERAREQf/2Q==" alt="example_visual" />
    </div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">images.jpeg</p><br>
<hr>
<br>
<h2>Sales by Product (Facet Wrap)</h2>
<p>Facet wrap creates a grid of subplots, one for each product. Similar to ggplot2's facet_wrap.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="color_col_select_facet_wrap_example">Color by: </label>
            <select id="color_col_select_facet_wrap_example" onchange="updateChart_facet_wrap_example()">
                <option value="color" selected>color</option>
                <option value="Product">Product</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="aggregator_select_facet_wrap_example">Aggregator: </label>
            <select id="aggregator_select_facet_wrap_example" onchange="updateChart_facet_wrap_example()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px;">
            <label for="facet1_select_facet_wrap_example">Facet by: </label>
            <select id="facet1_select_facet_wrap_example" onchange="updateChart_facet_wrap_example()">
                <option value="None">None</option>
                <option value="Product" selected>Product</option>
            </select>
        </div>
        
</div>

<!-- Chart -->
<div id="facet_wrap_example"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: facet_data</p><br>
<hr>
<br>
<h2>Sales by Product and Region (Facet Grid)</h2>
<p>Facet grid creates a 2D grid of subplots. First facet variable (Product) defines rows, second (Region) defines columns. Similar to ggplot2's facet_grid.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="aggregator_select_facet_grid_example">Aggregator: </label>
            <select id="aggregator_select_facet_grid_example" onchange="updateChart_facet_grid_example()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px;">
            <label for="facet1_select_facet_grid_example">Facet 1: </label>
            <select id="facet1_select_facet_grid_example" onchange="updateChart_facet_grid_example()">
                <option value="None">None</option>
                <option value="Product" selected>Product</option>
                <option value="Region">Region</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_facet_grid_example">Facet 2: </label>
            <select id="facet2_select_facet_grid_example" onchange="updateChart_facet_grid_example()">
                <option value="None">None</option>
                <option value="Product">Product</option>
                <option value="Region" selected>Region</option>
            </select>
        </div>
        
</div>

<!-- Chart -->
<div id="facet_grid_example"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: facet_grid_data</p><br>
<hr>
<br>
<h2>Dynamic Controls Demo - Stock Returns</h2>
<p>Use the dropdown menus to dynamically change: (1) Color by, (2) Line type by, (3) Aggregator, (4) Facet 1, (5) Facet 2.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="color_col_select_dynamic_controls">Color by: </label>
            <select id="color_col_select_dynamic_controls" onchange="updateChart_dynamic_controls()">
                <option value="Stock" selected>Stock</option>
                <option value="Strategy">Strategy</option>
                <option value="Region">Region</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="aggregator_select_dynamic_controls">Aggregator: </label>
            <select id="aggregator_select_dynamic_controls" onchange="updateChart_dynamic_controls()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px;">
            <label for="facet1_select_dynamic_controls">Facet 1: </label>
            <select id="facet1_select_dynamic_controls" onchange="updateChart_dynamic_controls()">
                <option value="None" selected>None</option>
                <option value="Stock">Stock</option>
                <option value="Strategy">Strategy</option>
                <option value="Region">Region</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_dynamic_controls">Facet 2: </label>
            <select id="facet2_select_dynamic_controls" onchange="updateChart_dynamic_controls()">
                <option value="None" selected>None</option>
                <option value="Stock">Stock</option>
                <option value="Strategy">Strategy</option>
                <option value="Region">Region</option>
            </select>
        </div>
        
</div>

<!-- Chart -->
<div id="dynamic_controls"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: dynamic_data</p><br>
<hr>
<br>
<h2>Aggregation Demo - Multiple Observations per X</h2>
<p>This dataset has 5 observations per month. Use the Aggregator dropdown to switch between: none (all points), mean, median, count, min, max.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="aggregator_select_aggregation_demo">Aggregator: </label>
            <select id="aggregator_select_aggregation_demo" onchange="updateChart_aggregation_demo()">
                <option value="none">none</option>
                <option value="mean" selected>mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="aggregation_demo"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: agg_data</p><br>
<hr>
<br>
<h2>Multi-Dimensional Weather Data - Dynamic X and Y Selection</h2>
<p>Use the dropdowns to dynamically switch between different time scales (X) and measurements (Y). This demonstrates how you can provide multiple options for both axes and let users explore different views of the same dataset.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="x_col_select_multi_dimensions">X dimension: </label>
            <select id="x_col_select_multi_dimensions" onchange="updateChart_multi_dimensions()">
                <option value="time_hours" selected>time_hours</option>
                <option value="time_halfhours">time_halfhours</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="y_col_select_multi_dimensions">Y dimension: </label>
            <select id="y_col_select_multi_dimensions" onchange="updateChart_multi_dimensions()">
                <option value="temperature_celsius" selected>temperature_celsius</option>
                <option value="temperature_fahrenheit">temperature_fahrenheit</option>
                <option value="humidity_percent">humidity_percent</option>
                <option value="pressure_hpa">pressure_hpa</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="aggregator_select_multi_dimensions">Aggregator: </label>
            <select id="aggregator_select_multi_dimensions" onchange="updateChart_multi_dimensions()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="multi_dimensions"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: multi_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Key Features Summary</h2>
<ul>
    <li><strong>Dynamic X and Y dimensions:</strong> Choose which variables to plot on X and Y axes from dropdowns</li>
    <li><strong>Time series support:</strong> Automatic date formatting and axis scaling</li>
    <li><strong>Dynamic color grouping:</strong> Choose which variable to color by from dropdown</li>
    <li><strong>Aggregation:</strong> Handle multiple observations per x value with mean, median, count, min, max, or none</li>
    <li><strong>Interactive filters:</strong> Dropdown menus for dynamic data filtering</li>
    <li><strong>Dynamic faceting:</strong> Choose 0, 1, or 2 variables for faceting on the fly</li>
    <li><strong>Customization:</strong> Control titles, labels, line width, and markers</li>
    <li><strong>Integration:</strong> Combine with other plot types, images, and text</li>
</ul>
<p><strong>Tip:</strong> Hover over lines to see detailed values!</p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
