<!DOCTYPE html>
<html>
<head>
    <title>LineChart Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>
    <style>
        .picture-container {
            padding: 20px;
            margin: 10px 0;
            text-align: center;
        }

        .picture-container h2 {
            font-size: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .picture-container img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .picture-container svg {
            max-width: 100%;
            height: auto;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['Date'];
    const Y_COLS = ['Revenue'];
    const COLOR_COLS = ['color'];
    const COLOR_MAPS = {'color': {'Revenue': '#636efa'}};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_COLOR_COL = 'color';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_revenue_trend = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_revenue_trend');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_revenue_trend');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_revenue_trend');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_revenue_trend' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_revenue_trend');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_revenue_trend');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_revenue_trend');
        const facet2Select = document.getElementById('facet2_select_revenue_trend');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'revenue_trend',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('revenue_trend', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('revenue_trend', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('revenue_trend', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('revenue_data').then(function(data) {
        allData = data;
        window.updateChart_revenue_trend();
    }).catch(function(error) {
        console.error('Error loading data for chart revenue_trend:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['Year'];
    const COLOR_MAPS = {'Year': {'2022': '#636efa', '2023': '#EF553B', '2024': '#00cc96'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'Year';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_multi_series = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_multi_series');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_multi_series');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_multi_series');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_multi_series' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_multi_series');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_multi_series');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_multi_series');
        const facet2Select = document.getElementById('facet2_select_multi_series');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'multi_series',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('multi_series', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('multi_series', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('multi_series', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updateChart_multi_series();
    }).catch(function(error) {
        console.error('Error loading data for chart multi_series:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['Department', 'Quarter'];
    const CATEGORICAL_FILTERS = ['Department', 'Quarter'];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Value'];
    const COLOR_COLS = ['Department', 'Metric'];
    const COLOR_MAPS = {'Metric': {'Sick_Days': '#EF553B', 'Productivity': '#636efa'}, 'Department': {'Engineering': '#636efa', 'Sales': '#EF553B', 'Operations': '#ab63fa', 'Marketing': '#00cc96'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_COLOR_COL = 'Department';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_filtered_metrics = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_filtered_metrics');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_filtered_metrics');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_filtered_metrics');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_filtered_metrics' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_filtered_metrics');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_filtered_metrics');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_filtered_metrics');
        const facet2Select = document.getElementById('facet2_select_filtered_metrics');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'filtered_metrics',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('filtered_metrics', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('filtered_metrics', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('filtered_metrics', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('metrics').then(function(data) {
        allData = data;
        window.updateChart_filtered_metrics();
    }).catch(function(error) {
        console.error('Error loading data for chart filtered_metrics:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['color', 'Product'];
    const COLOR_MAPS = {'Product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product D': '#ab63fa', 'Product B': '#EF553B'}, 'color': {'East': '#00cc96', 'West': '#ab63fa', 'North': '#636efa', 'South': '#EF553B'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'color';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_facet_wrap_example = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_wrap_example');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_wrap_example');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_facet_wrap_example');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_facet_wrap_example' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_facet_wrap_example');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_facet_wrap_example');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_wrap_example');
        const facet2Select = document.getElementById('facet2_select_facet_wrap_example');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'facet_wrap_example',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('facet_wrap_example', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_wrap_example', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_wrap_example', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('facet_data').then(function(data) {
        allData = data;
        window.updateChart_facet_wrap_example();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_wrap_example:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['color'];
    const COLOR_MAPS = {'color': {'2023': '#636efa', '2024': '#EF553B'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'color';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_facet_grid_example = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_grid_example');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_grid_example');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_facet_grid_example');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_facet_grid_example' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_facet_grid_example');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_facet_grid_example');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_grid_example');
        const facet2Select = document.getElementById('facet2_select_facet_grid_example');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'facet_grid_example',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('facet_grid_example', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_grid_example', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_grid_example', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('facet_grid_data').then(function(data) {
        allData = data;
        window.updateChart_facet_grid_example();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_grid_example:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Return'];
    const COLOR_COLS = ['Stock', 'Strategy', 'Region'];
    const COLOR_MAPS = {'Stock': {'GOOGL': '#EF553B', 'MSFT': '#00cc96', 'AAPL': '#636efa'}, 'Strategy': {'Hold': '#00cc96', 'Sell': '#EF553B', 'Buy': '#636efa'}, 'Region': {'EU': '#EF553B', 'ASIA': '#00cc96', 'US': '#636efa'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Return';
    const DEFAULT_COLOR_COL = 'Stock';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_dynamic_controls = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_dynamic_controls');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_dynamic_controls');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_dynamic_controls');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_dynamic_controls' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_dynamic_controls');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_dynamic_controls');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_dynamic_controls');
        const facet2Select = document.getElementById('facet2_select_dynamic_controls');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'dynamic_controls',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('dynamic_controls', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('dynamic_controls', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('dynamic_controls', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('dynamic_data').then(function(data) {
        allData = data;
        window.updateChart_dynamic_controls();
    }).catch(function(error) {
        console.error('Error loading data for chart dynamic_controls:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['Product'];
    const COLOR_MAPS = {'Product': {'Product A': '#636efa', 'Product B': '#EF553B'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'Product';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_aggregation_demo = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_aggregation_demo');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_aggregation_demo');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_aggregation_demo');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_aggregation_demo' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_aggregation_demo');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_aggregation_demo');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_aggregation_demo');
        const facet2Select = document.getElementById('facet2_select_aggregation_demo');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'aggregation_demo',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('aggregation_demo', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('aggregation_demo', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('aggregation_demo', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('agg_data').then(function(data) {
        allData = data;
        window.updateChart_aggregation_demo();
    }).catch(function(error) {
        console.error('Error loading data for chart aggregation_demo:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['time_hours', 'time_halfhours'];
    const Y_COLS = ['temperature_celsius', 'temperature_fahrenheit', 'humidity_percent', 'pressure_hpa'];
    const COLOR_COLS = ['color'];
    const COLOR_MAPS = {'color': {'default': '#636efa'}};
    const DEFAULT_X_COL = 'time_hours';
    const DEFAULT_Y_COL = 'temperature_celsius';
    const DEFAULT_COLOR_COL = 'color';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_multi_dimensions = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_multi_dimensions');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_multi_dimensions');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_multi_dimensions');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_multi_dimensions' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_multi_dimensions');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_multi_dimensions');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_multi_dimensions');
        const facet2Select = document.getElementById('facet2_select_multi_dimensions');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'multi_dimensions',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('multi_dimensions', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('multi_dimensions', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('multi_dimensions', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('multi_data').then(function(data) {
        allData = data;
        window.updateChart_multi_dimensions();
    }).catch(function(error) {
        console.error('Error loading data for chart multi_dimensions:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['Product', 'Units', 'Profit_Margin'];
    const CATEGORICAL_FILTERS = ['Product'];
    const CONTINUOUS_FILTERS = ['Units', 'Profit_Margin'];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['Product'];
    const COLOR_MAPS = {'Product': {'Doohickey': '#00cc96', 'Widget': '#636efa', 'Gadget': '#EF553B'}};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'Product';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_continuous_filters = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_continuous_filters');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_continuous_filters');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_continuous_filters');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_continuous_filters' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_continuous_filters');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_continuous_filters');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_continuous_filters');
        const facet2Select = document.getElementById('facet2_select_continuous_filters');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'continuous_filters',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                const xValues = result.xValues;
                const yValues = result.yValues;

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('continuous_filters', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    const xValues = result.xValues;
                    const yValues = result.yValues;

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('continuous_filters', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        const xValues = result.xValues;
                        const yValues = result.yValues;

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('continuous_filters', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('continuous_filter_data').then(function(data) {
        allData = data;
        window.updateChart_continuous_filters();
    }).catch(function(error) {
        console.error('Error loading data for chart continuous_filters:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="metrics" data-format="csv_embedded" data-src="">
Department,Quarter,Month,Value,Metric
Engineering,Q1,Jan,81.15015951422647,Productivity
Engineering,Q1,Jan,2.0,Sick_Days
Engineering,Q1,Feb,70.35208466746624,Productivity
Engineering,Q1,Feb,3.0,Sick_Days
Engineering,Q1,Mar,98.48803321940827,Productivity
Engineering,Q1,Mar,3.0,Sick_Days
Engineering,Q2,Apr,84.94144822346524,Productivity
Engineering,Q2,Apr,0.0,Sick_Days
Engineering,Q2,May,78.15387940253643,Productivity
Engineering,Q2,May,2.0,Sick_Days
Engineering,Q2,Jun,76.03823630062688,Productivity
Engineering,Q2,Jun,3.0,Sick_Days
Engineering,Q3,Jul,94.78972567759112,Productivity
Engineering,Q3,Jul,0.0,Sick_Days
Engineering,Q3,Aug,79.95093579508499,Productivity
Engineering,Q3,Aug,4.0,Sick_Days
Engineering,Q3,Sep,76.45657377582312,Productivity
Engineering,Q3,Sep,6.0,Sick_Days
Engineering,Q4,Oct,81.49073345785973,Productivity
Engineering,Q4,Oct,1.0,Sick_Days
Engineering,Q4,Nov,70.04428033915781,Productivity
Engineering,Q4,Nov,1.0,Sick_Days
Engineering,Q4,Dec,96.94130156671466,Productivity
Engineering,Q4,Dec,2.0,Sick_Days
Sales,Q1,Jan,70.58426344352218,Productivity
Sales,Q1,Jan,4.0,Sick_Days
Sales,Q1,Feb,81.7469503524305,Productivity
Sales,Q1,Feb,4.0,Sick_Days
Sales,Q1,Mar,72.01617004218501,Productivity
Sales,Q1,Mar,3.0,Sick_Days
Sales,Q2,Apr,86.7138019889016,Productivity
Sales,Q2,Apr,3.0,Sick_Days
Sales,Q2,May,86.66508602640718,Productivity
Sales,Q2,May,3.0,Sick_Days
Sales,Q2,Jun,85.65435284388292,Productivity
Sales,Q2,Jun,1.0,Sick_Days
Sales,Q3,Jul,88.98273977906723,Productivity
Sales,Q3,Jul,0.0,Sick_Days
Sales,Q3,Aug,74.23875254708992,Productivity
Sales,Q3,Aug,2.0,Sick_Days
Sales,Q3,Sep,92.86582441507795,Productivity
Sales,Q3,Sep,3.0,Sick_Days
Sales,Q4,Oct,87.10230093630699,Productivity
Sales,Q4,Oct,2.0,Sick_Days
Sales,Q4,Nov,70.1431616542463,Productivity
Sales,Q4,Nov,2.0,Sick_Days
Sales,Q4,Dec,81.54748971161959,Productivity
Sales,Q4,Dec,1.0,Sick_Days
Marketing,Q1,Jan,73.10540767316792,Productivity
Marketing,Q1,Jan,1.0,Sick_Days
Marketing,Q1,Feb,81.20783521968227,Productivity
Marketing,Q1,Feb,2.0,Sick_Days
Marketing,Q1,Mar,79.81235124021339,Productivity
Marketing,Q1,Mar,2.0,Sick_Days
Marketing,Q2,Apr,82.09156160218518,Productivity
Marketing,Q2,Apr,1.0,Sick_Days
Marketing,Q2,May,85.40828765547866,Productivity
Marketing,Q2,May,1.0,Sick_Days
Marketing,Q2,Jun,82.5996216544237,Productivity
Marketing,Q2,Jun,2.0,Sick_Days
Marketing,Q3,Jul,93.1602521148676,Productivity
Marketing,Q3,Jul,2.0,Sick_Days
Marketing,Q3,Aug,96.6236855610095,Productivity
Marketing,Q3,Aug,1.0,Sick_Days
Marketing,Q3,Sep,74.4271047380194,Productivity
Marketing,Q3,Sep,6.0,Sick_Days
Marketing,Q4,Oct,93.7633751867524,Productivity
Marketing,Q4,Oct,1.0,Sick_Days
Marketing,Q4,Nov,84.19951424182304,Productivity
Marketing,Q4,Nov,3.0,Sick_Days
Marketing,Q4,Dec,86.97393124020005,Productivity
Marketing,Q4,Dec,3.0,Sick_Days
Operations,Q1,Jan,93.28374912533566,Productivity
Operations,Q1,Jan,1.0,Sick_Days
Operations,Q1,Feb,77.66431220793449,Productivity
Operations,Q1,Feb,1.0,Sick_Days
Operations,Q1,Mar,82.91788233940356,Productivity
Operations,Q1,Mar,3.0,Sick_Days
Operations,Q2,Apr,87.58851668638565,Productivity
Operations,Q2,Apr,1.0,Sick_Days
Operations,Q2,May,99.86968008620617,Productivity
Operations,Q2,May,3.0,Sick_Days
Operations,Q2,Jun,98.7870160432186,Productivity
Operations,Q2,Jun,4.0,Sick_Days
Operations,Q3,Jul,88.77221623911288,Productivity
Operations,Q3,Jul,0.0,Sick_Days
Operations,Q3,Aug,73.19415504318167,Productivity
Operations,Q3,Aug,2.0,Sick_Days
Operations,Q3,Sep,95.15022925346378,Productivity
Operations,Q3,Sep,1.0,Sick_Days
Operations,Q4,Oct,83.34393382541646,Productivity
Operations,Q4,Oct,0.0,Sick_Days
Operations,Q4,Nov,89.41011025809719,Productivity
Operations,Q4,Nov,0.0,Sick_Days
Operations,Q4,Dec,96.44051464075734,Productivity
Operations,Q4,Dec,5.0,Sick_Days

</script><script type="text/plain" id="revenue_data" data-format="csv_embedded" data-src="">
Date,Revenue,color
2024-01-01,50106.07409714178,Revenue
2024-01-02,98738.3876219232,Revenue
2024-01-03,149251.36343648838,Revenue
2024-01-04,199579.52094878757,Revenue
2024-01-05,250254.68785915623,Revenue
2024-01-06,300287.66918396874,Revenue
2024-01-07,350084.7376010176,Revenue
2024-01-08,401308.4851374823,Revenue
2024-01-09,448871.1737496773,Revenue
2024-01-10,498943.7452005574,Revenue
2024-01-11,548619.9400127963,Revenue
2024-01-12,597725.2858644207,Revenue
2024-01-13,648171.9001978489,Revenue
2024-01-14,698027.5039940801,Revenue
2024-01-15,748904.1026650455,Revenue
2024-01-16,798146.6880547409,Revenue
2024-01-17,850303.3402493482,Revenue
2024-01-18,901498.1069840179,Revenue
2024-01-19,951074.0326461018,Revenue
2024-01-20,1.0009268726437924e6,Revenue
2024-01-21,1.049258009036991e6,Revenue
2024-01-22,1.099682075851669e6,Revenue
2024-01-23,1.1517412174655425e6,Revenue
2024-01-24,1.2023072864558706e6,Revenue
2024-01-25,1.2525542361173525e6,Revenue
2024-01-26,1.3020220191119828e6,Revenue
2024-01-27,1.353187586151804e6,Revenue
2024-01-28,1.4030561636866087e6,Revenue
2024-01-29,1.4528585419068874e6,Revenue
2024-01-30,1.5047018382097944e6,Revenue
2024-01-31,1.5545931808982904e6,Revenue
2024-02-01,1.60379757264691e6,Revenue
2024-02-02,1.6532676177473445e6,Revenue
2024-02-03,1.7042078236244419e6,Revenue
2024-02-04,1.7557010724517535e6,Revenue
2024-02-05,1.8047084926113184e6,Revenue
2024-02-06,1.8560589036237604e6,Revenue
2024-02-07,1.9036703896593845e6,Revenue
2024-02-08,1.9530848530238064e6,Revenue
2024-02-09,2.003684767045065e6,Revenue
2024-02-10,2.052907287278041e6,Revenue
2024-02-11,2.1024520350713255e6,Revenue
2024-02-12,2.1545228050210266e6,Revenue
2024-02-13,2.2039904959156057e6,Revenue
2024-02-14,2.254482508685056e6,Revenue
2024-02-15,2.304988025557981e6,Revenue
2024-02-16,2.356353477744001e6,Revenue
2024-02-17,2.408548860426451e6,Revenue
2024-02-18,2.457974857938316e6,Revenue
2024-02-19,2.507130368504117e6,Revenue
2024-02-20,2.5601876921384847e6,Revenue
2024-02-21,2.6112231758243144e6,Revenue
2024-02-22,2.6616781911413446e6,Revenue
2024-02-23,2.7108516144195283e6,Revenue
2024-02-24,2.7601299129314926e6,Revenue
2024-02-25,2.809904356019943e6,Revenue
2024-02-26,2.8602686873363773e6,Revenue
2024-02-27,2.910299457179463e6,Revenue
2024-02-28,2.9603081802003365e6,Revenue
2024-02-29,3.0091761328190966e6,Revenue
2024-03-01,3.060036923763358e6,Revenue
2024-03-02,3.1099945638143313e6,Revenue
2024-03-03,3.1601080957859894e6,Revenue
2024-03-04,3.2087351972845765e6,Revenue
2024-03-05,3.258317288555919e6,Revenue
2024-03-06,3.307724092079262e6,Revenue
2024-03-07,3.3573715014530504e6,Revenue
2024-03-08,3.4078278882530127e6,Revenue
2024-03-09,3.457553124383756e6,Revenue
2024-03-10,3.5080225893486855e6,Revenue
2024-03-11,3.558584044705804e6,Revenue
2024-03-12,3.61015850948127e6,Revenue
2024-03-13,3.659955234209106e6,Revenue
2024-03-14,3.7125256320499126e6,Revenue
2024-03-15,3.7643847485242165e6,Revenue
2024-03-16,3.814166795742444e6,Revenue
2024-03-17,3.863492452774938e6,Revenue
2024-03-18,3.913188264410836e6,Revenue
2024-03-19,3.9605961418639934e6,Revenue
2024-03-20,4.0106099920711378e6,Revenue
2024-03-21,4.059236171613703e6,Revenue
2024-03-22,4.1087286696721846e6,Revenue
2024-03-23,4.158044732504266e6,Revenue
2024-03-24,4.209368979118943e6,Revenue
2024-03-25,4.258253884248836e6,Revenue
2024-03-26,4.308167158264061e6,Revenue
2024-03-27,4.35698479587641e6,Revenue
2024-03-28,4.408289617854437e6,Revenue
2024-03-29,4.461645842700757e6,Revenue
2024-03-30,4.513202205234524e6,Revenue
2024-03-31,4.563388631790946e6,Revenue
2024-04-01,4.612389652069148e6,Revenue
2024-04-02,4.665561046854467e6,Revenue
2024-04-03,4.715666250320447e6,Revenue
2024-04-04,4.7669488958464125e6,Revenue
2024-04-05,4.815654244194313e6,Revenue
2024-04-06,4.864836042973813e6,Revenue
2024-04-07,4.914209761690169e6,Revenue
2024-04-08,4.963516007109523e6,Revenue
2024-04-09,5.013060399098367e6,Revenue
2024-04-10,5.063192409239583e6,Revenue
2024-04-11,5.112448985081738e6,Revenue
2024-04-12,5.162536116580985e6,Revenue
2024-04-13,5.2118943895080425e6,Revenue
2024-04-14,5.26245665152036e6,Revenue
2024-04-15,5.313178667659867e6,Revenue
2024-04-16,5.362412276960632e6,Revenue
2024-04-17,5.413614660146007e6,Revenue
2024-04-18,5.46367088920191e6,Revenue
2024-04-19,5.512644024507612e6,Revenue
2024-04-20,5.563572238633154e6,Revenue
2024-04-21,5.6133425378349945e6,Revenue
2024-04-22,5.664089980096205e6,Revenue
2024-04-23,5.713050611274166e6,Revenue
2024-04-24,5.7627930794407595e6,Revenue
2024-04-25,5.812140047873549e6,Revenue
2024-04-26,5.863243898634743e6,Revenue
2024-04-27,5.911799421322245e6,Revenue
2024-04-28,5.961988009849178e6,Revenue
2024-04-29,6.011246586509014e6,Revenue
2024-04-30,6.061359276113679e6,Revenue
2024-05-01,6.111875764148457e6,Revenue
2024-05-02,6.162263019414672e6,Revenue
2024-05-03,6.210845688359279e6,Revenue
2024-05-04,6.259385909877e6,Revenue
2024-05-05,6.3091822663344685e6,Revenue
2024-05-06,6.360058695398869e6,Revenue
2024-05-07,6.409148160816906e6,Revenue
2024-05-08,6.457241995033685e6,Revenue
2024-05-09,6.50642110764095e6,Revenue
2024-05-10,6.556843192540955e6,Revenue
2024-05-11,6.607567826844377e6,Revenue
2024-05-12,6.658263846363135e6,Revenue
2024-05-13,6.709022234836625e6,Revenue
2024-05-14,6.760136521934718e6,Revenue
2024-05-15,6.809096771831026e6,Revenue
2024-05-16,6.859415847165924e6,Revenue
2024-05-17,6.909566384243818e6,Revenue
2024-05-18,6.9588338473374965e6,Revenue
2024-05-19,7.008415161634687e6,Revenue
2024-05-20,7.057212269595256e6,Revenue
2024-05-21,7.106992106839209e6,Revenue
2024-05-22,7.157809462739593e6,Revenue
2024-05-23,7.208377390702128e6,Revenue
2024-05-24,7.258679401689086e6,Revenue
2024-05-25,7.309791501161383e6,Revenue
2024-05-26,7.359458656391775e6,Revenue
2024-05-27,7.410080206799403e6,Revenue
2024-05-28,7.4592269343226645e6,Revenue
2024-05-29,7.50929190172085e6,Revenue
2024-05-30,7.558642724522786e6,Revenue
2024-05-31,7.607954740037404e6,Revenue
2024-06-01,7.658151243886611e6,Revenue
2024-06-02,7.708197310025824e6,Revenue
2024-06-03,7.758276322807017e6,Revenue
2024-06-04,7.808777802573653e6,Revenue
2024-06-05,7.860110606039362e6,Revenue
2024-06-06,7.910797857694078e6,Revenue
2024-06-07,7.961528430932136e6,Revenue
2024-06-08,8.010867313242206e6,Revenue
2024-06-09,8.059479662175169e6,Revenue
2024-06-10,8.109726521260852e6,Revenue
2024-06-11,8.159567556780469e6,Revenue
2024-06-12,8.209921350993421e6,Revenue
2024-06-13,8.258423003619059e6,Revenue
2024-06-14,8.30836748708942e6,Revenue
2024-06-15,8.358424186466312e6,Revenue
2024-06-16,8.408147898007534e6,Revenue
2024-06-17,8.458240090367455e6,Revenue
2024-06-18,8.509892089558411e6,Revenue
2024-06-19,8.561522901053134e6,Revenue
2024-06-20,8.611463092242062e6,Revenue
2024-06-21,8.66183891499682e6,Revenue
2024-06-22,8.712743932301385e6,Revenue
2024-06-23,8.762478716409367e6,Revenue
2024-06-24,8.812310911509354e6,Revenue
2024-06-25,8.862936148160823e6,Revenue
2024-06-26,8.913436107866019e6,Revenue
2024-06-27,8.962421416533988e6,Revenue
2024-06-28,9.011736095968649e6,Revenue
2024-06-29,9.062307353596196e6,Revenue
2024-06-30,9.110505881917203e6,Revenue

</script><script type="text/plain" id="sales_data" data-format="csv_embedded" data-src="">
Month,Sales,Year
1,120,2022
2,135,2022
3,150,2022
4,145,2022
5,160,2022
6,175,2022
7,190,2022
8,185,2022
9,200,2022
10,210,2022
11,230,2022
12,250,2022
1,130,2023
2,145,2023
3,165,2023
4,160,2023
5,180,2023
6,195,2023
7,210,2023
8,205,2023
9,220,2023
10,235,2023
11,255,2023
12,280,2023
1,145,2024
2,165,2024
3,185,2024
4,180,2024
5,200,2024
6,220,2024
7,240,2024
8,235,2024
9,250,2024
10,270,2024
11,290,2024
12,320,2024

</script><script type="text/plain" id="multi_data" data-format="csv_embedded" data-src="">
time_hours,time_halfhours,temperature_celsius,temperature_fahrenheit,humidity_percent,pressure_hpa,location,color
1,0.5,17.00908364026573,65.52695465388216,82.7258882117852,1017.6999242549293,Station A,default
2,1.0,19.545398283881106,69.2887036905014,66.93987156787692,1016.0990448304884,Station A,default
3,1.5,20.81532641327163,73.08527054524605,79.58334890506623,1018.0258699300289,Station A,default
4,2.0,21.695405375485425,71.13709889771961,81.2776356051343,1015.5612134358211,Station A,default
5,2.5,23.478413519767667,74.39871368012074,61.05338365788254,1015.4921777483594,Station A,default
6,3.0,23.364371549389734,75.58237141506365,63.09967226718029,1013.6730296367923,Station A,default
7,3.5,22.832970610128335,70.92091663981489,53.27517104182817,1017.6073602887624,Station A,default
8,4.0,22.29792795463947,70.88085353917747,44.4672087254775,1015.3078198189928,Station A,default
9,4.5,20.716128006842006,72.92338523822166,48.449210233399434,1013.9734282663394,Station A,default
10,5.0,19.796908522847026,68.59349848421031,36.65891622346502,1016.14408562564,Station A,default
11,5.5,16.14713449502772,61.948997203982046,44.79507465174446,1012.8513499231789,Station A,default
12,6.0,14.89928797449104,58.47337780525872,38.504149368431065,1008.6353866109811,Station A,default
13,6.5,13.820182779076939,54.19776407812592,43.41221428234027,1007.1513938667658,Station A,default
14,7.0,9.717150086810085,52.5597293779077,37.01964293160971,1007.715240400576,Station A,default
15,7.5,11.514462509421856,49.89212918954024,49.481465997975256,1009.2219874668866,Station A,default
16,8.0,8.651813686822686,44.57481471939765,47.385496827850595,1008.6924759951937,Station A,default
17,8.5,5.770832854522892,46.56051707176079,53.430276523705125,1005.136527619954,Station A,default
18,9.0,6.688294636537305,43.46764904156103,57.12586958507508,1007.0097845455153,Station A,default
19,9.5,7.7600592187692,45.18355725884711,62.43823258007937,1005.8506061607951,Station A,default
20,10.0,7.212479040428629,46.564597030662114,70.66867092412086,1012.2692447731442,Station A,default
21,10.5,9.929591658958033,50.05411798816597,70.53605785341779,1012.9420254874059,Station A,default
22,11.0,10.3796782438551,52.527544428823624,80.28727365873407,1013.2265674172484,Station A,default
23,11.5,12.626659499821411,53.975895765346976,76.14763549988064,1017.1881382148124,Station A,default
24,12.0,14.976902772397546,56.61843019454348,87.09323236125721,1014.9375876517355,Station A,default

</script><script type="text/plain" id="continuous_filter_data" data-format="csv_embedded" data-src="">
Month,Sales,Profit_Margin,Units,Product,Region
1,84371.0584872796,47.612502252168355,901.5722464052214,Widget,North
2,123350.55777327913,29.95701087459849,283.06764249563514,Widget,North
3,134119.1236788116,26.677145966588032,886.8407785019584,Widget,North
4,111272.49025964597,37.220890344978,599.5861668948528,Widget,North
5,147500.15315993645,16.764193861272766,307.2231463367196,Widget,North
6,75470.12423166423,42.51114804724943,211.11647014177444,Widget,North
7,84109.50995597302,12.821710075012687,232.69754458285863,Widget,North
8,103087.54458792834,25.52576442301631,960.6051462121211,Widget,North
9,148750.67066686595,40.83439712801355,134.3919141223557,Widget,North
10,61219.36438339133,41.54811919443538,264.2820556974651,Widget,North
11,59830.94506263829,32.19424811485434,578.8648633329042,Widget,North
12,130236.78302234528,48.70494064403215,417.9141296737961,Widget,North
1,115100.42383260769,32.23943117936631,254.2188424733496,Widget,South
2,87442.56138858301,24.150923172405825,797.8442807581459,Widget,South
3,107385.83201433832,19.199477223018867,584.2225383265402,Widget,South
4,106423.87630027226,26.91332180225861,634.0460991347654,Widget,South
5,110154.2008551331,25.921635021834703,331.0030440831245,Widget,South
6,92553.67533331612,33.55968908437586,724.7244186608657,Widget,South
7,133917.6270750171,6.438302861699967,598.8172241986849,Widget,South
8,142746.43121693953,39.66740647673267,445.4013880995269,Widget,South
9,127260.89855632593,8.745775187762334,868.2024945215064,Widget,South
10,125479.88413436171,41.4642347261204,343.2121231221289,Widget,South
11,98620.82405826429,21.402747097382377,192.28031671022308,Widget,South
12,61003.21210073412,25.165369099582108,450.99047417206344,Widget,South
1,52048.926614210766,31.210965601172653,697.2312054259755,Widget,East
2,107790.31825705549,45.055112764163454,138.5712759047943,Widget,East
3,79851.22580764441,28.699807100321316,835.6158218827485,Widget,East
4,85026.78861819455,37.860070099977406,604.1558348732564,Widget,East
5,54425.01468253471,7.2562587041824775,394.64807908805875,Widget,East
6,56217.494091881636,45.23006255419931,926.9063866664444,Widget,East
7,105855.746266728,36.46441167958443,406.4075319141033,Widget,East
8,123444.49937503874,39.48822927489967,402.38992770258056,Widget,East
9,61544.57649239256,5.284191816018071,661.7594591102811,Widget,East
10,119267.13037681869,9.685594535189937,505.0226096423677,Widget,East
11,99471.95182172488,41.90479867839563,585.8285197786514,Widget,East
12,71582.84074413581,49.13048571195816,746.9446798374254,Widget,East
1,96458.38306304239,34.89159980251687,716.2603745490314,Widget,West
2,101102.4438327436,15.416739887617156,999.0845814117612,Widget,West
3,148776.41696578555,18.831635627014172,802.0935104814557,Widget,West
4,52850.116619724766,40.81530063162036,167.23933133166537,Widget,West
5,63929.10528774456,28.492564036544184,192.41692250956586,Widget,West
6,122152.82245459218,6.0733444713906675,759.161808967126,Widget,West
7,126968.92024044544,12.309572443022825,166.12184174822625,Widget,West
8,148513.53407338628,39.58311746193262,888.2280260295732,Widget,West
9,113102.79072125902,23.547739173678437,659.8713213093368,Widget,West
10,70113.02028201039,34.62574595864013,289.9832341401609,Widget,West
11,125807.53939063543,25.42295026101817,734.6887147649724,Widget,West
12,115232.14961456566,19.581303419339704,260.63575391007157,Widget,West
1,69404.04903830591,46.3469951574891,160.6214681201477,Gadget,North
2,77806.90150329062,11.384193752605967,689.4176551885503,Gadget,North
3,82277.99955359152,36.801561576937765,350.55441345831133,Gadget,North
4,96939.56072125427,10.631592591969914,521.0312259643822,Gadget,North
5,140086.52084571274,17.34203960928579,717.81457492655,Gadget,North
6,56185.29621711363,32.2450685830316,534.7944859525841,Gadget,North
7,123468.96639767424,33.1608421274121,422.84519603565525,Gadget,North
8,91565.85449722923,40.29674700093301,167.09609890695492,Gadget,North
9,118778.52790925343,11.315676203236618,966.1318663181951,Gadget,North
10,76810.16081280363,44.51699074127426,721.0799718842725,Gadget,North
11,121349.26367983021,33.21730631503051,623.5482230218496,Gadget,North
12,105144.42541159477,20.125602063243974,771.1724914338437,Gadget,North
1,77488.35157223954,44.864186130093806,545.111103125896,Gadget,South
2,62803.30421200246,19.84947700890683,942.4496730254908,Gadget,South
3,131530.62460646976,35.92013171281954,737.7662681953456,Gadget,South
4,69756.1844099359,11.42111857184687,435.06160665809057,Gadget,South
5,109096.20919514901,46.566538979594654,139.73444342872983,Gadget,South
6,120732.57014359337,7.405172800748878,274.1728632103915,Gadget,South
7,119439.43110098872,31.22209341558439,913.4787600083686,Gadget,South
8,106963.4964387685,27.146225951477795,917.7028281276547,Gadget,South
9,60462.193443561875,7.646529088852928,594.0024585230826,Gadget,South
10,92699.8674596984,22.27366408894,718.371999269346,Gadget,South
11,143030.5165511925,22.448277207010754,685.5690489273715,Gadget,South
12,51288.503580597,46.84698177995575,887.2611447575118,Gadget,South
1,78244.71599565959,31.15486819495249,963.0483708893618,Gadget,East
2,108269.81944005116,38.23148808112855,911.1050017498782,Gadget,East
3,110172.03254687993,32.46908146492406,934.8222553638559,Gadget,East
4,140001.64184776193,27.98021705027487,167.40324635154707,Gadget,East
5,114071.5514354246,39.59365071633859,460.77360662805637,Gadget,East
6,55566.88842173716,24.20115178621219,349.74737950604066,Gadget,East
7,129524.74667925741,27.384189076337197,425.6756423586741,Gadget,East
8,71852.08503134025,17.68898745202182,396.37060703241747,Gadget,East
9,128377.89239827129,49.17275186658348,283.17880521785037,Gadget,East
10,105960.30533999842,13.371312700802985,436.5280553048571,Gadget,East
11,57523.76971446884,40.2343628172267,464.9497010301449,Gadget,East
12,143680.03264925902,38.849784376746484,430.2502928250715,Gadget,East
1,107594.67726517815,19.595287386537947,595.0301430705832,Gadget,West
2,67842.99459752195,30.835104373152255,816.6846746599471,Gadget,West
3,149977.9851320424,6.804575270353441,728.0426340177145,Gadget,West
4,76092.62451320393,43.52087393045126,148.74266510638134,Gadget,West
5,76822.05434761246,12.886669579727997,882.2419341099655,Gadget,West
6,74307.41516015238,24.802460866939143,995.1484755141983,Gadget,West
7,102779.54207730522,30.620143621012808,746.022438601955,Gadget,West
8,134446.111387073,48.17524942035108,134.36714783273098,Gadget,West
9,116010.06118214759,39.8721081542559,233.71109932627567,Gadget,West
10,77181.38160762351,11.37394319888621,481.09809605547025,Gadget,West
11,138792.36943356466,22.392881147787115,920.8716038738357,Gadget,West
12,69638.87053012304,23.877961717612834,873.0731637093891,Gadget,West
1,141215.6239047376,19.841515328612537,591.4390046171841,Doohickey,North
2,136022.3542767605,27.201542254880756,135.62361699061597,Doohickey,North
3,98609.3132100261,34.77055558945189,122.16182098959561,Doohickey,North
4,80145.10941306093,11.233250410270017,249.86286335140852,Doohickey,North
5,65527.45669243341,25.949421354232594,625.2979997207336,Doohickey,North
6,144086.34578636978,20.11552628833727,953.2091163632081,Doohickey,North
7,127584.44090529426,25.586701069597638,477.87650919757544,Doohickey,North
8,117356.98933039527,21.96455305170022,482.19908685261134,Doohickey,North
9,66575.2560081155,12.94965627527549,408.578347133153,Doohickey,North
10,79766.00528050486,22.677317575991562,788.1145212215093,Doohickey,North
11,103176.2020749631,17.699736907994627,411.6999005946509,Doohickey,North
12,113421.9738437937,12.67571482072718,825.6174141084408,Doohickey,North
1,59723.9010210336,14.951731974501184,430.42087001774365,Doohickey,South
2,94767.35747306154,19.832782935648737,869.3505393659547,Doohickey,South
3,79760.6228812834,10.3376818545911,653.3861090362296,Doohickey,South
4,60527.33424479102,20.18561971033047,762.1246608547364,Doohickey,South
5,97495.53442310193,34.4944558541946,554.7124796514354,Doohickey,South
6,134090.4147222407,10.024963881445629,539.2466557235883,Doohickey,South
7,67470.54169130087,25.74655832326522,360.0262570363614,Doohickey,South
8,70478.63185854143,7.359074091353359,610.5830224541621,Doohickey,South
9,100627.44126490106,38.34891918492216,199.98549990884726,Doohickey,South
10,87877.90122312853,42.30628045807469,479.0717287513318,Doohickey,South
11,57499.81104265967,49.48453411911737,285.7773752970696,Doohickey,South
12,87039.4627362619,20.840315645247323,961.3938940442865,Doohickey,South
1,141196.71461391356,34.58831016947762,907.3049011995784,Doohickey,East
2,110416.05412816806,8.137189989584552,147.5706401950265,Doohickey,East
3,67426.06600321931,13.834229281639454,809.8210434913602,Doohickey,East
4,133840.68982934603,14.314239251218204,568.797331515208,Doohickey,East
5,84740.58266818195,18.816967632706586,285.64588675681773,Doohickey,East
6,53177.99871373761,28.834782568079007,633.4446814629802,Doohickey,East
7,145956.9743093212,36.97824069193587,625.2345128199034,Doohickey,East
8,55335.63553009959,27.855966353746382,390.6520866110526,Doohickey,East
9,63753.62959597961,11.64742639563466,272.06438240903395,Doohickey,East
10,54410.48387153185,45.200659133445726,694.2032875316124,Doohickey,East
11,110983.6152806067,41.75152350290753,949.392387204171,Doohickey,East
12,92145.23250427318,20.26852656166964,718.1088957721859,Doohickey,East
1,79904.29169902825,24.65405089263026,851.7415413319676,Doohickey,West
2,125984.33345720403,21.734059824538868,311.0751100172316,Doohickey,West
3,64879.39379075269,45.81222894004783,267.19143053758336,Doohickey,West
4,130062.77826988962,17.580179136475152,426.5459441763175,Doohickey,West
5,51085.87393624287,13.104933138674234,867.4584515361199,Doohickey,West
6,147426.1641030495,27.786724382985312,424.08700669771486,Doohickey,West
7,120638.0209758821,39.36911510677357,276.29550575723437,Doohickey,West
8,84715.00533803293,46.763480479814014,376.9785983714326,Doohickey,West
9,109656.12215743578,45.79468300551243,802.1348067247274,Doohickey,West
10,88411.30542451664,6.807111046835605,775.9610166378674,Doohickey,West
11,67054.94446844497,29.624831999532926,816.8386019728241,Doohickey,West
12,133628.60708046806,32.39766719670709,186.2857729434148,Doohickey,West

</script><script type="text/plain" id="dynamic_data" data-format="csv_embedded" data-src="">
Month,Return,Stock,Strategy,Region
1,4.413705028490672,AAPL,Buy,US
2,4.195952531862489,AAPL,Buy,US
3,6.082358356937364,AAPL,Buy,US
4,2.98761130567483,AAPL,Buy,US
5,10.934088150974722,AAPL,Buy,US
6,-1.0961158361086394,AAPL,Buy,US
7,7.571243686114777,AAPL,Buy,US
8,5.787882442753821,AAPL,Buy,US
9,5.8308448746357975,AAPL,Buy,US
10,4.214472862486859,AAPL,Buy,US
11,5.969438528078188,AAPL,Buy,US
12,6.233567550763581,AAPL,Buy,US
1,2.8317511971632676,AAPL,Buy,EU
2,5.552710536869115,AAPL,Buy,EU
3,2.721181580173638,AAPL,Buy,EU
4,-0.22198024838270702,AAPL,Buy,EU
5,9.6174614762655,AAPL,Buy,EU
6,5.448503360716944,AAPL,Buy,EU
7,4.020945326363821,AAPL,Buy,EU
8,8.639836843578612,AAPL,Buy,EU
9,7.79476382977988,AAPL,Buy,EU
10,5.612009015568591,AAPL,Buy,EU
11,10.1722620528998,AAPL,Buy,EU
12,4.6647070899579965,AAPL,Buy,EU
1,5.9440422730813705,AAPL,Buy,ASIA
2,1.2373197179320006,AAPL,Buy,ASIA
3,8.601748717430166,AAPL,Buy,ASIA
4,6.999727148902066,AAPL,Buy,ASIA
5,3.1495118086787057,AAPL,Buy,ASIA
6,5.661343912725663,AAPL,Buy,ASIA
7,4.697033988010728,AAPL,Buy,ASIA
8,7.03288079227276,AAPL,Buy,ASIA
9,11.15500411443167,AAPL,Buy,ASIA
10,3.8080298498619545,AAPL,Buy,ASIA
11,10.186979686611265,AAPL,Buy,ASIA
12,7.647603187184958,AAPL,Buy,ASIA
1,5.529543706978931,AAPL,Sell,US
2,6.824580484911322,AAPL,Sell,US
3,6.8204212050025514,AAPL,Sell,US
4,7.010847616564755,AAPL,Sell,US
5,7.432613551804735,AAPL,Sell,US
6,1.6501551264196683,AAPL,Sell,US
7,7.305511162085799,AAPL,Sell,US
8,4.100151980684349,AAPL,Sell,US
9,5.7110082928933785,AAPL,Sell,US
10,5.10400569906176,AAPL,Sell,US
11,8.003758396410586,AAPL,Sell,US
12,7.119610117069893,AAPL,Sell,US
1,3.515534515911259,AAPL,Sell,EU
2,4.888545172603631,AAPL,Sell,EU
3,1.3740934699308776,AAPL,Sell,EU
4,7.503951783402041,AAPL,Sell,EU
5,5.669942087144343,AAPL,Sell,EU
6,6.627960388789075,AAPL,Sell,EU
7,5.632531185471783,AAPL,Sell,EU
8,5.893804006589438,AAPL,Sell,EU
9,11.401713308974537,AAPL,Sell,EU
10,5.406999432544249,AAPL,Sell,EU
11,10.281618232126217,AAPL,Sell,EU
12,6.359640650401968,AAPL,Sell,EU
1,0.20116877423562673,AAPL,Sell,ASIA
2,5.908208401184913,AAPL,Sell,ASIA
3,8.264535105501732,AAPL,Sell,ASIA
4,7.264925811677672,AAPL,Sell,ASIA
5,1.1140392204873641,AAPL,Sell,ASIA
6,8.651144773160025,AAPL,Sell,ASIA
7,3.1838443292763383,AAPL,Sell,ASIA
8,11.400695326456566,AAPL,Sell,ASIA
9,1.3140981116255683,AAPL,Sell,ASIA
10,1.0754039535711646,AAPL,Sell,ASIA
11,7.551112607866601,AAPL,Sell,ASIA
12,7.458080416762067,AAPL,Sell,ASIA
1,3.2506528370631065,AAPL,Hold,US
2,3.4107833111664263,AAPL,Hold,US
3,-0.6236487870658833,AAPL,Hold,US
4,1.1903165239987104,AAPL,Hold,US
5,5.2074501616014315,AAPL,Hold,US
6,9.959051768101922,AAPL,Hold,US
7,8.253237654337093,AAPL,Hold,US
8,4.4931952639425115,AAPL,Hold,US
9,3.6650675027436037,AAPL,Hold,US
10,-2.3668521350184664,AAPL,Hold,US
11,4.627308886490073,AAPL,Hold,US
12,6.795378167105897,AAPL,Hold,US
1,7.782946080429879,AAPL,Hold,EU
2,7.6363485087376946,AAPL,Hold,EU
3,2.703969792264536,AAPL,Hold,EU
4,5.494803105358429,AAPL,Hold,EU
5,6.514553160184588,AAPL,Hold,EU
6,2.6112931102347265,AAPL,Hold,EU
7,3.716400897260463,AAPL,Hold,EU
8,5.93618407070992,AAPL,Hold,EU
9,7.410583800843131,AAPL,Hold,EU
10,-0.15030994962191468,AAPL,Hold,EU
11,8.411831934183084,AAPL,Hold,EU
12,5.131288921015302,AAPL,Hold,EU
1,5.949548233036799,AAPL,Hold,ASIA
2,7.658973746251426,AAPL,Hold,ASIA
3,7.4930123380012414,AAPL,Hold,ASIA
4,2.4571535869010623,AAPL,Hold,ASIA
5,4.244962822803871,AAPL,Hold,ASIA
6,2.6211322394644814,AAPL,Hold,ASIA
7,4.204628437645843,AAPL,Hold,ASIA
8,6.897263080883318,AAPL,Hold,ASIA
9,6.812540047605156,AAPL,Hold,ASIA
10,7.2754094681195545,AAPL,Hold,ASIA
11,13.597824261208254,AAPL,Hold,ASIA
12,6.972778422421081,AAPL,Hold,ASIA
1,6.379106105263135,GOOGL,Buy,US
2,10.066883971494114,GOOGL,Buy,US
3,-0.5435963511158444,GOOGL,Buy,US
4,6.238633909500864,GOOGL,Buy,US
5,4.865785108251604,GOOGL,Buy,US
6,4.702519361107088,GOOGL,Buy,US
7,4.946077204579821,GOOGL,Buy,US
8,5.356379569568014,GOOGL,Buy,US
9,2.888073534239897,GOOGL,Buy,US
10,2.555976644859851,GOOGL,Buy,US
11,8.68885803930991,GOOGL,Buy,US
12,2.2637914880107806,GOOGL,Buy,US
1,5.537670907524962,GOOGL,Buy,EU
2,7.558286839057117,GOOGL,Buy,EU
3,7.228704195233112,GOOGL,Buy,EU
4,0.19924687645012773,GOOGL,Buy,EU
5,2.8856850014108133,GOOGL,Buy,EU
6,0.8182261859681148,GOOGL,Buy,EU
7,7.553563405407313,GOOGL,Buy,EU
8,-2.0026631072424137,GOOGL,Buy,EU
9,9.047184882503945,GOOGL,Buy,EU
10,10.226612660082651,GOOGL,Buy,EU
11,5.148661436188412,GOOGL,Buy,EU
12,5.253482704074757,GOOGL,Buy,EU
1,3.349456830627516,GOOGL,Buy,ASIA
2,9.336630123982925,GOOGL,Buy,ASIA
3,7.361251287524931,GOOGL,Buy,ASIA
4,13.99737322798437,GOOGL,Buy,ASIA
5,4.243113885717525,GOOGL,Buy,ASIA
6,3.0591965076734082,GOOGL,Buy,ASIA
7,6.4954992385480494,GOOGL,Buy,ASIA
8,9.578944058495443,GOOGL,Buy,ASIA
9,8.788809593902712,GOOGL,Buy,ASIA
10,9.8246399055053,GOOGL,Buy,ASIA
11,2.0415410412868367,GOOGL,Buy,ASIA
12,7.208730619045364,GOOGL,Buy,ASIA
1,5.565560273256144,GOOGL,Sell,US
2,1.1068842780016672,GOOGL,Sell,US
3,5.377300562682102,GOOGL,Sell,US
4,5.63991366618438,GOOGL,Sell,US
5,14.590899566853981,GOOGL,Sell,US
6,3.5432048012414645,GOOGL,Sell,US
7,6.999964987019754,GOOGL,Sell,US
8,3.611074528396304,GOOGL,Sell,US
9,7.539275143375217,GOOGL,Sell,US
10,7.9084345785108665,GOOGL,Sell,US
11,7.442561040653148,GOOGL,Sell,US
12,6.465202467859304,GOOGL,Sell,US
1,-1.694858472481763,GOOGL,Sell,EU
2,0.4700378104647458,GOOGL,Sell,EU
3,1.567337996986601,GOOGL,Sell,EU
4,7.1360777471690255,GOOGL,Sell,EU
5,7.340748100358499,GOOGL,Sell,EU
6,4.6351918750884025,GOOGL,Sell,EU
7,6.583212989480145,GOOGL,Sell,EU
8,4.053433139371082,GOOGL,Sell,EU
9,3.939427270380012,GOOGL,Sell,EU
10,7.366510090203092,GOOGL,Sell,EU
11,-0.29526015031997854,GOOGL,Sell,EU
12,7.125923765176292,GOOGL,Sell,EU
1,1.2782784786275285,GOOGL,Sell,ASIA
2,5.288272214709318,GOOGL,Sell,ASIA
3,4.783150205349697,GOOGL,Sell,ASIA
4,8.653119350839665,GOOGL,Sell,ASIA
5,4.851386420482114,GOOGL,Sell,ASIA
6,5.5044599030797565,GOOGL,Sell,ASIA
7,0.5210523047412894,GOOGL,Sell,ASIA
8,1.8217987465051455,GOOGL,Sell,ASIA
9,3.7842331966846188,GOOGL,Sell,ASIA
10,5.459324135070419,GOOGL,Sell,ASIA
11,5.780794142758827,GOOGL,Sell,ASIA
12,8.22771922044016,GOOGL,Sell,ASIA
1,7.183414078828346,GOOGL,Hold,US
2,6.806421497490546,GOOGL,Hold,US
3,2.2177326341156776,GOOGL,Hold,US
4,7.859467596005047,GOOGL,Hold,US
5,2.5363746814102863,GOOGL,Hold,US
6,4.272789647439188,GOOGL,Hold,US
7,11.827164015495562,GOOGL,Hold,US
8,3.4846112263805145,GOOGL,Hold,US
9,8.329272532266856,GOOGL,Hold,US
10,8.953813690829636,GOOGL,Hold,US
11,6.731280385555193,GOOGL,Hold,US
12,5.747478804771909,GOOGL,Hold,US
1,-1.8169500226959059,GOOGL,Hold,EU
2,6.09981396402813,GOOGL,Hold,EU
3,3.0025837607368273,GOOGL,Hold,EU
4,0.31734543683899086,GOOGL,Hold,EU
5,2.545492753768916,GOOGL,Hold,EU
6,4.250988895421207,GOOGL,Hold,EU
7,-0.28839397605704137,GOOGL,Hold,EU
8,3.524687894248731,GOOGL,Hold,EU
9,4.737889045465439,GOOGL,Hold,EU
10,5.860104202397363,GOOGL,Hold,EU
11,7.173937183912464,GOOGL,Hold,EU
12,5.944305168374819,GOOGL,Hold,EU
1,4.948552061044724,GOOGL,Hold,ASIA
2,1.4176849885143572,GOOGL,Hold,ASIA
3,5.826192008696285,GOOGL,Hold,ASIA
4,0.5400015804052481,GOOGL,Hold,ASIA
5,7.700433574866509,GOOGL,Hold,ASIA
6,5.587899488021291,GOOGL,Hold,ASIA
7,5.928617122611622,GOOGL,Hold,ASIA
8,4.0478411424963845,GOOGL,Hold,ASIA
9,2.0812581353115864,GOOGL,Hold,ASIA
10,6.059079701911536,GOOGL,Hold,ASIA
11,6.2368318938837595,GOOGL,Hold,ASIA
12,7.733776515469728,GOOGL,Hold,ASIA
1,10.653921316791967,MSFT,Buy,US
2,1.9837149731855692,MSFT,Buy,US
3,7.533251285414229,MSFT,Buy,US
4,4.842053262841111,MSFT,Buy,US
5,2.466299477822935,MSFT,Buy,US
6,3.456915036403983,MSFT,Buy,US
7,7.3176640689828,MSFT,Buy,US
8,4.460378643255419,MSFT,Buy,US
9,0.41129131079684766,MSFT,Buy,US
10,-0.3724849472931606,MSFT,Buy,US
11,2.56438688074657,MSFT,Buy,US
12,8.465720405916008,MSFT,Buy,US
1,3.521923839334052,MSFT,Buy,EU
2,11.074114069824354,MSFT,Buy,EU
3,2.0602130867969564,MSFT,Buy,EU
4,8.7634600002572,MSFT,Buy,EU
5,6.737718981419681,MSFT,Buy,EU
6,4.365009684731177,MSFT,Buy,EU
7,5.993858807367601,MSFT,Buy,EU
8,1.6537276404641625,MSFT,Buy,EU
9,2.82561821587587,MSFT,Buy,EU
10,4.812036768496981,MSFT,Buy,EU
11,7.245547214354115,MSFT,Buy,EU
12,8.22188816733916,MSFT,Buy,EU
1,2.495896993447784,MSFT,Buy,ASIA
2,9.530804703775573,MSFT,Buy,ASIA
3,3.4843103786827343,MSFT,Buy,ASIA
4,5.220864120969002,MSFT,Buy,ASIA
5,6.6540395781517025,MSFT,Buy,ASIA
6,5.337200394217755,MSFT,Buy,ASIA
7,4.137728328857166,MSFT,Buy,ASIA
8,4.4148283096589855,MSFT,Buy,ASIA
9,2.732504338078184,MSFT,Buy,ASIA
10,5.610327715585493,MSFT,Buy,ASIA
11,7.779768787638934,MSFT,Buy,ASIA
12,8.959584964381598,MSFT,Buy,ASIA
1,-2.7351260999788556,MSFT,Sell,US
2,1.3895990820740194,MSFT,Sell,US
3,1.991895934382188,MSFT,Sell,US
4,0.5108946879755917,MSFT,Sell,US
5,0.6248670437221697,MSFT,Sell,US
6,6.512116819744887,MSFT,Sell,US
7,6.973438054451877,MSFT,Sell,US
8,4.892642729057241,MSFT,Sell,US
9,7.8286754333176685,MSFT,Sell,US
10,3.93462340162841,MSFT,Sell,US
11,1.3395070390086126,MSFT,Sell,US
12,2.991032463637316,MSFT,Sell,US
1,7.666029088405107,MSFT,Sell,EU
2,3.1482497794370445,MSFT,Sell,EU
3,8.719984211860242,MSFT,Sell,EU
4,-0.5968251889328501,MSFT,Sell,EU
5,2.890154197971709,MSFT,Sell,EU
6,7.463636925800331,MSFT,Sell,EU
7,5.7742839813888605,MSFT,Sell,EU
8,5.028010445261312,MSFT,Sell,EU
9,4.98273743284259,MSFT,Sell,EU
10,2.144798823165508,MSFT,Sell,EU
11,1.0035021448798247,MSFT,Sell,EU
12,4.229777508822353,MSFT,Sell,EU
1,1.0173873217960798,MSFT,Sell,ASIA
2,6.8550108155851985,MSFT,Sell,ASIA
3,4.961022287539128,MSFT,Sell,ASIA
4,4.432306361745165,MSFT,Sell,ASIA
5,6.6254861598637085,MSFT,Sell,ASIA
6,4.593719333346224,MSFT,Sell,ASIA
7,6.96986141634587,MSFT,Sell,ASIA
8,5.610911889687044,MSFT,Sell,ASIA
9,5.372611257278768,MSFT,Sell,ASIA
10,8.199809720127039,MSFT,Sell,ASIA
11,3.294084839060389,MSFT,Sell,ASIA
12,4.683154088895257,MSFT,Sell,ASIA
1,-0.2418711490249894,MSFT,Hold,US
2,-1.2316650969959422,MSFT,Hold,US
3,10.63909959254134,MSFT,Hold,US
4,3.714786128552888,MSFT,Hold,US
5,3.1650214562263415,MSFT,Hold,US
6,6.485888895808945,MSFT,Hold,US
7,4.7155729828709925,MSFT,Hold,US
8,6.700168316016739,MSFT,Hold,US
9,2.6938093792619795,MSFT,Hold,US
10,-1.3332978300048668,MSFT,Hold,US
11,2.74981631987169,MSFT,Hold,US
12,10.401709486553258,MSFT,Hold,US
1,1.0381065840481103,MSFT,Hold,EU
2,5.327670157408,MSFT,Hold,EU
3,4.911237637645593,MSFT,Hold,EU
4,5.5474359654238325,MSFT,Hold,EU
5,0.8826370026337338,MSFT,Hold,EU
6,7.110899005626532,MSFT,Hold,EU
7,4.3565980089607,MSFT,Hold,EU
8,6.712485242094992,MSFT,Hold,EU
9,6.690630979506009,MSFT,Hold,EU
10,4.970718657384532,MSFT,Hold,EU
11,8.334868676514834,MSFT,Hold,EU
12,2.804220150934441,MSFT,Hold,EU
1,8.285417398286164,MSFT,Hold,ASIA
2,-3.3361364169578147,MSFT,Hold,ASIA
3,5.87920259925483,MSFT,Hold,ASIA
4,6.506803422223746,MSFT,Hold,ASIA
5,7.798407765797319,MSFT,Hold,ASIA
6,6.448954244137774,MSFT,Hold,ASIA
7,4.086938789541423,MSFT,Hold,ASIA
8,4.90462159775612,MSFT,Hold,ASIA
9,1.8256021465193668,MSFT,Hold,ASIA
10,2.1596683316820737,MSFT,Hold,ASIA
11,12.595094729512319,MSFT,Hold,ASIA
12,13.07711235726645,MSFT,Hold,ASIA

</script><script type="text/plain" id="facet_data" data-format="csv_embedded" data-src="">
Month,Sales,Product,Region,color
1,147.47067733263407,Product A,North,North
2,139.01637258057025,Product A,North,North
3,124.2702716144009,Product A,North,North
4,136.61319543228186,Product A,North,North
5,166.5233366230693,Product A,North,North
6,164.58512098052572,Product A,North,North
7,170.98444446629827,Product A,North,North
8,136.41668071555176,Product A,North,North
9,176.2524587682287,Product A,North,North
10,158.67626425858003,Product A,North,North
11,184.99107585071508,Product A,North,North
12,201.58319859070474,Product A,North,North
1,101.60635325286252,Product A,South,South
2,148.80637482331525,Product A,South,South
3,127.3622642643724,Product A,South,South
4,150.19005423598662,Product A,South,South
5,149.8986774698636,Product A,South,South
6,130.86860132538214,Product A,South,South
7,174.1305551446788,Product A,South,South
8,143.5050981833848,Product A,South,South
9,153.3436328427996,Product A,South,South
10,161.25014360281386,Product A,South,South
11,189.7860506504099,Product A,South,South
12,201.16307109378317,Product A,South,South
1,123.94118238204771,Product A,East,East
2,141.96115139734812,Product A,East,East
3,120.68964221500181,Product A,East,East
4,142.80166354262047,Product A,East,East
5,166.9070903599692,Product A,East,East
6,172.17870025571867,Product A,East,East
7,149.11783925384546,Product A,East,East
8,175.23876402794585,Product A,East,East
9,162.77071430871138,Product A,East,East
10,175.36458140809253,Product A,East,East
11,197.7652429562071,Product A,East,East
12,187.49995557784285,Product A,East,East
1,133.45734802444028,Product A,West,West
2,114.08652912617745,Product A,West,West
3,130.87242492326303,Product A,West,West
4,154.74411685755462,Product A,West,West
5,159.0834176537349,Product A,West,West
6,166.47076617495915,Product A,West,West
7,176.70665404317373,Product A,West,West
8,135.05154326345857,Product A,West,West
9,147.22821614197483,Product A,West,West
10,154.4794039806451,Product A,West,West
11,168.69405820126295,Product A,West,West
12,193.33672383801724,Product A,West,West
1,128.86293618930694,Product B,North,North
2,154.17023282559725,Product B,North,North
3,145.2138035966246,Product B,North,North
4,135.54660233232318,Product B,North,North
5,127.78933360060817,Product B,North,North
6,150.58888555147576,Product B,North,North
7,143.69309589437833,Product B,North,North
8,146.49357070454266,Product B,North,North
9,183.65799548208548,Product B,North,North
10,190.70038658434277,Product B,North,North
11,185.3236442046341,Product B,North,North
12,178.78057225144073,Product B,North,North
1,145.4814114327472,Product B,South,South
2,107.53810256623811,Product B,South,South
3,126.07288360044278,Product B,South,South
4,116.5692203225536,Product B,South,South
5,127.44300235997675,Product B,South,South
6,150.74861535733461,Product B,South,South
7,145.6376346060346,Product B,South,South
8,172.85601315368234,Product B,South,South
9,186.5494642314958,Product B,South,South
10,190.737046251929,Product B,South,South
11,161.07148106506196,Product B,South,South
12,185.27112860288963,Product B,South,South
1,138.84802080756793,Product B,East,East
2,146.00752085425847,Product B,East,East
3,119.08722526721917,Product B,East,East
4,117.03799370394844,Product B,East,East
5,127.99778570842507,Product B,East,East
6,129.49103649896892,Product B,East,East
7,164.9632541854918,Product B,East,East
8,150.63433524165416,Product B,East,East
9,182.9861804529088,Product B,East,East
10,170.54829952405447,Product B,East,East
11,175.76370501234703,Product B,East,East
12,168.6620608991382,Product B,East,East
1,117.28259499801302,Product B,West,West
2,131.5625870382897,Product B,West,West
3,113.11392133511846,Product B,West,West
4,151.02309300072767,Product B,West,West
5,125.50199998889767,Product B,West,West
6,128.2991908480613,Product B,West,West
7,155.97891882200798,Product B,West,West
8,163.5081140242035,Product B,West,West
9,150.11666094555545,Product B,West,West
10,174.1564400607353,Product B,West,West
11,164.45918588701383,Product B,West,West
12,181.94773232312752,Product B,West,West
1,103.46448058901902,Product C,North,North
2,127.28145436384014,Product C,North,North
3,145.1497384709465,Product C,North,North
4,122.45113352435942,Product C,North,North
5,138.69802634790662,Product C,North,North
6,142.41290653619848,Product C,North,North
7,173.52720341799548,Product C,North,North
8,135.21599475247575,Product C,North,North
9,144.69053145911795,Product C,North,North
10,154.94403300529189,Product C,North,North
11,159.6183592745715,Product C,North,North
12,157.25108219734352,Product C,North,North
1,123.72283455233139,Product C,South,South
2,123.67931394295204,Product C,South,South
3,134.57887965621143,Product C,South,South
4,153.937778143659,Product C,South,South
5,121.71451246602692,Product C,South,South
6,148.38325495471855,Product C,South,South
7,152.61406963081112,Product C,South,South
8,154.87175677752367,Product C,South,South
9,154.91881315149274,Product C,South,South
10,163.98467142434077,Product C,South,South
11,189.91714661934617,Product C,South,South
12,189.7985754056761,Product C,South,South
1,132.90506435069275,Product C,East,East
2,109.98309288234915,Product C,East,East
3,128.54956118066946,Product C,East,East
4,131.45060980022518,Product C,East,East
5,156.33618461151949,Product C,East,East
6,125.24890921499968,Product C,East,East
7,130.45345115474248,Product C,East,East
8,183.2738277455859,Product C,East,East
9,169.7872247898336,Product C,East,East
10,168.84446565843132,Product C,East,East
11,158.4348159404313,Product C,East,East
12,200.70955167032935,Product C,East,East
1,147.1428965829283,Product C,West,West
2,123.25726186025699,Product C,West,West
3,147.1507966391107,Product C,West,West
4,115.95235781343064,Product C,West,West
5,156.70827421781223,Product C,West,West
6,133.53617054261971,Product C,West,West
7,155.44707415352732,Product C,West,West
8,141.16573066389861,Product C,West,West
9,171.10939627310745,Product C,West,West
10,177.84009771113818,Product C,West,West
11,153.8341975213385,Product C,West,West
12,183.47288182364377,Product C,West,West
1,127.78701347327996,Product D,North,North
2,127.7346730313302,Product D,North,North
3,157.6342330943199,Product D,North,North
4,140.27084637843978,Product D,North,North
5,134.67947546140897,Product D,North,North
6,138.3559612550788,Product D,North,North
7,159.9002614149651,Product D,North,North
8,179.06760362783848,Product D,North,North
9,178.27713930290173,Product D,North,North
10,154.25073346357888,Product D,North,North
11,162.06368727243319,Product D,North,North
12,203.0127737800723,Product D,North,North
1,106.61729896675429,Product D,South,South
2,122.6223262223705,Product D,South,South
3,148.19971958001747,Product D,South,South
4,141.34084966119184,Product D,South,South
5,139.02810166091146,Product D,South,South
6,154.03939560950633,Product D,South,South
7,163.07926010886706,Product D,South,South
8,181.07566294456893,Product D,South,South
9,166.24963552850525,Product D,South,South
10,170.24165786099053,Product D,South,South
11,181.5601579139266,Product D,South,South
12,180.40866840908456,Product D,South,South
1,121.41181764260216,Product D,East,East
2,142.82920729980634,Product D,East,East
3,147.17825697148317,Product D,East,East
4,133.9837953243968,Product D,East,East
5,143.73248679358426,Product D,East,East
6,159.9353497653037,Product D,East,East
7,168.8868716786574,Product D,East,East
8,178.5357888614418,Product D,East,East
9,173.42770739107328,Product D,East,East
10,192.45699097654494,Product D,East,East
11,189.108833013626,Product D,East,East
12,170.10315308500853,Product D,East,East
1,132.39723152917355,Product D,West,West
2,107.58194408256239,Product D,West,West
3,110.13818668299344,Product D,West,West
4,159.96995224311536,Product D,West,West
5,149.30686060185621,Product D,West,West
6,126.71977691604118,Product D,West,West
7,160.05791077428367,Product D,West,West
8,181.16487835812228,Product D,West,West
9,162.05290742784445,Product D,West,West
10,150.52166825286494,Product D,West,West
11,189.22406807564948,Product D,West,West
12,156.12918169756023,Product D,West,West

</script><script type="text/plain" id="agg_data" data-format="csv_embedded" data-src="">
Month,Sales,Product,color
1,154.60342962640883,Product A,Product A
1,121.22238623162559,Product A,Product A
1,147.5179808418493,Product A,Product A
1,144.53097514739895,Product A,Product A
1,118.19467772565741,Product A,Product A
2,113.52203937700988,Product A,Product A
2,135.58350218833448,Product A,Product A
2,141.59506689558066,Product A,Product A
2,110.55440396761257,Product A,Product A
2,121.37423861659988,Product A,Product A
3,143.23595346820605,Product A,Product A
3,153.0752774948302,Product A,Product A
3,119.40211229165007,Product A,Product A
3,148.28581891347835,Product A,Product A
3,138.1166806573174,Product A,Product A
4,123.55474772022608,Product A,Product A
4,147.66269097187848,Product A,Product A
4,126.27439567513977,Product A,Product A
4,137.93704810870025,Product A,Product A
4,161.59042389219374,Product A,Product A
5,152.3429220413495,Product A,Product A
5,146.49862721428298,Product A,Product A
5,158.9757653202371,Product A,Product A
5,142.75861587725623,Product A,Product A
5,159.80583119840458,Product A,Product A
6,130.62891548998215,Product A,Product A
6,148.88409322297224,Product A,Product A
6,149.16464120606494,Product A,Product A
6,166.89738534255133,Product A,Product A
6,169.8326170373554,Product A,Product A
7,173.03443489459102,Product A,Product A
7,160.76490632461946,Product A,Product A
7,143.3458748854339,Product A,Product A
7,143.18409386396604,Product A,Product A
7,140.0497922204147,Product A,Product A
8,156.16527311584787,Product A,Product A
8,167.3195134182836,Product A,Product A
8,144.66874250147148,Product A,Product A
8,177.40439842076432,Product A,Product A
8,164.4789212846172,Product A,Product A
9,149.50607867006744,Product A,Product A
9,172.10609990410023,Product A,Product A
9,157.75141045465585,Product A,Product A
9,153.75352242538568,Product A,Product A
9,193.39387913839997,Product A,Product A
10,160.90895671406284,Product A,Product A
10,176.96359453446414,Product A,Product A
10,181.13203218738172,Product A,Product A
10,162.30481421405926,Product A,Product A
10,158.44829952780776,Product A,Product A
11,189.72743260891417,Product A,Product A
11,189.02007682842228,Product A,Product A
11,170.291450521185,Product A,Product A
11,171.4787776352751,Product A,Product A
11,186.42490406801193,Product A,Product A
12,207.8190745030289,Product A,Product A
12,202.49447645892576,Product A,Product A
12,174.23823046498524,Product A,Product A
12,178.95220304968277,Product A,Product A
12,189.9089260777039,Product A,Product A
1,131.16994281118494,Product B,Product B
1,107.11228400679279,Product B,Product B
1,133.66255137547034,Product B,Product B
1,141.95289006465387,Product B,Product B
1,150.49071911186627,Product B,Product B
2,154.7200842317478,Product B,Product B
2,147.79280006909693,Product B,Product B
2,158.415768101069,Product B,Product B
2,147.82397688118883,Product B,Product B
2,131.32054213343213,Product B,Product B
3,151.3256886897579,Product B,Product B
3,123.37182184210084,Product B,Product B
3,132.77541353729745,Product B,Product B
3,151.6140383283626,Product B,Product B
3,143.13039889815252,Product B,Product B
4,127.75077252063937,Product B,Product B
4,158.6831303547717,Product B,Product B
4,140.95339794692364,Product B,Product B
4,132.46599501159514,Product B,Product B
4,132.9924121572106,Product B,Product B
5,153.47719159298828,Product B,Product B
5,144.3477300337986,Product B,Product B
5,142.11080794346663,Product B,Product B
5,151.7995032640132,Product B,Product B
5,126.55254323959846,Product B,Product B
6,171.4440859612549,Product B,Product B
6,151.55906266978917,Product B,Product B
6,137.26444802574704,Product B,Product B
6,150.8760560399544,Product B,Product B
6,146.29898058787342,Product B,Product B
7,182.85777085743422,Product B,Product B
7,154.10970282439416,Product B,Product B
7,184.30543075831707,Product B,Product B
7,144.14728265053193,Product B,Product B
7,158.39683815883245,Product B,Product B
8,185.56172374334466,Product B,Product B
8,144.40317678002432,Product B,Product B
8,146.91298602254847,Product B,Product B
8,179.92841168753887,Product B,Product B
8,163.89934146568422,Product B,Product B
9,167.57307629713344,Product B,Product B
9,175.92314946547694,Product B,Product B
9,163.99034464845968,Product B,Product B
9,165.46170943966683,Product B,Product B
9,179.90479412356854,Product B,Product B
10,169.3241711139548,Product B,Product B
10,198.0827022334792,Product B,Product B
10,164.169847892297,Product B,Product B
10,156.63810254032046,Product B,Product B
10,172.0065349728467,Product B,Product B
11,175.203693940075,Product B,Product B
11,170.52538246228482,Product B,Product B
11,184.8338020720614,Product B,Product B
11,161.50528948158066,Product B,Product B
11,203.86360593032873,Product B,Product B
12,175.14869994565578,Product B,Product B
12,206.17660104017656,Product B,Product B
12,161.39972239932928,Product B,Product B
12,160.8160092024419,Product B,Product B
12,206.71750170023512,Product B,Product B

</script><script type="text/plain" id="facet_grid_data" data-format="csv_embedded" data-src="">
Month,Sales,Product,Region,Year,color
1,123.54097962383582,Product A,North,2023,2023
2,113.9111444248085,Product A,North,2023,2023
3,137.43894309253866,Product A,North,2023,2023
4,146.39350470399876,Product A,North,2023,2023
5,155.57739940290807,Product A,North,2023,2023
6,168.0329177595181,Product A,North,2023,2023
7,164.59575344105235,Product A,North,2023,2023
8,160.21515383449855,Product A,North,2023,2023
9,184.60944801848441,Product A,North,2023,2023
10,145.37693287524115,Product A,North,2023,2023
11,155.730692256923,Product A,North,2023,2023
12,198.5169268240565,Product A,North,2023,2023
1,130.50377540995373,Product A,North,2024,2024
2,133.4885246744077,Product A,North,2024,2024
3,118.02901971441605,Product A,North,2024,2024
4,118.46594074561364,Product A,North,2024,2024
5,149.5753389073098,Product A,North,2024,2024
6,164.89959321513237,Product A,North,2024,2024
7,161.12070547421334,Product A,North,2024,2024
8,180.4385710460029,Product A,North,2024,2024
9,178.53160002054852,Product A,North,2024,2024
10,186.20951486831223,Product A,North,2024,2024
11,163.9555191125449,Product A,North,2024,2024
12,173.0917866123226,Product A,North,2024,2024
1,105.98408885053837,Product A,South,2023,2023
2,149.01635234059188,Product A,South,2023,2023
3,146.20264933787308,Product A,South,2023,2023
4,137.5135107804935,Product A,South,2023,2023
5,139.05067464888356,Product A,South,2023,2023
6,151.4814582710106,Product A,South,2023,2023
7,153.62683446027776,Product A,South,2023,2023
8,164.27288941733875,Product A,South,2023,2023
9,148.19073944498638,Product A,South,2023,2023
10,160.55997227314097,Product A,South,2023,2023
11,174.64075401432945,Product A,South,2023,2023
12,157.9104584916542,Product A,South,2023,2023
1,129.1590781200147,Product A,South,2024,2024
2,144.99587913011663,Product A,South,2024,2024
3,138.5103468134281,Product A,South,2024,2024
4,149.49755536945673,Product A,South,2024,2024
5,141.44469399468173,Product A,South,2024,2024
6,148.04430164046101,Product A,South,2024,2024
7,135.23002783500883,Product A,South,2024,2024
8,154.67548668675335,Product A,South,2024,2024
9,188.01746670655683,Product A,South,2024,2024
10,153.9453451782911,Product A,South,2024,2024
11,189.74083424515985,Product A,South,2024,2024
12,156.13570368366015,Product A,South,2024,2024
1,139.46042270530168,Product B,North,2023,2023
2,123.98347490355405,Product B,North,2023,2023
3,133.41370730332403,Product B,North,2023,2023
4,131.37324030767212,Product B,North,2023,2023
5,146.09612373423434,Product B,North,2023,2023
6,132.60399231955805,Product B,North,2023,2023
7,154.53421671949732,Product B,North,2023,2023
8,160.24990522893643,Product B,North,2023,2023
9,177.4156035477484,Product B,North,2023,2023
10,178.38277386619677,Product B,North,2023,2023
11,191.7668557873213,Product B,North,2023,2023
12,173.07457249476823,Product B,North,2023,2023
1,123.69402811584563,Product B,North,2024,2024
2,146.8260743219084,Product B,North,2024,2024
3,134.03268883356986,Product B,North,2024,2024
4,124.43477469739273,Product B,North,2024,2024
5,130.27347578774067,Product B,North,2024,2024
6,125.03943388936906,Product B,North,2024,2024
7,153.71973111903898,Product B,North,2024,2024
8,174.64305667005408,Product B,North,2024,2024
9,174.45546781191587,Product B,North,2024,2024
10,178.03215393445828,Product B,North,2024,2024
11,164.10190218763302,Product B,North,2024,2024
12,204.2963719820493,Product B,North,2024,2024
1,132.69204026550642,Product B,South,2023,2023
2,120.4236319760607,Product B,South,2023,2023
3,125.89404859210289,Product B,South,2023,2023
4,131.76427049690244,Product B,South,2023,2023
5,124.21423792665506,Product B,South,2023,2023
6,147.22962592292976,Product B,South,2023,2023
7,154.24543281721347,Product B,South,2023,2023
8,184.9076125190728,Product B,South,2023,2023
9,188.23009821076823,Product B,South,2023,2023
10,152.08674789356354,Product B,South,2023,2023
11,178.97368022590354,Product B,South,2023,2023
12,167.30013646271576,Product B,South,2023,2023
1,107.66523204286646,Product B,South,2024,2024
2,140.0860860995795,Product B,South,2024,2024
3,127.40282802204106,Product B,South,2024,2024
4,143.3620583519149,Product B,South,2024,2024
5,126.30740302474916,Product B,South,2024,2024
6,163.38707013542995,Product B,South,2024,2024
7,134.56724702351642,Product B,South,2024,2024
8,174.72911201657044,Product B,South,2024,2024
9,140.22534099762765,Product B,South,2024,2024
10,193.60957020697788,Product B,South,2024,2024
11,183.12908200850478,Product B,South,2024,2024
12,159.17340511918755,Product B,South,2024,2024

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/linechart_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>LineChart Examples</h1>
<p>This page demonstrates the key features of LineChart plots in JSPlots.</p>
<ul>
    <li><strong>Basic time series:</strong> Simple line chart with date axis</li>
    <li><strong>Multiple series:</strong> Comparing multiple lines with color dimension</li>
    <li><strong>Interactive filters:</strong> Dropdown menus to filter data dynamically</li>
    <li><strong>Dynamic controls:</strong> Change color, aggregation, and faceting on the fly</li>
    <li><strong>Aggregation:</strong> Handle multiple observations per x value</li>
    <li><strong>Faceting:</strong> Facet wrap (1 variable) and facet grid (2 variables)</li>
    <li><strong>Integration:</strong> Combining charts with images and text</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Daily Revenue Trend - H1 2024</h2>
<p>Basic time series showing 6-month revenue trend</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_revenue_trend">Aggregator: </label>
                <select id="aggregator_select_revenue_trend" onchange="updateChart_revenue_trend()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_revenue_trend_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>


<!-- Chart -->
<div id="revenue_trend"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: revenue_data</p><br>
<hr>
<br>
<h2>Monthly Sales Comparison Across Years</h2>
<p>Multiple series chart demonstrating color dimension to compare years</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_multi_series">Aggregator: </label>
                <select id="aggregator_select_multi_series" onchange="updateChart_multi_series()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_multi_series_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>


<!-- Chart -->
<div id="multi_series"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data</p><br>
<hr>
<br>
<h2>Department Productivity by Month</h2>
<p>Interactive filters allow you to select different departments and quarters</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="filtered_metrics_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="Department_select_filtered_metrics">Department: </label>
                <select id="Department_select_filtered_metrics" multiple onchange="updateChart_filtered_metrics()">
                <option value="Engineering" selected>Engineering</option>
                <option value="Marketing">Marketing</option>
                <option value="Operations">Operations</option>
                <option value="Sales">Sales</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="Department_select_filtered_metrics_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="Quarter_select_filtered_metrics">Quarter: </label>
                <select id="Quarter_select_filtered_metrics" multiple onchange="updateChart_filtered_metrics()">
                <option value="Q1" selected>Q1</option>
                <option value="Q2">Q2</option>
                <option value="Q3">Q3</option>
                <option value="Q4">Q4</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="Quarter_select_filtered_metrics_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_filtered_metrics">Color by: </label>
                <select id="color_col_select_filtered_metrics" onchange="updateChart_filtered_metrics()">
                <option value="Department" selected>Department</option>
                <option value="Metric">Metric</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_filtered_metrics_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_filtered_metrics">Aggregator: </label>
                <select id="aggregator_select_filtered_metrics" onchange="updateChart_filtered_metrics()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_filtered_metrics_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>


<!-- Chart -->
<div id="filtered_metrics"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: metrics</p><br>
<hr>
<br>
    <div class="picture-container">
        <h2>example_visual</h2>
        <p>Example visualization image</p>
        <img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxITEhUSExIWFRUXGBUYFhcWGBcXGBkWFhYYFhcYGhYYHCgiGBomGxUVJjEhJSktLi4uFx8zODMtNyotLisBCgoKDg0OGxAQGyslHyU1MC0tLjYtLTUrMzAtLS8rLTcrMC0tKzcyLzAtLS0tLS0vKy8tLy0tLi0vNS8tLS0vLf/AABEIAPQAzgMBIgACEQEDEQH/xAAcAAEAAgIDAQAAAAAAAAAAAAAABgcFCAEDBAL/xABHEAABAwICBwQFCQYEBgMAAAABAAIDBBEFIQYHEjFBUWETInGRMkKBocEIFCNSYnKCorEkM5KywuFDY9HwFSU0c5OzVGR0/8QAGwEBAAIDAQEAAAAAAAAAAAAAAAQFAQIGAwf/xAAwEQEAAgEDAwAHBwUAAAAAAAAAAQIDBAUREiExEyJBUZGh0SMyM1JhgbEkQnHB4f/aAAwDAQACEQMRAD8AvFERAREQEREBERARFSWvPWE5hdhtK8g2/aXtOdiLiEHqD3vED6wQZjTzXNBSudBRtbUTDJzyfoWHlcZyEchYZ7+CpzGtYmKVJJkrJWj6kR7JoHK0drjxuosiyO6eqkedp73OPNziT5kr2UWkFZDYxVU8dvqSvb7gVjUQWVo5rpxGAgT7NVHxDwGPtyEjB73Byu/QzTyixJv0EmzKBd0MlmyAcSBfvN3Zi+8XtuWtuB4G2aMnisbNFNSTNkjc5j2G7HtNiCOIKwNzEUA1Uaw24lEYpbNq4xd4GQkbu7Ro4ZkAjgSOBCn6AiIgIiICIiAiIgIiICIiAiIgIiIMXpRjDaSknqnZ9lG5wB4utZjfa4ge1ab1VS+R75JHFz3uc97jvLnEucT4klbH/KErjHhYjH+NPGw/daHS/wA0bVrWgIhCLIIiIJTgmLNgiOeZWNxHGO1vtBYsRuIvYkL4QZHR/GZaOpjqYTZ8btociNzmnoWkg9CtwMAxeOrpoqmL0JWBw3XF97Tbi03B6grS5X/8nHGy+nqKNx/dObIy/wBSW4cB0Dm3/GsC4kREBERAREQEREBERAREQEREBERBT/yknfslKP8AOcfKM/6qlNH9HpqtxEYAaLbTnXsOgtvPRXT8pP8A6Wl/7z/5F5tCKemw7Bm4jVAvDs2RtyLnveQAeZy8AGnegrXF9EqijaXkNmi9cWIIHE24W+sDl4KKvAvlu4X5LZ/Q3SqixO8MlE2GUs22seGPa+PcSyQAXIuLggEXG/O1B6xtHxQ4jPTMB2A4Oi/7cgD2gc7XLfwoI4xhJAAJJIAA3kncAp9o5oC14BqHO2j6jCAB0LrZnw9679R2j8dTXvMzNpsMZcGm477nNaCRysXe5WnrF0+psI2IIqZkkz27WwLMYxl7BziBckkGwHIkkZXCBYhqsLWGahkcJG59lIQWvt6odYWP3rjqFVuJEF5Ox2brkPZa2y8ZHI7s+HBbIaGacR1zxT1FOKeZ7S6JzHbUcoAu7ZdYWeBc7JvkCbqptdujxpa8Py2Z2bdxxc07LsuBts+0lBXqtD5PE+zib23yfTyC3UPjcP0PmqvVi6hHWxdnWKYflv8ABZGziIiwCIiAiIgIiICIiAiIgIiICIiCoflIs/Y6Y8pyPON3+iiuPNfNopRuaLiGf6To0OniaT7XsH4lMflHM/5dAeVUwecM3+iiOpTSiIRT4dUsL4nhz2gtLmlrgGyRuHC+RHC5Od7Xxa0VjmfDMRMzxCLarsSkbiNExp3T3zO5j2OZJ4DZLipjrD0crcSxB9RAxsMbWtiY6R9jIGE3fstBLQS42BsbALPYLo1R05k7CItD9rNzi54YfVD94Hh5nepJALWAXMavfrRbpwRHHvn/AEnV0fEc3QzV3geIYdWMfM2OWJ47OR8brljXEEOIcASA4DcDkSoXr0ieMYmLvReyF0f3Oza3L8bXq7Bh0ZkE2wBJa20LgkWtnb0vasbpRovTVzA2dhJbfYe02ey++x3EdCCFth36azHpq8x74+nPf5NLaX8qk9XdZUPr6GBhLg2pieBxa0OvLY/V2Nu45XU3+UnO01FIwHvNjlJHRzmge9jvJTXQnRGhw1zpImSPmII7WVzXFrTvDQGtDb232v1sqT1o19TNiMr6iJ0Rs0RscQbRC+zZzbh1ztE2JzJHBXun1mDUfh2if5+CNfHavmESVg6iXf8AOIerJv8A1k/BV8ptqXl2cZpOpmb5wSAe+ylNG1aIiwCIiAiIgIiICIiAiIgIiICIiCt9f8G1hJNvQmhd4XJZ/Wq91d0DY6dr7d6TvOPEi5DR4AfqVaWuuHawaq5jsXeU8d/ddUXqyfPJM+FjyAyN0gacxcPYLeB2yoO4YL58PTSf+vfT5K0vzZcVKshTi5UZw/HG+jIxzXDI2BcL+zMeXtWWhxmLgXnwjk+LQuHyYb1txMStbWiY7JBuXRPK1oLnEADeTuWIlx5x9CE35yENHk25PuWNmL5CHSu2iNw3Mb4N+JuVtkp1ee0NK0l6qnE5HvBYdiMcCBtP8b+iOm/9FVmt+rD54R67Yzc/ZLzsi/iHeasxkbneiL9eCq/Wxg0kU8cxcXNkZYfZcw5t3brOB9ruSv8AaNFkrljLavERHb9UfVZadHRWeZQVZbRPE/m1bTVBNhHNG533A4bf5brK6ExwS7cErQS7Np4+xefSrRr5tZ7XXYTbPeF0yubegrlQvVDpEKzDYSTeSEdjLxO1GAGuJO/aZsG/MnkposAiIgIiICIiAiIgIiICIiAiLH47jMNJA+onfsRsFyeJPBrRxcTkAgg2vzGGw4W6G/fqHsY0cdljhK93h3APxhVrqKoS6eqlAyZC1h8ZJA4e6Jyi+mulFRitZ2habEiOnhbnstJs1oA9J7ja54k8gANidXGhow+hbC6xmee0nI3bZFg0Hk0WHU3PFBGcbwdzj2kWT+I5/wB1iRiEze65rh7CrCxGhLTcDJY8t6Ku1O3Ys9uqe0pOLU2pHHlF6eeV/oxnxIsPesvRYY45yG/2RuWbpaFz9wWdosLa3M700+2YMM9XHM/qZNVe8ceIeDD8HuM8gsLrG0J+d0EscYvKwdpCOb2X7o+83ab4uHJTsCy5VgjNJqOpdG8PYbOBuFl8e0mkqWNYWhoGZtxKkeuvRj5niDpGC0NTeVnIPv8ASs/iO1yAkA4Kv1sJ/qY0tFDXBkjrQVGzHITua+57J56Akg8LPJ4LaJaPLZPUpp2KynFJM79pgaACTnLEMg7Pe4ZB3sPE2wLOREQEREBERAREQEREBERB01lWyKN0sjgxjAXOc42AaBckrVrWhp5JidRZpLaWMnsY91zuMrxxceA9UZcyZFrx09NTKaCB30ETvpXA5Syt4dWMPm4E8GlVOAgun5P2hwc52JTNuGkspwfrbnyez0R1LuQV7LE6KYcyno4Kdm6ONjT1cB3j4l1z7VllgfEsQcLELx/8KZe9l7iV8NlzQcxRBu4L7RcFw5oOUXyZBzC6n1TRxQQPXnggqMMe8C8lO4TNta+x6Mg8Nl21+ALWNbk1cbZ2yRPzZIx8bh9l7S0+4rTqohcxzmOFnNJaR1abH3hZgda9eE4lLTTR1ELiySNwc0jmOB5gi4I4gkLyIsjbnV/ppDidP2rLNlbYTRXzY48RzYbGx6EbwVKFppotpDPQVLKmB1nNyc3PZew+kxw4tPuIBGYC210Wx+KupY6qE914zB3tcMnMd1BB8ciMiFgZZERAREQEREBERAUN1saTGgw6SRhtLJaKI8Q94N3DkWtDiOoCmSoD5R+LbVTTUoOUcbpHctqV2yARzAj/ADoKfjjLjYC5Xu0foZJqqGKMbT3SNsOGRuSTyABJPILmqZ2MYZ67xd3Rp3N9v6eKu3UHoaI4DiEze/NdsIPCIHN1vtOHk0Higsuggk3glo/3wWUYy3ElfSLA4IXTTx8Su9EBfDogeC+0QeSXD2nmF4J8LeM2m6zSII6x7mHMWVU66tBW7JxOlZa5/amN3An/ABgOp9K3Eh31irznp2uFiFjzRjvRPaHRvBa5pzDmuFiCORBKDT2BrHZOOyeDvVPjy8V81NK5hs4eB4EcwVmtOdG3UFdNS5lodtRE+tE/NhvxNsj1aV5YO43YlF4j5sJ9YfELYYlWfqI0uNLV/M5HfQ1JAbfc2fcw/i9E8zsclXNfSGJ5afYeBHAhdDHkEEEggggjIgjMEHgUG76KP6A6QfPqCCpNttzbSWytKzuvy4AuBI6EKQLAIiICIiAiIg4c4AXOQG9alaR4uK/E6irJ+i2i4b/3UY2WZHcS1oy5lXrrt0n+Z4e6NrrTVN4mcwy30rvY02vwL2rW1w2IBzlP5WW+JHkg9+jmFPxGvig3GaTvEerGO88j7rGm3gFt7S07I2NjY0NYxrWsaNzWtFmgdAAFSHycMEu+prXD0QIIz1Nnye23Z/xFXokgiIsDguXK6ZD3gu5AREQEREBcELlEFMfKIwhtqStsMnOgeeJBBkj8i2X+JVNW4gxzNlbEa6aLtcHqcs2dnIOmzI3a/KXLVhZgZh/0tKHetC7Z/Ac2/EexYdZjAs46hv2AfI/3WHWRd3ybsczqaFx3gTxjwtHLn/4suhV5rUvVTivzfFaV97Ne/sndRMOzF+gc5p9i20WAREQEREBcErlQDXbpC6kw14YbSVDhC0jeGuBMh/haR4uCCjdaulX/ABCvkka68Mf0UPIsaTd/4nXN+WyOCjuKu/dDgI2+8uK8kMRc4NG8rKaS0JidEDxibn1BcD8FkbJ6nMM7DCaYW70gdM7r2jiWn+DYHsU1XiwOkEVNBEMhHFEweDWBvwXtWoIiIOh/phd66fXXcgIiICIiAiIgj2sNl8Lrh/8AWnPkwn4LUFbgawDbDK7/APNUe+NwWn6zAzOB92Gof9lrR7ST8Fhll5T2dI1vGRxefAd0fpf2rELI+4ZXMc17TZzSHNPIg3B8wt2KKoEkbJBue1rh4OAI/VaSLcPQF5OGUJP/AMWn/wDU0LAzyIiAiIgKnvlJwE0lLJ6rZnNPi+Mke5jlcKienNRG8Mpi1rztNkNxfZ2TdhHJ1/06rw1Oorgxzkt7G+PHN7dMNYI9HK3Y7VtNNs7wQx1/G2+3Wy7ZpHVEFjnLDfLiWH0suYsD5rYZjBZQbWBop2gNXTDZnYLuDR+9aOBA3vHA8d3K1LpN+jJk6MteInxP1+qZl0XTXms8r2aMlyqS1Wa3AS2kxB4G4RTk5dGSk7uj/PmrtXQIAiIg6Ae+u9dFu+u9AREQEREBEWCx7H+xkbE0XcW7RJzABJAyvvNj5dV5Z81MNJvfxDalJvPEPBrYqezwisceMex/5HtZ/UtVaamDhdzwxvM5k+AG9bL6YD59RyU0r9hjtlznMHetG4P3E23tC1ge6/w8F5aTXYtVz6Pnt57e9tkxWx/eZiuMUpFpdkNAa0EZAAWGd11swCVwvGWvHQ5+RWKWRwKoeyUFrrDjyspjzeKohcwlr2lpG8HJbmaN0JgpKeA74oYoz4sY1p/Ra46P0H/EcQgb3ezhex87zu7MPBLepNreZ4LZ5rgRcG4O4haRes2msT3jzDPE8cuURFsw6K2sZEwvkdstHH4AcSsA7TOK/dikI52aPivNp44l0DPV77iOo2QPIE+axcUIA3Lndz3bLgyzjx+xYafS1vTqsytXpnl9HC7a4F5Fh1sN/hko/Th73ukkN3ONyT/vcvb2Q5L6DbKj1W45tRHF5TMeGmP7sOV8yNuF9ooD2UlrM0a7CX5xGPo5D3gNzX/6H9b8ws5qu1rvo9mlrC6SmFgx+bnwjgLb3xjlvA3X3Kf45hbKiF8TxcOH+7dfiAtecYw59PM+F+9pyPMcHDxC7TZtd6fH6O33q/OFRq8PRbqjxLc2jqmSsbJG9r2OF2uaQWkHiCN67lqfoBrAqcMk7pMlO4/SQOPdPNzD6j+oyPEHK2zejOkNPX07amnftMdkQcnMcN7Ht4OFx43BFwQVcojJlud19IiwCIiAiIg+JJQ3eoDpZIHVjSOMTPc9/wDZSnGHG6hmM/8AUM+4P5nKu3WP6af2SdJ+I+8SF4nNHrNI8xZa1SRlpLXCxBII5EZELZqdl2qAaSaEw1DzILxvO9zbEE8y07z4WVNtOspgm0X8Sm6rDOSImvmFRLvoqWSV7Yomlz3Gwa3ef7dVOqXVtn35yRyawNPmSf0U/wBGNHIKUWiZYn0nHNx8XHh0GSttRu+HHX1PWn5ImPR3tPrdoNCNGG0NPsmxlfZ0rhzG5oP1W3PtJPFWBofVFzZGE+g4EeD75ebXH2rCAZLIaMTBkzmnLtALfebew8ifJUm3am06yL3nvbmJ/fx8+EvUY49DMRHhLERF2CpRLTttjA7q8eeyf6SsZGclltYJ+ii59p/Q7+yw1L6IXF75XjUzPv4/hcaOfsodyIipUoREQcEKu9a2jfaRfOY29+P0rbyzefLf5qxV1zRhwIOYORUnS6i2nyxkr7HnlxxesxLV9WXqExySHEm0wJMdS17XN4B8bHSMf42a4fiSr1T1M08opHw7IO0I3uLHBp4jukFt8t9xlcbibA1W6qXUE3zuqkY+YBzY2R3LWbQs5xcQC52ySLAWFzvvl9Bw5q5ccXr4lR3rNZ4laiIi3aiIiAiIgxOMtVdz4rFPUnsnbQj+jcRu2wdpwB4gbQF+YKwOtzWi2Tao6F925iWdpyPNkRHDm/jwyzOM1ZstA3qXH8xHwVdus8aef8pOkj7RZwbcLyS0y9kO5fdlxsTxK3Y6OkXtiisuyy5SbTLAuuRl/guxFrE8DOYLjm1aOY2duDtwd0PJ36rPKv5wLZr7wrSzsCWTEuZbune4G+6/EWv4WXS7du0zxjzfH6/VAz6X+6nwd2m1UJJ44Qf3YLnfefaw8QBf8S80bbBR6GvL5nyP9JznE9Lnd7N3sWbjqgVR7llnLnm6Zgp0UiHpRfDZAvq6r3s5REWAXC5RBisSlkic2eI2ew5ciOII4g7vap5o/j0NXGHRuG2ANuO4L2E8CN9rg2PFQnFBdpVVaY9pERPDI+OSM5PY4tcA7I2c0332XSbHqprPo58Sg6zFEx1Nn0WtGCa6sThAbKY6lv8AmNs+3R8ZHmQVK6X5QDf8TDyOrJgfcYxbzXVcKtdiKlqj5QEYHcoHk/amDR7mFRrGteOIygtgZDTg7iGmR4/E/u/lQX9jmOU1HEZqmZsTBxccyd9mtGb3dACVr7rJ1sy1wdTUodDTHJxOUko4h1vQYfqjfxOdlXuKYpPUSGWeV8rz6z3Fxte9hfcM9wyC8iDhXJoNBsxRjk1t/G1z71T0LNpwbzIHmbK7dFyBZU+8W+ziE3RR60ymsW5fa64jkvu65GVm5XBK+HyALwVdcBxWYrMj3PmAXnlrQOKjlbjFuK9+D6OVlVZ1uyjPryAi4+yzefcOqm4dFfJPFYed8laR3K7FhzUj0O0aJvPUs9IWZG4ZgEglzhwOQsPFZnA9Eqens6xkkHrvzIP2W7m/r1WfXQ6La4wz137z7lfn1XVHFURxvQdkr3Swydk5xJc0jaYScyRndtz4+Cjdbo5Ww59n2jRxiO1+XJ3uVpIpGfbcGXvMcT+jzpqclOymm4kWnZddpG8HIj2FeqPFeqtOsoYpRaWNjxye0O/ULA1mgtE/0WOiPON5H5XXA8lVZdi/JKVXXR7YRSPEwvXFVtPFfVdq6lGcFSDybK0j87b/AMqjuIYXXU1zJC4tHrs77bcyW5tHiAq7NtGanfh711WO3tScPCOeAojS46DxXofjAtvVfOmvE8cPeLQyGJ1Isq50qa+Vro42Oke7INY0uccxuaMys5iuMCxzU51T6OPjDq2Zpa6VuzE07xESHFxHDaIbbo3qrzatHaLxaUTVZY6eFG0OrnFpRdtBMPvgRe6QhZOHU/jJ30rW+M0P9LytpUXUqpq5NqdxkbqZrvuzQ/1OC8U+qzGGb6F/4XxP/leVtgiDTas0Vr4r9pRVDAN5MMlv4rWWIItkd63gXhxLBqaoFp6eKUf5kbX+W0MkGmVF+8Z99v6hWvgFZaysPFtTmFSnaZG+nde+1C82v9yTaaB0ACqrF8PmoKh0EoIIJ2HcHsv3Xt5g+43HBV244ZyVhK0t+mVhU9eLb12urlA6XGOq9LsX6rm7aOeVnGSqS1WJdVh2vlqJBDC0ve7cBy4kngBzK8eGwz1kohgbtOO87mtH1nu4D9eFyrm0V0biootlvekdbtJCM3H4NHAfqblWOj27qnm3hGz6mKxxHljdF9B4qe0k1ppt9z6DD9hp3n7Rz5WUtRF0OPHXHHTWFba02nmRERbtRERAREQEREEexvQuiqSXPi2Hn/EiOw6/M2ycfvAqmNJcPFPP2LHvLb2u4gnf0AHuRFE1GKnHPHd7YrT45WToVoJRhjKl7XTPNiBKQ5jTzDAACfvXsp+iKTSsVjiHnaZme4iItmoiIgIiICx+M4LT1TOzqImyN4bW9p3Xa4ZtPUEIiCntPtCaei70L5c89lzmuA6Du3t4krq1eaJwVpvM+UAZ2Y5oB6G7SbeBC5RRZx19Jxw9uqelc+EYRBTR9nBE2NvG28nm5xzcepK9yIpURw8RERAREQf/2Q==" alt="example_visual" />
    </div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">images.jpeg</p><br>
<hr>
<br>
<h2>Sales by Product (Facet Wrap)</h2>
<p>Facet wrap creates a grid of subplots, one for each product. Similar to ggplot2's facet_wrap.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_facet_wrap_example">Color by: </label>
                <select id="color_col_select_facet_wrap_example" onchange="updateChart_facet_wrap_example()">
                <option value="color" selected>color</option>
                <option value="Product">Product</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_facet_wrap_example_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_facet_wrap_example">Aggregator: </label>
                <select id="aggregator_select_facet_wrap_example" onchange="updateChart_facet_wrap_example()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_facet_wrap_example_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="facet1_select_facet_wrap_example">Facet by: </label>
                <select id="facet1_select_facet_wrap_example" onchange="updateChart_facet_wrap_example()">
                <option value="None">None</option>
                <option value="Product" selected>Product</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="facet1_select_facet_wrap_example_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<!-- Chart -->
<div id="facet_wrap_example"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: facet_data</p><br>
<hr>
<br>
<h2>Sales by Product and Region (Facet Grid)</h2>
<p>Facet grid creates a 2D grid of subplots. First facet variable (Product) defines rows, second (Region) defines columns. Similar to ggplot2's facet_grid.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_facet_grid_example">Aggregator: </label>
                <select id="aggregator_select_facet_grid_example" onchange="updateChart_facet_grid_example()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_facet_grid_example_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="facet1_select_facet_grid_example">Facet 1: </label>
                <select id="facet1_select_facet_grid_example" onchange="updateChart_facet_grid_example()">
                <option value="None">None</option>
                <option value="Product" selected>Product</option>
                <option value="Region">Region</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="facet1_select_facet_grid_example_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="facet2_select_facet_grid_example">Facet 2: </label>
                <select id="facet2_select_facet_grid_example" onchange="updateChart_facet_grid_example()">
                <option value="None">None</option>
                <option value="Product">Product</option>
                <option value="Region" selected>Region</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="facet2_select_facet_grid_example_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<!-- Chart -->
<div id="facet_grid_example"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: facet_grid_data</p><br>
<hr>
<br>
<h2>Dynamic Controls Demo - Stock Returns</h2>
<p>Use the dropdown menus to dynamically change: (1) Color by, (2) Line type by, (3) Aggregator, (4) Facet 1, (5) Facet 2.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_select_dynamic_controls">Color by: </label>
                <select id="color_col_select_dynamic_controls" onchange="updateChart_dynamic_controls()">
                <option value="Stock" selected>Stock</option>
                <option value="Strategy">Strategy</option>
                <option value="Region">Region</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_select_dynamic_controls_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_dynamic_controls">Aggregator: </label>
                <select id="aggregator_select_dynamic_controls" onchange="updateChart_dynamic_controls()">
                <option value="none">none</option>
                <option value="mean" selected>mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_dynamic_controls_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="facet1_select_dynamic_controls">Facet 1: </label>
                <select id="facet1_select_dynamic_controls" onchange="updateChart_dynamic_controls()">
                <option value="None" selected>None</option>
                <option value="Stock">Stock</option>
                <option value="Strategy">Strategy</option>
                <option value="Region">Region</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="facet1_select_dynamic_controls_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="facet2_select_dynamic_controls">Facet 2: </label>
                <select id="facet2_select_dynamic_controls" onchange="updateChart_dynamic_controls()">
                <option value="None" selected>None</option>
                <option value="Stock">Stock</option>
                <option value="Strategy">Strategy</option>
                <option value="Region">Region</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="facet2_select_dynamic_controls_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<!-- Chart -->
<div id="dynamic_controls"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: dynamic_data</p><br>
<hr>
<br>
<h2>Aggregation Demo - Multiple Observations per X</h2>
<p>This dataset has 5 observations per month. Use the Aggregator dropdown to switch between: none (all points), mean, median, count, min, max.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_aggregation_demo">Aggregator: </label>
                <select id="aggregator_select_aggregation_demo" onchange="updateChart_aggregation_demo()">
                <option value="none">none</option>
                <option value="mean" selected>mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_aggregation_demo_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>


<!-- Chart -->
<div id="aggregation_demo"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: agg_data</p><br>
<hr>
<br>
<h2>Multi-Dimensional Weather Data - Dynamic X and Y Selection</h2>
<p>Use the dropdowns to dynamically switch between different time scales (X) and measurements (Y). This demonstrates how you can provide multiple options for both axes and let users explore different views of the same dataset.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="x_col_select_multi_dimensions">X dimension: </label>
                <select id="x_col_select_multi_dimensions" onchange="updateChart_multi_dimensions()">
                <option value="time_hours" selected>time_hours</option>
                <option value="time_halfhours">time_halfhours</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="x_col_select_multi_dimensions_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="y_col_select_multi_dimensions">Y dimension: </label>
                <select id="y_col_select_multi_dimensions" onchange="updateChart_multi_dimensions()">
                <option value="temperature_celsius" selected>temperature_celsius</option>
                <option value="temperature_fahrenheit">temperature_fahrenheit</option>
                <option value="humidity_percent">humidity_percent</option>
                <option value="pressure_hpa">pressure_hpa</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="y_col_select_multi_dimensions_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_multi_dimensions">Aggregator: </label>
                <select id="aggregator_select_multi_dimensions" onchange="updateChart_multi_dimensions()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_multi_dimensions_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>


<!-- Chart -->
<div id="multi_dimensions"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: multi_data</p><br>
<hr>
<br>
<h2>Sales with Continuous Range Filters</h2>
<p>This example demonstrates jQuery UI range sliders for continuous variables. Use the Product dropdown for categorical filtering, and the Profit Margin and Units sliders to filter by numeric ranges. Each slider has two handles for min/max values.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="continuous_filters_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="Product_select_continuous_filters">Product: </label>
                <select id="Product_select_continuous_filters" multiple onchange="updateChart_continuous_filters()">
                <option value="Doohickey" selected>Doohickey</option>
                <option value="Gadget" selected>Gadget</option>
                <option value="Widget" selected>Widget</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="Product_select_continuous_filters_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 10px; display: flex; align-items: flex-start;">
    <div style="flex: 0 0 70%;">
        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Units: </label>
        <span id="Units_range_continuous_filters_display" style="display: inline-block; min-width: 200px; font-size: 0.9em; color: #666;">122.16 - 999.08</span>
        <div id="Units_range_continuous_filters_slider" style="margin: 10px 5px; width: 90%;"></div>
    </div>
    <div style="flex: 0 0 30%; text-align: right; padding-right: 10px; padding-top: 25px;">
        <span id="Units_range_continuous_filters_obs_count" style="font-size: 0.9em; color: #666;"></span>
    </div>
    <script>
        $(function() {
            // Value formatter function
            function formatValue_Units_range_continuous_filters(x) {
    return x === Math.floor(x) ? Math.floor(x).toString() : x.toFixed(2);
}

            // Initialize jQuery UI range slider
            $("#Units_range_continuous_filters_slider").slider({
                range: true,
                min: 122.16182098959561,
                max: 999.0845814117612,
                step: 0.8769227604221655,  // Integer steps for integers, smooth for others
                values: [122.16182098959561, 999.0845814117612],
                slide: function(event, ui) {
                    // Update display during sliding
                    const minVal = ui.values[0];
                    const maxVal = ui.values[1];
                    $("#Units_range_continuous_filters_display").text(formatValue_Units_range_continuous_filters(minVal) + " - " + formatValue_Units_range_continuous_filters(maxVal));
                },
                change: function(event, ui) {
                    // Update display and trigger chart update
                    const minVal = ui.values[0];
                    const maxVal = ui.values[1];
                    $("#Units_range_continuous_filters_display").text(formatValue_Units_range_continuous_filters(minVal) + " - " + formatValue_Units_range_continuous_filters(maxVal));

                    // Store values for easy access
                    $("#Units_range_continuous_filters_slider").data('minValue', minVal);
                    $("#Units_range_continuous_filters_slider").data('maxValue', maxVal);

                    // Call the update function
                    updateChart_continuous_filters()
                }
            });

            // Store initial values
            $("#Units_range_continuous_filters_slider").data('minValue', 122.16182098959561);
            $("#Units_range_continuous_filters_slider").data('maxValue', 999.0845814117612);
        });

        // Helper functions to get slider values
        function getUnits_range_continuous_filtersMin() {
            return $("#Units_range_continuous_filters_slider").slider("values", 0);
        }

        function getUnits_range_continuous_filtersMax() {
            return $("#Units_range_continuous_filters_slider").slider("values", 1);
        }
    </script>
</div>
<div style="margin: 15px 10px; display: flex; align-items: flex-start;">
    <div style="flex: 0 0 70%;">
        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Profit_Margin: </label>
        <span id="Profit_Margin_range_continuous_filters_display" style="display: inline-block; min-width: 200px; font-size: 0.9em; color: #666;">5.28 - 49.48</span>
        <div id="Profit_Margin_range_continuous_filters_slider" style="margin: 10px 5px; width: 90%;"></div>
    </div>
    <div style="flex: 0 0 30%; text-align: right; padding-right: 10px; padding-top: 25px;">
        <span id="Profit_Margin_range_continuous_filters_obs_count" style="font-size: 0.9em; color: #666;"></span>
    </div>
    <script>
        $(function() {
            // Value formatter function
            function formatValue_Profit_Margin_range_continuous_filters(x) {
    return x === Math.floor(x) ? Math.floor(x).toString() : x.toFixed(2);
}

            // Initialize jQuery UI range slider
            $("#Profit_Margin_range_continuous_filters_slider").slider({
                range: true,
                min: 5.284191816018071,
                max: 49.48453411911737,
                step: 0.0442003423030993,  // Integer steps for integers, smooth for others
                values: [5.284191816018071, 49.48453411911737],
                slide: function(event, ui) {
                    // Update display during sliding
                    const minVal = ui.values[0];
                    const maxVal = ui.values[1];
                    $("#Profit_Margin_range_continuous_filters_display").text(formatValue_Profit_Margin_range_continuous_filters(minVal) + " - " + formatValue_Profit_Margin_range_continuous_filters(maxVal));
                },
                change: function(event, ui) {
                    // Update display and trigger chart update
                    const minVal = ui.values[0];
                    const maxVal = ui.values[1];
                    $("#Profit_Margin_range_continuous_filters_display").text(formatValue_Profit_Margin_range_continuous_filters(minVal) + " - " + formatValue_Profit_Margin_range_continuous_filters(maxVal));

                    // Store values for easy access
                    $("#Profit_Margin_range_continuous_filters_slider").data('minValue', minVal);
                    $("#Profit_Margin_range_continuous_filters_slider").data('maxValue', maxVal);

                    // Call the update function
                    updateChart_continuous_filters()
                }
            });

            // Store initial values
            $("#Profit_Margin_range_continuous_filters_slider").data('minValue', 5.284191816018071);
            $("#Profit_Margin_range_continuous_filters_slider").data('maxValue', 49.48453411911737);
        });

        // Helper functions to get slider values
        function getProfit_Margin_range_continuous_filtersMin() {
            return $("#Profit_Margin_range_continuous_filters_slider").slider("values", 0);
        }

        function getProfit_Margin_range_continuous_filtersMax() {
            return $("#Profit_Margin_range_continuous_filters_slider").slider("values", 1);
        }
    </script>
</div>

</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_continuous_filters">Aggregator: </label>
                <select id="aggregator_select_continuous_filters" onchange="updateChart_continuous_filters()">
                <option value="none">none</option>
                <option value="mean" selected>mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_continuous_filters_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>


<!-- Chart -->
<div id="continuous_filters"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: continuous_filter_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Key Features Summary</h2>
<ul>
    <li><strong>Dynamic X and Y dimensions:</strong> Choose which variables to plot on X and Y axes from dropdowns</li>
    <li><strong>Time series support:</strong> Automatic date formatting and axis scaling</li>
    <li><strong>Dynamic color grouping:</strong> Choose which variable to color by from dropdown</li>
    <li><strong>Aggregation:</strong> Handle multiple observations per x value with mean, median, count, min, max, or none</li>
    <li><strong>Interactive filters:</strong> Dropdown menus for categorical filtering and jQuery UI range sliders for continuous numeric filtering</li>
    <li><strong>Continuous range sliders:</strong> Single slider bar with two draggable handles for min/max values (powered by jQuery UI)</li>
    <li><strong>Dynamic faceting:</strong> Choose 0, 1, or 2 variables for faceting on the fly</li>
    <li><strong>Customization:</strong> Control titles, labels, line width, and markers</li>
    <li><strong>Integration:</strong> Combine with other plot types, images, and text</li>
</ul>
<p><strong>Tip:</strong> Hover over lines to see detailed values!</p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.3.1.</small></p>
</body>
</html>
