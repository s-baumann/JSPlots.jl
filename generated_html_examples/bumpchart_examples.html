<!DOCTYPE html>
<html>
<head>
    <title>JSPlots.jl</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
    

    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COL = 'period';
    const PERFORMANCE_COLS = ['performance', 'volatility'];
    const ENTITY_COL = 'strategy';
    const COLOR_MAP = {'Quality': '#ab63fa', 'Growth': '#636efa', 'Value': '#EF553B', 'Income': '#FFA15A', 'Momentum': '#00cc96'};
    const COLOR_PALETTE = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A',
                           '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];
    const DEFAULT_PERF_COL = 'performance';

    let allData = [];
    let entityColors = {};  // Store entity color assignments

    // Calculate dense ranks for data
    function calculateDenseRanks(data, xCol, perfCol) {
        const xGroups = {};
        data.forEach(row => {
            const xVal = row[xCol];
            const xKey = String(xVal);
            if (!xGroups[xKey]) {
                xGroups[xKey] = [];
            }
            xGroups[xKey].push(row);
        });

        const rankedData = [];
        for (let xKey in xGroups) {
            const group = xGroups[xKey];

            // Sort by performance descending (best first)
            const sorted = group.sort((a, b) => b[perfCol] - a[perfCol]);

            // Get unique performance values
            const uniqueValues = [...new Set(sorted.map(r => r[perfCol]))].sort((a, b) => b - a);

            // Assign dense ranks (ties get same rank, next rank = current + 1)
            const valueToRank = {};
            uniqueValues.forEach((val, idx) => {
                valueToRank[val] = idx + 1;  // Dense rank: 1, 2, 3, ... (no gaps)
            });

            sorted.forEach(row => {
                rankedData.push({
                    ...row,
                    y_value: valueToRank[row[perfCol]],
                    original_value: row[perfCol]
                });
            });
        }

        return rankedData;
    }

    // Assign colors to entities from filtered data
    function assignEntityColors(data) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        entityColors = {};
        entities.forEach((entity, idx) => {
            entityColors[entity] = COLOR_MAP[entity] || COLOR_PALETTE[idx % COLOR_PALETTE.length];
        });
    }

    // Make it global so inline onchange can see it
    window.updateChart_example1_bump = function() {
        // Get current performance column
        const perfColSelect = document.getElementById('perf_col_select_example1_bump');
        const PERF_COL = perfColSelect ? perfColSelect.value : DEFAULT_PERF_COL;

        // Get Y-axis mode
        const yModeSelect = document.getElementById('y_mode_select_example1_bump');
        const Y_MODE = yModeSelect ? yModeSelect.value : 'Ranking';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_example1_bump');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_example1_bump' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_example1_bump');
        const facet2Select = document.getElementById('facet2_select_example1_bump');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Apply filters with observation counting
        const filteredData = applyFiltersWithCounting(
            allData,
            'example1_bump',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Assign colors to entities in filtered data
        assignEntityColors(filteredData);

        // Route to appropriate rendering function
        // For facets, rankings will be calculated within each facet
        if (FACET_COLS.length === 0) {
            // No facets: calculate rankings globally
            let processedData;
            if (Y_MODE === 'Ranking') {
                processedData = calculateDenseRanks(filteredData, X_COL, PERF_COL);
            } else {
                processedData = filteredData.map(row => ({
                    ...row,
                    y_value: row[PERF_COL],
                    original_value: row[PERF_COL]
                }));
            }
            renderNoFacets(processedData, X_COL, Y_MODE);
        } else if (FACET_COLS.length === 1) {
            // One facet: pass raw data and PERF_COL, rankings calculated per facet
            renderOneFacet(filteredData, X_COL, Y_MODE, FACET_COLS[0], PERF_COL);
        } else {
            // Two facets: pass raw data and PERF_COL, rankings calculated per facet
            renderTwoFacets(filteredData, X_COL, Y_MODE, FACET_COLS[0], FACET_COLS[1], PERF_COL);
        }
    };

    // Render without facets
    function renderNoFacets(data, xCol, yMode) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        const traces = [];

        entities.forEach(entity => {
            const entityData = data.filter(row => String(row[ENTITY_COL]) === entity);
            entityData.sort((a, b) => {
                const aVal = a[xCol];
                const bVal = b[xCol];
                if (aVal instanceof Date && bVal instanceof Date) {
                    return aVal - bVal;
                }
                return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
            });

            const xValues = entityData.map(row => row[xCol]);
            const yValues = entityData.map(row => row.y_value);
            const origValues = entityData.map(row => row.original_value);

            traces.push({
                x: xValues,
                y: yValues,
                type: 'scatter',
                mode: 'lines+markers',
                name: entity,
                line: {
                    color: entityColors[entity],
                    width: 3
                },
                marker: {size: 6},
                customdata: origValues,
                hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                              (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                              '<extra></extra>'
            });
        });

        const layout = {
            xaxis: {title: xCol},
            yaxis: {
                title: yMode === 'Ranking' ? 'Rank' : 'Performance',
                autorange: yMode === 'Ranking' ? 'reversed' : true  // Rank 1 at top
            },
            hovermode: 'closest',
            showlegend: true
        };

        Plotly.newPlot('example1_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example1_bump', traces);
        });
    }

    // Render with one facet
    function renderOneFacet(data, xCol, yMode, facetCol, perfCol) {
        const facetValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nFacets = facetValues.length;

        // Calculate grid dimensions (prefer wider grids)
        const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
        const nRows = Math.ceil(nFacets / nCols);

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        facetValues.forEach((facetVal, idx) => {
            const rawFacetData = data.filter(row => row[facetCol] === facetVal);

            // Calculate rankings within this facet
            let facetData;
            if (yMode === 'Ranking') {
                facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
            } else {
                facetData = rawFacetData.map(row => ({
                    ...row,
                    y_value: row[perfCol],
                    original_value: row[perfCol]
                }));
            }

            const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

            const row = Math.floor(idx / nCols) + 1;
            const col = (idx % nCols) + 1;
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

            entities.forEach(entity => {
                const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                entityData.sort((a, b) => {
                    const aVal = a[xCol];
                    const bVal = b[xCol];
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }
                    return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                });

                const xValues = entityData.map(row => row[xCol]);
                const yValues = entityData.map(row => row.y_value);
                const origValues = entityData.map(row => row.original_value);

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: entity,
                    legendgroup: entity,
                    showlegend: idx === 0,
                    xaxis: xaxis,
                    yaxis: yaxis,
                    line: {
                        color: entityColors[entity],
                        width: 3
                    },
                    marker: {size: 6},
                    customdata: origValues,
                    hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                  (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                  '<extra></extra>'
                });
            });

            // Add axis configuration
            layout[xaxis] = {
                title: row === nRows ? xCol : '',
                anchor: yaxis
            };

            if (yMode === 'Ranking') {
                layout[yaxis] = {
                    title: col === 1 ? 'Rank' : '',
                    anchor: xaxis,
                    autorange: 'reversed'
                };
            } else {
                layout[yaxis] = {
                    title: col === 1 ? 'Performance' : '',
                    anchor: xaxis,
                    autorange: true
                };
            }

            // Add annotation for facet label
            if (!layout.annotations) layout.annotations = [];
            layout.annotations.push({
                text: facetCol + ': ' + facetVal,
                showarrow: false,
                xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                x: 0.5,
                y: 1.05,
                xanchor: 'center',
                yanchor: 'bottom',
                font: {size: 10}
            });
        });

        Plotly.newPlot('example1_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example1_bump', traces);
        });
    }

    // Render with two facets
    function renderTwoFacets(data, xCol, yMode, facetRow, facetCol, perfCol) {
        const rowValues = [...new Set(data.map(row => row[facetRow]))].sort();
        const colValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nRows = rowValues.length;
        const nCols = colValues.length;

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        rowValues.forEach((rowVal, rowIdx) => {
            colValues.forEach((colVal, colIdx) => {
                const rawFacetData = data.filter(row =>
                    row[facetRow] === rowVal && row[facetCol] === colVal
                );

                // Calculate rankings within this facet combination
                let facetData;
                if (yMode === 'Ranking') {
                    facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
                } else {
                    facetData = rawFacetData.map(row => ({
                        ...row,
                        y_value: row[perfCol],
                        original_value: row[perfCol]
                    }));
                }

                const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

                const idx = rowIdx * nCols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                entities.forEach(entity => {
                    const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                    entityData.sort((a, b) => {
                        const aVal = a[xCol];
                        const bVal = b[xCol];
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }
                        return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                    });

                    const xValues = entityData.map(row => row[xCol]);
                    const yValues = entityData.map(row => row.y_value);
                    const origValues = entityData.map(row => row.original_value);

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: entity,
                        legendgroup: entity,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: entityColors[entity],
                            width: 3
                        },
                        marker: {size: 6},
                        customdata: origValues,
                        hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                      (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                      '<extra></extra>'
                    });
                });

                // Add axis configuration
                layout[xaxis] = {
                    title: rowIdx === nRows - 1 ? xCol : '',
                    anchor: yaxis
                };

                if (yMode === 'Ranking') {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Rank' : '',
                        anchor: xaxis,
                        autorange: 'reversed'
                    };
                } else {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Performance' : '',
                        anchor: xaxis,
                        autorange: true
                    };
                }

                // Add annotations for facet labels
                if (!layout.annotations) layout.annotations = [];

                // Column header
                if (rowIdx === 0) {
                    layout.annotations.push({
                        text: facetCol + ': ' + colVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 0.5,
                        y: 1.1,
                        xanchor: 'center',
                        yanchor: 'bottom',
                        font: {size: 10}
                    });
                }

                // Row label
                if (colIdx === nCols - 1) {
                    layout.annotations.push({
                        text: facetRow + ': ' + rowVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 1.05,
                        y: 0.5,
                        xanchor: 'left',
                        yanchor: 'middle',
                        textangle: -90,
                        font: {size: 10}
                    });
                }
            });
        });

        Plotly.newPlot('example1_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example1_bump', traces);
        });
    }

    // Setup cross-facet highlighting (hover over one line greys out all others)
    function setupCrossFacetHighlighting(chartId, allTraces) {
        const chartDiv = document.getElementById(chartId);
        const originalColors = allTraces.map(t => t.line.color);

        chartDiv.on('plotly_hover', function(data) {
            if (!data.points || data.points.length === 0) return;

            const hoveredEntity = data.points[0].data.name;

            // Update all traces: hovered stays colored, others turn grey
            const updates = allTraces.map((trace, idx) => {
                if (trace.name === hoveredEntity) {
                    return originalColors[idx];  // Keep original color
                } else {
                    return 'rgba(200, 200, 200, 0.3)';  // Grey out
                }
            });

            Plotly.restyle(chartId, {'line.color': updates});
        });

        chartDiv.on('plotly_unhover', function() {
            // Restore all original colors
            Plotly.restyle(chartId, {'line.color': originalColors});
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('strategy_data').then(function(data) {
        allData = data;
        window.updateChart_example1_bump();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('example1_bump');
    }).catch(function(error) {
        console.error('Error loading data for chart example1_bump:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['region'];
    const CONTINUOUS_FILTERS = [];
    const X_COL = 'quarter';
    const PERFORMANCE_COLS = ['sales', 'market_share'];
    const ENTITY_COL = 'product';
    const COLOR_MAP = {'Product A': '#636efa', 'Product C': '#00cc96', 'Product D': '#ab63fa', 'Product B': '#EF553B'};
    const COLOR_PALETTE = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A',
                           '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];
    const DEFAULT_PERF_COL = 'sales';

    let allData = [];
    let entityColors = {};  // Store entity color assignments

    // Calculate dense ranks for data
    function calculateDenseRanks(data, xCol, perfCol) {
        const xGroups = {};
        data.forEach(row => {
            const xVal = row[xCol];
            const xKey = String(xVal);
            if (!xGroups[xKey]) {
                xGroups[xKey] = [];
            }
            xGroups[xKey].push(row);
        });

        const rankedData = [];
        for (let xKey in xGroups) {
            const group = xGroups[xKey];

            // Sort by performance descending (best first)
            const sorted = group.sort((a, b) => b[perfCol] - a[perfCol]);

            // Get unique performance values
            const uniqueValues = [...new Set(sorted.map(r => r[perfCol]))].sort((a, b) => b - a);

            // Assign dense ranks (ties get same rank, next rank = current + 1)
            const valueToRank = {};
            uniqueValues.forEach((val, idx) => {
                valueToRank[val] = idx + 1;  // Dense rank: 1, 2, 3, ... (no gaps)
            });

            sorted.forEach(row => {
                rankedData.push({
                    ...row,
                    y_value: valueToRank[row[perfCol]],
                    original_value: row[perfCol]
                });
            });
        }

        return rankedData;
    }

    // Assign colors to entities from filtered data
    function assignEntityColors(data) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        entityColors = {};
        entities.forEach((entity, idx) => {
            entityColors[entity] = COLOR_MAP[entity] || COLOR_PALETTE[idx % COLOR_PALETTE.length];
        });
    }

    // Make it global so inline onchange can see it
    window.updateChart_example2_bump = function() {
        // Get current performance column
        const perfColSelect = document.getElementById('perf_col_select_example2_bump');
        const PERF_COL = perfColSelect ? perfColSelect.value : DEFAULT_PERF_COL;

        // Get Y-axis mode
        const yModeSelect = document.getElementById('y_mode_select_example2_bump');
        const Y_MODE = yModeSelect ? yModeSelect.value : 'Ranking';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_example2_bump');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_example2_bump' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_example2_bump');
        const facet2Select = document.getElementById('facet2_select_example2_bump');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Apply filters with observation counting
        const filteredData = applyFiltersWithCounting(
            allData,
            'example2_bump',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Assign colors to entities in filtered data
        assignEntityColors(filteredData);

        // Route to appropriate rendering function
        // For facets, rankings will be calculated within each facet
        if (FACET_COLS.length === 0) {
            // No facets: calculate rankings globally
            let processedData;
            if (Y_MODE === 'Ranking') {
                processedData = calculateDenseRanks(filteredData, X_COL, PERF_COL);
            } else {
                processedData = filteredData.map(row => ({
                    ...row,
                    y_value: row[PERF_COL],
                    original_value: row[PERF_COL]
                }));
            }
            renderNoFacets(processedData, X_COL, Y_MODE);
        } else if (FACET_COLS.length === 1) {
            // One facet: pass raw data and PERF_COL, rankings calculated per facet
            renderOneFacet(filteredData, X_COL, Y_MODE, FACET_COLS[0], PERF_COL);
        } else {
            // Two facets: pass raw data and PERF_COL, rankings calculated per facet
            renderTwoFacets(filteredData, X_COL, Y_MODE, FACET_COLS[0], FACET_COLS[1], PERF_COL);
        }
    };

    // Render without facets
    function renderNoFacets(data, xCol, yMode) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        const traces = [];

        entities.forEach(entity => {
            const entityData = data.filter(row => String(row[ENTITY_COL]) === entity);
            entityData.sort((a, b) => {
                const aVal = a[xCol];
                const bVal = b[xCol];
                if (aVal instanceof Date && bVal instanceof Date) {
                    return aVal - bVal;
                }
                return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
            });

            const xValues = entityData.map(row => row[xCol]);
            const yValues = entityData.map(row => row.y_value);
            const origValues = entityData.map(row => row.original_value);

            traces.push({
                x: xValues,
                y: yValues,
                type: 'scatter',
                mode: 'lines+markers',
                name: entity,
                line: {
                    color: entityColors[entity],
                    width: 2
                },
                marker: {size: 6},
                customdata: origValues,
                hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                              (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                              '<extra></extra>'
            });
        });

        const layout = {
            xaxis: {title: xCol},
            yaxis: {
                title: yMode === 'Ranking' ? 'Rank' : 'Performance',
                autorange: yMode === 'Ranking' ? 'reversed' : true  // Rank 1 at top
            },
            hovermode: 'closest',
            showlegend: true
        };

        Plotly.newPlot('example2_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example2_bump', traces);
        });
    }

    // Render with one facet
    function renderOneFacet(data, xCol, yMode, facetCol, perfCol) {
        const facetValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nFacets = facetValues.length;

        // Calculate grid dimensions (prefer wider grids)
        const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
        const nRows = Math.ceil(nFacets / nCols);

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        facetValues.forEach((facetVal, idx) => {
            const rawFacetData = data.filter(row => row[facetCol] === facetVal);

            // Calculate rankings within this facet
            let facetData;
            if (yMode === 'Ranking') {
                facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
            } else {
                facetData = rawFacetData.map(row => ({
                    ...row,
                    y_value: row[perfCol],
                    original_value: row[perfCol]
                }));
            }

            const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

            const row = Math.floor(idx / nCols) + 1;
            const col = (idx % nCols) + 1;
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

            entities.forEach(entity => {
                const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                entityData.sort((a, b) => {
                    const aVal = a[xCol];
                    const bVal = b[xCol];
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }
                    return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                });

                const xValues = entityData.map(row => row[xCol]);
                const yValues = entityData.map(row => row.y_value);
                const origValues = entityData.map(row => row.original_value);

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: entity,
                    legendgroup: entity,
                    showlegend: idx === 0,
                    xaxis: xaxis,
                    yaxis: yaxis,
                    line: {
                        color: entityColors[entity],
                        width: 2
                    },
                    marker: {size: 6},
                    customdata: origValues,
                    hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                  (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                  '<extra></extra>'
                });
            });

            // Add axis configuration
            layout[xaxis] = {
                title: row === nRows ? xCol : '',
                anchor: yaxis
            };

            if (yMode === 'Ranking') {
                layout[yaxis] = {
                    title: col === 1 ? 'Rank' : '',
                    anchor: xaxis,
                    autorange: 'reversed'
                };
            } else {
                layout[yaxis] = {
                    title: col === 1 ? 'Performance' : '',
                    anchor: xaxis,
                    autorange: true
                };
            }

            // Add annotation for facet label
            if (!layout.annotations) layout.annotations = [];
            layout.annotations.push({
                text: facetCol + ': ' + facetVal,
                showarrow: false,
                xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                x: 0.5,
                y: 1.05,
                xanchor: 'center',
                yanchor: 'bottom',
                font: {size: 10}
            });
        });

        Plotly.newPlot('example2_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example2_bump', traces);
        });
    }

    // Render with two facets
    function renderTwoFacets(data, xCol, yMode, facetRow, facetCol, perfCol) {
        const rowValues = [...new Set(data.map(row => row[facetRow]))].sort();
        const colValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nRows = rowValues.length;
        const nCols = colValues.length;

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        rowValues.forEach((rowVal, rowIdx) => {
            colValues.forEach((colVal, colIdx) => {
                const rawFacetData = data.filter(row =>
                    row[facetRow] === rowVal && row[facetCol] === colVal
                );

                // Calculate rankings within this facet combination
                let facetData;
                if (yMode === 'Ranking') {
                    facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
                } else {
                    facetData = rawFacetData.map(row => ({
                        ...row,
                        y_value: row[perfCol],
                        original_value: row[perfCol]
                    }));
                }

                const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

                const idx = rowIdx * nCols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                entities.forEach(entity => {
                    const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                    entityData.sort((a, b) => {
                        const aVal = a[xCol];
                        const bVal = b[xCol];
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }
                        return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                    });

                    const xValues = entityData.map(row => row[xCol]);
                    const yValues = entityData.map(row => row.y_value);
                    const origValues = entityData.map(row => row.original_value);

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: entity,
                        legendgroup: entity,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: entityColors[entity],
                            width: 2
                        },
                        marker: {size: 6},
                        customdata: origValues,
                        hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                      (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                      '<extra></extra>'
                    });
                });

                // Add axis configuration
                layout[xaxis] = {
                    title: rowIdx === nRows - 1 ? xCol : '',
                    anchor: yaxis
                };

                if (yMode === 'Ranking') {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Rank' : '',
                        anchor: xaxis,
                        autorange: 'reversed'
                    };
                } else {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Performance' : '',
                        anchor: xaxis,
                        autorange: true
                    };
                }

                // Add annotations for facet labels
                if (!layout.annotations) layout.annotations = [];

                // Column header
                if (rowIdx === 0) {
                    layout.annotations.push({
                        text: facetCol + ': ' + colVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 0.5,
                        y: 1.1,
                        xanchor: 'center',
                        yanchor: 'bottom',
                        font: {size: 10}
                    });
                }

                // Row label
                if (colIdx === nCols - 1) {
                    layout.annotations.push({
                        text: facetRow + ': ' + rowVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 1.05,
                        y: 0.5,
                        xanchor: 'left',
                        yanchor: 'middle',
                        textangle: -90,
                        font: {size: 10}
                    });
                }
            });
        });

        Plotly.newPlot('example2_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example2_bump', traces);
        });
    }

    // Setup cross-facet highlighting (hover over one line greys out all others)
    function setupCrossFacetHighlighting(chartId, allTraces) {
        const chartDiv = document.getElementById(chartId);
        const originalColors = allTraces.map(t => t.line.color);

        chartDiv.on('plotly_hover', function(data) {
            if (!data.points || data.points.length === 0) return;

            const hoveredEntity = data.points[0].data.name;

            // Update all traces: hovered stays colored, others turn grey
            const updates = allTraces.map((trace, idx) => {
                if (trace.name === hoveredEntity) {
                    return originalColors[idx];  // Keep original color
                } else {
                    return 'rgba(200, 200, 200, 0.3)';  // Grey out
                }
            });

            Plotly.restyle(chartId, {'line.color': updates});
        });

        chartDiv.on('plotly_unhover', function() {
            // Restore all original colors
            Plotly.restyle(chartId, {'line.color': originalColors});
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('product_data').then(function(data) {
        allData = data;
        window.updateChart_example2_bump();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('example2_bump');
    }).catch(function(error) {
        console.error('Error loading data for chart example2_bump:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['company'];
    const CONTINUOUS_FILTERS = [];
    const X_COL = 'month';
    const PERFORMANCE_COLS = ['revenue', 'profit_margin'];
    const ENTITY_COL = 'company';
    const COLOR_MAP = {'Gamma LLC': '#00cc96', 'Delta Co': '#ab63fa', 'Alpha Corp': '#636efa', 'Beta Inc': '#EF553B'};
    const COLOR_PALETTE = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A',
                           '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];
    const DEFAULT_PERF_COL = 'revenue';

    let allData = [];
    let entityColors = {};  // Store entity color assignments

    // Calculate dense ranks for data
    function calculateDenseRanks(data, xCol, perfCol) {
        const xGroups = {};
        data.forEach(row => {
            const xVal = row[xCol];
            const xKey = String(xVal);
            if (!xGroups[xKey]) {
                xGroups[xKey] = [];
            }
            xGroups[xKey].push(row);
        });

        const rankedData = [];
        for (let xKey in xGroups) {
            const group = xGroups[xKey];

            // Sort by performance descending (best first)
            const sorted = group.sort((a, b) => b[perfCol] - a[perfCol]);

            // Get unique performance values
            const uniqueValues = [...new Set(sorted.map(r => r[perfCol]))].sort((a, b) => b - a);

            // Assign dense ranks (ties get same rank, next rank = current + 1)
            const valueToRank = {};
            uniqueValues.forEach((val, idx) => {
                valueToRank[val] = idx + 1;  // Dense rank: 1, 2, 3, ... (no gaps)
            });

            sorted.forEach(row => {
                rankedData.push({
                    ...row,
                    y_value: valueToRank[row[perfCol]],
                    original_value: row[perfCol]
                });
            });
        }

        return rankedData;
    }

    // Assign colors to entities from filtered data
    function assignEntityColors(data) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        entityColors = {};
        entities.forEach((entity, idx) => {
            entityColors[entity] = COLOR_MAP[entity] || COLOR_PALETTE[idx % COLOR_PALETTE.length];
        });
    }

    // Make it global so inline onchange can see it
    window.updateChart_example3_bump = function() {
        // Get current performance column
        const perfColSelect = document.getElementById('perf_col_select_example3_bump');
        const PERF_COL = perfColSelect ? perfColSelect.value : DEFAULT_PERF_COL;

        // Get Y-axis mode
        const yModeSelect = document.getElementById('y_mode_select_example3_bump');
        const Y_MODE = yModeSelect ? yModeSelect.value : 'Absolute';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_example3_bump');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_example3_bump' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_example3_bump');
        const facet2Select = document.getElementById('facet2_select_example3_bump');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Apply filters with observation counting
        const filteredData = applyFiltersWithCounting(
            allData,
            'example3_bump',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Assign colors to entities in filtered data
        assignEntityColors(filteredData);

        // Route to appropriate rendering function
        // For facets, rankings will be calculated within each facet
        if (FACET_COLS.length === 0) {
            // No facets: calculate rankings globally
            let processedData;
            if (Y_MODE === 'Ranking') {
                processedData = calculateDenseRanks(filteredData, X_COL, PERF_COL);
            } else {
                processedData = filteredData.map(row => ({
                    ...row,
                    y_value: row[PERF_COL],
                    original_value: row[PERF_COL]
                }));
            }
            renderNoFacets(processedData, X_COL, Y_MODE);
        } else if (FACET_COLS.length === 1) {
            // One facet: pass raw data and PERF_COL, rankings calculated per facet
            renderOneFacet(filteredData, X_COL, Y_MODE, FACET_COLS[0], PERF_COL);
        } else {
            // Two facets: pass raw data and PERF_COL, rankings calculated per facet
            renderTwoFacets(filteredData, X_COL, Y_MODE, FACET_COLS[0], FACET_COLS[1], PERF_COL);
        }
    };

    // Render without facets
    function renderNoFacets(data, xCol, yMode) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        const traces = [];

        entities.forEach(entity => {
            const entityData = data.filter(row => String(row[ENTITY_COL]) === entity);
            entityData.sort((a, b) => {
                const aVal = a[xCol];
                const bVal = b[xCol];
                if (aVal instanceof Date && bVal instanceof Date) {
                    return aVal - bVal;
                }
                return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
            });

            const xValues = entityData.map(row => row[xCol]);
            const yValues = entityData.map(row => row.y_value);
            const origValues = entityData.map(row => row.original_value);

            traces.push({
                x: xValues,
                y: yValues,
                type: 'scatter',
                mode: 'lines+markers',
                name: entity,
                line: {
                    color: entityColors[entity],
                    width: 2
                },
                marker: {size: 6},
                customdata: origValues,
                hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                              (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                              '<extra></extra>'
            });
        });

        const layout = {
            xaxis: {title: xCol},
            yaxis: {
                title: yMode === 'Ranking' ? 'Rank' : 'Performance',
                autorange: yMode === 'Ranking' ? 'reversed' : true  // Rank 1 at top
            },
            hovermode: 'closest',
            showlegend: true
        };

        Plotly.newPlot('example3_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example3_bump', traces);
        });
    }

    // Render with one facet
    function renderOneFacet(data, xCol, yMode, facetCol, perfCol) {
        const facetValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nFacets = facetValues.length;

        // Calculate grid dimensions (prefer wider grids)
        const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
        const nRows = Math.ceil(nFacets / nCols);

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        facetValues.forEach((facetVal, idx) => {
            const rawFacetData = data.filter(row => row[facetCol] === facetVal);

            // Calculate rankings within this facet
            let facetData;
            if (yMode === 'Ranking') {
                facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
            } else {
                facetData = rawFacetData.map(row => ({
                    ...row,
                    y_value: row[perfCol],
                    original_value: row[perfCol]
                }));
            }

            const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

            const row = Math.floor(idx / nCols) + 1;
            const col = (idx % nCols) + 1;
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

            entities.forEach(entity => {
                const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                entityData.sort((a, b) => {
                    const aVal = a[xCol];
                    const bVal = b[xCol];
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }
                    return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                });

                const xValues = entityData.map(row => row[xCol]);
                const yValues = entityData.map(row => row.y_value);
                const origValues = entityData.map(row => row.original_value);

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: entity,
                    legendgroup: entity,
                    showlegend: idx === 0,
                    xaxis: xaxis,
                    yaxis: yaxis,
                    line: {
                        color: entityColors[entity],
                        width: 2
                    },
                    marker: {size: 6},
                    customdata: origValues,
                    hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                  (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                  '<extra></extra>'
                });
            });

            // Add axis configuration
            layout[xaxis] = {
                title: row === nRows ? xCol : '',
                anchor: yaxis
            };

            if (yMode === 'Ranking') {
                layout[yaxis] = {
                    title: col === 1 ? 'Rank' : '',
                    anchor: xaxis,
                    autorange: 'reversed'
                };
            } else {
                layout[yaxis] = {
                    title: col === 1 ? 'Performance' : '',
                    anchor: xaxis,
                    autorange: true
                };
            }

            // Add annotation for facet label
            if (!layout.annotations) layout.annotations = [];
            layout.annotations.push({
                text: facetCol + ': ' + facetVal,
                showarrow: false,
                xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                x: 0.5,
                y: 1.05,
                xanchor: 'center',
                yanchor: 'bottom',
                font: {size: 10}
            });
        });

        Plotly.newPlot('example3_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example3_bump', traces);
        });
    }

    // Render with two facets
    function renderTwoFacets(data, xCol, yMode, facetRow, facetCol, perfCol) {
        const rowValues = [...new Set(data.map(row => row[facetRow]))].sort();
        const colValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nRows = rowValues.length;
        const nCols = colValues.length;

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        rowValues.forEach((rowVal, rowIdx) => {
            colValues.forEach((colVal, colIdx) => {
                const rawFacetData = data.filter(row =>
                    row[facetRow] === rowVal && row[facetCol] === colVal
                );

                // Calculate rankings within this facet combination
                let facetData;
                if (yMode === 'Ranking') {
                    facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
                } else {
                    facetData = rawFacetData.map(row => ({
                        ...row,
                        y_value: row[perfCol],
                        original_value: row[perfCol]
                    }));
                }

                const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

                const idx = rowIdx * nCols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                entities.forEach(entity => {
                    const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                    entityData.sort((a, b) => {
                        const aVal = a[xCol];
                        const bVal = b[xCol];
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }
                        return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                    });

                    const xValues = entityData.map(row => row[xCol]);
                    const yValues = entityData.map(row => row.y_value);
                    const origValues = entityData.map(row => row.original_value);

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: entity,
                        legendgroup: entity,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: entityColors[entity],
                            width: 2
                        },
                        marker: {size: 6},
                        customdata: origValues,
                        hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                      (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                      '<extra></extra>'
                    });
                });

                // Add axis configuration
                layout[xaxis] = {
                    title: rowIdx === nRows - 1 ? xCol : '',
                    anchor: yaxis
                };

                if (yMode === 'Ranking') {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Rank' : '',
                        anchor: xaxis,
                        autorange: 'reversed'
                    };
                } else {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Performance' : '',
                        anchor: xaxis,
                        autorange: true
                    };
                }

                // Add annotations for facet labels
                if (!layout.annotations) layout.annotations = [];

                // Column header
                if (rowIdx === 0) {
                    layout.annotations.push({
                        text: facetCol + ': ' + colVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 0.5,
                        y: 1.1,
                        xanchor: 'center',
                        yanchor: 'bottom',
                        font: {size: 10}
                    });
                }

                // Row label
                if (colIdx === nCols - 1) {
                    layout.annotations.push({
                        text: facetRow + ': ' + rowVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 1.05,
                        y: 0.5,
                        xanchor: 'left',
                        yanchor: 'middle',
                        textangle: -90,
                        font: {size: 10}
                    });
                }
            });
        });

        Plotly.newPlot('example3_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example3_bump', traces);
        });
    }

    // Setup cross-facet highlighting (hover over one line greys out all others)
    function setupCrossFacetHighlighting(chartId, allTraces) {
        const chartDiv = document.getElementById(chartId);
        const originalColors = allTraces.map(t => t.line.color);

        chartDiv.on('plotly_hover', function(data) {
            if (!data.points || data.points.length === 0) return;

            const hoveredEntity = data.points[0].data.name;

            // Update all traces: hovered stays colored, others turn grey
            const updates = allTraces.map((trace, idx) => {
                if (trace.name === hoveredEntity) {
                    return originalColors[idx];  // Keep original color
                } else {
                    return 'rgba(200, 200, 200, 0.3)';  // Grey out
                }
            });

            Plotly.restyle(chartId, {'line.color': updates});
        });

        chartDiv.on('plotly_unhover', function() {
            // Restore all original colors
            Plotly.restyle(chartId, {'line.color': originalColors});
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('company_performance').then(function(data) {
        allData = data;
        window.updateChart_example3_bump();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('example3_bump');
    }).catch(function(error) {
        console.error('Error loading data for chart example3_bump:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COL = 'week';
    const PERFORMANCE_COLS = ['points'];
    const ENTITY_COL = 'team';
    const COLOR_MAP = {'Blue Tigers': '#EF553B', 'Red Bulls': '#636efa', 'Green Eagles': '#00cc96', 'Yellow Lions': '#ab63fa'};
    const COLOR_PALETTE = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A',
                           '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];
    const DEFAULT_PERF_COL = 'points';

    let allData = [];
    let entityColors = {};  // Store entity color assignments

    // Calculate dense ranks for data
    function calculateDenseRanks(data, xCol, perfCol) {
        const xGroups = {};
        data.forEach(row => {
            const xVal = row[xCol];
            const xKey = String(xVal);
            if (!xGroups[xKey]) {
                xGroups[xKey] = [];
            }
            xGroups[xKey].push(row);
        });

        const rankedData = [];
        for (let xKey in xGroups) {
            const group = xGroups[xKey];

            // Sort by performance descending (best first)
            const sorted = group.sort((a, b) => b[perfCol] - a[perfCol]);

            // Get unique performance values
            const uniqueValues = [...new Set(sorted.map(r => r[perfCol]))].sort((a, b) => b - a);

            // Assign dense ranks (ties get same rank, next rank = current + 1)
            const valueToRank = {};
            uniqueValues.forEach((val, idx) => {
                valueToRank[val] = idx + 1;  // Dense rank: 1, 2, 3, ... (no gaps)
            });

            sorted.forEach(row => {
                rankedData.push({
                    ...row,
                    y_value: valueToRank[row[perfCol]],
                    original_value: row[perfCol]
                });
            });
        }

        return rankedData;
    }

    // Assign colors to entities from filtered data
    function assignEntityColors(data) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        entityColors = {};
        entities.forEach((entity, idx) => {
            entityColors[entity] = COLOR_MAP[entity] || COLOR_PALETTE[idx % COLOR_PALETTE.length];
        });
    }

    // Make it global so inline onchange can see it
    window.updateChart_example4_bump = function() {
        // Get current performance column
        const perfColSelect = document.getElementById('perf_col_select_example4_bump');
        const PERF_COL = perfColSelect ? perfColSelect.value : DEFAULT_PERF_COL;

        // Get Y-axis mode
        const yModeSelect = document.getElementById('y_mode_select_example4_bump');
        const Y_MODE = yModeSelect ? yModeSelect.value : 'Ranking';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_example4_bump');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_example4_bump' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_example4_bump');
        const facet2Select = document.getElementById('facet2_select_example4_bump');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Apply filters with observation counting
        const filteredData = applyFiltersWithCounting(
            allData,
            'example4_bump',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Assign colors to entities in filtered data
        assignEntityColors(filteredData);

        // Route to appropriate rendering function
        // For facets, rankings will be calculated within each facet
        if (FACET_COLS.length === 0) {
            // No facets: calculate rankings globally
            let processedData;
            if (Y_MODE === 'Ranking') {
                processedData = calculateDenseRanks(filteredData, X_COL, PERF_COL);
            } else {
                processedData = filteredData.map(row => ({
                    ...row,
                    y_value: row[PERF_COL],
                    original_value: row[PERF_COL]
                }));
            }
            renderNoFacets(processedData, X_COL, Y_MODE);
        } else if (FACET_COLS.length === 1) {
            // One facet: pass raw data and PERF_COL, rankings calculated per facet
            renderOneFacet(filteredData, X_COL, Y_MODE, FACET_COLS[0], PERF_COL);
        } else {
            // Two facets: pass raw data and PERF_COL, rankings calculated per facet
            renderTwoFacets(filteredData, X_COL, Y_MODE, FACET_COLS[0], FACET_COLS[1], PERF_COL);
        }
    };

    // Render without facets
    function renderNoFacets(data, xCol, yMode) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        const traces = [];

        entities.forEach(entity => {
            const entityData = data.filter(row => String(row[ENTITY_COL]) === entity);
            entityData.sort((a, b) => {
                const aVal = a[xCol];
                const bVal = b[xCol];
                if (aVal instanceof Date && bVal instanceof Date) {
                    return aVal - bVal;
                }
                return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
            });

            const xValues = entityData.map(row => row[xCol]);
            const yValues = entityData.map(row => row.y_value);
            const origValues = entityData.map(row => row.original_value);

            traces.push({
                x: xValues,
                y: yValues,
                type: 'scatter',
                mode: 'lines+markers',
                name: entity,
                line: {
                    color: entityColors[entity],
                    width: 3
                },
                marker: {size: 6},
                customdata: origValues,
                hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                              (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                              '<extra></extra>'
            });
        });

        const layout = {
            xaxis: {title: xCol},
            yaxis: {
                title: yMode === 'Ranking' ? 'Rank' : 'Performance',
                autorange: yMode === 'Ranking' ? 'reversed' : true  // Rank 1 at top
            },
            hovermode: 'closest',
            showlegend: true
        };

        Plotly.newPlot('example4_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example4_bump', traces);
        });
    }

    // Render with one facet
    function renderOneFacet(data, xCol, yMode, facetCol, perfCol) {
        const facetValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nFacets = facetValues.length;

        // Calculate grid dimensions (prefer wider grids)
        const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
        const nRows = Math.ceil(nFacets / nCols);

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        facetValues.forEach((facetVal, idx) => {
            const rawFacetData = data.filter(row => row[facetCol] === facetVal);

            // Calculate rankings within this facet
            let facetData;
            if (yMode === 'Ranking') {
                facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
            } else {
                facetData = rawFacetData.map(row => ({
                    ...row,
                    y_value: row[perfCol],
                    original_value: row[perfCol]
                }));
            }

            const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

            const row = Math.floor(idx / nCols) + 1;
            const col = (idx % nCols) + 1;
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

            entities.forEach(entity => {
                const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                entityData.sort((a, b) => {
                    const aVal = a[xCol];
                    const bVal = b[xCol];
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }
                    return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                });

                const xValues = entityData.map(row => row[xCol]);
                const yValues = entityData.map(row => row.y_value);
                const origValues = entityData.map(row => row.original_value);

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: entity,
                    legendgroup: entity,
                    showlegend: idx === 0,
                    xaxis: xaxis,
                    yaxis: yaxis,
                    line: {
                        color: entityColors[entity],
                        width: 3
                    },
                    marker: {size: 6},
                    customdata: origValues,
                    hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                  (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                  '<extra></extra>'
                });
            });

            // Add axis configuration
            layout[xaxis] = {
                title: row === nRows ? xCol : '',
                anchor: yaxis
            };

            if (yMode === 'Ranking') {
                layout[yaxis] = {
                    title: col === 1 ? 'Rank' : '',
                    anchor: xaxis,
                    autorange: 'reversed'
                };
            } else {
                layout[yaxis] = {
                    title: col === 1 ? 'Performance' : '',
                    anchor: xaxis,
                    autorange: true
                };
            }

            // Add annotation for facet label
            if (!layout.annotations) layout.annotations = [];
            layout.annotations.push({
                text: facetCol + ': ' + facetVal,
                showarrow: false,
                xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                x: 0.5,
                y: 1.05,
                xanchor: 'center',
                yanchor: 'bottom',
                font: {size: 10}
            });
        });

        Plotly.newPlot('example4_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example4_bump', traces);
        });
    }

    // Render with two facets
    function renderTwoFacets(data, xCol, yMode, facetRow, facetCol, perfCol) {
        const rowValues = [...new Set(data.map(row => row[facetRow]))].sort();
        const colValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nRows = rowValues.length;
        const nCols = colValues.length;

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        rowValues.forEach((rowVal, rowIdx) => {
            colValues.forEach((colVal, colIdx) => {
                const rawFacetData = data.filter(row =>
                    row[facetRow] === rowVal && row[facetCol] === colVal
                );

                // Calculate rankings within this facet combination
                let facetData;
                if (yMode === 'Ranking') {
                    facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
                } else {
                    facetData = rawFacetData.map(row => ({
                        ...row,
                        y_value: row[perfCol],
                        original_value: row[perfCol]
                    }));
                }

                const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

                const idx = rowIdx * nCols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                entities.forEach(entity => {
                    const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                    entityData.sort((a, b) => {
                        const aVal = a[xCol];
                        const bVal = b[xCol];
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }
                        return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                    });

                    const xValues = entityData.map(row => row[xCol]);
                    const yValues = entityData.map(row => row.y_value);
                    const origValues = entityData.map(row => row.original_value);

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: entity,
                        legendgroup: entity,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: entityColors[entity],
                            width: 3
                        },
                        marker: {size: 6},
                        customdata: origValues,
                        hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                      (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                      '<extra></extra>'
                    });
                });

                // Add axis configuration
                layout[xaxis] = {
                    title: rowIdx === nRows - 1 ? xCol : '',
                    anchor: yaxis
                };

                if (yMode === 'Ranking') {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Rank' : '',
                        anchor: xaxis,
                        autorange: 'reversed'
                    };
                } else {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Performance' : '',
                        anchor: xaxis,
                        autorange: true
                    };
                }

                // Add annotations for facet labels
                if (!layout.annotations) layout.annotations = [];

                // Column header
                if (rowIdx === 0) {
                    layout.annotations.push({
                        text: facetCol + ': ' + colVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 0.5,
                        y: 1.1,
                        xanchor: 'center',
                        yanchor: 'bottom',
                        font: {size: 10}
                    });
                }

                // Row label
                if (colIdx === nCols - 1) {
                    layout.annotations.push({
                        text: facetRow + ': ' + rowVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 1.05,
                        y: 0.5,
                        xanchor: 'left',
                        yanchor: 'middle',
                        textangle: -90,
                        font: {size: 10}
                    });
                }
            });
        });

        Plotly.newPlot('example4_bump', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('example4_bump', traces);
        });
    }

    // Setup cross-facet highlighting (hover over one line greys out all others)
    function setupCrossFacetHighlighting(chartId, allTraces) {
        const chartDiv = document.getElementById(chartId);
        const originalColors = allTraces.map(t => t.line.color);

        chartDiv.on('plotly_hover', function(data) {
            if (!data.points || data.points.length === 0) return;

            const hoveredEntity = data.points[0].data.name;

            // Update all traces: hovered stays colored, others turn grey
            const updates = allTraces.map((trace, idx) => {
                if (trace.name === hoveredEntity) {
                    return originalColors[idx];  // Keep original color
                } else {
                    return 'rgba(200, 200, 200, 0.3)';  // Grey out
                }
            });

            Plotly.restyle(chartId, {'line.color': updates});
        });

        chartDiv.on('plotly_unhover', function() {
            // Restore all original colors
            Plotly.restyle(chartId, {'line.color': originalColors});
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('league.rankings').then(function(data) {
        allData = data;
        window.updateChart_example4_bump();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('example4_bump');
    }).catch(function(error) {
        console.error('Error loading data for chart example4_bump:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="strategy_data" data-format="csv_embedded" data-src="">
period,strategy,performance,volatility
1,Growth,69.01635575142528,7.0
2,Growth,74.5722600520778,8.0
3,Growth,78.4224039061839,14.0
4,Growth,83.45089574494467,7.0
5,Growth,87.3285067593529,15.0
6,Growth,87.03490681532955,13.0
7,Growth,83.62542524296566,10.0
8,Growth,82.46861725239621,19.0
9,Growth,77.43669906117333,8.0
10,Growth,67.36250683171887,17.0
11,Growth,62.757403976089364,18.0
12,Growth,56.210772825353644,17.0
1,Value,67.80779765201628,7.0
2,Value,71.93754321850389,11.0
3,Value,68.55327247802951,17.0
4,Value,72.51199963807007,6.0
5,Value,63.57002443928656,10.0
6,Value,59.710715775822415,16.0
7,Value,61.803876649395875,17.0
8,Value,60.37931289947612,11.0
9,Value,67.38547114001611,13.0
10,Value,59.22163190696412,13.0
11,Value,62.105543154156045,7.0
12,Value,59.06290603973719,10.0
1,Momentum,49.77985222723332,16.0
2,Momentum,48.14012270221227,15.0
3,Momentum,43.03368282228612,9.0
4,Momentum,44.5094819599307,15.0
5,Momentum,50.81723996330829,16.0
6,Momentum,46.22702682313252,15.0
7,Momentum,46.73601707509732,18.0
8,Momentum,45.782150896279795,12.0
9,Momentum,41.92897132026037,15.0
10,Momentum,43.52338254286349,16.0
11,Momentum,42.61752070068264,16.0
12,Momentum,45.01736386939758,17.0
1,Quality,82.76833383008304,18.0
2,Quality,83.41619284143042,15.0
3,Quality,74.98369122819774,16.0
4,Quality,71.43803175024657,13.0
5,Quality,74.33361566973804,14.0
6,Quality,79.06168097724874,5.0
7,Quality,80.82941227990823,9.0
8,Quality,83.2358675504648,12.0
9,Quality,73.60463344681557,5.0
10,Quality,78.69674990873439,10.0
11,Quality,79.2021398330601,17.0
12,Quality,80.72636576466599,15.0
1,Income,49.801251364502015,17.0
2,Income,49.03141445670409,14.0
3,Income,35.239782831607904,7.0
4,Income,39.643474537545515,18.0
5,Income,35.08020859342079,15.0
6,Income,38.793937869880246,16.0
7,Income,38.438572100848845,5.0
8,Income,40.883263621376955,11.0
9,Income,39.56576028578239,11.0
10,Income,41.942503011259156,15.0
11,Income,32.19972039085714,5.0
12,Income,34.47271099671788,16.0

</script><script type="text/plain" id="product_data" data-format="csv_embedded" data-src="">
quarter,product,region,sales,market_share
Q1,Product A,North,242,30.0
Q2,Product A,North,159,30.0
Q3,Product A,North,178,27.0
Q4,Product A,North,221,36.0
Q1,Product B,North,240,30.0
Q2,Product B,North,247,18.0
Q3,Product B,North,256,34.0
Q4,Product B,North,237,26.0
Q1,Product C,North,234,15.0
Q2,Product C,North,312,12.0
Q3,Product C,North,325,15.0
Q4,Product C,North,235,35.0
Q1,Product D,North,386,35.0
Q2,Product D,North,419,39.0
Q3,Product D,North,433,11.0
Q4,Product D,North,459,39.0
Q1,Product A,South,412,19.0
Q2,Product A,South,458,27.0
Q3,Product A,South,402,24.0
Q4,Product A,South,444,22.0
Q1,Product B,South,140,33.0
Q2,Product B,South,114,11.0
Q3,Product B,South,146,33.0
Q4,Product B,South,162,25.0
Q1,Product C,South,378,15.0
Q2,Product C,South,291,23.0
Q3,Product C,South,287,31.0
Q4,Product C,South,374,11.0
Q1,Product D,South,134,30.0
Q2,Product D,South,85,33.0
Q3,Product D,South,152,16.0
Q4,Product D,South,86,34.0
Q1,Product A,East,132,39.0
Q2,Product A,East,153,23.0
Q3,Product A,East,169,19.0
Q4,Product A,East,100,22.0
Q1,Product B,East,196,10.0
Q2,Product B,East,205,40.0
Q3,Product B,East,164,32.0
Q4,Product B,East,148,25.0
Q1,Product C,East,379,40.0
Q2,Product C,East,317,21.0
Q3,Product C,East,300,13.0
Q4,Product C,East,376,32.0
Q1,Product D,East,415,23.0
Q2,Product D,East,447,34.0
Q3,Product D,East,461,37.0
Q4,Product D,East,456,30.0
Q1,Product A,West,319,33.0
Q2,Product A,West,248,17.0
Q3,Product A,West,258,12.0
Q4,Product A,West,283,13.0
Q1,Product B,West,395,25.0
Q2,Product B,West,455,15.0
Q3,Product B,West,445,40.0
Q4,Product B,West,433,39.0
Q1,Product C,West,125,25.0
Q2,Product C,West,160,22.0
Q3,Product C,West,113,13.0
Q4,Product C,West,147,35.0
Q1,Product D,West,409,15.0
Q2,Product D,West,372,18.0
Q3,Product D,West,350,19.0
Q4,Product D,West,394,32.0

</script><script type="text/plain" id="league.team_info" data-format="csv_embedded" data-src="">
team,founded
Red Bulls,1995
Blue Tigers,1988
Green Eagles,2001
Yellow Lions,1972

</script><script type="text/plain" id="league.rankings" data-format="csv_embedded" data-src="">
week,team,points
1,Red Bulls,68.77642916897044
2,Red Bulls,68.53179704553176
3,Red Bulls,70.2676820685818
4,Red Bulls,69.3105717132688
5,Red Bulls,67.16776499482415
6,Red Bulls,65.04638736626703
7,Red Bulls,69.18040106057964
8,Red Bulls,66.22647966033898
9,Red Bulls,66.43709209592305
10,Red Bulls,66.46423239255431
1,Blue Tigers,68.36480475736334
2,Blue Tigers,72.25403170155427
3,Blue Tigers,72.0746745973372
4,Blue Tigers,73.42643577764152
5,Blue Tigers,72.80670155313916
6,Blue Tigers,75.71849399589978
7,Blue Tigers,73.22225870819508
8,Blue Tigers,72.55408548071249
9,Blue Tigers,75.33691667013589
10,Blue Tigers,74.0664485606661
1,Green Eagles,63.04272812436158
2,Green Eagles,67.0165616587014
3,Green Eagles,69.84001777041122
4,Green Eagles,61.648977717488144
5,Green Eagles,62.14108787511729
6,Green Eagles,60.558399044835014
7,Green Eagles,58.87161954359144
8,Green Eagles,58.66167770077569
9,Green Eagles,54.65482349891067
10,Green Eagles,53.362715139162475
1,Yellow Lions,53.15916964694334
2,Yellow Lions,54.17726879588842
3,Yellow Lions,50.47927749883534
4,Yellow Lions,48.45714945340414
5,Yellow Lions,45.96280864481456
6,Yellow Lions,46.21854766618942
7,Yellow Lions,47.75645005301847
8,Yellow Lions,46.11906916387032
9,Yellow Lions,45.549820500237445
10,Yellow Lions,47.39618496221646

</script><script type="text/plain" id="company_performance" data-format="csv_embedded" data-src="">
month,company,revenue,profit_margin
2024-01-01,Alpha Corp,156.94585348898897,14.0
2024-02-01,Alpha Corp,169.48400240754586,22.0
2024-03-01,Alpha Corp,163.49455401343334,8.0
2024-04-01,Alpha Corp,191.99699606664143,25.0
2024-05-01,Alpha Corp,197.92741360213668,23.0
2024-06-01,Alpha Corp,212.96831331923758,19.0
2024-07-01,Alpha Corp,218.57077017429083,20.0
2024-08-01,Alpha Corp,218.0470928539181,20.0
2024-09-01,Alpha Corp,215.2700211756662,17.0
2024-10-01,Alpha Corp,226.48227874575335,14.0
2024-11-01,Alpha Corp,208.63276934063987,23.0
2024-12-01,Alpha Corp,215.245641037467,19.0
2024-01-01,Beta Inc,217.8825691108731,20.0
2024-02-01,Beta Inc,235.33369931802906,16.0
2024-03-01,Beta Inc,246.4191599795677,11.0
2024-04-01,Beta Inc,254.7465750347118,18.0
2024-05-01,Beta Inc,248.09956885710963,23.0
2024-06-01,Beta Inc,260.40278833615,17.0
2024-07-01,Beta Inc,259.9891467618894,24.0
2024-08-01,Beta Inc,291.23608254881356,15.0
2024-09-01,Beta Inc,294.5701436751611,6.0
2024-10-01,Beta Inc,312.5724399303949,20.0
2024-11-01,Beta Inc,313.43122345465565,20.0
2024-12-01,Beta Inc,300.3076554231441,19.0
2024-01-01,Gamma LLC,133.39949870207215,16.0
2024-02-01,Gamma LLC,141.63210439498332,17.0
2024-03-01,Gamma LLC,138.7005151498582,15.0
2024-04-01,Gamma LLC,138.5298932845348,5.0
2024-05-01,Gamma LLC,142.70934353049486,11.0
2024-06-01,Gamma LLC,145.37034827418495,7.0
2024-07-01,Gamma LLC,135.01332581976214,24.0
2024-08-01,Gamma LLC,128.92554197295829,9.0
2024-09-01,Gamma LLC,121.54999472402503,25.0
2024-10-01,Gamma LLC,107.10342206077877,18.0
2024-11-01,Gamma LLC,100.66493070307655,19.0
2024-12-01,Gamma LLC,101.44787076547786,20.0
2024-01-01,Delta Co,277.5817134286445,8.0
2024-02-01,Delta Co,279.21600511461975,20.0
2024-03-01,Delta Co,263.0070893094632,10.0
2024-04-01,Delta Co,259.8191752017433,16.0
2024-05-01,Delta Co,253.6838237942496,10.0
2024-06-01,Delta Co,225.53152057272243,24.0
2024-07-01,Delta Co,234.5922329826589,16.0
2024-08-01,Delta Co,244.42605927287195,25.0
2024-09-01,Delta Co,246.15227086383433,8.0
2024-10-01,Delta Co,258.1204989591548,15.0
2024-11-01,Delta Co,270.7218909079879,13.0
2024-12-01,Delta Co,281.4911822588756,19.0

</script>

<!-- ACTUAL CONTENT -->

<h1>Bump Chart Examples</h1>
<p></p>

<h2>Example 1: Investment Strategy Rankings</h2>
<p>Rankings of investment strategies over time. Hover over a line to highlight it across all facets. Switch between performance metrics. Toggle between ranking and absolute values.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="y_mode_select_example1_bump">Y-axis Mode: </label>
                <select id="y_mode_select_example1_bump" onchange="updateChart_example1_bump()">
                <option value="Ranking" selected>Ranking</option>
                <option value="Absolute">Absolute</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="y_mode_select_example1_bump_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
            <div style="background-color: #f0f8ff; padding: 10px; margin: 10px 0; border-radius: 5px;">
        <h4 style="margin: 0 0 10px 0;">Performance Metric</h4>
        <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="perf_col_select_example1_bump">Metric: </label>
                <select id="perf_col_select_example1_bump" onchange="updateChart_example1_bump()">
                    <option value="performance" selected>performance</option>
                    <option value="volatility">volatility</option>
                </select>
            </div>
        </div>
    </div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="example1_bump_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="example1_bump_aspect_ratio_label">0.3</span>
    <input type="range" id="example1_bump_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-1.2039728043259361"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="example1_bump"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: strategy_data</p><br>
<hr>
<br>
<h2>Example 2: Product Rankings by Region</h2>
<p>Product performance rankings faceted by region. Filter regions using the dropdown. Hover to highlight a product across all regions. Dense ranking used: ties get the same rank, next rank continues without gaps.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="example2_bump_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="region_select_example2_bump">region: </label>
                <select id="region_select_example2_bump" multiple onchange="updateChart_example2_bump()">
                <option value="East" selected>East</option>
                <option value="North" selected>North</option>
                <option value="South" selected>South</option>
                <option value="West" selected>West</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="region_select_example2_bump_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="y_mode_select_example2_bump">Y-axis Mode: </label>
                <select id="y_mode_select_example2_bump" onchange="updateChart_example2_bump()">
                <option value="Ranking" selected>Ranking</option>
                <option value="Absolute">Absolute</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="y_mode_select_example2_bump_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
            <div style="background-color: #f0f8ff; padding: 10px; margin: 10px 0; border-radius: 5px;">
        <h4 style="margin: 0 0 10px 0;">Performance Metric</h4>
        <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="perf_col_select_example2_bump">Metric: </label>
                <select id="perf_col_select_example2_bump" onchange="updateChart_example2_bump()">
                    <option value="sales" selected>sales</option>
                    <option value="market_share">market_share</option>
                </select>
            </div>
        </div>
    </div>
<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0;">
    <label for="facet1_select_example2_bump">Facet by: </label>
    <select id="facet1_select_example2_bump" onchange="updateChart_example2_bump()">
        <option value="None">None</option>
<option value="region" selected>region</option>
    </select>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="example2_bump_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="example2_bump_aspect_ratio_label">0.3</span>
    <input type="range" id="example2_bump_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-1.2039728043259361"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="example2_bump"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: product_data</p><br>
<hr>
<br>
<h2>Example 3: Company Performance (Absolute Values)</h2>
<p>Company metrics shown as absolute values rather than rankings. Toggle Y-axis mode to switch to rankings. Select which companies to display using the filter.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="example3_bump_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="company_select_example3_bump">company: </label>
                <select id="company_select_example3_bump" multiple onchange="updateChart_example3_bump()">
                <option value="Alpha Corp" selected>Alpha Corp</option>
                <option value="Beta Inc" selected>Beta Inc</option>
                <option value="Delta Co" selected>Delta Co</option>
                <option value="Gamma LLC" selected>Gamma LLC</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="company_select_example3_bump_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="y_mode_select_example3_bump">Y-axis Mode: </label>
                <select id="y_mode_select_example3_bump" onchange="updateChart_example3_bump()">
                <option value="Ranking">Ranking</option>
                <option value="Absolute" selected>Absolute</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="y_mode_select_example3_bump_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
            <div style="background-color: #f0f8ff; padding: 10px; margin: 10px 0; border-radius: 5px;">
        <h4 style="margin: 0 0 10px 0;">Performance Metric</h4>
        <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="perf_col_select_example3_bump">Metric: </label>
                <select id="perf_col_select_example3_bump" onchange="updateChart_example3_bump()">
                    <option value="revenue" selected>revenue</option>
                    <option value="profit_margin">profit_margin</option>
                </select>
            </div>
        </div>
    </div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="example3_bump_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="example3_bump_aspect_ratio_label">0.3</span>
    <input type="range" id="example3_bump_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-1.2039728043259361"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="example3_bump"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: company_performance</p><br>
<hr>
<br>
<h2>Example 4: League Rankings from Struct Data Source</h2>
<p>This bump chart references data from a LeagueData struct using Symbol("league.rankings").</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="y_mode_select_example4_bump">Y-axis Mode: </label>
                <select id="y_mode_select_example4_bump" onchange="updateChart_example4_bump()">
                <option value="Ranking" selected>Ranking</option>
                <option value="Absolute">Absolute</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="y_mode_select_example4_bump_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
            <div style="background-color: #f0f8ff; padding: 10px; margin: 10px 0; border-radius: 5px;">
        <h4 style="margin: 0 0 10px 0;">Performance Metric</h4>
        <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="perf_col_select_example4_bump">Metric: </label>
                <select id="perf_col_select_example4_bump" onchange="updateChart_example4_bump()">
                    <option value="points" selected>points</option>
                </select>
            </div>
        </div>
    </div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="example4_bump_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="example4_bump_aspect_ratio_label">0.3</span>
    <input type="range" id="example4_bump_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-1.2039728043259361"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="example4_bump"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: league.rankings</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.4.0.</small></p>
</body>
</html>
