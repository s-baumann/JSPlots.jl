<!DOCTYPE html>
<html>
<head>
    <title>JSPlots.jl</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

    <!-- libgif.js for GIF frame control -->
    <script src="https://unpkg.com/libgif-js@0.0.3/libgif.js"></script>
</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                resolve(results.data);
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                resolve(data);
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        resolve(results.data);
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['category'];
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = false;

    // Store data globally
    let allData = [];
    let removedCategories = {};  // Map from facet_key to Set of removed categories

    function getFacetKey_pnl() {
        const facet1Select = document.getElementById('facet1_select_pnl');
        const facet2Select = document.getElementById('facet2_select_pnl');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;
        return (facet1 || 'none') + '|' + (facet2 || 'none');
    }

    function getRemovedSet_pnl() {
        const key = getFacetKey_pnl();
        if (!removedCategories[key]) {
            removedCategories[key] = new Set();
        }
        return removedCategories[key];
    }

    function calculateWaterfall_pnl(data) {
        const removed = getRemovedSet_pnl();
        const activeData = data.filter(row => !removed.has(String(row[CATEGORY_COL])));

        let runningTotal = 0;
        const processed = [];

        for (const row of activeData) {
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            processed.push({
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing'
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total'
            });
        }

        return processed;
    }

    function updateTable_pnl(processedData, allCategories) {
        if (!SHOW_TABLE) return;

        const tbody = document.getElementById('waterfall_tbody_pnl');
        if (!tbody) return;

        const removed = getRemovedSet_pnl();
        tbody.innerHTML = '';

        // Build a map for quick lookup
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.category] = item;
        }

        // Show all original categories (including removed ones)
        for (const cat of allCategories) {
            const row = document.createElement('tr');
            const isRemoved = removed.has(cat);
            const item = dataMap[cat];

            if (isRemoved) {
                row.classList.add('removed');
            } else if (item) {
                if (item.type === 'increasing') {
                    row.classList.add('positive');
                } else if (item.type === 'decreasing') {
                    row.classList.add('negative');
                } else if (item.type === 'total') {
                    row.classList.add('total');
                }
            }

            row.dataset.category = cat;
            row.onclick = function() {
                if (cat !== 'Total') {
                    toggleCategory_pnl(cat);
                }
            };

            const categoryCell = document.createElement('td');
            categoryCell.textContent = cat;
            row.appendChild(categoryCell);

            const valueCell = document.createElement('td');
            if (item) {
                valueCell.textContent = item.value.toFixed(2);
                valueCell.style.textAlign = 'right';
            } else {
                valueCell.textContent = '-';
            }
            row.appendChild(valueCell);

            const totalCell = document.createElement('td');
            if (item) {
                totalCell.textContent = item.end.toFixed(2);
                totalCell.style.textAlign = 'right';
            } else {
                totalCell.textContent = '-';
            }
            row.appendChild(totalCell);

            tbody.appendChild(row);
        }
    }

    function toggleCategory_pnl(category) {
        const removed = getRemovedSet_pnl();
        if (removed.has(category)) {
            removed.delete(category);
        } else {
            removed.add(category);
        }
        window.updateChart_pnl();
    }

    window.resetWaterfall_pnl = function() {
        const key = getFacetKey_pnl();
        removedCategories[key] = new Set();
        window.updateChart_pnl();
    };

    // Make it global so inline onchange can see it
    window.updateChart_pnl = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update color column if dropdown exists
        const colorColSelect = document.getElementById('color_col_select_pnl');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_pnl');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get all categories for table (before removal)
        const allCategories = [...new Set(filteredData.map(row => String(row[CATEGORY_COL])))];

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_pnl');
        const facet2Select = document.getElementById('facet2_select_pnl');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single waterfall chart
            const processed = calculateWaterfall_pnl(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('pnl', [trace], layout, {responsive: true});

            // Add click handler
            document.getElementById('pnl').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_pnl(clickedCategory);
                }
            });

            // Update table
            updateTable_pnl(processed, allCategories);

        } else {
            // Faceting not implemented for waterfall yet
            // (could be added in future enhancement)
            const processed = calculateWaterfall_pnl(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('pnl', [trace], layout, {responsive: true});

            document.getElementById('pnl').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_pnl(clickedCategory);
                }
            });

            updateTable_pnl(processed, allCategories);
        }
    };

    // Load and parse data
    loadDataset('pnl_data').then(function(data) {
        allData = data;
        window.updateChart_pnl();
    }).catch(function(error) {
        console.error('Error loading data for chart pnl:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['category'];
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = true;

    // Store data globally
    let allData = [];
    let removedCategories = {};  // Map from facet_key to Set of removed categories

    function getFacetKey_cashflow() {
        const facet1Select = document.getElementById('facet1_select_cashflow');
        const facet2Select = document.getElementById('facet2_select_cashflow');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;
        return (facet1 || 'none') + '|' + (facet2 || 'none');
    }

    function getRemovedSet_cashflow() {
        const key = getFacetKey_cashflow();
        if (!removedCategories[key]) {
            removedCategories[key] = new Set();
        }
        return removedCategories[key];
    }

    function calculateWaterfall_cashflow(data) {
        const removed = getRemovedSet_cashflow();
        const activeData = data.filter(row => !removed.has(String(row[CATEGORY_COL])));

        let runningTotal = 0;
        const processed = [];

        for (const row of activeData) {
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            processed.push({
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing'
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total'
            });
        }

        return processed;
    }

    function updateTable_cashflow(processedData, allCategories) {
        if (!SHOW_TABLE) return;

        const tbody = document.getElementById('waterfall_tbody_cashflow');
        if (!tbody) return;

        const removed = getRemovedSet_cashflow();
        tbody.innerHTML = '';

        // Build a map for quick lookup
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.category] = item;
        }

        // Show all original categories (including removed ones)
        for (const cat of allCategories) {
            const row = document.createElement('tr');
            const isRemoved = removed.has(cat);
            const item = dataMap[cat];

            if (isRemoved) {
                row.classList.add('removed');
            } else if (item) {
                if (item.type === 'increasing') {
                    row.classList.add('positive');
                } else if (item.type === 'decreasing') {
                    row.classList.add('negative');
                } else if (item.type === 'total') {
                    row.classList.add('total');
                }
            }

            row.dataset.category = cat;
            row.onclick = function() {
                if (cat !== 'Total') {
                    toggleCategory_cashflow(cat);
                }
            };

            const categoryCell = document.createElement('td');
            categoryCell.textContent = cat;
            row.appendChild(categoryCell);

            const valueCell = document.createElement('td');
            if (item) {
                valueCell.textContent = item.value.toFixed(2);
                valueCell.style.textAlign = 'right';
            } else {
                valueCell.textContent = '-';
            }
            row.appendChild(valueCell);

            const totalCell = document.createElement('td');
            if (item) {
                totalCell.textContent = item.end.toFixed(2);
                totalCell.style.textAlign = 'right';
            } else {
                totalCell.textContent = '-';
            }
            row.appendChild(totalCell);

            tbody.appendChild(row);
        }
    }

    function toggleCategory_cashflow(category) {
        const removed = getRemovedSet_cashflow();
        if (removed.has(category)) {
            removed.delete(category);
        } else {
            removed.add(category);
        }
        window.updateChart_cashflow();
    }

    window.resetWaterfall_cashflow = function() {
        const key = getFacetKey_cashflow();
        removedCategories[key] = new Set();
        window.updateChart_cashflow();
    };

    // Make it global so inline onchange can see it
    window.updateChart_cashflow = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update color column if dropdown exists
        const colorColSelect = document.getElementById('color_col_select_cashflow');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_cashflow');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get all categories for table (before removal)
        const allCategories = [...new Set(filteredData.map(row => String(row[CATEGORY_COL])))];

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_cashflow');
        const facet2Select = document.getElementById('facet2_select_cashflow');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single waterfall chart
            const processed = calculateWaterfall_cashflow(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('cashflow', [trace], layout, {responsive: true});

            // Add click handler
            document.getElementById('cashflow').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_cashflow(clickedCategory);
                }
            });

            // Update table
            updateTable_cashflow(processed, allCategories);

        } else {
            // Faceting not implemented for waterfall yet
            // (could be added in future enhancement)
            const processed = calculateWaterfall_cashflow(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('cashflow', [trace], layout, {responsive: true});

            document.getElementById('cashflow').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_cashflow(clickedCategory);
                }
            });

            updateTable_cashflow(processed, allCategories);
        }
    };

    // Load and parse data
    loadDataset('cash_data').then(function(data) {
        allData = data;
        window.updateChart_cashflow();
    }).catch(function(error) {
        console.error('Error loading data for chart cashflow:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['region'];
    const COLOR_COLS = ['category'];
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = false;

    // Store data globally
    let allData = [];
    let removedCategories = {};  // Map from facet_key to Set of removed categories

    function getFacetKey_variance() {
        const facet1Select = document.getElementById('facet1_select_variance');
        const facet2Select = document.getElementById('facet2_select_variance');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;
        return (facet1 || 'none') + '|' + (facet2 || 'none');
    }

    function getRemovedSet_variance() {
        const key = getFacetKey_variance();
        if (!removedCategories[key]) {
            removedCategories[key] = new Set();
        }
        return removedCategories[key];
    }

    function calculateWaterfall_variance(data) {
        const removed = getRemovedSet_variance();
        const activeData = data.filter(row => !removed.has(String(row[CATEGORY_COL])));

        let runningTotal = 0;
        const processed = [];

        for (const row of activeData) {
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            processed.push({
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing'
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total'
            });
        }

        return processed;
    }

    function updateTable_variance(processedData, allCategories) {
        if (!SHOW_TABLE) return;

        const tbody = document.getElementById('waterfall_tbody_variance');
        if (!tbody) return;

        const removed = getRemovedSet_variance();
        tbody.innerHTML = '';

        // Build a map for quick lookup
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.category] = item;
        }

        // Show all original categories (including removed ones)
        for (const cat of allCategories) {
            const row = document.createElement('tr');
            const isRemoved = removed.has(cat);
            const item = dataMap[cat];

            if (isRemoved) {
                row.classList.add('removed');
            } else if (item) {
                if (item.type === 'increasing') {
                    row.classList.add('positive');
                } else if (item.type === 'decreasing') {
                    row.classList.add('negative');
                } else if (item.type === 'total') {
                    row.classList.add('total');
                }
            }

            row.dataset.category = cat;
            row.onclick = function() {
                if (cat !== 'Total') {
                    toggleCategory_variance(cat);
                }
            };

            const categoryCell = document.createElement('td');
            categoryCell.textContent = cat;
            row.appendChild(categoryCell);

            const valueCell = document.createElement('td');
            if (item) {
                valueCell.textContent = item.value.toFixed(2);
                valueCell.style.textAlign = 'right';
            } else {
                valueCell.textContent = '-';
            }
            row.appendChild(valueCell);

            const totalCell = document.createElement('td');
            if (item) {
                totalCell.textContent = item.end.toFixed(2);
                totalCell.style.textAlign = 'right';
            } else {
                totalCell.textContent = '-';
            }
            row.appendChild(totalCell);

            tbody.appendChild(row);
        }
    }

    function toggleCategory_variance(category) {
        const removed = getRemovedSet_variance();
        if (removed.has(category)) {
            removed.delete(category);
        } else {
            removed.add(category);
        }
        window.updateChart_variance();
    }

    window.resetWaterfall_variance = function() {
        const key = getFacetKey_variance();
        removedCategories[key] = new Set();
        window.updateChart_variance();
    };

    // Make it global so inline onchange can see it
    window.updateChart_variance = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update color column if dropdown exists
        const colorColSelect = document.getElementById('color_col_select_variance');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_variance');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get all categories for table (before removal)
        const allCategories = [...new Set(filteredData.map(row => String(row[CATEGORY_COL])))];

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_variance');
        const facet2Select = document.getElementById('facet2_select_variance');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single waterfall chart
            const processed = calculateWaterfall_variance(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('variance', [trace], layout, {responsive: true});

            // Add click handler
            document.getElementById('variance').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_variance(clickedCategory);
                }
            });

            // Update table
            updateTable_variance(processed, allCategories);

        } else {
            // Faceting not implemented for waterfall yet
            // (could be added in future enhancement)
            const processed = calculateWaterfall_variance(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('variance', [trace], layout, {responsive: true});

            document.getElementById('variance').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_variance(clickedCategory);
                }
            });

            updateTable_variance(processed, allCategories);
        }
    };

    // Load and parse data
    loadDataset('variance_data').then(function(data) {
        allData = data;
        window.updateChart_variance();
    }).catch(function(error) {
        console.error('Error loading data for chart variance:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['year', 'department'];
    const COLOR_COLS = ['category'];
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = true;

    // Store data globally
    let allData = [];
    let removedCategories = {};  // Map from facet_key to Set of removed categories

    function getFacetKey_budget() {
        const facet1Select = document.getElementById('facet1_select_budget');
        const facet2Select = document.getElementById('facet2_select_budget');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;
        return (facet1 || 'none') + '|' + (facet2 || 'none');
    }

    function getRemovedSet_budget() {
        const key = getFacetKey_budget();
        if (!removedCategories[key]) {
            removedCategories[key] = new Set();
        }
        return removedCategories[key];
    }

    function calculateWaterfall_budget(data) {
        const removed = getRemovedSet_budget();
        const activeData = data.filter(row => !removed.has(String(row[CATEGORY_COL])));

        let runningTotal = 0;
        const processed = [];

        for (const row of activeData) {
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            processed.push({
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing'
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total'
            });
        }

        return processed;
    }

    function updateTable_budget(processedData, allCategories) {
        if (!SHOW_TABLE) return;

        const tbody = document.getElementById('waterfall_tbody_budget');
        if (!tbody) return;

        const removed = getRemovedSet_budget();
        tbody.innerHTML = '';

        // Build a map for quick lookup
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.category] = item;
        }

        // Show all original categories (including removed ones)
        for (const cat of allCategories) {
            const row = document.createElement('tr');
            const isRemoved = removed.has(cat);
            const item = dataMap[cat];

            if (isRemoved) {
                row.classList.add('removed');
            } else if (item) {
                if (item.type === 'increasing') {
                    row.classList.add('positive');
                } else if (item.type === 'decreasing') {
                    row.classList.add('negative');
                } else if (item.type === 'total') {
                    row.classList.add('total');
                }
            }

            row.dataset.category = cat;
            row.onclick = function() {
                if (cat !== 'Total') {
                    toggleCategory_budget(cat);
                }
            };

            const categoryCell = document.createElement('td');
            categoryCell.textContent = cat;
            row.appendChild(categoryCell);

            const valueCell = document.createElement('td');
            if (item) {
                valueCell.textContent = item.value.toFixed(2);
                valueCell.style.textAlign = 'right';
            } else {
                valueCell.textContent = '-';
            }
            row.appendChild(valueCell);

            const totalCell = document.createElement('td');
            if (item) {
                totalCell.textContent = item.end.toFixed(2);
                totalCell.style.textAlign = 'right';
            } else {
                totalCell.textContent = '-';
            }
            row.appendChild(totalCell);

            tbody.appendChild(row);
        }
    }

    function toggleCategory_budget(category) {
        const removed = getRemovedSet_budget();
        if (removed.has(category)) {
            removed.delete(category);
        } else {
            removed.add(category);
        }
        window.updateChart_budget();
    }

    window.resetWaterfall_budget = function() {
        const key = getFacetKey_budget();
        removedCategories[key] = new Set();
        window.updateChart_budget();
    };

    // Make it global so inline onchange can see it
    window.updateChart_budget = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update color column if dropdown exists
        const colorColSelect = document.getElementById('color_col_select_budget');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_budget');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get all categories for table (before removal)
        const allCategories = [...new Set(filteredData.map(row => String(row[CATEGORY_COL])))];

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_budget');
        const facet2Select = document.getElementById('facet2_select_budget');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single waterfall chart
            const processed = calculateWaterfall_budget(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('budget', [trace], layout, {responsive: true});

            // Add click handler
            document.getElementById('budget').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_budget(clickedCategory);
                }
            });

            // Update table
            updateTable_budget(processed, allCategories);

        } else {
            // Faceting not implemented for waterfall yet
            // (could be added in future enhancement)
            const processed = calculateWaterfall_budget(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('budget', [trace], layout, {responsive: true});

            document.getElementById('budget').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_budget(clickedCategory);
                }
            });

            updateTable_budget(processed, allCategories);
        }
    };

    // Load and parse data
    loadDataset('budget_data').then(function(data) {
        allData = data;
        window.updateChart_budget();
    }).catch(function(error) {
        console.error('Error loading data for chart budget:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['category'];
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = false;
    const SHOW_TOTALS = true;

    // Store data globally
    let allData = [];
    let removedCategories = {};  // Map from facet_key to Set of removed categories

    function getFacetKey_simple() {
        const facet1Select = document.getElementById('facet1_select_simple');
        const facet2Select = document.getElementById('facet2_select_simple');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;
        return (facet1 || 'none') + '|' + (facet2 || 'none');
    }

    function getRemovedSet_simple() {
        const key = getFacetKey_simple();
        if (!removedCategories[key]) {
            removedCategories[key] = new Set();
        }
        return removedCategories[key];
    }

    function calculateWaterfall_simple(data) {
        const removed = getRemovedSet_simple();
        const activeData = data.filter(row => !removed.has(String(row[CATEGORY_COL])));

        let runningTotal = 0;
        const processed = [];

        for (const row of activeData) {
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            processed.push({
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing'
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total'
            });
        }

        return processed;
    }

    function updateTable_simple(processedData, allCategories) {
        if (!SHOW_TABLE) return;

        const tbody = document.getElementById('waterfall_tbody_simple');
        if (!tbody) return;

        const removed = getRemovedSet_simple();
        tbody.innerHTML = '';

        // Build a map for quick lookup
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.category] = item;
        }

        // Show all original categories (including removed ones)
        for (const cat of allCategories) {
            const row = document.createElement('tr');
            const isRemoved = removed.has(cat);
            const item = dataMap[cat];

            if (isRemoved) {
                row.classList.add('removed');
            } else if (item) {
                if (item.type === 'increasing') {
                    row.classList.add('positive');
                } else if (item.type === 'decreasing') {
                    row.classList.add('negative');
                } else if (item.type === 'total') {
                    row.classList.add('total');
                }
            }

            row.dataset.category = cat;
            row.onclick = function() {
                if (cat !== 'Total') {
                    toggleCategory_simple(cat);
                }
            };

            const categoryCell = document.createElement('td');
            categoryCell.textContent = cat;
            row.appendChild(categoryCell);

            const valueCell = document.createElement('td');
            if (item) {
                valueCell.textContent = item.value.toFixed(2);
                valueCell.style.textAlign = 'right';
            } else {
                valueCell.textContent = '-';
            }
            row.appendChild(valueCell);

            const totalCell = document.createElement('td');
            if (item) {
                totalCell.textContent = item.end.toFixed(2);
                totalCell.style.textAlign = 'right';
            } else {
                totalCell.textContent = '-';
            }
            row.appendChild(totalCell);

            tbody.appendChild(row);
        }
    }

    function toggleCategory_simple(category) {
        const removed = getRemovedSet_simple();
        if (removed.has(category)) {
            removed.delete(category);
        } else {
            removed.add(category);
        }
        window.updateChart_simple();
    }

    window.resetWaterfall_simple = function() {
        const key = getFacetKey_simple();
        removedCategories[key] = new Set();
        window.updateChart_simple();
    };

    // Make it global so inline onchange can see it
    window.updateChart_simple = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update color column if dropdown exists
        const colorColSelect = document.getElementById('color_col_select_simple');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_simple');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get all categories for table (before removal)
        const allCategories = [...new Set(filteredData.map(row => String(row[CATEGORY_COL])))];

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_simple');
        const facet2Select = document.getElementById('facet2_select_simple');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single waterfall chart
            const processed = calculateWaterfall_simple(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('simple', [trace], layout, {responsive: true});

            // Add click handler
            document.getElementById('simple').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_simple(clickedCategory);
                }
            });

            // Update table
            updateTable_simple(processed, allCategories);

        } else {
            // Faceting not implemented for waterfall yet
            // (could be added in future enhancement)
            const processed = calculateWaterfall_simple(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('simple', [trace], layout, {responsive: true});

            document.getElementById('simple').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_simple(clickedCategory);
                }
            });

            updateTable_simple(processed, allCategories);
        }
    };

    // Load and parse data
    loadDataset('simple_data').then(function(data) {
        allData = data;
        window.updateChart_simple();
    }).catch(function(error) {
        console.error('Error loading data for chart simple:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['financial_category', 'department'];
    let CATEGORY_COL = 'financial_category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = false;

    // Store data globally
    let allData = [];
    let removedCategories = {};  // Map from facet_key to Set of removed categories

    function getFacetKey_multi_color() {
        const facet1Select = document.getElementById('facet1_select_multi_color');
        const facet2Select = document.getElementById('facet2_select_multi_color');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;
        return (facet1 || 'none') + '|' + (facet2 || 'none');
    }

    function getRemovedSet_multi_color() {
        const key = getFacetKey_multi_color();
        if (!removedCategories[key]) {
            removedCategories[key] = new Set();
        }
        return removedCategories[key];
    }

    function calculateWaterfall_multi_color(data) {
        const removed = getRemovedSet_multi_color();
        const activeData = data.filter(row => !removed.has(String(row[CATEGORY_COL])));

        let runningTotal = 0;
        const processed = [];

        for (const row of activeData) {
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            processed.push({
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing'
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total'
            });
        }

        return processed;
    }

    function updateTable_multi_color(processedData, allCategories) {
        if (!SHOW_TABLE) return;

        const tbody = document.getElementById('waterfall_tbody_multi_color');
        if (!tbody) return;

        const removed = getRemovedSet_multi_color();
        tbody.innerHTML = '';

        // Build a map for quick lookup
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.category] = item;
        }

        // Show all original categories (including removed ones)
        for (const cat of allCategories) {
            const row = document.createElement('tr');
            const isRemoved = removed.has(cat);
            const item = dataMap[cat];

            if (isRemoved) {
                row.classList.add('removed');
            } else if (item) {
                if (item.type === 'increasing') {
                    row.classList.add('positive');
                } else if (item.type === 'decreasing') {
                    row.classList.add('negative');
                } else if (item.type === 'total') {
                    row.classList.add('total');
                }
            }

            row.dataset.category = cat;
            row.onclick = function() {
                if (cat !== 'Total') {
                    toggleCategory_multi_color(cat);
                }
            };

            const categoryCell = document.createElement('td');
            categoryCell.textContent = cat;
            row.appendChild(categoryCell);

            const valueCell = document.createElement('td');
            if (item) {
                valueCell.textContent = item.value.toFixed(2);
                valueCell.style.textAlign = 'right';
            } else {
                valueCell.textContent = '-';
            }
            row.appendChild(valueCell);

            const totalCell = document.createElement('td');
            if (item) {
                totalCell.textContent = item.end.toFixed(2);
                totalCell.style.textAlign = 'right';
            } else {
                totalCell.textContent = '-';
            }
            row.appendChild(totalCell);

            tbody.appendChild(row);
        }
    }

    function toggleCategory_multi_color(category) {
        const removed = getRemovedSet_multi_color();
        if (removed.has(category)) {
            removed.delete(category);
        } else {
            removed.add(category);
        }
        window.updateChart_multi_color();
    }

    window.resetWaterfall_multi_color = function() {
        const key = getFacetKey_multi_color();
        removedCategories[key] = new Set();
        window.updateChart_multi_color();
    };

    // Make it global so inline onchange can see it
    window.updateChart_multi_color = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update color column if dropdown exists
        const colorColSelect = document.getElementById('color_col_select_multi_color');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_multi_color');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get all categories for table (before removal)
        const allCategories = [...new Set(filteredData.map(row => String(row[CATEGORY_COL])))];

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_multi_color');
        const facet2Select = document.getElementById('facet2_select_multi_color');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single waterfall chart
            const processed = calculateWaterfall_multi_color(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('multi_color', [trace], layout, {responsive: true});

            // Add click handler
            document.getElementById('multi_color').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_multi_color(clickedCategory);
                }
            });

            // Update table
            updateTable_multi_color(processed, allCategories);

        } else {
            // Faceting not implemented for waterfall yet
            // (could be added in future enhancement)
            const processed = calculateWaterfall_multi_color(filteredData);

            const categories = processed.map(d => d.category);
            const values = processed.map(d => d.value);
            const starts = processed.map(d => d.start);
            const measure = processed.map(d =>
                d.type === 'total' ? 'total' :
                d.type === 'increasing' ? 'relative' : 'relative'
            );

            const trace = {
                type: 'waterfall',
                orientation: 'v',
                x: categories,
                y: values,
                base: starts,
                measure: measure,
                text: values.map(v => v.toFixed(2)),
                textposition: 'outside',
                connector: {
                    line: { color: 'rgb(63, 63, 63)', width: 2 }
                },
                increasing: { marker: { color: '#2ecc71' } },
                decreasing: { marker: { color: '#e74c3c' } },
                totals: { marker: { color: '#3498db' } },
                hovertemplate: '%{x}<br>Value: %{y}<br>Total: %{base}+%{y}<extra></extra>'
            };

            const layout = {
                showlegend: false,
                xaxis: { title: CATEGORY_COL },
                yaxis: { title: VALUE_COL },
                height: 500,
                margin: {l: 80, r: 50, t: 50, b: 100}
            };

            Plotly.newPlot('multi_color', [trace], layout, {responsive: true});

            document.getElementById('multi_color').on('plotly_click', function(data) {
                const clickedCategory = data.points[0].x;
                if (clickedCategory !== 'Total') {
                    toggleCategory_multi_color(clickedCategory);
                }
            });

            updateTable_multi_color(processed, allCategories);
        }
    };

    // Load and parse data
    loadDataset('multi_color_data').then(function(data) {
        allData = data;
        window.updateChart_multi_color();
    }).catch(function(error) {
        console.error('Error loading data for chart multi_color:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="cash_data" data-format="csv_embedded" data-src="">
category,value
Opening Cash,5000
Operating CF,3000
Investing CF,-1500
Financing CF,1000

</script><script type="text/plain" id="pnl_data" data-format="csv_embedded" data-src="">
category,value
Revenue,10000
COGS,-4000
Gross Profit,6000
Marketing,-1500
R&D,-800
Admin,-700
EBIT,3000
Taxes,-600
Net Income,2400

</script><script type="text/plain" id="budget_data" data-format="csv_embedded" data-src="">
category,value,department,year
Budget,1000.0,Sales,2023
Actual Spending,43.41649986647599,Sales,2023
Variance,43.41649986647599,Sales,2023
Budget,1000.0,Sales,2024
Actual Spending,28.163020418921406,Sales,2024
Variance,28.163020418921406,Sales,2024
Budget,500.0,Marketing,2023
Actual Spending,-88.40168664148558,Marketing,2023
Variance,-88.40168664148558,Marketing,2023
Budget,500.0,Marketing,2024
Actual Spending,-38.88772581610749,Marketing,2024
Variance,-38.88772581610749,Marketing,2024
Budget,1500.0,Engineering,2023
Actual Spending,5.75543122190993,Engineering,2023
Variance,5.75543122190993,Engineering,2023
Budget,1500.0,Engineering,2024
Actual Spending,27.073145060626302,Engineering,2024
Variance,27.073145060626302,Engineering,2024
Budget,800.0,Operations,2023
Actual Spending,-69.41310680804213,Operations,2023
Variance,-69.41310680804213,Operations,2023
Budget,800.0,Operations,2024
Actual Spending,13.441878222265586,Operations,2024
Variance,13.441878222265586,Operations,2024

</script><script type="text/plain" id="simple_data" data-format="csv_embedded" data-src="">
category,value
Starting Value,1000
Increase 1,300
Increase 2,200
Decrease 1,-150
Decrease 2,-100

</script><script type="text/plain" id="variance_data" data-format="csv_embedded" data-src="">
category,value,region
Base Sales,10000,North
Price Impact,500,North
Volume Impact,-300,North
Mix Impact,200,North
Actual Sales,10400,North
Base Sales,8000,South
Price Impact,-200,South
Volume Impact,400,South
Mix Impact,100,South
Actual Sales,8300,South
Base Sales,12000,East
Price Impact,800,East
Volume Impact,-500,East
Mix Impact,300,East
Actual Sales,12600,East
Base Sales,9000,West
Price Impact,200,West
Volume Impact,300,West
Mix Impact,-100,West
Actual Sales,9400,West

</script><script type="text/plain" id="multi_color_data" data-format="csv_embedded" data-src="">
financial_category,department,value
Revenue,Sales,5000
Direct Costs,Operations,-2000
Overhead,Admin,-800
Marketing,Marketing,-600
Net Income,All Depts,1600

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/waterfall_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>Waterfall Chart Examples</h1>
<p>This page demonstrates the interactive Waterfall chart type in JSPlots.</p>
<ul>
    <li><strong>Automatic cumulative sum calculation:</strong> Enter category and value data, waterfall handles the rest</li>
    <li><strong>Side-by-side calculation table:</strong> See exact values and running totals</li>
    <li><strong>Click-to-remove interaction:</strong> Click on bars or table rows to temporarily exclude from calculation</li>
    <li><strong>Reset functionality:</strong> Restore all removed segments with one click</li>
    <li><strong>Color coding:</strong> Green for positive values, red for negative, blue for totals</li>
    <li><strong>Filtering:</strong> Switch between different datasets</li>
</ul>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 1: Profit & Loss Statement</h2>
<p>A classic use case for waterfall charts: showing how revenue flows through various expenses to net income.</p>
<p>Features demonstrated:</p>
<ul>
    <li>Positive values (Revenue, Gross Profit) in green</li>
    <li>Negative values (Costs, Expenses) in red</li>
    <li>Running total displayed in the table</li>
    <li>Click on any bar or table row to exclude from calculation</li>
    <li>Reset button to restore all segments</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Profit & Loss Statement</h2>
<p>Click on bars or table rows to exclude items from the calculation. Use Reset to restore.</p>




<!-- Chart -->
<div id="pnl"></div>
<style>
    .waterfall-layout-pnl {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-pnl {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-pnl {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-pnl {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-pnl th,
    .waterfall-table-pnl td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-pnl th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-pnl tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-pnl tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-pnl tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-pnl tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-pnl tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-pnl {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-pnl:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-pnl">
    <div class="waterfall-chart-section-pnl">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-pnl">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on rows or chart bars to exclude from calculation</p>
                <table class="waterfall-table-pnl" id="waterfall_table_pnl">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Change</th>
                            <th>Running Total</th>
                        </tr>
                    </thead>
                    <tbody id="waterfall_tbody_pnl">
                    </tbody>
                </table>
                <button class="waterfall-reset-btn-pnl" onclick="resetWaterfall_pnl()"> Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: pnl_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 2: Cash Flow Bridge</h2>
<p>Show how cash position changes from opening to closing balance through operating, investing, and financing activities.</p>
<p>This example demonstrates:</p>
<ul>
    <li>Mix of positive and negative cash flows</li>
    <li>Total bar showing final cash position</li>
    <li>Interactive removal to see "what-if" scenarios</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Cash Flow Bridge - Q1 2024</h2>
<p>Waterfall showing cash flow changes. Total bar shows ending cash position.</p>




<!-- Chart -->
<div id="cashflow"></div>
<style>
    .waterfall-layout-cashflow {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-cashflow {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-cashflow {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-cashflow {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-cashflow th,
    .waterfall-table-cashflow td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-cashflow th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-cashflow tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-cashflow tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-cashflow tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-cashflow tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-cashflow tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-cashflow {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-cashflow:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-cashflow">
    <div class="waterfall-chart-section-cashflow">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-cashflow">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on rows or chart bars to exclude from calculation</p>
                <table class="waterfall-table-cashflow" id="waterfall_table_cashflow">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Change</th>
                            <th>Running Total</th>
                        </tr>
                    </thead>
                    <tbody id="waterfall_tbody_cashflow">
                    </tbody>
                </table>
                <button class="waterfall-reset-btn-cashflow" onclick="resetWaterfall_cashflow()"> Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: cash_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 3: Sales Variance Analysis with Filters</h2>
<p>Analyze sales variance by breaking down the impact of price, volume, and mix changes.</p>
<p>This example includes:</p>
<ul>
    <li>Multiple regions selectable via filters</li>
    <li>Variance analysis showing positive and negative impacts</li>
    <li>Side-by-side table for detailed calculation review</li>
    <li>Click-to-remove to isolate specific variance drivers</li>
</ul>
<p><strong>Try this:</strong> Select different regions to see how variance components differ across markets!</p>

    </div>
<br>
<hr>
<br>
<h2>Sales Variance Analysis by Region</h2>
<p>Use the region filter to switch between markets. Click on variance components to see impact on actual sales.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0;">Filters</h4>
            <div style="margin: 10px;">
            <label for="region_select_variance">region: </label>
            <select id="region_select_variance" multiple onchange="updateChart_variance()">
                <option value="East">East</option>
                <option value="North" selected>North</option>
                <option value="South">South</option>
                <option value="West">West</option>
            </select>
        </div>
        
</div>



<!-- Chart -->
<div id="variance"></div>
<style>
    .waterfall-layout-variance {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-variance {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-variance {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-variance {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-variance th,
    .waterfall-table-variance td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-variance th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-variance tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-variance tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-variance tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-variance tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-variance tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-variance {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-variance:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-variance">
    <div class="waterfall-chart-section-variance">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-variance">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on rows or chart bars to exclude from calculation</p>
                <table class="waterfall-table-variance" id="waterfall_table_variance">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Change</th>
                            <th>Running Total</th>
                        </tr>
                    </thead>
                    <tbody id="waterfall_tbody_variance">
                    </tbody>
                </table>
                <button class="waterfall-reset-btn-variance" onclick="resetWaterfall_variance()"> Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: variance_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 4: Budget vs Actuals Comparison</h2>
<p>Compare budgeted vs actual expenses across departments with multiple filters.</p>
<p>Features:</p>
<ul>
    <li>Department filter to focus on specific areas</li>
    <li>Year filter for historical comparison</li>
    <li>Both positive and negative variances</li>
    <li>Table shows running variance total</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Budget vs Actuals - Department Variance</h2>
<p>Filter by department and year to see specific variances. Red indicates over-budget, green under-budget.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0;">Filters</h4>
            <div style="margin: 10px;">
            <label for="year_select_budget">year: </label>
            <select id="year_select_budget" multiple onchange="updateChart_budget()">
                <option value="2023">2023</option>
                <option value="2024" selected>2024</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="department_select_budget">department: </label>
            <select id="department_select_budget" multiple onchange="updateChart_budget()">
                <option value="Engineering">Engineering</option>
                <option value="Marketing">Marketing</option>
                <option value="Operations">Operations</option>
                <option value="Sales" selected>Sales</option>
            </select>
        </div>
        
</div>



<!-- Chart -->
<div id="budget"></div>
<style>
    .waterfall-layout-budget {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-budget {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-budget {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-budget {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-budget th,
    .waterfall-table-budget td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-budget th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-budget tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-budget tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-budget tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-budget tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-budget tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-budget {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-budget:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-budget">
    <div class="waterfall-chart-section-budget">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-budget">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on rows or chart bars to exclude from calculation</p>
                <table class="waterfall-table-budget" id="waterfall_table_budget">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Change</th>
                            <th>Running Total</th>
                        </tr>
                    </thead>
                    <tbody id="waterfall_tbody_budget">
                    </tbody>
                </table>
                <button class="waterfall-reset-btn-budget" onclick="resetWaterfall_budget()"> Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: budget_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 5: Waterfall Chart Without Table</h2>
<p>Sometimes you just want the visual without the detailed calculations.</p>
<p>This example shows a waterfall chart with the table disabled (show_table=false).</p>

    </div>
<br>
<hr>
<br>
<h2>Simple Waterfall - Chart Only</h2>
<p>This waterfall chart has show_table=false, so only the visualization is displayed.</p>




<!-- Chart -->
<div id="simple"></div>
<style>
    .waterfall-layout-simple {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-simple {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-simple {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-simple {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-simple th,
    .waterfall-table-simple td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-simple th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-simple tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-simple tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-simple tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-simple tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-simple tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-simple {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-simple:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-simple">
    <div class="waterfall-chart-section-simple">
        <!-- Chart will be rendered here -->
    </div>
    
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: simple_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 6: Multiple Color Column Options</h2>
<p>This example demonstrates the ability to switch between different category columns.</p>
<p>The same data can be viewed through different lenses - by financial category OR by department.</p>
<p>Features:</p>
<ul>
    <li>Color Column dropdown to switch between category perspectives</li>
    <li>Same underlying data, different groupings</li>
    <li>Useful for multi-dimensional analysis</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Multi-Perspective Waterfall Analysis</h2>
<p>Use the Color Column dropdown to switch between financial and departmental views of the same data.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="color_col">Color Column: </label>
            <select id="color_col" onchange="updateChart_multi_color()">
                <option value="financial_category" selected>financial_category</option>
                <option value="department">department</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="multi_color"></div>
<style>
    .waterfall-layout-multi_color {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-multi_color {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-multi_color {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-multi_color {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-multi_color th,
    .waterfall-table-multi_color td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-multi_color th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-multi_color tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-multi_color tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-multi_color tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-multi_color tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-multi_color tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-multi_color {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-multi_color:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-multi_color">
    <div class="waterfall-chart-section-multi_color">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-multi_color">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on rows or chart bars to exclude from calculation</p>
                <table class="waterfall-table-multi_color" id="waterfall_table_multi_color">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Change</th>
                            <th>Running Total</th>
                        </tr>
                    </thead>
                    <tbody id="waterfall_tbody_multi_color">
                    </tbody>
                </table>
                <button class="waterfall-reset-btn-multi_color" onclick="resetWaterfall_multi_color()"> Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: multi_color_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary</h2>
<p>The Waterfall chart type provides:</p>
<ul>
    <li><strong>Automatic calculation:</strong> Just provide categories and values, cumulative sums are calculated automatically</li>
    <li><strong>Side-by-side table:</strong> Optional calculation table showing each step and running total</li>
    <li><strong>Interactive removal:</strong> Click on bars or table rows to temporarily exclude from calculation</li>
    <li><strong>Reset functionality:</strong> Restore all removed segments with the reset button</li>
    <li><strong>Color coding:</strong>
        <ul>
            <li>Green: Positive values (increases)</li>
            <li>Red: Negative values (decreases)</li>
            <li>Blue: Total bars</li>
        </ul>
    </li>
    <li><strong>Filtering:</strong> Standard multi-select filters to switch between datasets</li>
    <li><strong>Customization:</strong>
        <ul>
            <li><code>show_table</code>: Toggle calculation table display</li>
            <li><code>show_totals</code>: Add a total bar at the end</li>
            <li><code>color_cols</code> and <code>value_col</code>: Specify data columns</li>
        </ul>
    </li>
</ul>

<h3>Use Cases</h3>
<ul>
    <li>Financial analysis (P&L, cash flow, variance analysis)</li>
    <li>Budget vs actual comparisons</li>
    <li>Sequential process flows showing cumulative impact</li>
    <li>Inventory or population change analysis</li>
    <li>Revenue bridge analysis</li>
    <li>Cost breakdown and attribution</li>
</ul>

<h3>Tips</h3>
<ul>
    <li>Click on any bar or table row to see the impact of removing that component</li>
    <li>Use the Reset button to quickly restore all segments</li>
    <li>Combine with filters to compare waterfalls across different dimensions</li>
    <li>Set <code>show_totals=false</code> when your last category is already a total</li>
    <li>The table maintains the same row order as your input DataFrame</li>
</ul>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
