<!DOCTYPE html>
<html>
<head>
    <title>JSPlots.jl</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->


<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = ['currency', 'accounting'];
    const COLOR_COLS = ['category'];
    const ITEM_COL = 'item';
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = false;
    const COLOR_MAPS = {"category":{"PnL":"#636efa","Taxation":"#EF553B"}};

    // Store data globally
    let allData = [];
    let removedItems = new Set();  // Set of removed item names
    let removedCategories = new Set();  // Set of removed category names

    function calculateWaterfall_pnl(data) {
        const activeData = data.filter(row => {
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            return !removedItems.has(item) && !removedCategories.has(category);
        });

        let runningTotal = 0;
        const processed = [];

        for (let i = 0; i < activeData.length; i++) {
            const row = activeData[i];
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            // All items are 'relative' (floating bars showing individual changes)
            // First item starts from 0 but still uses relative measure
            processed.push({
                item: item,
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing',
                isFirst: i === 0
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                item: 'Total',
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total',
                isFirst: false
            });
        }

        return processed;
    }

    function updateTable_pnl(processedData, allItemsData) {
        if (!SHOW_TABLE) return;

        const container = document.getElementById('waterfall_table_container_pnl');
        if (!container) return;

        // Build a map for quick lookup by item name
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.item] = item;
        }

        // Group items by category
        const categoryGroups = {};
        for (const row of allItemsData) {
            const cat = String(row[CATEGORY_COL]);
            const item = String(row[ITEM_COL]);
            if (!categoryGroups[cat]) {
                categoryGroups[cat] = [];
            }
            categoryGroups[cat].push(item);
        }

        // Build table HTML
        let html = '<table class="waterfall-table-pnl">';
        html += '<thead><tr><th>Item</th><th>Change</th><th>Running Total</th></tr></thead>';
        html += '<tbody>';

        // Iterate through categories
        for (const [category, items] of Object.entries(categoryGroups)) {
            const catRemoved = removedCategories.has(category);

            // Category header row
            html += `<tr class="category-header" style="background-color: #e0e0e0; font-weight: bold; cursor: pointer;"
                     onclick="toggleCategoryGroup_pnl('${category}')">`;
            html += `<td colspan="3">`;
            html += `<input type="checkbox" ${!catRemoved ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleCategoryGroup_pnl('${category}')"
                     style="margin-right: 8px;">`;
            html += `${category}</td></tr>`;

            // Item rows within category
            for (const item of items) {
                const itemRemoved = removedItems.has(item) || catRemoved;
                const data = dataMap[item];

                let rowClass = '';
                if (itemRemoved) {
                    rowClass = 'removed';
                } else if (data) {
                    if (data.type === 'absolute' || data.type === 'increasing') {
                        rowClass = 'positive';
                    } else if (data.type === 'decreasing') {
                        rowClass = 'negative';
                    } else if (data.type === 'total') {
                        rowClass = 'total';
                    }
                }

                html += `<tr class="${rowClass}" style="cursor: pointer; padding-left: 20px;"
                         onclick="toggleItem_pnl('${item}')">`;
                html += `<td style="padding-left: 20px;">${item}</td>`;

                if (data && !itemRemoved) {
                    html += `<td style="text-align: right;">${data.value.toFixed(2)}</td>`;
                    html += `<td style="text-align: right;">${data.end.toFixed(2)}</td>`;
                } else {
                    html += `<td style="text-align: right;">-</td>`;
                    html += `<td style="text-align: right;">-</td>`;
                }
                html += '</tr>';
            }
        }

        // Add Total row if it exists in processed data
        const totalData = processedData.find(d => d.type === 'total');
        if (totalData) {
            const totalRemoved = removedItems.has('Total');
            const rowClass = totalRemoved ? 'removed' : 'total';

            html += `<tr class="${rowClass}" style="background-color: #f5f5f5; font-weight: bold; cursor: pointer;"
                     onclick="toggleItem_pnl('Total')">`;
            html += `<td style="padding-left: 20px;">Total</td>`;

            if (!totalRemoved) {
                html += `<td style="text-align: right;">${totalData.value.toFixed(2)}</td>`;
                html += `<td style="text-align: right;">${totalData.end.toFixed(2)}</td>`;
            } else {
                html += `<td style="text-align: right;">-</td>`;
                html += `<td style="text-align: right;">-</td>`;
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    window.toggleItem_pnl = function(item) {
        // Allow toggling of all items including Total
        if (removedItems.has(item)) {
            removedItems.delete(item);
        } else {
            removedItems.add(item);
        }
        window.updateChart_pnl();
    };

    window.toggleCategoryGroup_pnl = function(category) {
        if (removedCategories.has(category)) {
            removedCategories.delete(category);
        } else {
            removedCategories.add(category);
        }
        window.updateChart_pnl();
    };

    window.resetWaterfall_pnl = function() {
        removedItems = new Set();
        removedCategories = new Set();
        window.updateChart_pnl();
    };

    // Make it global so inline onchange can see it
    window.updateChart_pnl = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update category column if dropdown exists
        const colorColSelect = document.getElementById('color_col_pnl');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get color mode
        const colorModeSelect = document.getElementById('color_mode_pnl');
        const colorMode = colorModeSelect ? colorModeSelect.value : 'Value (Positive/Negative)';
        console.log('Color mode:', colorMode);
        console.log('CATEGORY_COL:', CATEGORY_COL);
        console.log('COLOR_MAPS:', COLOR_MAPS);

        // Get current filter values (single selection)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_pnl');
            if (select) {
                filters[col] = select.value;
            }
        });

        // Filter data (single selection per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                if (String(row[col]) !== filters[col]) {
                    return false;
                }
            }
            return true;
        });

        // Calculate waterfall (includes all items)
        const processed = calculateWaterfall_pnl(filteredData);

        // Filter processed data for chart display (remove toggled items like Total)
        const processedForChart = processed.filter(d => !removedItems.has(d.item));

        const items = processedForChart.map(d => d.item);
        const values = processedForChart.map(d => d.value);
        const bases = processedForChart.map(d => d.type === 'total' ? 0 : d.start);

        // Determine colors based on mode
        let markerColors;
        if (colorMode === 'Category' && COLOR_MAPS[CATEGORY_COL]) {
            // Category-based coloring
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                const categoryColor = COLOR_MAPS[CATEGORY_COL][d.category];
                return categoryColor || '#4285F4';
            });
            console.log('Using category-based colors:', markerColors);
        } else {
            // Value-based coloring (positive/negative)
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                return d.value >= 0 ? '#4CAF50' : '#F44336';  // Green for positive, Red for negative
            });
            console.log('Using value-based colors (positive/negative):', markerColors);
        }

        // Build waterfall using bar chart with base values
        // This gives us full control over colors
        const trace = {
            type: 'bar',
            orientation: 'v',
            x: items,
            y: values,
            base: bases,
            text: values.map(v => v.toFixed(2)),
            textposition: 'outside',
            hovertemplate: '%{x}<br>Change: %{y:.2f}<br>Running Total: %{base:+y:.2f}<extra></extra>',
            marker: {
                color: markerColors,
                line: { width: 1, color: '#333' }
            }
        };

        // Add connector lines as shapes
        const shapes = [];
        for (let i = 0; i < processedForChart.length - 1; i++) {
            if (processedForChart[i].type !== 'total' && processedForChart[i + 1].type !== 'total') {
                const endY = processedForChart[i].end;
                shapes.push({
                    type: 'line',
                    x0: i + 0.4,
                    x1: i + 1 - 0.4,
                    y0: endY,
                    y1: endY,
                    line: {
                        color: 'rgb(63, 63, 63)',
                        width: 2,
                        dash: 'dot'
                    }
                });
            }
        }

        const layout = {
            showlegend: false,
            xaxis: { title: ITEM_COL },
            yaxis: { title: VALUE_COL },
            height: 500,
            margin: {l: 80, r: 50, t: 50, b: 100},
            shapes: shapes
        };

        // Use newPlot to ensure colors update properly
        // (react sometimes doesn't update all trace properties)
        Plotly.newPlot('pnl', [trace], layout, {responsive: true}).then(function() {
            // Initialize click handler after first plot is created
            initClickHandler_pnl();
        });

        // Update table
        updateTable_pnl(processed, filteredData);
    };

    // Track if click handler has been initialized
    let clickHandlerInitialized = false;

    // Initialize click handler after first plot is created
    function initClickHandler_pnl() {
        if (clickHandlerInitialized) return;
        const chartDiv = document.getElementById('pnl');
        chartDiv.on('plotly_click', function(data) {
            const clickedItem = data.points[0].x;
            window.toggleItem_pnl(clickedItem);
        });
        clickHandlerInitialized = true;
    }

    // Load and parse data
    loadDataset('pnl_data').then(function(data) {
        allData = data;
        window.updateChart_pnl();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('pnl');
    }).catch(function(error) {
        console.error('Error loading data for chart pnl:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['category'];
    const ITEM_COL = 'item';
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = true;
    const COLOR_MAPS = {"category":{"Cash Flow":"#636efa"}};

    // Store data globally
    let allData = [];
    let removedItems = new Set();  // Set of removed item names
    let removedCategories = new Set();  // Set of removed category names

    function calculateWaterfall_cashflow(data) {
        const activeData = data.filter(row => {
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            return !removedItems.has(item) && !removedCategories.has(category);
        });

        let runningTotal = 0;
        const processed = [];

        for (let i = 0; i < activeData.length; i++) {
            const row = activeData[i];
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            // All items are 'relative' (floating bars showing individual changes)
            // First item starts from 0 but still uses relative measure
            processed.push({
                item: item,
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing',
                isFirst: i === 0
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                item: 'Total',
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total',
                isFirst: false
            });
        }

        return processed;
    }

    function updateTable_cashflow(processedData, allItemsData) {
        if (!SHOW_TABLE) return;

        const container = document.getElementById('waterfall_table_container_cashflow');
        if (!container) return;

        // Build a map for quick lookup by item name
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.item] = item;
        }

        // Group items by category
        const categoryGroups = {};
        for (const row of allItemsData) {
            const cat = String(row[CATEGORY_COL]);
            const item = String(row[ITEM_COL]);
            if (!categoryGroups[cat]) {
                categoryGroups[cat] = [];
            }
            categoryGroups[cat].push(item);
        }

        // Build table HTML
        let html = '<table class="waterfall-table-cashflow">';
        html += '<thead><tr><th>Item</th><th>Change</th><th>Running Total</th></tr></thead>';
        html += '<tbody>';

        // Iterate through categories
        for (const [category, items] of Object.entries(categoryGroups)) {
            const catRemoved = removedCategories.has(category);

            // Category header row
            html += `<tr class="category-header" style="background-color: #e0e0e0; font-weight: bold; cursor: pointer;"
                     onclick="toggleCategoryGroup_cashflow('${category}')">`;
            html += `<td colspan="3">`;
            html += `<input type="checkbox" ${!catRemoved ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleCategoryGroup_cashflow('${category}')"
                     style="margin-right: 8px;">`;
            html += `${category}</td></tr>`;

            // Item rows within category
            for (const item of items) {
                const itemRemoved = removedItems.has(item) || catRemoved;
                const data = dataMap[item];

                let rowClass = '';
                if (itemRemoved) {
                    rowClass = 'removed';
                } else if (data) {
                    if (data.type === 'absolute' || data.type === 'increasing') {
                        rowClass = 'positive';
                    } else if (data.type === 'decreasing') {
                        rowClass = 'negative';
                    } else if (data.type === 'total') {
                        rowClass = 'total';
                    }
                }

                html += `<tr class="${rowClass}" style="cursor: pointer; padding-left: 20px;"
                         onclick="toggleItem_cashflow('${item}')">`;
                html += `<td style="padding-left: 20px;">${item}</td>`;

                if (data && !itemRemoved) {
                    html += `<td style="text-align: right;">${data.value.toFixed(2)}</td>`;
                    html += `<td style="text-align: right;">${data.end.toFixed(2)}</td>`;
                } else {
                    html += `<td style="text-align: right;">-</td>`;
                    html += `<td style="text-align: right;">-</td>`;
                }
                html += '</tr>';
            }
        }

        // Add Total row if it exists in processed data
        const totalData = processedData.find(d => d.type === 'total');
        if (totalData) {
            const totalRemoved = removedItems.has('Total');
            const rowClass = totalRemoved ? 'removed' : 'total';

            html += `<tr class="${rowClass}" style="background-color: #f5f5f5; font-weight: bold; cursor: pointer;"
                     onclick="toggleItem_cashflow('Total')">`;
            html += `<td style="padding-left: 20px;">Total</td>`;

            if (!totalRemoved) {
                html += `<td style="text-align: right;">${totalData.value.toFixed(2)}</td>`;
                html += `<td style="text-align: right;">${totalData.end.toFixed(2)}</td>`;
            } else {
                html += `<td style="text-align: right;">-</td>`;
                html += `<td style="text-align: right;">-</td>`;
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    window.toggleItem_cashflow = function(item) {
        // Allow toggling of all items including Total
        if (removedItems.has(item)) {
            removedItems.delete(item);
        } else {
            removedItems.add(item);
        }
        window.updateChart_cashflow();
    };

    window.toggleCategoryGroup_cashflow = function(category) {
        if (removedCategories.has(category)) {
            removedCategories.delete(category);
        } else {
            removedCategories.add(category);
        }
        window.updateChart_cashflow();
    };

    window.resetWaterfall_cashflow = function() {
        removedItems = new Set();
        removedCategories = new Set();
        window.updateChart_cashflow();
    };

    // Make it global so inline onchange can see it
    window.updateChart_cashflow = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update category column if dropdown exists
        const colorColSelect = document.getElementById('color_col_cashflow');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get color mode
        const colorModeSelect = document.getElementById('color_mode_cashflow');
        const colorMode = colorModeSelect ? colorModeSelect.value : 'Value (Positive/Negative)';
        console.log('Color mode:', colorMode);
        console.log('CATEGORY_COL:', CATEGORY_COL);
        console.log('COLOR_MAPS:', COLOR_MAPS);

        // Get current filter values (single selection)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_cashflow');
            if (select) {
                filters[col] = select.value;
            }
        });

        // Filter data (single selection per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                if (String(row[col]) !== filters[col]) {
                    return false;
                }
            }
            return true;
        });

        // Calculate waterfall (includes all items)
        const processed = calculateWaterfall_cashflow(filteredData);

        // Filter processed data for chart display (remove toggled items like Total)
        const processedForChart = processed.filter(d => !removedItems.has(d.item));

        const items = processedForChart.map(d => d.item);
        const values = processedForChart.map(d => d.value);
        const bases = processedForChart.map(d => d.type === 'total' ? 0 : d.start);

        // Determine colors based on mode
        let markerColors;
        if (colorMode === 'Category' && COLOR_MAPS[CATEGORY_COL]) {
            // Category-based coloring
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                const categoryColor = COLOR_MAPS[CATEGORY_COL][d.category];
                return categoryColor || '#4285F4';
            });
            console.log('Using category-based colors:', markerColors);
        } else {
            // Value-based coloring (positive/negative)
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                return d.value >= 0 ? '#4CAF50' : '#F44336';  // Green for positive, Red for negative
            });
            console.log('Using value-based colors (positive/negative):', markerColors);
        }

        // Build waterfall using bar chart with base values
        // This gives us full control over colors
        const trace = {
            type: 'bar',
            orientation: 'v',
            x: items,
            y: values,
            base: bases,
            text: values.map(v => v.toFixed(2)),
            textposition: 'outside',
            hovertemplate: '%{x}<br>Change: %{y:.2f}<br>Running Total: %{base:+y:.2f}<extra></extra>',
            marker: {
                color: markerColors,
                line: { width: 1, color: '#333' }
            }
        };

        // Add connector lines as shapes
        const shapes = [];
        for (let i = 0; i < processedForChart.length - 1; i++) {
            if (processedForChart[i].type !== 'total' && processedForChart[i + 1].type !== 'total') {
                const endY = processedForChart[i].end;
                shapes.push({
                    type: 'line',
                    x0: i + 0.4,
                    x1: i + 1 - 0.4,
                    y0: endY,
                    y1: endY,
                    line: {
                        color: 'rgb(63, 63, 63)',
                        width: 2,
                        dash: 'dot'
                    }
                });
            }
        }

        const layout = {
            showlegend: false,
            xaxis: { title: ITEM_COL },
            yaxis: { title: VALUE_COL },
            height: 500,
            margin: {l: 80, r: 50, t: 50, b: 100},
            shapes: shapes
        };

        // Use newPlot to ensure colors update properly
        // (react sometimes doesn't update all trace properties)
        Plotly.newPlot('cashflow', [trace], layout, {responsive: true}).then(function() {
            // Initialize click handler after first plot is created
            initClickHandler_cashflow();
        });

        // Update table
        updateTable_cashflow(processed, filteredData);
    };

    // Track if click handler has been initialized
    let clickHandlerInitialized = false;

    // Initialize click handler after first plot is created
    function initClickHandler_cashflow() {
        if (clickHandlerInitialized) return;
        const chartDiv = document.getElementById('cashflow');
        chartDiv.on('plotly_click', function(data) {
            const clickedItem = data.points[0].x;
            window.toggleItem_cashflow(clickedItem);
        });
        clickHandlerInitialized = true;
    }

    // Load and parse data
    loadDataset('cash_data').then(function(data) {
        allData = data;
        window.updateChart_cashflow();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('cashflow');
    }).catch(function(error) {
        console.error('Error loading data for chart cashflow:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['region'];
    const COLOR_COLS = ['category'];
    const ITEM_COL = 'item';
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = false;
    const COLOR_MAPS = {"category":{"Variance":"#636efa"}};

    // Store data globally
    let allData = [];
    let removedItems = new Set();  // Set of removed item names
    let removedCategories = new Set();  // Set of removed category names

    function calculateWaterfall_variance(data) {
        const activeData = data.filter(row => {
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            return !removedItems.has(item) && !removedCategories.has(category);
        });

        let runningTotal = 0;
        const processed = [];

        for (let i = 0; i < activeData.length; i++) {
            const row = activeData[i];
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            // All items are 'relative' (floating bars showing individual changes)
            // First item starts from 0 but still uses relative measure
            processed.push({
                item: item,
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing',
                isFirst: i === 0
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                item: 'Total',
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total',
                isFirst: false
            });
        }

        return processed;
    }

    function updateTable_variance(processedData, allItemsData) {
        if (!SHOW_TABLE) return;

        const container = document.getElementById('waterfall_table_container_variance');
        if (!container) return;

        // Build a map for quick lookup by item name
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.item] = item;
        }

        // Group items by category
        const categoryGroups = {};
        for (const row of allItemsData) {
            const cat = String(row[CATEGORY_COL]);
            const item = String(row[ITEM_COL]);
            if (!categoryGroups[cat]) {
                categoryGroups[cat] = [];
            }
            categoryGroups[cat].push(item);
        }

        // Build table HTML
        let html = '<table class="waterfall-table-variance">';
        html += '<thead><tr><th>Item</th><th>Change</th><th>Running Total</th></tr></thead>';
        html += '<tbody>';

        // Iterate through categories
        for (const [category, items] of Object.entries(categoryGroups)) {
            const catRemoved = removedCategories.has(category);

            // Category header row
            html += `<tr class="category-header" style="background-color: #e0e0e0; font-weight: bold; cursor: pointer;"
                     onclick="toggleCategoryGroup_variance('${category}')">`;
            html += `<td colspan="3">`;
            html += `<input type="checkbox" ${!catRemoved ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleCategoryGroup_variance('${category}')"
                     style="margin-right: 8px;">`;
            html += `${category}</td></tr>`;

            // Item rows within category
            for (const item of items) {
                const itemRemoved = removedItems.has(item) || catRemoved;
                const data = dataMap[item];

                let rowClass = '';
                if (itemRemoved) {
                    rowClass = 'removed';
                } else if (data) {
                    if (data.type === 'absolute' || data.type === 'increasing') {
                        rowClass = 'positive';
                    } else if (data.type === 'decreasing') {
                        rowClass = 'negative';
                    } else if (data.type === 'total') {
                        rowClass = 'total';
                    }
                }

                html += `<tr class="${rowClass}" style="cursor: pointer; padding-left: 20px;"
                         onclick="toggleItem_variance('${item}')">`;
                html += `<td style="padding-left: 20px;">${item}</td>`;

                if (data && !itemRemoved) {
                    html += `<td style="text-align: right;">${data.value.toFixed(2)}</td>`;
                    html += `<td style="text-align: right;">${data.end.toFixed(2)}</td>`;
                } else {
                    html += `<td style="text-align: right;">-</td>`;
                    html += `<td style="text-align: right;">-</td>`;
                }
                html += '</tr>';
            }
        }

        // Add Total row if it exists in processed data
        const totalData = processedData.find(d => d.type === 'total');
        if (totalData) {
            const totalRemoved = removedItems.has('Total');
            const rowClass = totalRemoved ? 'removed' : 'total';

            html += `<tr class="${rowClass}" style="background-color: #f5f5f5; font-weight: bold; cursor: pointer;"
                     onclick="toggleItem_variance('Total')">`;
            html += `<td style="padding-left: 20px;">Total</td>`;

            if (!totalRemoved) {
                html += `<td style="text-align: right;">${totalData.value.toFixed(2)}</td>`;
                html += `<td style="text-align: right;">${totalData.end.toFixed(2)}</td>`;
            } else {
                html += `<td style="text-align: right;">-</td>`;
                html += `<td style="text-align: right;">-</td>`;
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    window.toggleItem_variance = function(item) {
        // Allow toggling of all items including Total
        if (removedItems.has(item)) {
            removedItems.delete(item);
        } else {
            removedItems.add(item);
        }
        window.updateChart_variance();
    };

    window.toggleCategoryGroup_variance = function(category) {
        if (removedCategories.has(category)) {
            removedCategories.delete(category);
        } else {
            removedCategories.add(category);
        }
        window.updateChart_variance();
    };

    window.resetWaterfall_variance = function() {
        removedItems = new Set();
        removedCategories = new Set();
        window.updateChart_variance();
    };

    // Make it global so inline onchange can see it
    window.updateChart_variance = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update category column if dropdown exists
        const colorColSelect = document.getElementById('color_col_variance');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get color mode
        const colorModeSelect = document.getElementById('color_mode_variance');
        const colorMode = colorModeSelect ? colorModeSelect.value : 'Value (Positive/Negative)';
        console.log('Color mode:', colorMode);
        console.log('CATEGORY_COL:', CATEGORY_COL);
        console.log('COLOR_MAPS:', COLOR_MAPS);

        // Get current filter values (single selection)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_variance');
            if (select) {
                filters[col] = select.value;
            }
        });

        // Filter data (single selection per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                if (String(row[col]) !== filters[col]) {
                    return false;
                }
            }
            return true;
        });

        // Calculate waterfall (includes all items)
        const processed = calculateWaterfall_variance(filteredData);

        // Filter processed data for chart display (remove toggled items like Total)
        const processedForChart = processed.filter(d => !removedItems.has(d.item));

        const items = processedForChart.map(d => d.item);
        const values = processedForChart.map(d => d.value);
        const bases = processedForChart.map(d => d.type === 'total' ? 0 : d.start);

        // Determine colors based on mode
        let markerColors;
        if (colorMode === 'Category' && COLOR_MAPS[CATEGORY_COL]) {
            // Category-based coloring
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                const categoryColor = COLOR_MAPS[CATEGORY_COL][d.category];
                return categoryColor || '#4285F4';
            });
            console.log('Using category-based colors:', markerColors);
        } else {
            // Value-based coloring (positive/negative)
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                return d.value >= 0 ? '#4CAF50' : '#F44336';  // Green for positive, Red for negative
            });
            console.log('Using value-based colors (positive/negative):', markerColors);
        }

        // Build waterfall using bar chart with base values
        // This gives us full control over colors
        const trace = {
            type: 'bar',
            orientation: 'v',
            x: items,
            y: values,
            base: bases,
            text: values.map(v => v.toFixed(2)),
            textposition: 'outside',
            hovertemplate: '%{x}<br>Change: %{y:.2f}<br>Running Total: %{base:+y:.2f}<extra></extra>',
            marker: {
                color: markerColors,
                line: { width: 1, color: '#333' }
            }
        };

        // Add connector lines as shapes
        const shapes = [];
        for (let i = 0; i < processedForChart.length - 1; i++) {
            if (processedForChart[i].type !== 'total' && processedForChart[i + 1].type !== 'total') {
                const endY = processedForChart[i].end;
                shapes.push({
                    type: 'line',
                    x0: i + 0.4,
                    x1: i + 1 - 0.4,
                    y0: endY,
                    y1: endY,
                    line: {
                        color: 'rgb(63, 63, 63)',
                        width: 2,
                        dash: 'dot'
                    }
                });
            }
        }

        const layout = {
            showlegend: false,
            xaxis: { title: ITEM_COL },
            yaxis: { title: VALUE_COL },
            height: 500,
            margin: {l: 80, r: 50, t: 50, b: 100},
            shapes: shapes
        };

        // Use newPlot to ensure colors update properly
        // (react sometimes doesn't update all trace properties)
        Plotly.newPlot('variance', [trace], layout, {responsive: true}).then(function() {
            // Initialize click handler after first plot is created
            initClickHandler_variance();
        });

        // Update table
        updateTable_variance(processed, filteredData);
    };

    // Track if click handler has been initialized
    let clickHandlerInitialized = false;

    // Initialize click handler after first plot is created
    function initClickHandler_variance() {
        if (clickHandlerInitialized) return;
        const chartDiv = document.getElementById('variance');
        chartDiv.on('plotly_click', function(data) {
            const clickedItem = data.points[0].x;
            window.toggleItem_variance(clickedItem);
        });
        clickHandlerInitialized = true;
    }

    // Load and parse data
    loadDataset('variance_data').then(function(data) {
        allData = data;
        window.updateChart_variance();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('variance');
    }).catch(function(error) {
        console.error('Error loading data for chart variance:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['year', 'department'];
    const COLOR_COLS = ['category'];
    const ITEM_COL = 'item';
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = true;
    const COLOR_MAPS = {"category":{"Budget Analysis":"#636efa"}};

    // Store data globally
    let allData = [];
    let removedItems = new Set();  // Set of removed item names
    let removedCategories = new Set();  // Set of removed category names

    function calculateWaterfall_budget(data) {
        const activeData = data.filter(row => {
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            return !removedItems.has(item) && !removedCategories.has(category);
        });

        let runningTotal = 0;
        const processed = [];

        for (let i = 0; i < activeData.length; i++) {
            const row = activeData[i];
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            // All items are 'relative' (floating bars showing individual changes)
            // First item starts from 0 but still uses relative measure
            processed.push({
                item: item,
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing',
                isFirst: i === 0
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                item: 'Total',
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total',
                isFirst: false
            });
        }

        return processed;
    }

    function updateTable_budget(processedData, allItemsData) {
        if (!SHOW_TABLE) return;

        const container = document.getElementById('waterfall_table_container_budget');
        if (!container) return;

        // Build a map for quick lookup by item name
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.item] = item;
        }

        // Group items by category
        const categoryGroups = {};
        for (const row of allItemsData) {
            const cat = String(row[CATEGORY_COL]);
            const item = String(row[ITEM_COL]);
            if (!categoryGroups[cat]) {
                categoryGroups[cat] = [];
            }
            categoryGroups[cat].push(item);
        }

        // Build table HTML
        let html = '<table class="waterfall-table-budget">';
        html += '<thead><tr><th>Item</th><th>Change</th><th>Running Total</th></tr></thead>';
        html += '<tbody>';

        // Iterate through categories
        for (const [category, items] of Object.entries(categoryGroups)) {
            const catRemoved = removedCategories.has(category);

            // Category header row
            html += `<tr class="category-header" style="background-color: #e0e0e0; font-weight: bold; cursor: pointer;"
                     onclick="toggleCategoryGroup_budget('${category}')">`;
            html += `<td colspan="3">`;
            html += `<input type="checkbox" ${!catRemoved ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleCategoryGroup_budget('${category}')"
                     style="margin-right: 8px;">`;
            html += `${category}</td></tr>`;

            // Item rows within category
            for (const item of items) {
                const itemRemoved = removedItems.has(item) || catRemoved;
                const data = dataMap[item];

                let rowClass = '';
                if (itemRemoved) {
                    rowClass = 'removed';
                } else if (data) {
                    if (data.type === 'absolute' || data.type === 'increasing') {
                        rowClass = 'positive';
                    } else if (data.type === 'decreasing') {
                        rowClass = 'negative';
                    } else if (data.type === 'total') {
                        rowClass = 'total';
                    }
                }

                html += `<tr class="${rowClass}" style="cursor: pointer; padding-left: 20px;"
                         onclick="toggleItem_budget('${item}')">`;
                html += `<td style="padding-left: 20px;">${item}</td>`;

                if (data && !itemRemoved) {
                    html += `<td style="text-align: right;">${data.value.toFixed(2)}</td>`;
                    html += `<td style="text-align: right;">${data.end.toFixed(2)}</td>`;
                } else {
                    html += `<td style="text-align: right;">-</td>`;
                    html += `<td style="text-align: right;">-</td>`;
                }
                html += '</tr>';
            }
        }

        // Add Total row if it exists in processed data
        const totalData = processedData.find(d => d.type === 'total');
        if (totalData) {
            const totalRemoved = removedItems.has('Total');
            const rowClass = totalRemoved ? 'removed' : 'total';

            html += `<tr class="${rowClass}" style="background-color: #f5f5f5; font-weight: bold; cursor: pointer;"
                     onclick="toggleItem_budget('Total')">`;
            html += `<td style="padding-left: 20px;">Total</td>`;

            if (!totalRemoved) {
                html += `<td style="text-align: right;">${totalData.value.toFixed(2)}</td>`;
                html += `<td style="text-align: right;">${totalData.end.toFixed(2)}</td>`;
            } else {
                html += `<td style="text-align: right;">-</td>`;
                html += `<td style="text-align: right;">-</td>`;
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    window.toggleItem_budget = function(item) {
        // Allow toggling of all items including Total
        if (removedItems.has(item)) {
            removedItems.delete(item);
        } else {
            removedItems.add(item);
        }
        window.updateChart_budget();
    };

    window.toggleCategoryGroup_budget = function(category) {
        if (removedCategories.has(category)) {
            removedCategories.delete(category);
        } else {
            removedCategories.add(category);
        }
        window.updateChart_budget();
    };

    window.resetWaterfall_budget = function() {
        removedItems = new Set();
        removedCategories = new Set();
        window.updateChart_budget();
    };

    // Make it global so inline onchange can see it
    window.updateChart_budget = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update category column if dropdown exists
        const colorColSelect = document.getElementById('color_col_budget');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get color mode
        const colorModeSelect = document.getElementById('color_mode_budget');
        const colorMode = colorModeSelect ? colorModeSelect.value : 'Value (Positive/Negative)';
        console.log('Color mode:', colorMode);
        console.log('CATEGORY_COL:', CATEGORY_COL);
        console.log('COLOR_MAPS:', COLOR_MAPS);

        // Get current filter values (single selection)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_budget');
            if (select) {
                filters[col] = select.value;
            }
        });

        // Filter data (single selection per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                if (String(row[col]) !== filters[col]) {
                    return false;
                }
            }
            return true;
        });

        // Calculate waterfall (includes all items)
        const processed = calculateWaterfall_budget(filteredData);

        // Filter processed data for chart display (remove toggled items like Total)
        const processedForChart = processed.filter(d => !removedItems.has(d.item));

        const items = processedForChart.map(d => d.item);
        const values = processedForChart.map(d => d.value);
        const bases = processedForChart.map(d => d.type === 'total' ? 0 : d.start);

        // Determine colors based on mode
        let markerColors;
        if (colorMode === 'Category' && COLOR_MAPS[CATEGORY_COL]) {
            // Category-based coloring
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                const categoryColor = COLOR_MAPS[CATEGORY_COL][d.category];
                return categoryColor || '#4285F4';
            });
            console.log('Using category-based colors:', markerColors);
        } else {
            // Value-based coloring (positive/negative)
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                return d.value >= 0 ? '#4CAF50' : '#F44336';  // Green for positive, Red for negative
            });
            console.log('Using value-based colors (positive/negative):', markerColors);
        }

        // Build waterfall using bar chart with base values
        // This gives us full control over colors
        const trace = {
            type: 'bar',
            orientation: 'v',
            x: items,
            y: values,
            base: bases,
            text: values.map(v => v.toFixed(2)),
            textposition: 'outside',
            hovertemplate: '%{x}<br>Change: %{y:.2f}<br>Running Total: %{base:+y:.2f}<extra></extra>',
            marker: {
                color: markerColors,
                line: { width: 1, color: '#333' }
            }
        };

        // Add connector lines as shapes
        const shapes = [];
        for (let i = 0; i < processedForChart.length - 1; i++) {
            if (processedForChart[i].type !== 'total' && processedForChart[i + 1].type !== 'total') {
                const endY = processedForChart[i].end;
                shapes.push({
                    type: 'line',
                    x0: i + 0.4,
                    x1: i + 1 - 0.4,
                    y0: endY,
                    y1: endY,
                    line: {
                        color: 'rgb(63, 63, 63)',
                        width: 2,
                        dash: 'dot'
                    }
                });
            }
        }

        const layout = {
            showlegend: false,
            xaxis: { title: ITEM_COL },
            yaxis: { title: VALUE_COL },
            height: 500,
            margin: {l: 80, r: 50, t: 50, b: 100},
            shapes: shapes
        };

        // Use newPlot to ensure colors update properly
        // (react sometimes doesn't update all trace properties)
        Plotly.newPlot('budget', [trace], layout, {responsive: true}).then(function() {
            // Initialize click handler after first plot is created
            initClickHandler_budget();
        });

        // Update table
        updateTable_budget(processed, filteredData);
    };

    // Track if click handler has been initialized
    let clickHandlerInitialized = false;

    // Initialize click handler after first plot is created
    function initClickHandler_budget() {
        if (clickHandlerInitialized) return;
        const chartDiv = document.getElementById('budget');
        chartDiv.on('plotly_click', function(data) {
            const clickedItem = data.points[0].x;
            window.toggleItem_budget(clickedItem);
        });
        clickHandlerInitialized = true;
    }

    // Load and parse data
    loadDataset('budget_data').then(function(data) {
        allData = data;
        window.updateChart_budget();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('budget');
    }).catch(function(error) {
        console.error('Error loading data for chart budget:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['category'];
    const ITEM_COL = 'item';
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = false;
    const SHOW_TOTALS = true;
    const COLOR_MAPS = {"category":{"Simple":"#636efa"}};

    // Store data globally
    let allData = [];
    let removedItems = new Set();  // Set of removed item names
    let removedCategories = new Set();  // Set of removed category names

    function calculateWaterfall_simple(data) {
        const activeData = data.filter(row => {
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            return !removedItems.has(item) && !removedCategories.has(category);
        });

        let runningTotal = 0;
        const processed = [];

        for (let i = 0; i < activeData.length; i++) {
            const row = activeData[i];
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            // All items are 'relative' (floating bars showing individual changes)
            // First item starts from 0 but still uses relative measure
            processed.push({
                item: item,
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing',
                isFirst: i === 0
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                item: 'Total',
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total',
                isFirst: false
            });
        }

        return processed;
    }

    function updateTable_simple(processedData, allItemsData) {
        if (!SHOW_TABLE) return;

        const container = document.getElementById('waterfall_table_container_simple');
        if (!container) return;

        // Build a map for quick lookup by item name
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.item] = item;
        }

        // Group items by category
        const categoryGroups = {};
        for (const row of allItemsData) {
            const cat = String(row[CATEGORY_COL]);
            const item = String(row[ITEM_COL]);
            if (!categoryGroups[cat]) {
                categoryGroups[cat] = [];
            }
            categoryGroups[cat].push(item);
        }

        // Build table HTML
        let html = '<table class="waterfall-table-simple">';
        html += '<thead><tr><th>Item</th><th>Change</th><th>Running Total</th></tr></thead>';
        html += '<tbody>';

        // Iterate through categories
        for (const [category, items] of Object.entries(categoryGroups)) {
            const catRemoved = removedCategories.has(category);

            // Category header row
            html += `<tr class="category-header" style="background-color: #e0e0e0; font-weight: bold; cursor: pointer;"
                     onclick="toggleCategoryGroup_simple('${category}')">`;
            html += `<td colspan="3">`;
            html += `<input type="checkbox" ${!catRemoved ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleCategoryGroup_simple('${category}')"
                     style="margin-right: 8px;">`;
            html += `${category}</td></tr>`;

            // Item rows within category
            for (const item of items) {
                const itemRemoved = removedItems.has(item) || catRemoved;
                const data = dataMap[item];

                let rowClass = '';
                if (itemRemoved) {
                    rowClass = 'removed';
                } else if (data) {
                    if (data.type === 'absolute' || data.type === 'increasing') {
                        rowClass = 'positive';
                    } else if (data.type === 'decreasing') {
                        rowClass = 'negative';
                    } else if (data.type === 'total') {
                        rowClass = 'total';
                    }
                }

                html += `<tr class="${rowClass}" style="cursor: pointer; padding-left: 20px;"
                         onclick="toggleItem_simple('${item}')">`;
                html += `<td style="padding-left: 20px;">${item}</td>`;

                if (data && !itemRemoved) {
                    html += `<td style="text-align: right;">${data.value.toFixed(2)}</td>`;
                    html += `<td style="text-align: right;">${data.end.toFixed(2)}</td>`;
                } else {
                    html += `<td style="text-align: right;">-</td>`;
                    html += `<td style="text-align: right;">-</td>`;
                }
                html += '</tr>';
            }
        }

        // Add Total row if it exists in processed data
        const totalData = processedData.find(d => d.type === 'total');
        if (totalData) {
            const totalRemoved = removedItems.has('Total');
            const rowClass = totalRemoved ? 'removed' : 'total';

            html += `<tr class="${rowClass}" style="background-color: #f5f5f5; font-weight: bold; cursor: pointer;"
                     onclick="toggleItem_simple('Total')">`;
            html += `<td style="padding-left: 20px;">Total</td>`;

            if (!totalRemoved) {
                html += `<td style="text-align: right;">${totalData.value.toFixed(2)}</td>`;
                html += `<td style="text-align: right;">${totalData.end.toFixed(2)}</td>`;
            } else {
                html += `<td style="text-align: right;">-</td>`;
                html += `<td style="text-align: right;">-</td>`;
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    window.toggleItem_simple = function(item) {
        // Allow toggling of all items including Total
        if (removedItems.has(item)) {
            removedItems.delete(item);
        } else {
            removedItems.add(item);
        }
        window.updateChart_simple();
    };

    window.toggleCategoryGroup_simple = function(category) {
        if (removedCategories.has(category)) {
            removedCategories.delete(category);
        } else {
            removedCategories.add(category);
        }
        window.updateChart_simple();
    };

    window.resetWaterfall_simple = function() {
        removedItems = new Set();
        removedCategories = new Set();
        window.updateChart_simple();
    };

    // Make it global so inline onchange can see it
    window.updateChart_simple = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update category column if dropdown exists
        const colorColSelect = document.getElementById('color_col_simple');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get color mode
        const colorModeSelect = document.getElementById('color_mode_simple');
        const colorMode = colorModeSelect ? colorModeSelect.value : 'Value (Positive/Negative)';
        console.log('Color mode:', colorMode);
        console.log('CATEGORY_COL:', CATEGORY_COL);
        console.log('COLOR_MAPS:', COLOR_MAPS);

        // Get current filter values (single selection)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_simple');
            if (select) {
                filters[col] = select.value;
            }
        });

        // Filter data (single selection per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                if (String(row[col]) !== filters[col]) {
                    return false;
                }
            }
            return true;
        });

        // Calculate waterfall (includes all items)
        const processed = calculateWaterfall_simple(filteredData);

        // Filter processed data for chart display (remove toggled items like Total)
        const processedForChart = processed.filter(d => !removedItems.has(d.item));

        const items = processedForChart.map(d => d.item);
        const values = processedForChart.map(d => d.value);
        const bases = processedForChart.map(d => d.type === 'total' ? 0 : d.start);

        // Determine colors based on mode
        let markerColors;
        if (colorMode === 'Category' && COLOR_MAPS[CATEGORY_COL]) {
            // Category-based coloring
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                const categoryColor = COLOR_MAPS[CATEGORY_COL][d.category];
                return categoryColor || '#4285F4';
            });
            console.log('Using category-based colors:', markerColors);
        } else {
            // Value-based coloring (positive/negative)
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                return d.value >= 0 ? '#4CAF50' : '#F44336';  // Green for positive, Red for negative
            });
            console.log('Using value-based colors (positive/negative):', markerColors);
        }

        // Build waterfall using bar chart with base values
        // This gives us full control over colors
        const trace = {
            type: 'bar',
            orientation: 'v',
            x: items,
            y: values,
            base: bases,
            text: values.map(v => v.toFixed(2)),
            textposition: 'outside',
            hovertemplate: '%{x}<br>Change: %{y:.2f}<br>Running Total: %{base:+y:.2f}<extra></extra>',
            marker: {
                color: markerColors,
                line: { width: 1, color: '#333' }
            }
        };

        // Add connector lines as shapes
        const shapes = [];
        for (let i = 0; i < processedForChart.length - 1; i++) {
            if (processedForChart[i].type !== 'total' && processedForChart[i + 1].type !== 'total') {
                const endY = processedForChart[i].end;
                shapes.push({
                    type: 'line',
                    x0: i + 0.4,
                    x1: i + 1 - 0.4,
                    y0: endY,
                    y1: endY,
                    line: {
                        color: 'rgb(63, 63, 63)',
                        width: 2,
                        dash: 'dot'
                    }
                });
            }
        }

        const layout = {
            showlegend: false,
            xaxis: { title: ITEM_COL },
            yaxis: { title: VALUE_COL },
            height: 500,
            margin: {l: 80, r: 50, t: 50, b: 100},
            shapes: shapes
        };

        // Use newPlot to ensure colors update properly
        // (react sometimes doesn't update all trace properties)
        Plotly.newPlot('simple', [trace], layout, {responsive: true}).then(function() {
            // Initialize click handler after first plot is created
            initClickHandler_simple();
        });

        // Update table
        updateTable_simple(processed, filteredData);
    };

    // Track if click handler has been initialized
    let clickHandlerInitialized = false;

    // Initialize click handler after first plot is created
    function initClickHandler_simple() {
        if (clickHandlerInitialized) return;
        const chartDiv = document.getElementById('simple');
        chartDiv.on('plotly_click', function(data) {
            const clickedItem = data.points[0].x;
            window.toggleItem_simple(clickedItem);
        });
        clickHandlerInitialized = true;
    }

    // Load and parse data
    loadDataset('simple_data').then(function(data) {
        allData = data;
        window.updateChart_simple();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('simple');
    }).catch(function(error) {
        console.error('Error loading data for chart simple:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['financial_category', 'department'];
    const ITEM_COL = 'item';
    let CATEGORY_COL = 'financial_category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = false;
    const COLOR_MAPS = {"financial_category":{"Net":"#00cc96","Income":"#636efa","Expense":"#EF553B"},"department":{"Admin":"#00cc96","Sales":"#636efa","All Depts":"#FFA15A","Operations":"#EF553B","Marketing":"#ab63fa"}};

    // Store data globally
    let allData = [];
    let removedItems = new Set();  // Set of removed item names
    let removedCategories = new Set();  // Set of removed category names

    function calculateWaterfall_multi_color(data) {
        const activeData = data.filter(row => {
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            return !removedItems.has(item) && !removedCategories.has(category);
        });

        let runningTotal = 0;
        const processed = [];

        for (let i = 0; i < activeData.length; i++) {
            const row = activeData[i];
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            // All items are 'relative' (floating bars showing individual changes)
            // First item starts from 0 but still uses relative measure
            processed.push({
                item: item,
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing',
                isFirst: i === 0
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                item: 'Total',
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total',
                isFirst: false
            });
        }

        return processed;
    }

    function updateTable_multi_color(processedData, allItemsData) {
        if (!SHOW_TABLE) return;

        const container = document.getElementById('waterfall_table_container_multi_color');
        if (!container) return;

        // Build a map for quick lookup by item name
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.item] = item;
        }

        // Group items by category
        const categoryGroups = {};
        for (const row of allItemsData) {
            const cat = String(row[CATEGORY_COL]);
            const item = String(row[ITEM_COL]);
            if (!categoryGroups[cat]) {
                categoryGroups[cat] = [];
            }
            categoryGroups[cat].push(item);
        }

        // Build table HTML
        let html = '<table class="waterfall-table-multi_color">';
        html += '<thead><tr><th>Item</th><th>Change</th><th>Running Total</th></tr></thead>';
        html += '<tbody>';

        // Iterate through categories
        for (const [category, items] of Object.entries(categoryGroups)) {
            const catRemoved = removedCategories.has(category);

            // Category header row
            html += `<tr class="category-header" style="background-color: #e0e0e0; font-weight: bold; cursor: pointer;"
                     onclick="toggleCategoryGroup_multi_color('${category}')">`;
            html += `<td colspan="3">`;
            html += `<input type="checkbox" ${!catRemoved ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleCategoryGroup_multi_color('${category}')"
                     style="margin-right: 8px;">`;
            html += `${category}</td></tr>`;

            // Item rows within category
            for (const item of items) {
                const itemRemoved = removedItems.has(item) || catRemoved;
                const data = dataMap[item];

                let rowClass = '';
                if (itemRemoved) {
                    rowClass = 'removed';
                } else if (data) {
                    if (data.type === 'absolute' || data.type === 'increasing') {
                        rowClass = 'positive';
                    } else if (data.type === 'decreasing') {
                        rowClass = 'negative';
                    } else if (data.type === 'total') {
                        rowClass = 'total';
                    }
                }

                html += `<tr class="${rowClass}" style="cursor: pointer; padding-left: 20px;"
                         onclick="toggleItem_multi_color('${item}')">`;
                html += `<td style="padding-left: 20px;">${item}</td>`;

                if (data && !itemRemoved) {
                    html += `<td style="text-align: right;">${data.value.toFixed(2)}</td>`;
                    html += `<td style="text-align: right;">${data.end.toFixed(2)}</td>`;
                } else {
                    html += `<td style="text-align: right;">-</td>`;
                    html += `<td style="text-align: right;">-</td>`;
                }
                html += '</tr>';
            }
        }

        // Add Total row if it exists in processed data
        const totalData = processedData.find(d => d.type === 'total');
        if (totalData) {
            const totalRemoved = removedItems.has('Total');
            const rowClass = totalRemoved ? 'removed' : 'total';

            html += `<tr class="${rowClass}" style="background-color: #f5f5f5; font-weight: bold; cursor: pointer;"
                     onclick="toggleItem_multi_color('Total')">`;
            html += `<td style="padding-left: 20px;">Total</td>`;

            if (!totalRemoved) {
                html += `<td style="text-align: right;">${totalData.value.toFixed(2)}</td>`;
                html += `<td style="text-align: right;">${totalData.end.toFixed(2)}</td>`;
            } else {
                html += `<td style="text-align: right;">-</td>`;
                html += `<td style="text-align: right;">-</td>`;
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    window.toggleItem_multi_color = function(item) {
        // Allow toggling of all items including Total
        if (removedItems.has(item)) {
            removedItems.delete(item);
        } else {
            removedItems.add(item);
        }
        window.updateChart_multi_color();
    };

    window.toggleCategoryGroup_multi_color = function(category) {
        if (removedCategories.has(category)) {
            removedCategories.delete(category);
        } else {
            removedCategories.add(category);
        }
        window.updateChart_multi_color();
    };

    window.resetWaterfall_multi_color = function() {
        removedItems = new Set();
        removedCategories = new Set();
        window.updateChart_multi_color();
    };

    // Make it global so inline onchange can see it
    window.updateChart_multi_color = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update category column if dropdown exists
        const colorColSelect = document.getElementById('color_col_multi_color');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get color mode
        const colorModeSelect = document.getElementById('color_mode_multi_color');
        const colorMode = colorModeSelect ? colorModeSelect.value : 'Value (Positive/Negative)';
        console.log('Color mode:', colorMode);
        console.log('CATEGORY_COL:', CATEGORY_COL);
        console.log('COLOR_MAPS:', COLOR_MAPS);

        // Get current filter values (single selection)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_multi_color');
            if (select) {
                filters[col] = select.value;
            }
        });

        // Filter data (single selection per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                if (String(row[col]) !== filters[col]) {
                    return false;
                }
            }
            return true;
        });

        // Calculate waterfall (includes all items)
        const processed = calculateWaterfall_multi_color(filteredData);

        // Filter processed data for chart display (remove toggled items like Total)
        const processedForChart = processed.filter(d => !removedItems.has(d.item));

        const items = processedForChart.map(d => d.item);
        const values = processedForChart.map(d => d.value);
        const bases = processedForChart.map(d => d.type === 'total' ? 0 : d.start);

        // Determine colors based on mode
        let markerColors;
        if (colorMode === 'Category' && COLOR_MAPS[CATEGORY_COL]) {
            // Category-based coloring
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                const categoryColor = COLOR_MAPS[CATEGORY_COL][d.category];
                return categoryColor || '#4285F4';
            });
            console.log('Using category-based colors:', markerColors);
        } else {
            // Value-based coloring (positive/negative)
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                return d.value >= 0 ? '#4CAF50' : '#F44336';  // Green for positive, Red for negative
            });
            console.log('Using value-based colors (positive/negative):', markerColors);
        }

        // Build waterfall using bar chart with base values
        // This gives us full control over colors
        const trace = {
            type: 'bar',
            orientation: 'v',
            x: items,
            y: values,
            base: bases,
            text: values.map(v => v.toFixed(2)),
            textposition: 'outside',
            hovertemplate: '%{x}<br>Change: %{y:.2f}<br>Running Total: %{base:+y:.2f}<extra></extra>',
            marker: {
                color: markerColors,
                line: { width: 1, color: '#333' }
            }
        };

        // Add connector lines as shapes
        const shapes = [];
        for (let i = 0; i < processedForChart.length - 1; i++) {
            if (processedForChart[i].type !== 'total' && processedForChart[i + 1].type !== 'total') {
                const endY = processedForChart[i].end;
                shapes.push({
                    type: 'line',
                    x0: i + 0.4,
                    x1: i + 1 - 0.4,
                    y0: endY,
                    y1: endY,
                    line: {
                        color: 'rgb(63, 63, 63)',
                        width: 2,
                        dash: 'dot'
                    }
                });
            }
        }

        const layout = {
            showlegend: false,
            xaxis: { title: ITEM_COL },
            yaxis: { title: VALUE_COL },
            height: 500,
            margin: {l: 80, r: 50, t: 50, b: 100},
            shapes: shapes
        };

        // Use newPlot to ensure colors update properly
        // (react sometimes doesn't update all trace properties)
        Plotly.newPlot('multi_color', [trace], layout, {responsive: true}).then(function() {
            // Initialize click handler after first plot is created
            initClickHandler_multi_color();
        });

        // Update table
        updateTable_multi_color(processed, filteredData);
    };

    // Track if click handler has been initialized
    let clickHandlerInitialized = false;

    // Initialize click handler after first plot is created
    function initClickHandler_multi_color() {
        if (clickHandlerInitialized) return;
        const chartDiv = document.getElementById('multi_color');
        chartDiv.on('plotly_click', function(data) {
            const clickedItem = data.points[0].x;
            window.toggleItem_multi_color(clickedItem);
        });
        clickHandlerInitialized = true;
    }

    // Load and parse data
    loadDataset('multi_color_data').then(function(data) {
        allData = data;
        window.updateChart_multi_color();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('multi_color');
    }).catch(function(error) {
        console.error('Error loading data for chart multi_color:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="cash_data" data-format="csv_embedded" data-src="">
item,category,value
Opening Cash,Cash Flow,5000
Operating CF,Cash Flow,3000
Investing CF,Cash Flow,-1500
Financing CF,Cash Flow,1000

</script><script type="text/plain" id="pnl_data" data-format="csv_embedded" data-src="">
item,category,value,accounting,currency
Revenue,PnL,10000.0,Non-GAAP,EUR
COGS,PnL,-4000.0,Non-GAAP,EUR
Gross Profit,PnL,6000.0,Non-GAAP,EUR
Marketing,PnL,-1500.0,Non-GAAP,EUR
R&D,PnL,-800.0,Non-GAAP,EUR
Admin,PnL,-700.0,Non-GAAP,EUR
EBIT,PnL,3000.0,Non-GAAP,EUR
Profit Taxes,Taxation,-600.0,Non-GAAP,EUR
Death Tax,Taxation,-200.0,Non-GAAP,EUR
Deficit Tax,Taxation,-300.0,Non-GAAP,EUR
Other Taxes,Taxation,-200.0,Non-GAAP,EUR
Revenue,PnL,10434.16499866476,GAAP,EUR
COGS,PnL,-4112.652081675686,GAAP,EUR
Gross Profit,PnL,5469.589880151087,GAAP,EUR
Marketing,PnL,-1441.668411275839,GAAP,EUR
R&D,PnL,-804.604344977528,GAAP,EUR
Admin,PnL,-718.9512015424384,GAAP,EUR
EBIT,PnL,2791.760679575874,GAAP,EUR
Profit Taxes,Taxation,-608.0651269333594,GAAP,EUR
Death Tax,Taxation,-185.70285510497396,GAAP,EUR
Deficit Tax,Taxation,-311.2934448844502,GAAP,EUR
Other Taxes,Taxation,-199.94959224223663,GAAP,EUR
Revenue,PnL,11000.0,Non-GAAP,USD
COGS,PnL,-4400.0,Non-GAAP,USD
Gross Profit,PnL,6600.000000000001,Non-GAAP,USD
Marketing,PnL,-1650.0000000000002,Non-GAAP,USD
R&D,PnL,-880.0000000000001,Non-GAAP,USD
Admin,PnL,-770.0000000000001,Non-GAAP,USD
EBIT,PnL,3300.0000000000005,Non-GAAP,USD
Profit Taxes,Taxation,-660.0,Non-GAAP,USD
Death Tax,Taxation,-220.00000000000003,Non-GAAP,USD
Deficit Tax,Taxation,-330.0,Non-GAAP,USD
Other Taxes,Taxation,-220.00000000000003,Non-GAAP,USD
Revenue,PnL,11477.581498531237,GAAP,USD
COGS,PnL,-4523.917289843254,GAAP,USD
Gross Profit,PnL,6016.5488681661955,GAAP,USD
Marketing,PnL,-1585.835252403423,GAAP,USD
R&D,PnL,-885.0647794752808,GAAP,USD
Admin,PnL,-790.8463216966824,GAAP,USD
EBIT,PnL,3070.9367475334616,GAAP,USD
Profit Taxes,Taxation,-668.8716396266954,GAAP,USD
Death Tax,Taxation,-204.27314061547136,GAAP,USD
Deficit Tax,Taxation,-342.42278937289524,GAAP,USD
Other Taxes,Taxation,-219.94455146646033,GAAP,USD

</script><script type="text/plain" id="budget_data" data-format="csv_embedded" data-src="">
item,category,value,department,year
Budget,Budget Analysis,1000.0,Sales,2023
Actual Spending,Budget Analysis,-90.64330805766372,Sales,2023
Variance,Budget Analysis,-90.64330805766372,Sales,2023
Budget,Budget Analysis,1000.0,Sales,2024
Actual Spending,Budget Analysis,63.18953687445401,Sales,2024
Variance,Budget Analysis,63.18953687445401,Sales,2024
Budget,Budget Analysis,500.0,Marketing,2023
Actual Spending,Budget Analysis,44.961661768340946,Marketing,2023
Variance,Budget Analysis,44.961661768340946,Marketing,2023
Budget,Budget Analysis,500.0,Marketing,2024
Actual Spending,Budget Analysis,64.58719832725194,Marketing,2024
Variance,Budget Analysis,64.58719832725194,Marketing,2024
Budget,Budget Analysis,1500.0,Engineering,2023
Actual Spending,Budget Analysis,-1.4946345987200402,Engineering,2023
Variance,Budget Analysis,-1.4946345987200402,Engineering,2023
Budget,Budget Analysis,1500.0,Engineering,2024
Actual Spending,Budget Analysis,-31.06167972365688,Engineering,2024
Variance,Budget Analysis,-31.06167972365688,Engineering,2024
Budget,Budget Analysis,800.0,Operations,2023
Actual Spending,Budget Analysis,-34.629554917129894,Operations,2023
Variance,Budget Analysis,-34.629554917129894,Operations,2023
Budget,Budget Analysis,800.0,Operations,2024
Actual Spending,Budget Analysis,81.32813290069794,Operations,2024
Variance,Budget Analysis,81.32813290069794,Operations,2024

</script><script type="text/plain" id="simple_data" data-format="csv_embedded" data-src="">
item,category,value
Starting Value,Simple,1000
Increase 1,Simple,300
Increase 2,Simple,200
Decrease 1,Simple,-150
Decrease 2,Simple,-100

</script><script type="text/plain" id="variance_data" data-format="csv_embedded" data-src="">
item,category,value,region
Base Sales,Variance,10000,North
Price Impact,Variance,500,North
Volume Impact,Variance,-300,North
Mix Impact,Variance,200,North
Actual Sales,Variance,10400,North
Base Sales,Variance,8000,South
Price Impact,Variance,-200,South
Volume Impact,Variance,400,South
Mix Impact,Variance,100,South
Actual Sales,Variance,8300,South
Base Sales,Variance,12000,East
Price Impact,Variance,800,East
Volume Impact,Variance,-500,East
Mix Impact,Variance,300,East
Actual Sales,Variance,12600,East
Base Sales,Variance,9000,West
Price Impact,Variance,200,West
Volume Impact,Variance,300,West
Mix Impact,Variance,-100,West
Actual Sales,Variance,9400,West

</script><script type="text/plain" id="multi_color_data" data-format="csv_embedded" data-src="">
item,financial_category,department,value
Revenue,Income,Sales,5000
Direct Costs,Expense,Operations,-2000
Overhead,Expense,Admin,-800
Marketing,Expense,Marketing,-600
Net Income,Net,All Depts,1600

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/waterfall_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>Waterfall Chart Examples</h1>
<p>This page demonstrates the interactive Waterfall chart type in JSPlots.</p>
<ul>
    <li><strong>Automatic cumulative sum calculation:</strong> Enter category and value data, waterfall handles the rest</li>
    <li><strong>Side-by-side calculation table:</strong> See exact values and running totals</li>
    <li><strong>Click-to-remove interaction:</strong> Click on bars or table rows to temporarily exclude from calculation</li>
    <li><strong>Reset functionality:</strong> Restore all removed segments with one click</li>
    <li><strong>Color coding:</strong> Green for positive values, red for negative, black for totals. Or switch to category-based coloring</li>
    <li><strong>Filtering:</strong> Switch between different datasets using single-select dropdowns</li>
</ul>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 1: Profit & Loss Statement</h2>
<p>A classic use case for waterfall charts: showing how revenue flows through various expenses to net income.</p>
<p>Features demonstrated:</p>
<ul>
    <li>Positive values (Revenue, Gross Profit) in green</li>
    <li>Negative values (Costs, Expenses) in red</li>
    <li>Running total displayed in the table</li>
    <li>Click on any bar or table row to exclude from calculation</li>
    <li>Reset button to restore all segments</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Profit & Loss Statement</h2>
<p>Click on bars or table rows to exclude items from the calculation. Use Reset to restore.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="pnl_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="currency_select_pnl">currency: </label>
                <select id="currency_select_pnl" onchange="updateChart_pnl()">
                <option value="EUR" selected>EUR</option>
                <option value="USD">USD</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="currency_select_pnl_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="accounting_select_pnl">accounting: </label>
                <select id="accounting_select_pnl" onchange="updateChart_pnl()">
                <option value="Non-GAAP" selected>Non-GAAP</option>
                <option value="GAAP">GAAP</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="accounting_select_pnl_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_mode_pnl">Color By: </label>
                <select id="color_mode_pnl" onchange="updateChart_pnl()">
                <option value="Value (Positive/Negative)" selected>Value (Positive/Negative)</option>
                <option value="Category">Category</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_mode_pnl_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="pnl_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="pnl_aspect_ratio_label">0.4</span>
    <input type="range" id="pnl_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="pnl"></div>
<style>
    .waterfall-layout-pnl {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-pnl {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-pnl {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-pnl {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-pnl th,
    .waterfall-table-pnl td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-pnl th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-pnl tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-pnl tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-pnl tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-pnl tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-pnl tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-pnl {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-pnl:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-pnl">
    <div class="waterfall-chart-section-pnl">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-pnl">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on category headers to toggle groups, or individual rows to exclude items</p>
                <div id="waterfall_table_container_pnl">
                    <!-- Table will be generated by JavaScript -->
                </div>
                <button class="waterfall-reset-btn-pnl" onclick="resetWaterfall_pnl()">ð Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: pnl_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 2: Cash Flow Bridge</h2>
<p>Show how cash position changes from opening to closing balance through operating, investing, and financing activities.</p>
<p>This example demonstrates:</p>
<ul>
    <li>Mix of positive and negative cash flows</li>
    <li>Total bar showing final cash position</li>
    <li>Interactive removal to see "what-if" scenarios</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Cash Flow Bridge - Q1 2024</h2>
<p>Waterfall showing cash flow changes. Total bar shows ending cash position.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_mode_cashflow">Color By: </label>
                <select id="color_mode_cashflow" onchange="updateChart_cashflow()">
                <option value="Value (Positive/Negative)" selected>Value (Positive/Negative)</option>
                <option value="Category">Category</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_mode_cashflow_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="cashflow_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="cashflow_aspect_ratio_label">0.4</span>
    <input type="range" id="cashflow_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="cashflow"></div>
<style>
    .waterfall-layout-cashflow {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-cashflow {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-cashflow {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-cashflow {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-cashflow th,
    .waterfall-table-cashflow td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-cashflow th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-cashflow tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-cashflow tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-cashflow tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-cashflow tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-cashflow tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-cashflow {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-cashflow:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-cashflow">
    <div class="waterfall-chart-section-cashflow">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-cashflow">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on category headers to toggle groups, or individual rows to exclude items</p>
                <div id="waterfall_table_container_cashflow">
                    <!-- Table will be generated by JavaScript -->
                </div>
                <button class="waterfall-reset-btn-cashflow" onclick="resetWaterfall_cashflow()">ð Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: cash_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 3: Sales Variance Analysis with Filters</h2>
<p>Analyze sales variance by breaking down the impact of price, volume, and mix changes.</p>
<p>This example includes:</p>
<ul>
    <li>Multiple regions selectable via filters</li>
    <li>Variance analysis showing positive and negative impacts</li>
    <li>Side-by-side table for detailed calculation review</li>
    <li>Click-to-remove to isolate specific variance drivers</li>
</ul>
<p><strong>Try this:</strong> Select different regions to see how variance components differ across markets!</p>

    </div>
<br>
<hr>
<br>
<h2>Sales Variance Analysis by Region</h2>
<p>Use the region filter to switch between markets. Click on variance components to see impact on actual sales.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="variance_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="region_select_variance">region: </label>
                <select id="region_select_variance" onchange="updateChart_variance()">
                <option value="North" selected>North</option>
                <option value="South">South</option>
                <option value="East">East</option>
                <option value="West">West</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="region_select_variance_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_mode_variance">Color By: </label>
                <select id="color_mode_variance" onchange="updateChart_variance()">
                <option value="Value (Positive/Negative)" selected>Value (Positive/Negative)</option>
                <option value="Category">Category</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_mode_variance_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="variance_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="variance_aspect_ratio_label">0.4</span>
    <input type="range" id="variance_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="variance"></div>
<style>
    .waterfall-layout-variance {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-variance {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-variance {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-variance {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-variance th,
    .waterfall-table-variance td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-variance th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-variance tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-variance tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-variance tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-variance tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-variance tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-variance {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-variance:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-variance">
    <div class="waterfall-chart-section-variance">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-variance">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on category headers to toggle groups, or individual rows to exclude items</p>
                <div id="waterfall_table_container_variance">
                    <!-- Table will be generated by JavaScript -->
                </div>
                <button class="waterfall-reset-btn-variance" onclick="resetWaterfall_variance()">ð Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: variance_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 4: Budget vs Actuals Comparison</h2>
<p>Compare budgeted vs actual expenses across departments with multiple filters.</p>
<p>Features:</p>
<ul>
    <li>Department filter to focus on specific areas</li>
    <li>Year filter for historical comparison</li>
    <li>Both positive and negative variances</li>
    <li>Table shows running variance total</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Budget vs Actuals - Department Variance</h2>
<p>Filter by department and year to see specific variances. Red indicates over-budget, green under-budget.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="budget_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="year_select_budget">year: </label>
                <select id="year_select_budget" onchange="updateChart_budget()">
                <option value="2023">2023</option>
                <option value="2024" selected>2024</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="year_select_budget_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="department_select_budget">department: </label>
                <select id="department_select_budget" onchange="updateChart_budget()">
                <option value="Sales" selected>Sales</option>
                <option value="Marketing">Marketing</option>
                <option value="Engineering">Engineering</option>
                <option value="Operations">Operations</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="department_select_budget_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_mode_budget">Color By: </label>
                <select id="color_mode_budget" onchange="updateChart_budget()">
                <option value="Value (Positive/Negative)" selected>Value (Positive/Negative)</option>
                <option value="Category">Category</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_mode_budget_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="budget_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="budget_aspect_ratio_label">0.4</span>
    <input type="range" id="budget_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="budget"></div>
<style>
    .waterfall-layout-budget {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-budget {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-budget {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-budget {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-budget th,
    .waterfall-table-budget td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-budget th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-budget tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-budget tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-budget tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-budget tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-budget tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-budget {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-budget:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-budget">
    <div class="waterfall-chart-section-budget">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-budget">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on category headers to toggle groups, or individual rows to exclude items</p>
                <div id="waterfall_table_container_budget">
                    <!-- Table will be generated by JavaScript -->
                </div>
                <button class="waterfall-reset-btn-budget" onclick="resetWaterfall_budget()">ð Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: budget_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 5: Waterfall Chart Without Table</h2>
<p>Sometimes you just want the visual without the detailed calculations.</p>
<p>This example shows a waterfall chart with the table disabled (show_table=false).</p>

    </div>
<br>
<hr>
<br>
<h2>Simple Waterfall - Chart Only</h2>
<p>This waterfall chart has show_table=false, so only the visualization is displayed.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_mode_simple">Color By: </label>
                <select id="color_mode_simple" onchange="updateChart_simple()">
                <option value="Value (Positive/Negative)" selected>Value (Positive/Negative)</option>
                <option value="Category">Category</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_mode_simple_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="simple_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="simple_aspect_ratio_label">0.4</span>
    <input type="range" id="simple_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="simple"></div>
<style>
    .waterfall-layout-simple {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-simple {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-simple {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-simple {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-simple th,
    .waterfall-table-simple td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-simple th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-simple tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-simple tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-simple tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-simple tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-simple tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-simple {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-simple:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-simple">
    <div class="waterfall-chart-section-simple">
        <!-- Chart will be rendered here -->
    </div>
    
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: simple_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 6: Multiple Color Column Options</h2>
<p>This example demonstrates the ability to switch between different category columns.</p>
<p>The same data can be viewed through different lenses - by financial category OR by department.</p>
<p>Features:</p>
<ul>
    <li>Color Column dropdown to switch between category perspectives</li>
    <li>Same underlying data, different groupings</li>
    <li>Useful for multi-dimensional analysis</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Multi-Perspective Waterfall Analysis</h2>
<p>Use the Color Column dropdown to switch between financial and departmental views of the same data.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_mode_multi_color">Color By: </label>
                <select id="color_mode_multi_color" onchange="updateChart_multi_color()">
                <option value="Value (Positive/Negative)" selected>Value (Positive/Negative)</option>
                <option value="Category">Category</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_mode_multi_color_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_multi_color">Category Column: </label>
                <select id="color_col_multi_color" onchange="updateChart_multi_color()">
                <option value="financial_category" selected>financial_category</option>
                <option value="department">department</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_multi_color_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="multi_color_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="multi_color_aspect_ratio_label">0.4</span>
    <input type="range" id="multi_color_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="multi_color"></div>
<style>
    .waterfall-layout-multi_color {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-multi_color {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-multi_color {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-multi_color {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-multi_color th,
    .waterfall-table-multi_color td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-multi_color th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-multi_color tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-multi_color tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-multi_color tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-multi_color tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-multi_color tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-multi_color {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-multi_color:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-multi_color">
    <div class="waterfall-chart-section-multi_color">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-multi_color">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on category headers to toggle groups, or individual rows to exclude items</p>
                <div id="waterfall_table_container_multi_color">
                    <!-- Table will be generated by JavaScript -->
                </div>
                <button class="waterfall-reset-btn-multi_color" onclick="resetWaterfall_multi_color()">ð Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: multi_color_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary</h2>
<p>The Waterfall chart type provides:</p>
<ul>
    <li><strong>Automatic calculation:</strong> Just provide categories and values, cumulative sums are calculated automatically</li>
    <li><strong>Side-by-side table:</strong> Optional calculation table showing each step and running total, grouped by category</li>
    <li><strong>Interactive removal:</strong> Click on bars or table rows to temporarily exclude from calculation</li>
    <li><strong>Category grouping:</strong> Toggle entire categories on/off using category checkboxes in the table</li>
    <li><strong>Reset functionality:</strong> Restore all removed segments with the reset button</li>
    <li><strong>Color coding:</strong>
        <ul>
            <li>Value mode: Green for positive values, Red for negative values</li>
            <li>Category mode: Different color for each category from the color palette</li>
            <li>Total bar: Always black regardless of color mode</li>
        </ul>
    </li>
    <li><strong>Filtering:</strong> Single-select filters to switch between datasets</li>
    <li><strong>Customization:</strong>
        <ul>
            <li><code>item_col</code>: Column containing item labels for the x-axis</li>
            <li><code>color_cols</code>: Column(s) for grouping items by category</li>
            <li><code>value_col</code>: Column containing numeric values</li>
            <li><code>show_table</code>: Toggle calculation table display</li>
            <li><code>show_totals</code>: Add a total bar at the end (toggleable from table)</li>
        </ul>
    </li>
</ul>

<h3>Use Cases</h3>
<ul>
    <li>Financial analysis (P&L, cash flow, variance analysis)</li>
    <li>Budget vs actual comparisons</li>
    <li>Sequential process flows showing cumulative impact</li>
    <li>Inventory or population change analysis</li>
    <li>Revenue bridge analysis</li>
    <li>Cost breakdown and attribution</li>
</ul>

<h3>Tips</h3>
<ul>
    <li>Click on any bar or table row to see the impact of removing that component</li>
    <li>Click category checkboxes to toggle entire groups on/off</li>
    <li>Use the Color By dropdown to switch between value-based and category-based coloring</li>
    <li>Use the Reset button to quickly restore all segments</li>
    <li>Combine with filters to compare waterfalls across different dimensions</li>
    <li>Set <code>show_totals=false</code> when your last item is already a total</li>
    <li>The total bar can be toggled on/off by clicking its row in the table</li>
</ul>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.4.2.</small></p>
</body>
</html>
