<!DOCTYPE html>
<html>
<head>
    <title>AreaChart Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\\d{4}-\\d{2}-\\d{2}\$/;  // YYYY-MM-DD
    var datetimePattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;  // YYYY-MM-DDTHH:MM:SS

    // Check first row to identify date columns
    var firstRow = data[0];
    var dateColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                }
            }
        }
    }

    // If no date columns found, return data unchanged
    if (dateColumns.length === 0) return data;

    // Convert date strings to Date objects in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Date'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['Region'];
    const COLOR_MAPS = {'Region': {'East': '#00cc96', 'West': '#ab63fa', 'North': '#636efa', 'South': '#EF553B'}};
    const GROUP_ORDER = {'Region': ['North', 'South', 'East', 'West']};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'Region';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_stacked_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stacked_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stacked_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_stacked_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_stacked_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stacked_area');
        const facet2Select = document.getElementById('facet2_select_stacked_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_by_region').then(function(data) {
        allData = data;
        window.updatePlot_stacked_area();
    }).catch(function(error) {
        console.error('Error loading data for chart stacked_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const COLOR_COLS = ['Product'];
    const COLOR_MAPS = {'Product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product B': '#EF553B'}};
    const GROUP_ORDER = {'Product': ['Product A', 'Product B', 'Product C']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_COLOR_COL = 'Product';
    const FILL_OPACITY = 0.4;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_unstacked_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_unstacked_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_unstacked_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_unstacked_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_unstacked_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'unstack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_unstacked_area');
        const facet2Select = document.getElementById('facet2_select_unstacked_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('product_values').then(function(data) {
        allData = data;
        window.updatePlot_unstacked_area();
    }).catch(function(error) {
        console.error('Error loading data for chart unstacked_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['MarketShare'];
    const COLOR_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Category D': '#ab63fa', 'Category C': '#00cc96', 'Category B': '#EF553B', 'Category A': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Category A', 'Category B', 'Category C', 'Category D']};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'MarketShare';
    const DEFAULT_COLOR_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_normalized_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_normalized_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_normalized_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_normalized_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_normalized_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'normalised_stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_normalized_area');
        const facet2Select = document.getElementById('facet2_select_normalized_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('market_share').then(function(data) {
        allData = data;
        window.updatePlot_normalized_area();
    }).catch(function(error) {
        console.error('Error loading data for chart normalized_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Department'];
    const Y_COLS = ['Headcount'];
    const COLOR_COLS = ['Team'];
    const COLOR_MAPS = {'Team': {'Team C': '#00cc96', 'Team B': '#EF553B', 'Team A': '#636efa'}};
    const GROUP_ORDER = {'Team': ['Team A', 'Team B', 'Team C']};
    const DEFAULT_X_COL = 'Department';
    const DEFAULT_Y_COL = 'Headcount';
    const DEFAULT_COLOR_COL = 'Team';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_discrete_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_discrete_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_discrete_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_discrete_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_discrete_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_discrete_area');
        const facet2Select = document.getElementById('facet2_select_discrete_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('headcount_data').then(function(data) {
        allData = data;
        window.updatePlot_discrete_area();
    }).catch(function(error) {
        console.error('Error loading data for chart discrete_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['Year', 'Region'];
    const X_COLS = ['Date'];
    const Y_COLS = ['Revenue'];
    const COLOR_COLS = ['Channel'];
    const COLOR_MAPS = {'Channel': {'Retail': '#EF553B', 'Online': '#636efa', 'Wholesale': '#00cc96'}};
    const GROUP_ORDER = {'Channel': ['Online', 'Retail', 'Wholesale']};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_COLOR_COL = 'Channel';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_filtered_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_filtered_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_filtered_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_filtered_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_filtered_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_filtered_area');
        const facet2Select = document.getElementById('facet2_select_filtered_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('channel_revenue').then(function(data) {
        allData = data;
        window.updatePlot_filtered_area();
    }).catch(function(error) {
        console.error('Error loading data for chart filtered_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Week'];
    const Y_COLS = ['Value'];
    const COLOR_COLS = ['Source'];
    const COLOR_MAPS = {'Source': {'Source 1': '#636efa', 'Source 2': '#EF553B', 'Source 3': '#00cc96'}};
    const GROUP_ORDER = {'Source': ['Source 1', 'Source 2', 'Source 3']};
    const DEFAULT_X_COL = 'Week';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_COLOR_COL = 'Source';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_facet_wrap_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_wrap_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_wrap_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_facet_wrap_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_facet_wrap_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_wrap_area');
        const facet2Select = document.getElementById('facet2_select_facet_wrap_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('metrics_data').then(function(data) {
        allData = data;
        window.updatePlot_facet_wrap_area();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_wrap_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const COLOR_COLS = ['Segment'];
    const COLOR_MAPS = {'Segment': {'Segment 1': '#636efa', 'Segment 2': '#EF553B'}};
    const GROUP_ORDER = {'Segment': ['Segment 1', 'Segment 2']};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_COLOR_COL = 'Segment';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_facet_grid_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_grid_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_grid_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_facet_grid_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_facet_grid_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_grid_area');
        const facet2Select = document.getElementById('facet2_select_facet_grid_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('grid_sales').then(function(data) {
        allData = data;
        window.updatePlot_facet_grid_area();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_grid_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Quarter'];
    const Y_COLS = ['Revenue', 'Profit', 'Growth'];
    const COLOR_COLS = ['Industry', 'CompanySize'];
    const COLOR_MAPS = {'Industry': {'Finance': '#EF553B', 'Healthcare': '#00cc96', 'Tech': '#636efa'}, 'CompanySize': {'Medium': '#EF553B', 'Small': '#636efa', 'Large': '#00cc96'}};
    const GROUP_ORDER = {'Industry': ['Tech', 'Finance', 'Healthcare'], 'CompanySize': ['Small', 'Medium', 'Large']};
    const DEFAULT_X_COL = 'Quarter';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_COLOR_COL = 'Industry';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_dynamic_grouping = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_dynamic_grouping');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_dynamic_grouping');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_dynamic_grouping');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_dynamic_grouping');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_dynamic_grouping');
        const facet2Select = document.getElementById('facet2_select_dynamic_grouping');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('business_metrics').then(function(data) {
        allData = data;
        window.updatePlot_dynamic_grouping();
    }).catch(function(error) {
        console.error('Error loading data for chart dynamic_grouping:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const COLOR_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_COLOR_COL = 'Category';
    const FILL_OPACITY = 0.5;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_unstack_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_unstack_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_unstack_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_unstack_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_unstack_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'unstack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_unstack_mode');
        const facet2Select = document.getElementById('facet2_select_unstack_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_unstack_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart unstack_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const COLOR_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_COLOR_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_stack_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stack_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stack_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_stack_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_stack_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stack_mode');
        const facet2Select = document.getElementById('facet2_select_stack_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_stack_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart stack_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const COLOR_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_COLOR_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_normalized_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_normalized_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_normalized_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_normalized_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_normalized_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'normalised_stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_normalized_mode');
        const facet2Select = document.getElementById('facet2_select_normalized_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_normalized_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart normalized_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Quarter', 'Month', 'Week'];
    const Y_COLS = ['Revenue', 'Units'];
    const COLOR_COLS = ['Region'];
    const COLOR_MAPS = {'Region': {'East': '#00cc96', 'North': '#636efa', 'South': '#EF553B'}};
    const GROUP_ORDER = {'Region': ['North', 'South', 'East']};
    const DEFAULT_X_COL = 'Quarter';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_COLOR_COL = 'Region';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_dynamic_x_axis = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_dynamic_x_axis');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_dynamic_x_axis');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_dynamic_x_axis');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_COLOR_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_dynamic_x_axis');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_dynamic_x_axis');
        const facet2Select = document.getElementById('facet2_select_dynamic_x_axis');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('dynamic_x_axis', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('dynamic_x_axis', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('dynamic_x_axis', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_data_x').then(function(data) {
        allData = data;
        window.updatePlot_dynamic_x_axis();
    }).catch(function(error) {
        console.error('Error loading data for chart dynamic_x_axis:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="channel_revenue" data-format="csv_embedded" data-src="">
Date,Revenue,Channel,Region,Year
2024-01-01,128898.19162286987,Online,North,2022
2024-01-08,110260.82341098026,Online,North,2022
2024-01-15,99653.16595313889,Online,North,2022
2024-01-22,84194.8279487777,Online,North,2022
2024-01-29,100916.47483925207,Online,North,2022
2024-02-05,130858.65683425186,Online,North,2022
2024-02-12,102946.42618658845,Online,North,2022
2024-02-19,108910.5703790076,Online,North,2022
2024-02-26,139189.19812835797,Online,North,2022
2024-03-04,142613.5676150997,Online,North,2022
2024-03-11,113087.21781377732,Online,North,2022
2024-03-18,151149.69492252535,Online,North,2022
2024-03-25,103579.43245862695,Online,North,2022
2024-04-01,76183.19574236724,Online,North,2022
2024-04-08,113027.9508161264,Online,North,2022
2024-04-15,128213.91813633243,Online,North,2022
2024-04-22,116493.84014612358,Online,North,2022
2024-04-29,94004.96282162977,Online,North,2022
2024-05-06,116276.3410886012,Online,North,2022
2024-05-13,125365.84859467825,Online,North,2022
2024-05-20,147076.2137188966,Online,North,2022
2024-05-27,120663.46069340913,Online,North,2022
2024-06-03,104236.36162087577,Online,North,2022
2024-06-10,120202.55302199081,Online,North,2022
2024-06-17,88191.18593116212,Online,North,2022
2024-06-24,89656.58635275648,Online,North,2022
2024-07-01,124755.80020191663,Online,North,2022
2024-07-08,164900.0790833347,Online,North,2022
2024-07-15,113713.52082727064,Online,North,2022
2024-07-22,104562.00771354572,Online,North,2022
2024-07-29,152557.9309379274,Online,North,2022
2024-08-05,138228.58687012942,Online,North,2022
2024-08-12,98633.64763162189,Online,North,2022
2024-08-19,147324.34789160185,Online,North,2022
2024-08-26,140100.35082120216,Online,North,2022
2024-09-02,151945.6280425372,Online,North,2022
2024-09-09,121203.7162593896,Online,North,2022
2024-09-16,175799.26899411768,Online,North,2022
2024-09-23,149181.05241749412,Online,North,2022
2024-09-30,154555.98535889314,Online,North,2022
2024-10-07,127052.35890988441,Online,North,2022
2024-10-14,116504.16605111567,Online,North,2022
2024-10-21,136608.26840539096,Online,North,2022
2024-10-28,160242.71596078007,Online,North,2022
2024-11-04,141397.84358650207,Online,North,2022
2024-11-11,110281.4507629603,Online,North,2022
2024-11-18,113553.56088388019,Online,North,2022
2024-11-25,141331.2358890641,Online,North,2022
2024-12-02,131444.95225548994,Online,North,2022
2024-12-09,142653.82831282317,Online,North,2022
2024-12-16,133921.5897562118,Online,North,2022
2024-12-23,141303.77380954206,Online,North,2022
2024-12-30,96235.09116529465,Online,North,2022
2024-01-01,88572.14723587601,Online,South,2022
2024-01-08,97096.47865284377,Online,South,2022
2024-01-15,101299.30037705626,Online,South,2022
2024-01-22,124565.62225854925,Online,South,2022
2024-01-29,122831.17454492515,Online,South,2022
2024-02-05,101688.6377654569,Online,South,2022
2024-02-12,148036.14525153965,Online,South,2022
2024-02-19,139287.9401544311,Online,South,2022
2024-02-26,84643.47683849299,Online,South,2022
2024-03-04,110915.21496940115,Online,South,2022
2024-03-11,119924.48350350572,Online,South,2022
2024-03-18,125426.54828763077,Online,South,2022
2024-03-25,101638.74863805278,Online,South,2022
2024-04-01,104373.03718415168,Online,South,2022
2024-04-08,113877.13858356937,Online,South,2022
2024-04-15,123022.99358980847,Online,South,2022
2024-04-22,105208.1317017453,Online,South,2022
2024-04-29,80832.69720100529,Online,South,2022
2024-05-06,156916.81726542802,Online,South,2022
2024-05-13,103972.40529486354,Online,South,2022
2024-05-20,131327.64946652835,Online,South,2022
2024-05-27,111804.58078924974,Online,South,2022
2024-06-03,121505.55817822862,Online,South,2022
2024-06-10,109195.65038601584,Online,South,2022
2024-06-17,139747.9540573276,Online,South,2022
2024-06-24,122733.39734768853,Online,South,2022
2024-07-01,150996.45528233692,Online,South,2022
2024-07-08,126429.42914191651,Online,South,2022
2024-07-15,120757.30122164363,Online,South,2022
2024-07-22,145134.20371869818,Online,South,2022
2024-07-29,147382.78566007217,Online,South,2022
2024-08-05,128252.01520449364,Online,South,2022
2024-08-12,173964.65594409587,Online,South,2022
2024-08-19,166592.5789950119,Online,South,2022
2024-08-26,105166.71125434636,Online,South,2022
2024-09-02,152253.67006443028,Online,South,2022
2024-09-09,134687.6232499816,Online,South,2022
2024-09-16,126110.28110706201,Online,South,2022
2024-09-23,152311.76742881164,Online,South,2022
2024-09-30,155576.48189152824,Online,South,2022
2024-10-07,147937.657969117,Online,South,2022
2024-10-14,133652.58320762595,Online,South,2022
2024-10-21,162433.6906839506,Online,South,2022
2024-10-28,159980.8689571573,Online,South,2022
2024-11-04,126312.79024282609,Online,South,2022
2024-11-11,135775.223424101,Online,South,2022
2024-11-18,150002.88339853077,Online,South,2022
2024-11-25,144504.46764137354,Online,South,2022
2024-12-02,161782.19823926286,Online,South,2022
2024-12-09,157341.2462640274,Online,South,2022
2024-12-16,133913.04043576133,Online,South,2022
2024-12-23,168295.0829613138,Online,South,2022
2024-12-30,105719.69093336973,Online,South,2022
2024-01-01,101568.26991921617,Retail,North,2022
2024-01-08,127679.33852677801,Retail,North,2022
2024-01-15,134603.47187704567,Retail,North,2022
2024-01-22,122298.33009499022,Retail,North,2022
2024-01-29,81971.67109473277,Retail,North,2022
2024-02-05,83099.38433878416,Retail,North,2022
2024-02-12,117016.19471682527,Retail,North,2022
2024-02-19,118011.24520564915,Retail,North,2022
2024-02-26,79908.60483362142,Retail,North,2022
2024-03-04,131152.4194361244,Retail,North,2022
2024-03-11,125840.36766999733,Retail,North,2022
2024-03-18,105108.91722023202,Retail,North,2022
2024-03-25,121312.2463505244,Retail,North,2022
2024-04-01,74189.580638118,Retail,North,2022
2024-04-08,95511.65914084435,Retail,North,2022
2024-04-15,102148.07297320456,Retail,North,2022
2024-04-22,110316.68462684628,Retail,North,2022
2024-04-29,106691.05765747238,Retail,North,2022
2024-05-06,135695.7322162341,Retail,North,2022
2024-05-13,104681.91759677637,Retail,North,2022
2024-05-20,130197.93877447667,Retail,North,2022
2024-05-27,140577.90577943844,Retail,North,2022
2024-06-03,160719.92806495354,Retail,North,2022
2024-06-10,107484.52228921326,Retail,North,2022
2024-06-17,98206.34655724335,Retail,North,2022
2024-06-24,148055.50192874554,Retail,North,2022
2024-07-01,123180.7028440897,Retail,North,2022
2024-07-08,139826.954179465,Retail,North,2022
2024-07-15,124906.59484585462,Retail,North,2022
2024-07-22,108027.59167983981,Retail,North,2022
2024-07-29,130565.81422820911,Retail,North,2022
2024-08-05,134336.50816633756,Retail,North,2022
2024-08-12,108264.85494775287,Retail,North,2022
2024-08-19,125465.85738099505,Retail,North,2022
2024-08-26,159674.0701919233,Retail,North,2022
2024-09-02,150930.61135805468,Retail,North,2022
2024-09-09,120602.37002332596,Retail,North,2022
2024-09-16,149178.65483700554,Retail,North,2022
2024-09-23,161974.33673815816,Retail,North,2022
2024-09-30,132858.63965900673,Retail,North,2022
2024-10-07,135397.14570533176,Retail,North,2022
2024-10-14,163299.67685387173,Retail,North,2022
2024-10-21,132230.04706974933,Retail,North,2022
2024-10-28,141004.817746941,Retail,North,2022
2024-11-04,117083.10725214591,Retail,North,2022
2024-11-11,141530.13948293473,Retail,North,2022
2024-11-18,147963.07244683645,Retail,North,2022
2024-11-25,143792.46456703945,Retail,North,2022
2024-12-02,142720.0142042199,Retail,North,2022
2024-12-09,158251.0342636638,Retail,North,2022
2024-12-16,139336.75727227516,Retail,North,2022
2024-12-23,154326.26409559188,Retail,North,2022
2024-12-30,90418.55702682362,Retail,North,2022
2024-01-01,108394.02768583178,Retail,South,2022
2024-01-08,118425.5798239019,Retail,South,2022
2024-01-15,108513.68306006555,Retail,South,2022
2024-01-22,104848.41462671633,Retail,South,2022
2024-01-29,110199.5212348672,Retail,South,2022
2024-02-05,105943.25929920815,Retail,South,2022
2024-02-12,121259.1927083958,Retail,South,2022
2024-02-19,124487.76165909445,Retail,South,2022
2024-02-26,75747.84729962511,Retail,South,2022
2024-03-04,111454.90943941876,Retail,South,2022
2024-03-11,105917.36436398374,Retail,South,2022
2024-03-18,120372.56240355878,Retail,South,2022
2024-03-25,115255.59952088221,Retail,South,2022
2024-04-01,121381.22198794328,Retail,South,2022
2024-04-08,113365.9334903747,Retail,South,2022
2024-04-15,120720.81233070078,Retail,South,2022
2024-04-22,156327.4803982224,Retail,South,2022
2024-04-29,106303.59618105058,Retail,South,2022
2024-05-06,125952.37723707553,Retail,South,2022
2024-05-13,113040.96239519285,Retail,South,2022
2024-05-20,84613.72941082803,Retail,South,2022
2024-05-27,123857.57562227387,Retail,South,2022
2024-06-03,83400.45329086683,Retail,South,2022
2024-06-10,82424.31792123234,Retail,South,2022
2024-06-17,142184.88640974628,Retail,South,2022
2024-06-24,107939.57153925541,Retail,South,2022
2024-07-01,122482.83517914641,Retail,South,2022
2024-07-08,127077.38896439305,Retail,South,2022
2024-07-15,98051.10881537515,Retail,South,2022
2024-07-22,173584.42966171043,Retail,South,2022
2024-07-29,100980.9760501988,Retail,South,2022
2024-08-05,103930.62251626186,Retail,South,2022
2024-08-12,140371.31290356792,Retail,South,2022
2024-08-19,121693.27291178619,Retail,South,2022
2024-08-26,156984.6348270389,Retail,South,2022
2024-09-02,142065.70266916172,Retail,South,2022
2024-09-09,159373.6839714771,Retail,South,2022
2024-09-16,141560.44751107457,Retail,South,2022
2024-09-23,158878.5147145568,Retail,South,2022
2024-09-30,115857.4533179765,Retail,South,2022
2024-10-07,107319.19788984698,Retail,South,2022
2024-10-14,127929.85581728566,Retail,South,2022
2024-10-21,131990.5669936533,Retail,South,2022
2024-10-28,165909.37843081867,Retail,South,2022
2024-11-04,136130.52858077688,Retail,South,2022
2024-11-11,147051.92157903546,Retail,South,2022
2024-11-18,147895.70298078406,Retail,South,2022
2024-11-25,137600.4041520927,Retail,South,2022
2024-12-02,112508.72625164014,Retail,South,2022
2024-12-09,191426.13720418862,Retail,South,2022
2024-12-16,179325.43590352876,Retail,South,2022
2024-12-23,135764.2897720292,Retail,South,2022
2024-12-30,80766.66318730773,Retail,South,2022
2024-01-01,109426.20700249048,Wholesale,North,2022
2024-01-08,105464.51577235949,Wholesale,North,2022
2024-01-15,61795.028674905574,Wholesale,North,2022
2024-01-22,107227.791870598,Wholesale,North,2022
2024-01-29,30737.566994590117,Wholesale,North,2022
2024-02-05,91773.72426977604,Wholesale,North,2022
2024-02-12,130869.26084385585,Wholesale,North,2022
2024-02-19,117745.55694213271,Wholesale,North,2022
2024-02-26,106632.82778737268,Wholesale,North,2022
2024-03-04,108664.11311619935,Wholesale,North,2022
2024-03-11,105732.14623999456,Wholesale,North,2022
2024-03-18,61000.56206066298,Wholesale,North,2022
2024-03-25,126747.4483947288,Wholesale,North,2022
2024-04-01,122516.32485849735,Wholesale,North,2022
2024-04-08,100163.47535882771,Wholesale,North,2022
2024-04-15,130417.42032096894,Wholesale,North,2022
2024-04-22,93322.1879158623,Wholesale,North,2022
2024-04-29,118588.11907611998,Wholesale,North,2022
2024-05-06,118435.35789512536,Wholesale,North,2022
2024-05-13,157730.10863178852,Wholesale,North,2022
2024-05-20,111846.99719745808,Wholesale,North,2022
2024-05-27,97130.84154983233,Wholesale,North,2022
2024-06-03,118580.22955021646,Wholesale,North,2022
2024-06-10,156241.5517207175,Wholesale,North,2022
2024-06-17,110180.1631046765,Wholesale,North,2022
2024-06-24,135550.79298667892,Wholesale,North,2022
2024-07-01,159002.74254369846,Wholesale,North,2022
2024-07-08,119282.2716444201,Wholesale,North,2022
2024-07-15,135489.10702592216,Wholesale,North,2022
2024-07-22,128523.15015293879,Wholesale,North,2022
2024-07-29,157008.2760438279,Wholesale,North,2022
2024-08-05,137284.0211043079,Wholesale,North,2022
2024-08-12,142530.802537332,Wholesale,North,2022
2024-08-19,122273.36382830367,Wholesale,North,2022
2024-08-26,129403.61431535074,Wholesale,North,2022
2024-09-02,144698.39284096216,Wholesale,North,2022
2024-09-09,125905.78098570721,Wholesale,North,2022
2024-09-16,146080.17490934656,Wholesale,North,2022
2024-09-23,151451.64592692975,Wholesale,North,2022
2024-09-30,187567.29187461664,Wholesale,North,2022
2024-10-07,146880.14529826812,Wholesale,North,2022
2024-10-14,152943.0266774342,Wholesale,North,2022
2024-10-21,172917.8343967431,Wholesale,North,2022
2024-10-28,152402.80249415516,Wholesale,North,2022
2024-11-04,144936.8364733578,Wholesale,North,2022
2024-11-11,127299.90744618593,Wholesale,North,2022
2024-11-18,151450.8906514577,Wholesale,North,2022
2024-11-25,151661.17035746115,Wholesale,North,2022
2024-12-02,165936.43292681494,Wholesale,North,2022
2024-12-09,169666.59523336223,Wholesale,North,2022
2024-12-16,153460.30825178145,Wholesale,North,2022
2024-12-23,117032.2478711462,Wholesale,North,2022
2024-12-30,97159.59944150479,Wholesale,North,2022
2024-01-01,79038.34787918154,Wholesale,South,2022
2024-01-08,74109.61611675116,Wholesale,South,2022
2024-01-15,80471.26837469584,Wholesale,South,2022
2024-01-22,99458.04784223718,Wholesale,South,2022
2024-01-29,107520.33488161063,Wholesale,South,2022
2024-02-05,99224.48415608272,Wholesale,South,2022
2024-02-12,107634.15159175736,Wholesale,South,2022
2024-02-19,95327.42861279512,Wholesale,South,2022
2024-02-26,113257.85983663613,Wholesale,South,2022
2024-03-04,113846.43297161697,Wholesale,South,2022
2024-03-11,130632.31943137525,Wholesale,South,2022
2024-03-18,132104.07425431738,Wholesale,South,2022
2024-03-25,139596.3318945273,Wholesale,South,2022
2024-04-01,121016.77426492581,Wholesale,South,2022
2024-04-08,128979.2483938458,Wholesale,South,2022
2024-04-15,122682.93062064082,Wholesale,South,2022
2024-04-22,147673.11759748874,Wholesale,South,2022
2024-04-29,115981.13640528443,Wholesale,South,2022
2024-05-06,141388.3614951037,Wholesale,South,2022
2024-05-13,109092.66874302222,Wholesale,South,2022
2024-05-20,107898.46092220972,Wholesale,South,2022
2024-05-27,114117.44359592565,Wholesale,South,2022
2024-06-03,113970.44072071643,Wholesale,South,2022
2024-06-10,106730.56195930488,Wholesale,South,2022
2024-06-17,103834.43659702415,Wholesale,South,2022
2024-06-24,146324.7130722063,Wholesale,South,2022
2024-07-01,169301.54264693303,Wholesale,South,2022
2024-07-08,149078.4438363262,Wholesale,South,2022
2024-07-15,158455.99437630927,Wholesale,South,2022
2024-07-22,177236.57440198923,Wholesale,South,2022
2024-07-29,138527.4288693334,Wholesale,South,2022
2024-08-05,152909.0509634837,Wholesale,South,2022
2024-08-12,163725.2116617635,Wholesale,South,2022
2024-08-19,133272.56116005537,Wholesale,South,2022
2024-08-26,132926.29236158475,Wholesale,South,2022
2024-09-02,153552.39726224414,Wholesale,South,2022
2024-09-09,140092.325943956,Wholesale,South,2022
2024-09-16,115850.34207145545,Wholesale,South,2022
2024-09-23,157361.13996177856,Wholesale,South,2022
2024-09-30,179785.87988566386,Wholesale,South,2022
2024-10-07,117112.37479836938,Wholesale,South,2022
2024-10-14,154615.3882821196,Wholesale,South,2022
2024-10-21,143180.71942915913,Wholesale,South,2022
2024-10-28,125040.75040068214,Wholesale,South,2022
2024-11-04,153032.16276329925,Wholesale,South,2022
2024-11-11,143156.17799517786,Wholesale,South,2022
2024-11-18,172311.3980111871,Wholesale,South,2022
2024-11-25,143673.03358320112,Wholesale,South,2022
2024-12-02,157197.37386418396,Wholesale,South,2022
2024-12-09,129909.68756960616,Wholesale,South,2022
2024-12-16,145458.1788350694,Wholesale,South,2022
2024-12-23,162589.38119885552,Wholesale,South,2022
2024-12-30,91879.18452063875,Wholesale,South,2022
2024-01-01,148648.37953506556,Online,North,2023
2024-01-08,87686.68074189452,Online,North,2023
2024-01-15,143657.00195576967,Online,North,2023
2024-01-22,90469.27530562968,Online,North,2023
2024-01-29,104433.20659673157,Online,North,2023
2024-02-05,101360.75134737346,Online,North,2023
2024-02-12,176838.62215566548,Online,North,2023
2024-02-19,72354.61583644158,Online,North,2023
2024-02-26,101150.7080541331,Online,North,2023
2024-03-04,103575.8552709402,Online,North,2023
2024-03-11,126642.55377634818,Online,North,2023
2024-03-18,99417.59536599186,Online,North,2023
2024-03-25,121674.45447369575,Online,North,2023
2024-04-01,116374.81199536753,Online,North,2023
2024-04-08,134929.2572110648,Online,North,2023
2024-04-15,125175.05288854046,Online,North,2023
2024-04-22,109286.7967543544,Online,North,2023
2024-04-29,122752.12848096045,Online,North,2023
2024-05-06,83382.8198759014,Online,North,2023
2024-05-13,138601.79032471846,Online,North,2023
2024-05-20,126789.4477383526,Online,North,2023
2024-05-27,125949.88022073523,Online,North,2023
2024-06-03,134451.04067196522,Online,North,2023
2024-06-10,141589.45103463752,Online,North,2023
2024-06-17,130516.27803771524,Online,North,2023
2024-06-24,148892.8127711587,Online,North,2023
2024-07-01,114954.8052401911,Online,North,2023
2024-07-08,118696.09865161624,Online,North,2023
2024-07-15,142695.73642548488,Online,North,2023
2024-07-22,146635.9068371054,Online,North,2023
2024-07-29,147581.2055988658,Online,North,2023
2024-08-05,142896.8174458965,Online,North,2023
2024-08-12,168396.63527703512,Online,North,2023
2024-08-19,131281.94314627344,Online,North,2023
2024-08-26,123926.50462157089,Online,North,2023
2024-09-02,129549.54125409521,Online,North,2023
2024-09-09,109146.3078922694,Online,North,2023
2024-09-16,160497.102048604,Online,North,2023
2024-09-23,170945.3503014014,Online,North,2023
2024-09-30,103503.19089777661,Online,North,2023
2024-10-07,142450.24092766733,Online,North,2023
2024-10-14,131421.47397120393,Online,North,2023
2024-10-21,138412.50719679802,Online,North,2023
2024-10-28,158792.86533422777,Online,North,2023
2024-11-04,99418.5776568276,Online,North,2023
2024-11-11,134156.7093906952,Online,North,2023
2024-11-18,149192.17314642615,Online,North,2023
2024-11-25,143803.53135998,Online,North,2023
2024-12-02,165183.5925578688,Online,North,2023
2024-12-09,179343.71738733357,Online,North,2023
2024-12-16,141502.04258049332,Online,North,2023
2024-12-23,157250.7911764932,Online,North,2023
2024-12-30,120145.93507172514,Online,North,2023
2024-01-01,134835.73390054423,Online,South,2023
2024-01-08,134909.10404521553,Online,South,2023
2024-01-15,100258.78473954354,Online,South,2023
2024-01-22,125877.77307357716,Online,South,2023
2024-01-29,117609.02528690503,Online,South,2023
2024-02-05,120611.74151580094,Online,South,2023
2024-02-12,130699.90984325962,Online,South,2023
2024-02-19,79674.0354008885,Online,South,2023
2024-02-26,105991.91621502313,Online,South,2023
2024-03-04,112604.92321816312,Online,South,2023
2024-03-11,102712.4360839032,Online,South,2023
2024-03-18,128609.71246423086,Online,South,2023
2024-03-25,144222.64225127033,Online,South,2023
2024-04-01,106744.66163531254,Online,South,2023
2024-04-08,87195.6227975083,Online,South,2023
2024-04-15,136030.75763407024,Online,South,2023
2024-04-22,123327.44004496658,Online,South,2023
2024-04-29,115354.79020362858,Online,South,2023
2024-05-06,147413.78518212997,Online,South,2023
2024-05-13,120267.14910052682,Online,South,2023
2024-05-20,114798.74252221716,Online,South,2023
2024-05-27,112475.41115958524,Online,South,2023
2024-06-03,137323.5659662243,Online,South,2023
2024-06-10,134717.68970393704,Online,South,2023
2024-06-17,120884.4515416036,Online,South,2023
2024-06-24,126965.72354713515,Online,South,2023
2024-07-01,87170.82585452433,Online,South,2023
2024-07-08,174890.16405322772,Online,South,2023
2024-07-15,155538.1926936989,Online,South,2023
2024-07-22,130138.59439096376,Online,South,2023
2024-07-29,117235.25004810638,Online,South,2023
2024-08-05,135473.19116214407,Online,South,2023
2024-08-12,142209.3261738836,Online,South,2023
2024-08-19,84126.48696557636,Online,South,2023
2024-08-26,145983.09503364732,Online,South,2023
2024-09-02,147511.08014735166,Online,South,2023
2024-09-09,133044.6235609226,Online,South,2023
2024-09-16,128242.39810132007,Online,South,2023
2024-09-23,149674.95494100748,Online,South,2023
2024-09-30,183472.73994698346,Online,South,2023
2024-10-07,131323.1703064072,Online,South,2023
2024-10-14,161954.02716313192,Online,South,2023
2024-10-21,172211.17725261106,Online,South,2023
2024-10-28,147862.74414627874,Online,South,2023
2024-11-04,181873.2818517491,Online,South,2023
2024-11-11,149346.31655383704,Online,South,2023
2024-11-18,155071.9016821574,Online,South,2023
2024-11-25,149148.61528233645,Online,South,2023
2024-12-02,142853.83920125366,Online,South,2023
2024-12-09,144193.34922260823,Online,South,2023
2024-12-16,133197.189038137,Online,South,2023
2024-12-23,155172.8216655309,Online,South,2023
2024-12-30,102537.14672689697,Online,South,2023
2024-01-01,138639.19843596555,Retail,North,2023
2024-01-08,63522.395226465036,Retail,North,2023
2024-01-15,99527.73934010415,Retail,North,2023
2024-01-22,108538.08483191353,Retail,North,2023
2024-01-29,77699.8367568753,Retail,North,2023
2024-02-05,99009.46833460961,Retail,North,2023
2024-02-12,123287.26423548177,Retail,North,2023
2024-02-19,110831.61653029145,Retail,North,2023
2024-02-26,75740.25240279747,Retail,North,2023
2024-03-04,90784.93933998853,Retail,North,2023
2024-03-11,105992.33555633,Retail,North,2023
2024-03-18,107592.38921501511,Retail,North,2023
2024-03-25,91441.12344771874,Retail,North,2023
2024-04-01,110291.17492668437,Retail,North,2023
2024-04-08,101292.23690702388,Retail,North,2023
2024-04-15,126184.35406783171,Retail,North,2023
2024-04-22,110390.2598594899,Retail,North,2023
2024-04-29,96224.8199258556,Retail,North,2023
2024-05-06,120489.56292904139,Retail,North,2023
2024-05-13,112585.11268042403,Retail,North,2023
2024-05-20,146082.42187480253,Retail,North,2023
2024-05-27,131819.10235728443,Retail,North,2023
2024-06-03,62237.51885889814,Retail,North,2023
2024-06-10,130188.077507842,Retail,North,2023
2024-06-17,134806.70852149848,Retail,North,2023
2024-06-24,108053.26339379072,Retail,North,2023
2024-07-01,142078.26246374345,Retail,North,2023
2024-07-08,139807.6874495648,Retail,North,2023
2024-07-15,113828.13258922733,Retail,North,2023
2024-07-22,113119.0184713969,Retail,North,2023
2024-07-29,120711.50091391994,Retail,North,2023
2024-08-05,119448.21187755968,Retail,North,2023
2024-08-12,106348.2886183956,Retail,North,2023
2024-08-19,136799.9837886814,Retail,North,2023
2024-08-26,126585.1112437669,Retail,North,2023
2024-09-02,175377.07273391023,Retail,North,2023
2024-09-09,164007.81995131925,Retail,North,2023
2024-09-16,144304.3926312288,Retail,North,2023
2024-09-23,149571.0845827387,Retail,North,2023
2024-09-30,127656.0704353241,Retail,North,2023
2024-10-07,171114.08534386716,Retail,North,2023
2024-10-14,163829.4521744076,Retail,North,2023
2024-10-21,142178.27475869862,Retail,North,2023
2024-10-28,149950.923321892,Retail,North,2023
2024-11-04,138443.0054765135,Retail,North,2023
2024-11-11,120751.1009147565,Retail,North,2023
2024-11-18,131385.89846181116,Retail,North,2023
2024-11-25,106329.47072618105,Retail,North,2023
2024-12-02,168269.0799734101,Retail,North,2023
2024-12-09,157163.05475308123,Retail,North,2023
2024-12-16,145907.9148255295,Retail,North,2023
2024-12-23,163008.43833129812,Retail,North,2023
2024-12-30,94357.25766679911,Retail,North,2023
2024-01-01,77612.5217476479,Retail,South,2023
2024-01-08,105399.7025937223,Retail,South,2023
2024-01-15,128216.88444244303,Retail,South,2023
2024-01-22,102775.04811066571,Retail,South,2023
2024-01-29,110742.34624589623,Retail,South,2023
2024-02-05,62832.74189611766,Retail,South,2023
2024-02-12,117527.66081319598,Retail,South,2023
2024-02-19,100594.75672923998,Retail,South,2023
2024-02-26,118376.43757393213,Retail,South,2023
2024-03-04,130854.2108504535,Retail,South,2023
2024-03-11,126715.13622522539,Retail,South,2023
2024-03-18,139478.89747930653,Retail,South,2023
2024-03-25,116650.85162461532,Retail,South,2023
2024-04-01,84035.61926572755,Retail,South,2023
2024-04-08,129738.69709077857,Retail,South,2023
2024-04-15,149679.7404739149,Retail,South,2023
2024-04-22,93714.60224966158,Retail,South,2023
2024-04-29,131799.2382956007,Retail,South,2023
2024-05-06,115931.20562999218,Retail,South,2023
2024-05-13,116578.840086345,Retail,South,2023
2024-05-20,95510.35593588866,Retail,South,2023
2024-05-27,99376.496224345,Retail,South,2023
2024-06-03,93935.27118004176,Retail,South,2023
2024-06-10,108050.17599562724,Retail,South,2023
2024-06-17,143343.97292374697,Retail,South,2023
2024-06-24,129401.14643070621,Retail,South,2023
2024-07-01,109837.22783499488,Retail,South,2023
2024-07-08,130393.7343736846,Retail,South,2023
2024-07-15,117746.54488633624,Retail,South,2023
2024-07-22,128999.29659054583,Retail,South,2023
2024-07-29,139396.9836160508,Retail,South,2023
2024-08-05,149420.21163650946,Retail,South,2023
2024-08-12,130945.12042464901,Retail,South,2023
2024-08-19,115552.64698742647,Retail,South,2023
2024-08-26,155869.2729342366,Retail,South,2023
2024-09-02,148198.63734220783,Retail,South,2023
2024-09-09,189891.26731899704,Retail,South,2023
2024-09-16,182767.576961742,Retail,South,2023
2024-09-23,119668.85628851414,Retail,South,2023
2024-09-30,112613.53361028865,Retail,South,2023
2024-10-07,140693.8437820567,Retail,South,2023
2024-10-14,146825.28725086735,Retail,South,2023
2024-10-21,152302.23250389367,Retail,South,2023
2024-10-28,123410.26550968873,Retail,South,2023
2024-11-04,142433.5184933793,Retail,South,2023
2024-11-11,148697.9678181299,Retail,South,2023
2024-11-18,155347.0739572916,Retail,South,2023
2024-11-25,157771.73183344756,Retail,South,2023
2024-12-02,148955.59535649675,Retail,South,2023
2024-12-09,154815.44094484707,Retail,South,2023
2024-12-16,145308.3983285493,Retail,South,2023
2024-12-23,130248.67600213342,Retail,South,2023
2024-12-30,104246.95811229707,Retail,South,2023
2024-01-01,80637.29688129289,Wholesale,North,2023
2024-01-08,97381.21243267324,Wholesale,North,2023
2024-01-15,114558.96930483333,Wholesale,North,2023
2024-01-22,105311.24442882744,Wholesale,North,2023
2024-01-29,80294.73003595177,Wholesale,North,2023
2024-02-05,145867.14991928684,Wholesale,North,2023
2024-02-12,89762.61796860283,Wholesale,North,2023
2024-02-19,94189.21612837749,Wholesale,North,2023
2024-02-26,91140.60123333041,Wholesale,North,2023
2024-03-04,116775.23503964448,Wholesale,North,2023
2024-03-11,89053.87575651576,Wholesale,North,2023
2024-03-18,111343.96610339945,Wholesale,North,2023
2024-03-25,148854.62863666652,Wholesale,North,2023
2024-04-01,119286.71905490954,Wholesale,North,2023
2024-04-08,146412.9372080629,Wholesale,North,2023
2024-04-15,127015.76820907147,Wholesale,North,2023
2024-04-22,110182.1204435261,Wholesale,North,2023
2024-04-29,141156.83126211166,Wholesale,North,2023
2024-05-06,98258.53062374785,Wholesale,North,2023
2024-05-13,142601.60473812057,Wholesale,North,2023
2024-05-20,118850.1478773501,Wholesale,North,2023
2024-05-27,116027.84194600601,Wholesale,North,2023
2024-06-03,123425.78089373442,Wholesale,North,2023
2024-06-10,110211.50294631084,Wholesale,North,2023
2024-06-17,127762.07303097834,Wholesale,North,2023
2024-06-24,125385.33479400421,Wholesale,North,2023
2024-07-01,140672.06646289187,Wholesale,North,2023
2024-07-08,124522.02250609105,Wholesale,North,2023
2024-07-15,162237.90522536368,Wholesale,North,2023
2024-07-22,136169.743971252,Wholesale,North,2023
2024-07-29,165689.99922344374,Wholesale,North,2023
2024-08-05,139974.95984804645,Wholesale,North,2023
2024-08-12,134866.3144833817,Wholesale,North,2023
2024-08-19,152981.42830577624,Wholesale,North,2023
2024-08-26,135418.70413596428,Wholesale,North,2023
2024-09-02,164783.90554427207,Wholesale,North,2023
2024-09-09,139266.49715464102,Wholesale,North,2023
2024-09-16,166401.07859337854,Wholesale,North,2023
2024-09-23,148606.3629654502,Wholesale,North,2023
2024-09-30,140559.3079640477,Wholesale,North,2023
2024-10-07,108617.10229022987,Wholesale,North,2023
2024-10-14,208413.7827304748,Wholesale,North,2023
2024-10-21,115311.29800594371,Wholesale,North,2023
2024-10-28,140357.57075085983,Wholesale,North,2023
2024-11-04,106812.44348415623,Wholesale,North,2023
2024-11-11,148311.28900859097,Wholesale,North,2023
2024-11-18,163518.18926211918,Wholesale,North,2023
2024-11-25,163474.01226685295,Wholesale,North,2023
2024-12-02,133390.41490188584,Wholesale,North,2023
2024-12-09,157146.61396653045,Wholesale,North,2023
2024-12-16,122786.67170866553,Wholesale,North,2023
2024-12-23,182579.07168337225,Wholesale,North,2023
2024-12-30,82973.67908147394,Wholesale,North,2023
2024-01-01,53778.19392511664,Wholesale,South,2023
2024-01-08,151479.1517352276,Wholesale,South,2023
2024-01-15,83094.91066767648,Wholesale,South,2023
2024-01-22,84799.50511153652,Wholesale,South,2023
2024-01-29,147354.24736791037,Wholesale,South,2023
2024-02-05,108909.32373576816,Wholesale,South,2023
2024-02-12,124827.43170472761,Wholesale,South,2023
2024-02-19,92212.43830043766,Wholesale,South,2023
2024-02-26,131393.82655025672,Wholesale,South,2023
2024-03-04,128608.76305389985,Wholesale,South,2023
2024-03-11,93833.12580453834,Wholesale,South,2023
2024-03-18,89237.87497149139,Wholesale,South,2023
2024-03-25,84898.98075566722,Wholesale,South,2023
2024-04-01,148368.56561088073,Wholesale,South,2023
2024-04-08,110189.02587854456,Wholesale,South,2023
2024-04-15,103583.08181910946,Wholesale,South,2023
2024-04-22,109903.30756824111,Wholesale,South,2023
2024-04-29,101833.2021036312,Wholesale,South,2023
2024-05-06,126090.62113134224,Wholesale,South,2023
2024-05-13,127818.96081076321,Wholesale,South,2023
2024-05-20,119191.18564708604,Wholesale,South,2023
2024-05-27,121299.85954540105,Wholesale,South,2023
2024-06-03,102445.29405741765,Wholesale,South,2023
2024-06-10,98644.27816251287,Wholesale,South,2023
2024-06-17,124902.01447473723,Wholesale,South,2023
2024-06-24,118479.22155113086,Wholesale,South,2023
2024-07-01,135918.09041217572,Wholesale,South,2023
2024-07-08,130371.18563531361,Wholesale,South,2023
2024-07-15,139352.3837558676,Wholesale,South,2023
2024-07-22,128727.38142488968,Wholesale,South,2023
2024-07-29,123747.19317305443,Wholesale,South,2023
2024-08-05,144352.70266704287,Wholesale,South,2023
2024-08-12,151261.87954988494,Wholesale,South,2023
2024-08-19,122578.372093889,Wholesale,South,2023
2024-08-26,142476.82726840506,Wholesale,South,2023
2024-09-02,146181.39869116945,Wholesale,South,2023
2024-09-09,129867.87050294611,Wholesale,South,2023
2024-09-16,165207.80412791116,Wholesale,South,2023
2024-09-23,148466.2354505905,Wholesale,South,2023
2024-09-30,115967.98036849816,Wholesale,South,2023
2024-10-07,145166.86437430832,Wholesale,South,2023
2024-10-14,165435.41339884387,Wholesale,South,2023
2024-10-21,153665.032153567,Wholesale,South,2023
2024-10-28,158078.70534353075,Wholesale,South,2023
2024-11-04,156656.70843971753,Wholesale,South,2023
2024-11-11,152566.3099933109,Wholesale,South,2023
2024-11-18,150743.3667022923,Wholesale,South,2023
2024-11-25,149508.40183625856,Wholesale,South,2023
2024-12-02,167757.5011769376,Wholesale,South,2023
2024-12-09,149614.35537467222,Wholesale,South,2023
2024-12-16,160812.40875789587,Wholesale,South,2023
2024-12-23,141736.61317337735,Wholesale,South,2023
2024-12-30,109376.1952696661,Wholesale,South,2023
2024-01-01,120576.76112893342,Online,North,2024
2024-01-08,112838.81484091208,Online,North,2024
2024-01-15,106800.53212111074,Online,North,2024
2024-01-22,134949.85058543546,Online,North,2024
2024-01-29,60216.35870796494,Online,North,2024
2024-02-05,92825.3097457467,Online,North,2024
2024-02-12,109854.83394275318,Online,North,2024
2024-02-19,78952.6379095298,Online,North,2024
2024-02-26,135347.47518078168,Online,North,2024
2024-03-04,133764.26029386825,Online,North,2024
2024-03-11,106346.8634251864,Online,North,2024
2024-03-18,127749.8056161555,Online,North,2024
2024-03-25,104960.81464830149,Online,North,2024
2024-04-01,166178.93854832905,Online,North,2024
2024-04-08,107633.7807799099,Online,North,2024
2024-04-15,127470.12833719449,Online,North,2024
2024-04-22,112197.59547086243,Online,North,2024
2024-04-29,147107.19324773725,Online,North,2024
2024-05-06,159647.89742386466,Online,North,2024
2024-05-13,142707.17586214736,Online,North,2024
2024-05-20,112673.9983431859,Online,North,2024
2024-05-27,130865.65726014091,Online,North,2024
2024-06-03,145709.63654715416,Online,North,2024
2024-06-10,58816.03179998078,Online,North,2024
2024-06-17,152586.20587340146,Online,North,2024
2024-06-24,87951.5022192745,Online,North,2024
2024-07-01,147868.19257707716,Online,North,2024
2024-07-08,78812.77531890295,Online,North,2024
2024-07-15,93176.98609781655,Online,North,2024
2024-07-22,128012.86393240793,Online,North,2024
2024-07-29,156524.01462100857,Online,North,2024
2024-08-05,136123.60664039315,Online,North,2024
2024-08-12,133919.8226852789,Online,North,2024
2024-08-19,152424.95578540652,Online,North,2024
2024-08-26,110835.00015972182,Online,North,2024
2024-09-02,117044.58298784052,Online,North,2024
2024-09-09,124172.00553894343,Online,North,2024
2024-09-16,103510.70901040421,Online,North,2024
2024-09-23,132083.71175572753,Online,North,2024
2024-09-30,163134.60090926473,Online,North,2024
2024-10-07,159491.13667752492,Online,North,2024
2024-10-14,128014.51897084365,Online,North,2024
2024-10-21,155324.7476280994,Online,North,2024
2024-10-28,157366.14648038748,Online,North,2024
2024-11-04,161984.87574002886,Online,North,2024
2024-11-11,162227.26352890552,Online,North,2024
2024-11-18,139294.00554144502,Online,North,2024
2024-11-25,137632.10717323137,Online,North,2024
2024-12-02,141650.38852170366,Online,North,2024
2024-12-09,167563.01528627443,Online,North,2024
2024-12-16,142438.48963586686,Online,North,2024
2024-12-23,167315.6577761378,Online,North,2024
2024-12-30,74617.68728145333,Online,North,2024
2024-01-01,108056.82592676916,Online,South,2024
2024-01-08,66931.57174372708,Online,South,2024
2024-01-15,130787.1105799746,Online,South,2024
2024-01-22,131230.56970104805,Online,South,2024
2024-01-29,94172.79208502593,Online,South,2024
2024-02-05,108457.5794499458,Online,South,2024
2024-02-12,97579.54355056898,Online,South,2024
2024-02-19,109707.38906259731,Online,South,2024
2024-02-26,117897.35751781726,Online,South,2024
2024-03-04,81608.6171356308,Online,South,2024
2024-03-11,108389.35816848284,Online,South,2024
2024-03-18,77340.77768897869,Online,South,2024
2024-03-25,125431.28354274995,Online,South,2024
2024-04-01,117599.90930227003,Online,South,2024
2024-04-08,109712.75718042317,Online,South,2024
2024-04-15,75363.96535587555,Online,South,2024
2024-04-22,135626.98492576578,Online,South,2024
2024-04-29,111745.53012972465,Online,South,2024
2024-05-06,83777.15216046854,Online,South,2024
2024-05-13,123446.56334731741,Online,South,2024
2024-05-20,117119.78941204296,Online,South,2024
2024-05-27,143722.41270637157,Online,South,2024
2024-06-03,117813.45263053942,Online,South,2024
2024-06-10,134351.32430033,Online,South,2024
2024-06-17,132395.2210101682,Online,South,2024
2024-06-24,122328.84457611774,Online,South,2024
2024-07-01,102006.1347019501,Online,South,2024
2024-07-08,134371.69209849872,Online,South,2024
2024-07-15,135254.48797992797,Online,South,2024
2024-07-22,153077.3173570919,Online,South,2024
2024-07-29,121002.78041143282,Online,South,2024
2024-08-05,131816.19902304516,Online,South,2024
2024-08-12,155083.22171945963,Online,South,2024
2024-08-19,152564.62757260128,Online,South,2024
2024-08-26,120957.17262779386,Online,South,2024
2024-09-02,188580.3531001734,Online,South,2024
2024-09-09,107654.26827425853,Online,South,2024
2024-09-16,121010.16317475389,Online,South,2024
2024-09-23,152373.8867055711,Online,South,2024
2024-09-30,124697.66023573073,Online,South,2024
2024-10-07,112779.31869200953,Online,South,2024
2024-10-14,116113.17404519019,Online,South,2024
2024-10-21,170300.12538472514,Online,South,2024
2024-10-28,158047.48979690793,Online,South,2024
2024-11-04,154808.59764913667,Online,South,2024
2024-11-11,140686.5648813072,Online,South,2024
2024-11-18,151787.24389923172,Online,South,2024
2024-11-25,151010.26395477477,Online,South,2024
2024-12-02,143993.2942220003,Online,South,2024
2024-12-09,140167.04603685118,Online,South,2024
2024-12-16,153897.18109827902,Online,South,2024
2024-12-23,150424.99804473156,Online,South,2024
2024-12-30,107602.10084565228,Online,South,2024
2024-01-01,147241.06728738386,Retail,North,2024
2024-01-08,129053.69519582248,Retail,North,2024
2024-01-15,143419.1401753748,Retail,North,2024
2024-01-22,121907.1807220228,Retail,North,2024
2024-01-29,103097.35504697372,Retail,North,2024
2024-02-05,105986.29129935698,Retail,North,2024
2024-02-12,116193.98369730744,Retail,North,2024
2024-02-19,111617.31245926784,Retail,North,2024
2024-02-26,96770.92645784268,Retail,North,2024
2024-03-04,107403.2892606239,Retail,North,2024
2024-03-11,126132.08357836236,Retail,North,2024
2024-03-18,87778.27434169812,Retail,North,2024
2024-03-25,150226.11132552777,Retail,North,2024
2024-04-01,113627.53807196603,Retail,North,2024
2024-04-08,108475.9945189924,Retail,North,2024
2024-04-15,123046.66846741276,Retail,North,2024
2024-04-22,114609.96563586824,Retail,North,2024
2024-04-29,113151.22691186046,Retail,North,2024
2024-05-06,157030.18329580998,Retail,North,2024
2024-05-13,166864.23044323106,Retail,North,2024
2024-05-20,168123.3912038604,Retail,North,2024
2024-05-27,166106.06711324636,Retail,North,2024
2024-06-03,110519.10591737769,Retail,North,2024
2024-06-10,128097.68786096659,Retail,North,2024
2024-06-17,133535.50568963855,Retail,North,2024
2024-06-24,135015.25116077202,Retail,North,2024
2024-07-01,133011.32401871,Retail,North,2024
2024-07-08,113328.41396639014,Retail,North,2024
2024-07-15,81551.24685622231,Retail,North,2024
2024-07-22,115911.24088725817,Retail,North,2024
2024-07-29,130270.49716409302,Retail,North,2024
2024-08-05,116528.51117930427,Retail,North,2024
2024-08-12,141686.74152697477,Retail,North,2024
2024-08-19,153713.51462178183,Retail,North,2024
2024-08-26,110661.0898255175,Retail,North,2024
2024-09-02,131050.73142403283,Retail,North,2024
2024-09-09,138339.33790983516,Retail,North,2024
2024-09-16,165406.8194488182,Retail,North,2024
2024-09-23,135548.84509412025,Retail,North,2024
2024-09-30,150318.88531875185,Retail,North,2024
2024-10-07,137374.7641034357,Retail,North,2024
2024-10-14,156675.76348902867,Retail,North,2024
2024-10-21,157417.33803956019,Retail,North,2024
2024-10-28,119141.4196890473,Retail,North,2024
2024-11-04,131725.73871551396,Retail,North,2024
2024-11-11,155975.63260579557,Retail,North,2024
2024-11-18,119066.82464630812,Retail,North,2024
2024-11-25,118812.14848282756,Retail,North,2024
2024-12-02,150690.3508947197,Retail,North,2024
2024-12-09,163635.909866101,Retail,North,2024
2024-12-16,136998.4676687183,Retail,North,2024
2024-12-23,170558.75686189544,Retail,North,2024
2024-12-30,119114.64348048395,Retail,North,2024
2024-01-01,103075.27760453596,Retail,South,2024
2024-01-08,95549.48944564018,Retail,South,2024
2024-01-15,111232.02834861277,Retail,South,2024
2024-01-22,112710.06357309913,Retail,South,2024
2024-01-29,95315.98795725744,Retail,South,2024
2024-02-05,117561.89524562076,Retail,South,2024
2024-02-12,119840.7360181553,Retail,South,2024
2024-02-19,128070.83055826635,Retail,South,2024
2024-02-26,109631.63234390639,Retail,South,2024
2024-03-04,112892.24821803013,Retail,South,2024
2024-03-11,97762.72087471135,Retail,South,2024
2024-03-18,123752.23347326035,Retail,South,2024
2024-03-25,159431.26767261236,Retail,South,2024
2024-04-01,121689.04747609193,Retail,South,2024
2024-04-08,104184.04594454904,Retail,South,2024
2024-04-15,89929.30820070356,Retail,South,2024
2024-04-22,110552.10322722369,Retail,South,2024
2024-04-29,115579.26172657483,Retail,South,2024
2024-05-06,147638.99057167905,Retail,South,2024
2024-05-13,106848.43076840011,Retail,South,2024
2024-05-20,116356.07049796582,Retail,South,2024
2024-05-27,130801.13156112612,Retail,South,2024
2024-06-03,129423.20417193294,Retail,South,2024
2024-06-10,145770.57687475835,Retail,South,2024
2024-06-17,133885.592373726,Retail,South,2024
2024-06-24,154007.36950776423,Retail,South,2024
2024-07-01,111061.45214786218,Retail,South,2024
2024-07-08,102270.3117226888,Retail,South,2024
2024-07-15,146713.50199906362,Retail,South,2024
2024-07-22,124908.63240140991,Retail,South,2024
2024-07-29,143950.3503868161,Retail,South,2024
2024-08-05,112463.62709380119,Retail,South,2024
2024-08-12,107309.2306706276,Retail,South,2024
2024-08-19,159796.12530769844,Retail,South,2024
2024-08-26,143208.26356573,Retail,South,2024
2024-09-02,117055.04797328297,Retail,South,2024
2024-09-09,109756.52016395555,Retail,South,2024
2024-09-16,134615.93299758434,Retail,South,2024
2024-09-23,99898.44443928613,Retail,South,2024
2024-09-30,124437.96957533159,Retail,South,2024
2024-10-07,133564.84140154347,Retail,South,2024
2024-10-14,186505.31442801378,Retail,South,2024
2024-10-21,130995.53628762499,Retail,South,2024
2024-10-28,158371.18544999018,Retail,South,2024
2024-11-04,143223.52159304335,Retail,South,2024
2024-11-11,112002.40096285858,Retail,South,2024
2024-11-18,115762.0919035559,Retail,South,2024
2024-11-25,137174.52983477485,Retail,South,2024
2024-12-02,150652.2722812769,Retail,South,2024
2024-12-09,159134.34614645757,Retail,South,2024
2024-12-16,192852.48652365286,Retail,South,2024
2024-12-23,135425.76150848955,Retail,South,2024
2024-12-30,68356.99519592858,Retail,South,2024
2024-01-01,87450.74988678982,Wholesale,North,2024
2024-01-08,126448.86537536526,Wholesale,North,2024
2024-01-15,112015.16101393776,Wholesale,North,2024
2024-01-22,104976.90514305086,Wholesale,North,2024
2024-01-29,143246.25625156995,Wholesale,North,2024
2024-02-05,104959.55405463738,Wholesale,North,2024
2024-02-12,102779.84623761535,Wholesale,North,2024
2024-02-19,83465.7786613909,Wholesale,North,2024
2024-02-26,93922.75376648549,Wholesale,North,2024
2024-03-04,133474.34787963322,Wholesale,North,2024
2024-03-11,134513.3495747752,Wholesale,North,2024
2024-03-18,90396.65004969912,Wholesale,North,2024
2024-03-25,82320.51973887297,Wholesale,North,2024
2024-04-01,121324.37424982306,Wholesale,North,2024
2024-04-08,102084.24467243052,Wholesale,North,2024
2024-04-15,109642.4888611069,Wholesale,North,2024
2024-04-22,115835.1978906675,Wholesale,North,2024
2024-04-29,125071.05492172993,Wholesale,North,2024
2024-05-06,93162.7181739898,Wholesale,North,2024
2024-05-13,132046.60488573377,Wholesale,North,2024
2024-05-20,135228.13581035263,Wholesale,North,2024
2024-05-27,150163.88596271415,Wholesale,North,2024
2024-06-03,104846.07729664029,Wholesale,North,2024
2024-06-10,122260.01333660996,Wholesale,North,2024
2024-06-17,116890.05386552798,Wholesale,North,2024
2024-06-24,131255.73901771446,Wholesale,North,2024
2024-07-01,105184.53553525344,Wholesale,North,2024
2024-07-08,144283.3741947345,Wholesale,North,2024
2024-07-15,136567.12538380217,Wholesale,North,2024
2024-07-22,130789.23008213432,Wholesale,North,2024
2024-07-29,146488.93309050938,Wholesale,North,2024
2024-08-05,128696.50230574973,Wholesale,North,2024
2024-08-12,133376.88014884214,Wholesale,North,2024
2024-08-19,147342.47206540965,Wholesale,North,2024
2024-08-26,143566.7888511231,Wholesale,North,2024
2024-09-02,131973.54271867534,Wholesale,North,2024
2024-09-09,136279.92777481952,Wholesale,North,2024
2024-09-16,142818.95547134918,Wholesale,North,2024
2024-09-23,111025.40539554332,Wholesale,North,2024
2024-09-30,182334.17146017877,Wholesale,North,2024
2024-10-07,164654.86835878255,Wholesale,North,2024
2024-10-14,138579.43356593561,Wholesale,North,2024
2024-10-21,155782.0932903213,Wholesale,North,2024
2024-10-28,128634.15599495001,Wholesale,North,2024
2024-11-04,120131.13549986135,Wholesale,North,2024
2024-11-11,156607.13855304764,Wholesale,North,2024
2024-11-18,132850.596518368,Wholesale,North,2024
2024-11-25,165825.51320700522,Wholesale,North,2024
2024-12-02,147011.71296760597,Wholesale,North,2024
2024-12-09,134384.17104520096,Wholesale,North,2024
2024-12-16,134553.24186276307,Wholesale,North,2024
2024-12-23,154119.93975091956,Wholesale,North,2024
2024-12-30,136858.40806946805,Wholesale,North,2024
2024-01-01,86448.64560187238,Wholesale,South,2024
2024-01-08,96555.15467345888,Wholesale,South,2024
2024-01-15,128144.57520164596,Wholesale,South,2024
2024-01-22,110888.42080410567,Wholesale,South,2024
2024-01-29,88421.71494986238,Wholesale,South,2024
2024-02-05,121210.25519750077,Wholesale,South,2024
2024-02-12,108343.3019854674,Wholesale,South,2024
2024-02-19,88615.96271042367,Wholesale,South,2024
2024-02-26,73441.10459947979,Wholesale,South,2024
2024-03-04,101213.14054470384,Wholesale,South,2024
2024-03-11,106422.5755811916,Wholesale,South,2024
2024-03-18,103431.64429909142,Wholesale,South,2024
2024-03-25,141004.4026200947,Wholesale,South,2024
2024-04-01,113410.35623047462,Wholesale,South,2024
2024-04-08,136279.98286435375,Wholesale,South,2024
2024-04-15,128344.33890247918,Wholesale,South,2024
2024-04-22,139790.1481542597,Wholesale,South,2024
2024-04-29,99356.43946569282,Wholesale,South,2024
2024-05-06,130888.12616454279,Wholesale,South,2024
2024-05-13,107895.6725561196,Wholesale,South,2024
2024-05-20,111770.00316587764,Wholesale,South,2024
2024-05-27,135169.2918761893,Wholesale,South,2024
2024-06-03,64466.90740107758,Wholesale,South,2024
2024-06-10,124409.77069876064,Wholesale,South,2024
2024-06-17,130129.6141944928,Wholesale,South,2024
2024-06-24,161980.652507582,Wholesale,South,2024
2024-07-01,139478.90733649768,Wholesale,South,2024
2024-07-08,136280.22535061184,Wholesale,South,2024
2024-07-15,120769.83487770954,Wholesale,South,2024
2024-07-22,124267.42856798509,Wholesale,South,2024
2024-07-29,125158.37119128146,Wholesale,South,2024
2024-08-05,142489.3966660369,Wholesale,South,2024
2024-08-12,130464.32278245126,Wholesale,South,2024
2024-08-19,129003.57416940726,Wholesale,South,2024
2024-08-26,133794.97323475365,Wholesale,South,2024
2024-09-02,133627.63221124222,Wholesale,South,2024
2024-09-09,134674.93972633197,Wholesale,South,2024
2024-09-16,120089.62687357886,Wholesale,South,2024
2024-09-23,153711.47894556297,Wholesale,South,2024
2024-09-30,132961.34945197887,Wholesale,South,2024
2024-10-07,130143.53715005585,Wholesale,South,2024
2024-10-14,141360.80285524955,Wholesale,South,2024
2024-10-21,128533.06671673094,Wholesale,South,2024
2024-10-28,140453.07454262415,Wholesale,South,2024
2024-11-04,95042.64592258722,Wholesale,South,2024
2024-11-11,137361.378291713,Wholesale,South,2024
2024-11-18,167373.4124535329,Wholesale,South,2024
2024-11-25,135425.2004244228,Wholesale,South,2024
2024-12-02,171921.41751950022,Wholesale,South,2024
2024-12-09,152709.5125065589,Wholesale,South,2024
2024-12-16,172875.5523304942,Wholesale,South,2024
2024-12-23,188794.786555183,Wholesale,South,2024
2024-12-30,85255.25988182443,Wholesale,South,2024

</script><script type="text/plain" id="sales_by_region" data-format="csv_embedded" data-src="">
Date,Sales,Region
2024-01-01,10071.563954462172,North
2024-01-02,11421.363406598672,North
2024-01-03,12651.426530447843,North
2024-01-04,11355.482505581076,North
2024-01-05,9755.54775738247,North
2024-01-06,11508.070279853431,North
2024-01-07,14000.85146934226,North
2024-01-08,10733.118367142462,North
2024-01-09,10238.894641412147,North
2024-01-10,7440.741257192988,North
2024-01-11,12207.589425581225,North
2024-01-12,12186.004922249265,North
2024-01-13,15322.192189589054,North
2024-01-14,8690.33326329126,North
2024-01-15,10536.854189478681,North
2024-01-16,10131.361492784452,North
2024-01-17,11235.482089094836,North
2024-01-18,9609.54154841823,North
2024-01-19,11598.83732444483,North
2024-01-20,10957.06294942348,North
2024-01-21,13405.326472686615,North
2024-01-22,13188.29721357826,North
2024-01-23,11471.73379086261,North
2024-01-24,12393.222406234161,North
2024-01-25,13005.779985917623,North
2024-01-26,11993.939698705328,North
2024-01-27,10320.134696632942,North
2024-01-28,13901.545906860993,North
2024-01-29,13911.032071748625,North
2024-01-30,12397.603345813406,North
2024-01-31,11004.56741374895,North
2024-02-01,8786.457356749965,North
2024-02-02,9577.883487122772,North
2024-02-03,7738.045260400123,North
2024-02-04,13199.631329407226,North
2024-02-05,11336.965007094657,North
2024-02-06,11407.172290543862,North
2024-02-07,14976.45812264634,North
2024-02-08,13084.461579040073,North
2024-02-09,11622.70467644363,North
2024-02-10,10857.625944246673,North
2024-02-11,10615.867102600623,North
2024-02-12,9258.900935044252,North
2024-02-13,14517.502932023777,North
2024-02-14,10577.493588764739,North
2024-02-15,10634.442594344302,North
2024-02-16,12123.998614841961,North
2024-02-17,13496.019773398217,North
2024-02-18,10828.250654926635,North
2024-02-19,13538.443974457887,North
2024-02-20,10154.085931885013,North
2024-02-21,12576.257496570432,North
2024-02-22,12970.701034079997,North
2024-02-23,9471.38121458612,North
2024-02-24,12583.117936886161,North
2024-02-25,13412.230154181414,North
2024-02-26,12063.139631981509,North
2024-02-27,15189.50173224273,North
2024-02-28,11497.429758499517,North
2024-02-29,11234.0649329953,North
2024-03-01,14232.340244023084,North
2024-03-02,11727.341849992174,North
2024-03-03,10364.937969531604,North
2024-03-04,10572.933376249059,North
2024-03-05,15189.570118439682,North
2024-03-06,15475.664685277847,North
2024-03-07,15013.416827380443,North
2024-03-08,14515.088300076797,North
2024-03-09,14352.594673909072,North
2024-03-10,12123.200890772168,North
2024-03-11,13596.013137640803,North
2024-03-12,12343.703344486883,North
2024-03-13,13485.169830427616,North
2024-03-14,14760.685559638363,North
2024-03-15,15173.14696017706,North
2024-03-16,12709.006621239248,North
2024-03-17,9957.570462600253,North
2024-03-18,9946.466485215953,North
2024-03-19,16372.69078176653,North
2024-03-20,19006.502345883866,North
2024-03-21,13701.030297580743,North
2024-03-22,13501.794841763942,North
2024-03-23,17469.030575108598,North
2024-03-24,16452.10931496951,North
2024-03-25,16267.533620413986,North
2024-03-26,16851.526927572075,North
2024-03-27,14533.447842526071,North
2024-03-28,16041.295082244618,North
2024-03-29,14714.0882720453,North
2024-03-30,12575.789664245054,North
2024-03-31,15216.262884275375,North
2024-04-01,16268.500362854069,North
2024-04-02,13381.887349688175,North
2024-04-03,15381.463507406794,North
2024-04-04,12850.088021918764,North
2024-04-05,16827.677773248248,North
2024-04-06,16384.69740817089,North
2024-04-07,14758.82725383621,North
2024-04-08,19028.658827409614,North
2024-04-09,16212.611731697796,North
2024-04-10,12254.355731699936,North
2024-04-11,14666.43844656738,North
2024-04-12,14433.33335915839,North
2024-04-13,17147.867047351567,North
2024-04-14,15690.255693497898,North
2024-04-15,17898.94450698072,North
2024-04-16,16728.503440157132,North
2024-04-17,15486.755025361243,North
2024-04-18,16126.723945127433,North
2024-04-19,15369.617247229644,North
2024-04-20,19746.024180815086,North
2024-04-21,12816.274771429438,North
2024-04-22,17241.048254803543,North
2024-04-23,16071.887731887235,North
2024-04-24,12546.794818179995,North
2024-04-25,14745.584881139077,North
2024-04-26,15529.374766920746,North
2024-04-27,12968.14520857923,North
2024-04-28,13658.77823336309,North
2024-04-29,15959.309936269072,North
2024-04-30,16517.8296982036,North
2024-05-01,17261.393224738138,North
2024-05-02,17354.77011055735,North
2024-05-03,17182.49740733527,North
2024-05-04,15747.011703972921,North
2024-05-05,15080.591647790954,North
2024-05-06,23366.052079322428,North
2024-05-07,19924.59813585347,North
2024-05-08,16729.3071306168,North
2024-05-09,16430.071787497556,North
2024-05-10,16261.144034511097,North
2024-05-11,14966.690659247804,North
2024-05-12,17933.75991659705,North
2024-05-13,20123.516741559084,North
2024-05-14,13406.03497069943,North
2024-05-15,16883.19345636355,North
2024-05-16,15369.075072721096,North
2024-05-17,18313.471424911037,North
2024-05-18,18450.241898492382,North
2024-05-19,16587.963053514628,North
2024-05-20,18760.887446545537,North
2024-05-21,19264.881113342053,North
2024-05-22,19752.097097626316,North
2024-05-23,19837.432213111366,North
2024-05-24,12128.098819551573,North
2024-05-25,14474.70633257832,North
2024-05-26,15203.505827489795,North
2024-05-27,17839.54911894067,North
2024-05-28,16132.297389620624,North
2024-05-29,19696.66523088874,North
2024-05-30,17268.144626385583,North
2024-05-31,17523.796122823864,North
2024-06-01,19287.64792713424,North
2024-06-02,14940.113683897154,North
2024-06-03,23438.868664955637,North
2024-06-04,19448.037055119097,North
2024-06-05,20001.823932193212,North
2024-06-06,17483.763498281834,North
2024-06-07,18295.619977693856,North
2024-06-08,15532.650696679491,North
2024-06-09,17895.848225240454,North
2024-06-10,20678.714737758914,North
2024-06-11,19525.624658282235,North
2024-06-12,16185.789339533894,North
2024-06-13,16185.509654308546,North
2024-06-14,17719.11277209941,North
2024-06-15,17478.766846226797,North
2024-06-16,15559.002350588837,North
2024-06-17,18304.808610184024,North
2024-06-18,18281.83751882072,North
2024-06-19,16897.59516995437,North
2024-06-20,21438.501243331142,North
2024-06-21,16926.770207581947,North
2024-06-22,18659.940893820025,North
2024-06-23,20210.782684580874,North
2024-06-24,17750.198851003453,North
2024-06-25,18905.571466231468,North
2024-06-26,19703.59754661686,North
2024-06-27,19078.11458556634,North
2024-06-28,19041.90554774789,North
2024-06-29,16815.19548940538,North
2024-06-30,21654.25953819954,North
2024-01-01,10594.914915207615,South
2024-01-02,11129.497716477536,South
2024-01-03,8592.268306257241,South
2024-01-04,9808.553273688005,South
2024-01-05,10948.054748673387,South
2024-01-06,13098.253888396388,South
2024-01-07,10224.837741363212,South
2024-01-08,11048.272176330067,South
2024-01-09,7082.454274376189,South
2024-01-10,8729.695004916024,South
2024-01-11,9652.473710418972,South
2024-01-12,9492.939569725377,South
2024-01-13,8206.288200241803,South
2024-01-14,10892.914444134347,South
2024-01-15,9572.920871930639,South
2024-01-16,14122.877502461071,South
2024-01-17,13209.501821079306,South
2024-01-18,12493.241528167058,South
2024-01-19,8718.365968043101,South
2024-01-20,11395.204590335456,South
2024-01-21,12179.652552009116,South
2024-01-22,11863.147060335426,South
2024-01-23,13827.572199805403,South
2024-01-24,10994.488155117167,South
2024-01-25,10133.031039186857,South
2024-01-26,10385.745203997578,South
2024-01-27,14145.669246415273,South
2024-01-28,10606.699915121124,South
2024-01-29,11840.660728370422,South
2024-01-30,14472.082298958183,South
2024-01-31,11123.291213909453,South
2024-02-01,12310.07861056227,South
2024-02-02,10233.573164329331,South
2024-02-03,12869.327049431467,South
2024-02-04,9298.667663401786,South
2024-02-05,11339.181679709962,South
2024-02-06,12370.825802802721,South
2024-02-07,14690.194110636558,South
2024-02-08,11204.947791123483,South
2024-02-09,13208.14542244509,South
2024-02-10,9354.327586120955,South
2024-02-11,11405.512107081513,South
2024-02-12,11134.775014979285,South
2024-02-13,11665.93460947516,South
2024-02-14,11315.911744770532,South
2024-02-15,8153.169930482228,South
2024-02-16,14344.16189667192,South
2024-02-17,15440.128674107471,South
2024-02-18,18460.092119704,South
2024-02-19,15338.239089751954,South
2024-02-20,14443.468688172354,South
2024-02-21,11093.29201494858,South
2024-02-22,12259.505688127381,South
2024-02-23,11838.65927797716,South
2024-02-24,7539.224261570042,South
2024-02-25,10364.198926406716,South
2024-02-26,14152.775946062771,South
2024-02-27,11679.293724538576,South
2024-02-28,13938.0202056345,South
2024-02-29,15527.340362966912,South
2024-03-01,15058.743704288017,South
2024-03-02,14047.99458852867,South
2024-03-03,10024.24340921582,South
2024-03-04,16093.991629569839,South
2024-03-05,13141.62594134073,South
2024-03-06,13719.59845897807,South
2024-03-07,15512.050899880778,South
2024-03-08,9052.834747392442,South
2024-03-09,12978.893315856014,South
2024-03-10,15198.73986632914,South
2024-03-11,13750.00753157114,South
2024-03-12,10343.166718083781,South
2024-03-13,12504.432505567755,South
2024-03-14,13386.55226530438,South
2024-03-15,12779.031334610201,South
2024-03-16,11972.777678870709,South
2024-03-17,10229.600680640982,South
2024-03-18,15328.784768372483,South
2024-03-19,13270.639803604628,South
2024-03-20,13508.350576790237,South
2024-03-21,17420.30771139986,South
2024-03-22,14512.666582794467,South
2024-03-23,14831.891287733053,South
2024-03-24,16121.430296801713,South
2024-03-25,13490.134141457576,South
2024-03-26,13364.552637158855,South
2024-03-27,13253.937812877864,South
2024-03-28,14879.227922808252,South
2024-03-29,17759.90295039156,South
2024-03-30,13493.139031486928,South
2024-03-31,15498.038086021517,South
2024-04-01,13874.278830902995,South
2024-04-02,13320.099738062758,South
2024-04-03,15961.203747594753,South
2024-04-04,15729.804646129827,South
2024-04-05,10785.605583077457,South
2024-04-06,13298.43346175785,South
2024-04-07,12575.360320466383,South
2024-04-08,12622.782933158198,South
2024-04-09,15641.345749846954,South
2024-04-10,19290.62001130271,South
2024-04-11,13863.770090697333,South
2024-04-12,14332.802323566262,South
2024-04-13,10573.228148100992,South
2024-04-14,18390.40673145505,South
2024-04-15,16503.228559052495,South
2024-04-16,18888.666921338434,South
2024-04-17,16594.715120829744,South
2024-04-18,16970.514892695086,South
2024-04-19,13601.872936458225,South
2024-04-20,20415.820292880726,South
2024-04-21,17827.61779759685,South
2024-04-22,13833.269660647622,South
2024-04-23,15068.567005193523,South
2024-04-24,17212.794137744484,South
2024-04-25,18847.78697609272,South
2024-04-26,15162.966477549544,South
2024-04-27,17537.662903473396,South
2024-04-28,14503.888753658563,South
2024-04-29,15736.199476708754,South
2024-04-30,15925.600343149052,South
2024-05-01,14028.290664141994,South
2024-05-02,17098.68714972156,South
2024-05-03,14138.162987868825,South
2024-05-04,14698.861346960384,South
2024-05-05,18022.96089881378,South
2024-05-06,17009.10359315908,South
2024-05-07,13880.352096108429,South
2024-05-08,15801.634317560285,South
2024-05-09,17509.672711724066,South
2024-05-10,14441.417875910794,South
2024-05-11,14443.086809068669,South
2024-05-12,13867.408784055808,South
2024-05-13,18991.324626000645,South
2024-05-14,13338.137846799418,South
2024-05-15,20234.67172434579,South
2024-05-16,18118.780514506096,South
2024-05-17,15593.322380756197,South
2024-05-18,17761.567382639547,South
2024-05-19,16532.525598725322,South
2024-05-20,16588.98609686947,South
2024-05-21,19424.42734703744,South
2024-05-22,14115.655159158909,South
2024-05-23,14762.32323301088,South
2024-05-24,17198.22772824642,South
2024-05-25,17938.234724738955,South
2024-05-26,19653.313765238352,South
2024-05-27,18450.69947229285,South
2024-05-28,20041.380180609307,South
2024-05-29,15575.412875877395,South
2024-05-30,20698.719218541042,South
2024-05-31,16482.52710860618,South
2024-06-01,17206.00176049188,South
2024-06-02,17400.209788429776,South
2024-06-03,18691.65866279209,South
2024-06-04,15350.472246117217,South
2024-06-05,16357.06549224306,South
2024-06-06,18698.5940125136,South
2024-06-07,16189.960933556275,South
2024-06-08,17112.60915034847,South
2024-06-09,15100.069789311161,South
2024-06-10,15432.062270562255,South
2024-06-11,16776.436811459724,South
2024-06-12,17649.592411521255,South
2024-06-13,18156.006612232966,South
2024-06-14,16630.060285378273,South
2024-06-15,16802.963369711317,South
2024-06-16,13481.700118272372,South
2024-06-17,21031.827169953838,South
2024-06-18,18959.737986822314,South
2024-06-19,19483.20125148834,South
2024-06-20,19608.89542344176,South
2024-06-21,22798.30659836899,South
2024-06-22,18026.99852809151,South
2024-06-23,16716.79040493329,South
2024-06-24,15207.735579020233,South
2024-06-25,18497.72690628245,South
2024-06-26,19755.82413627022,South
2024-06-27,16306.219588049891,South
2024-06-28,21855.76479201852,South
2024-06-29,17830.410037673653,South
2024-06-30,17571.357502613377,South
2024-01-01,11893.602311867864,East
2024-01-02,12861.941271759988,East
2024-01-03,7878.80848549188,East
2024-01-04,13726.344714849001,East
2024-01-05,7246.421985326193,East
2024-01-06,6617.152332572137,East
2024-01-07,12462.832390616539,East
2024-01-08,10876.806663830677,East
2024-01-09,10280.977623284442,East
2024-01-10,9926.77232974426,East
2024-01-11,11154.36751823473,East
2024-01-12,11655.615155498968,East
2024-01-13,12741.945691354756,East
2024-01-14,8867.579045348497,East
2024-01-15,13001.069085938827,East
2024-01-16,11089.31741367036,East
2024-01-17,8151.921011884951,East
2024-01-18,12528.812766964551,East
2024-01-19,9595.6716767498,East
2024-01-20,10687.25087781371,East
2024-01-21,11012.02278977231,East
2024-01-22,11661.341725773955,East
2024-01-23,11248.181439839127,East
2024-01-24,12001.214832158958,East
2024-01-25,13556.505984098098,East
2024-01-26,13302.956842024256,East
2024-01-27,10697.299049374655,East
2024-01-28,14965.547185739568,East
2024-01-29,12538.297801180874,East
2024-01-30,9570.120448207324,East
2024-01-31,11633.031776901074,East
2024-02-01,11560.140496797385,East
2024-02-02,9445.559719774204,East
2024-02-03,15427.60965078065,East
2024-02-04,8035.5912455714115,East
2024-02-05,12133.652157352062,East
2024-02-06,13185.273804461702,East
2024-02-07,9497.71138180167,East
2024-02-08,13398.80469234359,East
2024-02-09,11522.827555665363,East
2024-02-10,11602.114351149477,East
2024-02-11,11143.286955106805,East
2024-02-12,14848.34165850638,East
2024-02-13,14999.165978775165,East
2024-02-14,14004.995452018307,East
2024-02-15,11406.476602439798,East
2024-02-16,13734.995630623296,East
2024-02-17,14581.931873096535,East
2024-02-18,11152.925291479314,East
2024-02-19,10646.173283608998,East
2024-02-20,12922.168784923719,East
2024-02-21,12814.215745691736,East
2024-02-22,11060.648685703536,East
2024-02-23,12627.997783497989,East
2024-02-24,11199.819655492978,East
2024-02-25,14353.47831143347,East
2024-02-26,12507.164219908755,East
2024-02-27,12314.32156926812,East
2024-02-28,12959.635666129017,East
2024-02-29,14438.910662306384,East
2024-03-01,12666.016176857338,East
2024-03-02,11440.85388799292,East
2024-03-03,16059.98814042491,East
2024-03-04,11435.559590856425,East
2024-03-05,16028.508712077608,East
2024-03-06,12922.129619898118,East
2024-03-07,11905.00142957544,East
2024-03-08,11536.58719276615,East
2024-03-09,12103.965086984908,East
2024-03-10,13065.028348552027,East
2024-03-11,15045.003127402604,East
2024-03-12,17293.053052429565,East
2024-03-13,14500.627005975959,East
2024-03-14,13232.825501720723,East
2024-03-15,10886.472604375143,East
2024-03-16,15243.496045329532,East
2024-03-17,12492.619345146011,East
2024-03-18,15120.86912083654,East
2024-03-19,14886.23482369648,East
2024-03-20,12210.116619827872,East
2024-03-21,11851.97840214347,East
2024-03-22,12925.675296119516,East
2024-03-23,11831.824878666612,East
2024-03-24,10277.777054688224,East
2024-03-25,12579.785262441603,East
2024-03-26,13638.354134121124,East
2024-03-27,14209.12650624039,East
2024-03-28,16082.830606195752,East
2024-03-29,13035.35788381395,East
2024-03-30,10616.76838871084,East
2024-03-31,12146.102742548888,East
2024-04-01,14614.486603490304,East
2024-04-02,15280.561612075222,East
2024-04-03,12999.228815070439,East
2024-04-04,16568.297011424682,East
2024-04-05,15613.857715290902,East
2024-04-06,15504.91048823229,East
2024-04-07,19530.19862999818,East
2024-04-08,13758.950103698546,East
2024-04-09,17248.83651227282,East
2024-04-10,13620.046658311052,East
2024-04-11,14944.244251836142,East
2024-04-12,17132.787313156292,East
2024-04-13,13979.644449357142,East
2024-04-14,15880.9499795058,East
2024-04-15,15392.338021878593,East
2024-04-16,16551.995762720584,East
2024-04-17,14851.427175088083,East
2024-04-18,18389.260911204892,East
2024-04-19,15600.004996731406,East
2024-04-20,17100.49564235428,East
2024-04-21,14819.569639153893,East
2024-04-22,14982.254817916793,East
2024-04-23,14486.083517533147,East
2024-04-24,13469.542222056574,East
2024-04-25,15231.246327248064,East
2024-04-26,14714.589609817318,East
2024-04-27,17862.340533725728,East
2024-04-28,16948.64340732581,East
2024-04-29,15194.502184252118,East
2024-04-30,15145.17484551904,East
2024-05-01,16096.499445768619,East
2024-05-02,14583.357938037698,East
2024-05-03,15770.809393473119,East
2024-05-04,15826.321731671262,East
2024-05-05,19281.960466135257,East
2024-05-06,18629.166724284558,East
2024-05-07,16236.517176437545,East
2024-05-08,19951.689159200745,East
2024-05-09,13897.545835490157,East
2024-05-10,13758.673174663212,East
2024-05-11,17700.271968350564,East
2024-05-12,16120.531834079007,East
2024-05-13,15326.68250302698,East
2024-05-14,17272.633582244747,East
2024-05-15,16862.001316939793,East
2024-05-16,18317.83908119441,East
2024-05-17,17082.644651196963,East
2024-05-18,14898.274172940779,East
2024-05-19,14725.28645238155,East
2024-05-20,19685.482733592824,East
2024-05-21,14224.566218971588,East
2024-05-22,13963.367178781427,East
2024-05-23,17551.840169640956,East
2024-05-24,19192.32272482103,East
2024-05-25,17465.003010986904,East
2024-05-26,14262.664973173063,East
2024-05-27,22040.068662144866,East
2024-05-28,16091.208230244076,East
2024-05-29,20862.585990695236,East
2024-05-30,16134.546316901804,East
2024-05-31,18485.866734256,East
2024-06-01,12923.797507553569,East
2024-06-02,17570.91361842923,East
2024-06-03,16991.886072564754,East
2024-06-04,19412.912432600173,East
2024-06-05,15799.18311276345,East
2024-06-06,18332.221952915883,East
2024-06-07,16972.925633929866,East
2024-06-08,16589.23544761721,East
2024-06-09,15319.657792572993,East
2024-06-10,19916.251805473392,East
2024-06-11,16708.410685123992,East
2024-06-12,19101.273442778,East
2024-06-13,16371.615463706681,East
2024-06-14,14070.926917091081,East
2024-06-15,15758.075727152634,East
2024-06-16,16436.0899460602,East
2024-06-17,19252.05377953433,East
2024-06-18,20352.32001737433,East
2024-06-19,17447.513030324364,East
2024-06-20,18808.837852263197,East
2024-06-21,17942.260276842528,East
2024-06-22,20089.352460546474,East
2024-06-23,19096.37628186783,East
2024-06-24,21874.35643170973,East
2024-06-25,20766.32058180451,East
2024-06-26,16835.052575421912,East
2024-06-27,16697.44585369463,East
2024-06-28,16841.959693139306,East
2024-06-29,21395.2738278579,East
2024-06-30,17617.16877645169,East
2024-01-01,11089.554491750292,West
2024-01-02,6293.657838019153,West
2024-01-03,12738.850588684154,West
2024-01-04,9881.180584928761,West
2024-01-05,9764.672289937125,West
2024-01-06,8711.634484838727,West
2024-01-07,13497.982472279318,West
2024-01-08,8380.487442929243,West
2024-01-09,10834.387579453953,West
2024-01-10,11505.31125371015,West
2024-01-11,9526.385462685485,West
2024-01-12,10689.34347408688,West
2024-01-13,9698.439365758763,West
2024-01-14,9379.342001843714,West
2024-01-15,7156.517739539451,West
2024-01-16,8962.016416380613,West
2024-01-17,12206.127381853526,West
2024-01-18,10822.444270688273,West
2024-01-19,13898.486698113706,West
2024-01-20,9463.020170660431,West
2024-01-21,11271.774496423188,West
2024-01-22,12029.087805959323,West
2024-01-23,11262.294151108877,West
2024-01-24,15772.217276963449,West
2024-01-25,10068.887743226465,West
2024-01-26,10152.484368281112,West
2024-01-27,13296.458882634817,West
2024-01-28,10257.350770404573,West
2024-01-29,13912.696884745934,West
2024-01-30,12496.281987884475,West
2024-01-31,9532.720339379845,West
2024-02-01,15935.26276871308,West
2024-02-02,8337.163639420643,West
2024-02-03,14919.079959597491,West
2024-02-04,9086.496236851444,West
2024-02-05,11141.40363838027,West
2024-02-06,11441.686207847113,West
2024-02-07,14347.653450183654,West
2024-02-08,8402.63479856066,West
2024-02-09,12079.684159553175,West
2024-02-10,11958.556126963827,West
2024-02-11,14808.350689978262,West
2024-02-12,12810.316738640498,West
2024-02-13,7881.7704050884,West
2024-02-14,11779.408881375219,West
2024-02-15,6688.880782282018,West
2024-02-16,10431.020984993222,West
2024-02-17,10704.714140256143,West
2024-02-18,10983.459101843688,West
2024-02-19,14691.640420279173,West
2024-02-20,10679.66380278095,West
2024-02-21,14765.619697089838,West
2024-02-22,16659.328888954435,West
2024-02-23,12674.010216838311,West
2024-02-24,11061.426704650848,West
2024-02-25,8959.400911047871,West
2024-02-26,16399.672381710807,West
2024-02-27,13904.374619200284,West
2024-02-28,14386.9690429063,West
2024-02-29,9041.745248089475,West
2024-03-01,14931.032700518694,West
2024-03-02,12157.72055163492,West
2024-03-03,14280.034880194777,West
2024-03-04,16487.127290093944,West
2024-03-05,14467.550246767154,West
2024-03-06,14188.017276949098,West
2024-03-07,8974.793405867826,West
2024-03-08,11019.656251192644,West
2024-03-09,17034.315519606025,West
2024-03-10,10607.639609779588,West
2024-03-11,9331.470022261801,West
2024-03-12,14366.46261029514,West
2024-03-13,10894.75858852756,West
2024-03-14,14929.149753352458,West
2024-03-15,18344.021883304842,West
2024-03-16,12795.412399020652,West
2024-03-17,9068.299241878276,West
2024-03-18,15789.7688681139,West
2024-03-19,12404.549243023182,West
2024-03-20,16421.264966062117,West
2024-03-21,14158.765412213594,West
2024-03-22,14896.382594182634,West
2024-03-23,12893.89218994879,West
2024-03-24,11881.35148195702,West
2024-03-25,14893.616105061947,West
2024-03-26,13313.381854696547,West
2024-03-27,14998.69000878726,West
2024-03-28,12079.17528798311,West
2024-03-29,13353.453046197572,West
2024-03-30,9061.84556495936,West
2024-03-31,11234.467513402793,West
2024-04-01,15398.551108423282,West
2024-04-02,16453.1365405784,West
2024-04-03,15975.736497811653,West
2024-04-04,16605.00451673383,West
2024-04-05,14267.687117791798,West
2024-04-06,12005.427413547743,West
2024-04-07,14823.055464736623,West
2024-04-08,16836.03870408493,West
2024-04-09,16665.468825638454,West
2024-04-10,16049.496271028473,West
2024-04-11,10009.134026023074,West
2024-04-12,17946.14746093114,West
2024-04-13,17191.44876771852,West
2024-04-14,18168.575585664963,West
2024-04-15,12344.301421730617,West
2024-04-16,16936.141825242412,West
2024-04-17,17217.281780614474,West
2024-04-18,15415.360973621246,West
2024-04-19,15116.01376416628,West
2024-04-20,18310.030299192054,West
2024-04-21,14515.660756926023,West
2024-04-22,17064.692314694796,West
2024-04-23,15918.891439087745,West
2024-04-24,12616.52834685597,West
2024-04-25,13773.645296288028,West
2024-04-26,17423.83326337193,West
2024-04-27,9674.566210617799,West
2024-04-28,16109.939972976706,West
2024-04-29,14205.26431266627,West
2024-04-30,18164.14033549458,West
2024-05-01,15850.316811727307,West
2024-05-02,19096.896490221126,West
2024-05-03,15662.854836569883,West
2024-05-04,18535.042764346195,West
2024-05-05,12891.165556560227,West
2024-05-06,12843.487234811622,West
2024-05-07,20134.28259525779,West
2024-05-08,17258.86451733233,West
2024-05-09,17014.808843154307,West
2024-05-10,16308.581054651335,West
2024-05-11,16895.410352070798,West
2024-05-12,17576.205099869185,West
2024-05-13,12234.323303871928,West
2024-05-14,17877.061019856876,West
2024-05-15,16725.781107412047,West
2024-05-16,19979.20481374712,West
2024-05-17,16242.510623712715,West
2024-05-18,16109.652534438834,West
2024-05-19,20376.000500543807,West
2024-05-20,14491.461030155577,West
2024-05-21,21366.415205256046,West
2024-05-22,15715.875813465394,West
2024-05-23,22465.398508525173,West
2024-05-24,17705.341101154318,West
2024-05-25,12514.594467268587,West
2024-05-26,13585.591451929558,West
2024-05-27,18770.816760987836,West
2024-05-28,16372.407990716008,West
2024-05-29,15643.712207650098,West
2024-05-30,19129.241927283278,West
2024-05-31,17777.228291329746,West
2024-06-01,17927.139504850056,West
2024-06-02,18784.226217974738,West
2024-06-03,18535.671749786678,West
2024-06-04,20811.1594581382,West
2024-06-05,20144.038313935373,West
2024-06-06,19919.294639641048,West
2024-06-07,14819.328810887704,West
2024-06-08,16825.96341972766,West
2024-06-09,18947.41294318505,West
2024-06-10,17991.568539146356,West
2024-06-11,16283.93170187387,West
2024-06-12,19287.32948135529,West
2024-06-13,21401.8388907697,West
2024-06-14,18755.153547944945,West
2024-06-15,18522.68796754859,West
2024-06-16,16419.513642928043,West
2024-06-17,21178.471255373915,West
2024-06-18,16176.12524008794,West
2024-06-19,13375.585132108625,West
2024-06-20,16934.499531757043,West
2024-06-21,17700.580549961916,West
2024-06-22,18093.594844324343,West
2024-06-23,18236.26693960681,West
2024-06-24,20470.849697466605,West
2024-06-25,17982.98470379983,West
2024-06-26,18400.16418999319,West
2024-06-27,18409.634490607354,West
2024-06-28,17295.706507087754,West
2024-06-29,16697.639561270447,West
2024-06-30,19692.856301682652,West

</script><script type="text/plain" id="metrics_data" data-format="csv_embedded" data-src="">
Week,Value,Metric,Source
1,91.14620637457325,Metric A,Source 1
2,106.73864467610528,Metric A,Source 1
3,112.40847616084115,Metric A,Source 1
4,92.42894975790337,Metric A,Source 1
5,139.32943116588044,Metric A,Source 1
6,127.30737922996286,Metric A,Source 1
7,118.35616959151506,Metric A,Source 1
8,102.73776461983559,Metric A,Source 1
9,128.4039259186555,Metric A,Source 1
10,119.8735591950983,Metric A,Source 1
11,161.05951309028399,Metric A,Source 1
12,127.2523238766328,Metric A,Source 1
1,98.46294467116608,Metric A,Source 2
2,106.32932755543409,Metric A,Source 2
3,110.73512181071523,Metric A,Source 2
4,95.21911717224178,Metric A,Source 2
5,117.89129795974462,Metric A,Source 2
6,162.87587470488882,Metric A,Source 2
7,110.10964849781647,Metric A,Source 2
8,108.50719132519825,Metric A,Source 2
9,101.37624684849952,Metric A,Source 2
10,128.3434057632589,Metric A,Source 2
11,138.62292523831226,Metric A,Source 2
12,160.31724604691345,Metric A,Source 2
1,74.57198900562172,Metric A,Source 3
2,48.57513571191307,Metric A,Source 3
3,84.94137508793135,Metric A,Source 3
4,112.04603670124895,Metric A,Source 3
5,135.058391642248,Metric A,Source 3
6,101.26551488658197,Metric A,Source 3
7,139.19350827607119,Metric A,Source 3
8,96.82824185405147,Metric A,Source 3
9,147.32555853619613,Metric A,Source 3
10,159.9459468632083,Metric A,Source 3
11,115.95092338701738,Metric A,Source 3
12,119.72066806203689,Metric A,Source 3
1,92.46041509195692,Metric B,Source 1
2,79.64572592320306,Metric B,Source 1
3,135.0750259948613,Metric B,Source 1
4,132.08399253894197,Metric B,Source 1
5,125.56976129876472,Metric B,Source 1
6,135.9458998488901,Metric B,Source 1
7,98.58742536680792,Metric B,Source 1
8,174.08242901385415,Metric B,Source 1
9,130.75825767849307,Metric B,Source 1
10,132.6019715309094,Metric B,Source 1
11,153.81153628997524,Metric B,Source 1
12,143.62529316920376,Metric B,Source 1
1,105.35042215955359,Metric B,Source 2
2,147.774237166005,Metric B,Source 2
3,125.23562715459116,Metric B,Source 2
4,105.39936105481681,Metric B,Source 2
5,106.17799758404294,Metric B,Source 2
6,110.74685121682839,Metric B,Source 2
7,127.83067701732041,Metric B,Source 2
8,116.67772412063987,Metric B,Source 2
9,108.07093315756994,Metric B,Source 2
10,155.93369936243093,Metric B,Source 2
11,150.06562328178993,Metric B,Source 2
12,112.92106350366859,Metric B,Source 2
1,128.17845701956145,Metric B,Source 3
2,99.3296786539486,Metric B,Source 3
3,131.47443946310057,Metric B,Source 3
4,131.70948570926686,Metric B,Source 3
5,141.04915197229678,Metric B,Source 3
6,69.97357767761655,Metric B,Source 3
7,130.74138810523687,Metric B,Source 3
8,147.29144110900202,Metric B,Source 3
9,140.11259659127154,Metric B,Source 3
10,117.84357141153694,Metric B,Source 3
11,136.22615579533655,Metric B,Source 3
12,144.0963027799092,Metric B,Source 3
1,135.57435033400256,Metric C,Source 1
2,95.09651309112898,Metric C,Source 1
3,87.28152580047416,Metric C,Source 1
4,125.53883677567465,Metric C,Source 1
5,118.07138324243732,Metric C,Source 1
6,124.53527436010151,Metric C,Source 1
7,117.98714578845929,Metric C,Source 1
8,130.24309924651826,Metric C,Source 1
9,200.5378534783172,Metric C,Source 1
10,114.4364733078424,Metric C,Source 1
11,99.25505180791359,Metric C,Source 1
12,151.4674885645606,Metric C,Source 1
1,84.39733807685882,Metric C,Source 2
2,69.67948325643965,Metric C,Source 2
3,105.21105600456313,Metric C,Source 2
4,76.9701365027553,Metric C,Source 2
5,136.11907268834682,Metric C,Source 2
6,123.3674370742462,Metric C,Source 2
7,78.9264001992479,Metric C,Source 2
8,125.82866291435434,Metric C,Source 2
9,105.2422484444334,Metric C,Source 2
10,126.39765478908976,Metric C,Source 2
11,96.07861585127866,Metric C,Source 2
12,105.52967703004614,Metric C,Source 2
1,95.22372381112693,Metric C,Source 3
2,115.76691553924034,Metric C,Source 3
3,107.17726734368617,Metric C,Source 3
4,110.92206298700049,Metric C,Source 3
5,102.34968209284725,Metric C,Source 3
6,93.11406131875614,Metric C,Source 3
7,119.44604713912274,Metric C,Source 3
8,137.7122554958862,Metric C,Source 3
9,120.04284421021808,Metric C,Source 3
10,111.95417414228955,Metric C,Source 3
11,138.12819315212198,Metric C,Source 3
12,135.29140831658822,Metric C,Source 3
1,102.34989193765736,Metric D,Source 1
2,113.98074533855377,Metric D,Source 1
3,110.58220921976671,Metric D,Source 1
4,129.03300282059445,Metric D,Source 1
5,92.44852478216939,Metric D,Source 1
6,103.29668403475145,Metric D,Source 1
7,128.35195963198305,Metric D,Source 1
8,128.91778987651816,Metric D,Source 1
9,155.86765212183246,Metric D,Source 1
10,124.18363863478118,Metric D,Source 1
11,151.02964900052172,Metric D,Source 1
12,132.6052587192819,Metric D,Source 1
1,69.86048490886536,Metric D,Source 2
2,92.209280780211,Metric D,Source 2
3,125.80370057833105,Metric D,Source 2
4,90.81774083180312,Metric D,Source 2
5,111.02517515926301,Metric D,Source 2
6,134.83278671042342,Metric D,Source 2
7,138.52173453490957,Metric D,Source 2
8,102.50701036307981,Metric D,Source 2
9,128.99032761455416,Metric D,Source 2
10,93.07939820188578,Metric D,Source 2
11,169.6480555436283,Metric D,Source 2
12,104.23902203407118,Metric D,Source 2
1,129.72800204724396,Metric D,Source 3
2,116.7723943284842,Metric D,Source 3
3,137.78318062695632,Metric D,Source 3
4,131.22499853400032,Metric D,Source 3
5,120.23075350896802,Metric D,Source 3
6,119.47558954593504,Metric D,Source 3
7,90.63971177046324,Metric D,Source 3
8,118.57004774985671,Metric D,Source 3
9,127.26219624959732,Metric D,Source 3
10,146.46576881360483,Metric D,Source 3
11,131.9580008662773,Metric D,Source 3
12,157.83583841545737,Metric D,Source 3

</script><script type="text/plain" id="compare_data" data-format="csv_embedded" data-src="">
Time,Value,Category
1,11.967080399780984,Cat 1
2,6.021390753085862,Cat 1
3,13.339773583839197,Cat 1
4,13.02440490300445,Cat 1
5,14.189095510157982,Cat 1
6,12.363067122926035,Cat 1
7,9.096431142977838,Cat 1
8,16.931685740361864,Cat 1
9,14.198828745620345,Cat 1
10,13.948839912015842,Cat 1
11,18.405717034341507,Cat 1
12,13.154238419159144,Cat 1
13,16.680551037714213,Cat 1
14,18.42871046457639,Cat 1
15,18.280606093072166,Cat 1
16,14.425256842003929,Cat 1
17,15.364342880394176,Cat 1
18,16.898403465271773,Cat 1
19,21.459148016779725,Cat 1
20,22.022889654176847,Cat 1
1,12.935299811663603,Cat 2
2,17.530563621150094,Cat 2
3,8.21410097111773,Cat 2
4,10.884628934438389,Cat 2
5,8.205485320131743,Cat 2
6,8.967814488886212,Cat 2
7,19.84602835309171,Cat 2
8,16.100350239473407,Cat 2
9,6.994227148133186,Cat 2
10,18.247725694485112,Cat 2
11,14.15034685285767,Cat 2
12,15.735516240420958,Cat 2
13,15.50283561100006,Cat 2
14,14.065690208286101,Cat 2
15,17.291568640304398,Cat 2
16,13.645989774435037,Cat 2
17,20.694917501477637,Cat 2
18,23.400237624393995,Cat 2
19,23.90441093790094,Cat 2
20,20.782528527764324,Cat 2
1,10.68431814985805,Cat 3
2,16.73341114286022,Cat 3
3,8.696319900872973,Cat 3
4,5.623549565114571,Cat 3
5,9.357000994975301,Cat 3
6,13.883026769313465,Cat 3
7,15.608031518770282,Cat 3
8,13.841045820103961,Cat 3
9,14.844276654211294,Cat 3
10,16.813671462583475,Cat 3
11,16.024410419322752,Cat 3
12,16.506195017606498,Cat 3
13,19.657232844415205,Cat 3
14,15.843693233479204,Cat 3
15,18.48226264467191,Cat 3
16,16.506274850336666,Cat 3
17,17.48807081070907,Cat 3
18,24.523131827741242,Cat 3
19,23.87303354478853,Cat 3
20,19.603420037749856,Cat 3

</script><script type="text/plain" id="product_values" data-format="csv_embedded" data-src="">
Time,Value,Product
0.0,62.55052931327036,Product A
0.5,69.06379229118593,Product A
1.0,61.73930135991943,Product A
1.5,69.14379441717485,Product A
2.0,73.10759269218265,Product A
2.5,71.43355837583401,Product A
3.0,71.52595940082807,Product A
3.5,73.28965964744228,Product A
4.0,74.90123558255593,Product A
4.5,68.84431966401463,Product A
5.0,59.92729415825747,Product A
5.5,70.14752191831971,Product A
6.0,69.04950660775252,Product A
6.5,73.7777680226415,Product A
7.0,72.84810476214015,Product A
7.5,61.17174819720693,Product A
8.0,70.56087573283986,Product A
8.5,70.57050356386176,Product A
9.0,72.21937473098744,Product A
9.5,77.69981365023875,Product A
10.0,72.56415083918482,Product A
10.5,73.28923617146997,Product A
11.0,69.8028659985627,Product A
11.5,74.21095678406064,Product A
12.0,73.15607225069076,Product A
12.5,72.32916974394507,Product A
13.0,61.94181481593233,Product A
13.5,65.84181084572721,Product A
14.0,62.38760201290534,Product A
14.5,63.818689692539564,Product A
15.0,68.72684498917984,Product A
15.5,60.397503167286466,Product A
16.0,66.24327060561143,Product A
16.5,45.71644468743205,Product A
17.0,67.10285502534364,Product A
17.5,65.35637368540858,Product A
18.0,53.55844971354765,Product A
18.5,57.55097029972909,Product A
19.0,64.97598136092967,Product A
19.5,53.226974340543485,Product A
20.0,54.836286064107576,Product A
0.0,54.205454618775754,Product B
0.5,53.15031941704279,Product B
1.0,44.03641445925639,Product B
1.5,66.36059776451788,Product B
2.0,50.53889764162329,Product B
2.5,54.337614009061,Product B
3.0,56.56882115077364,Product B
3.5,57.152118212170016,Product B
4.0,69.07174656236496,Product B
4.5,69.3216912402651,Product B
5.0,74.33584026640179,Product B
5.5,61.0092753309874,Product B
6.0,78.40369638615348,Product B
6.5,67.31961208054035,Product B
7.0,71.39149996820011,Product B
7.5,69.38764226512896,Product B
8.0,70.59689613973075,Product B
8.5,64.72373947072836,Product B
9.0,72.05468117405924,Product B
9.5,64.72721249491602,Product B
10.0,70.85550604252877,Product B
10.5,71.71053138584139,Product B
11.0,66.11911851732918,Product B
11.5,68.710453294297,Product B
12.0,62.42524856766281,Product B
12.5,35.88685876018703,Product B
13.0,40.043371816092474,Product B
13.5,40.88622845358117,Product B
14.0,42.2158427015705,Product B
14.5,41.763948802622444,Product B
15.0,41.85625974002638,Product B
15.5,45.90811576337845,Product B
16.0,33.51072980634262,Product B
16.5,31.506534789207844,Product B
17.0,41.60118525698405,Product B
17.5,34.790986995943456,Product B
18.0,38.73927450309498,Product B
18.5,33.806697222799926,Product B
19.0,42.67165419164006,Product B
19.5,37.012469098006974,Product B
20.0,46.74726303732144,Product B
0.0,30.086371841557757,Product C
0.5,33.52163447532588,Product C
1.0,33.418362935222575,Product C
1.5,35.90821851991103,Product C
2.0,36.30682749505989,Product C
2.5,27.95142538541033,Product C
3.0,34.296613425464784,Product C
3.5,33.68809705623389,Product C
4.0,32.97993602983415,Product C
4.5,55.77142866572188,Product C
5.0,55.12985576613776,Product C
5.5,68.05070430559256,Product C
6.0,67.11166448939053,Product C
6.5,70.2579008862711,Product C
7.0,61.666606307468605,Product C
7.5,63.1624857266713,Product C
8.0,70.60638957502944,Product C
8.5,70.9507290507576,Product C
9.0,61.54388730097955,Product C
9.5,67.35636237504171,Product C
10.0,71.30560714196402,Product C
10.5,64.8964166712621,Product C
11.0,62.12860044668729,Product C
11.5,63.337431738182715,Product C
12.0,73.62858582448878,Product C
12.5,67.55797476155429,Product C
13.0,66.97576865943134,Product C
13.5,61.76029386315613,Product C
14.0,65.73714041646379,Product C
14.5,71.8030573434442,Product C
15.0,58.20812295332509,Product C
15.5,66.63849553555629,Product C
16.0,60.02429874238927,Product C
16.5,71.12727498277467,Product C
17.0,66.92131684616265,Product C
17.5,67.3062938998331,Product C
18.0,64.30510766488719,Product C
18.5,57.46251699980379,Product C
19.0,53.88124441082948,Product C
19.5,60.679333416071536,Product C
20.0,56.41554881364987,Product C

</script><script type="text/plain" id="sales_data_x" data-format="csv_embedded" data-src="">
Quarter,Month,Week,Revenue,Units,Region,Product
1,1,1,53780.22065916621,503.5001771235509,North,Widget
2,4,14,62545.75113168249,553.9065693242377,North,Widget
3,7,27,62920.83278533169,568.1924963065392,North,Widget
4,10,40,42806.74685202544,556.8799170944376,North,Widget
5,13,53,68296.49415379147,654.2984565701167,North,Widget
6,16,66,65600.4893297276,416.5942030616737,North,Widget
7,19,79,47733.46119535667,543.6861449930152,North,Widget
8,22,92,42584.92679743078,698.1797042532337,North,Widget
9,25,105,61228.94686214841,729.40746429313,North,Widget
10,28,118,71810.6464930205,744.8218361086663,North,Widget
11,31,131,93035.86963717421,675.1795596439335,North,Widget
12,34,144,72196.32956760396,958.5110604842549,North,Widget
1,1,1,42867.67456893784,602.7157091802203,North,Gadget
2,4,14,68648.04078773322,538.8971241320644,North,Gadget
3,7,27,59869.352724648874,578.6394233449853,North,Gadget
4,10,40,61142.43413645271,767.2256694934933,North,Gadget
5,13,53,67990.09388396726,728.3231308575248,North,Gadget
6,16,66,57687.27801924371,701.3692017676273,North,Gadget
7,19,79,75721.64462756323,636.297861397587,North,Gadget
8,22,92,74862.33498990082,610.7370859810131,North,Gadget
9,25,105,64658.99596031314,609.4556214125132,North,Gadget
10,28,118,65880.04091555942,861.4279399670902,North,Gadget
11,31,131,59426.70910588714,747.3609582187042,North,Gadget
12,34,144,55907.125510401005,766.3988608862156,North,Gadget
1,1,1,41498.58582502938,573.1622290053333,North,Gizmo
2,4,14,52936.98836130123,561.6785823543105,North,Gizmo
3,7,27,65527.45898428102,450.3466202707059,North,Gizmo
4,10,40,38975.52943046135,556.257870551409,North,Gizmo
5,13,53,69537.21548463317,533.1835517225647,North,Gizmo
6,16,66,55777.392284244954,709.8826737813872,North,Gizmo
7,19,79,69843.54031042832,777.5672431977864,North,Gizmo
8,22,92,77707.84744227107,476.0655526050599,North,Gizmo
9,25,105,73970.09839814856,711.4299381099122,North,Gizmo
10,28,118,66102.72471311304,726.1571745634042,North,Gizmo
11,31,131,67782.63296398426,545.7711281951466,North,Gizmo
12,34,144,84360.97550240152,664.8482585118531,North,Gizmo
1,1,1,42055.70364499961,381.41916544193657,South,Widget
2,4,14,44733.994569359566,461.4548992875408,South,Widget
3,7,27,73701.17124805402,654.2729246648138,South,Widget
4,10,40,41170.86858522492,583.4829292801171,South,Widget
5,13,53,47581.22037371849,688.67681022991,South,Widget
6,16,66,53423.00206799022,607.8854161240497,South,Widget
7,19,79,62737.81172689135,684.575813199169,South,Widget
8,22,92,41842.23381593566,723.6084205475071,South,Widget
9,25,105,80122.154695906,915.1745636005721,South,Widget
10,28,118,81616.08732111008,637.9696168268025,South,Widget
11,31,131,69810.65417785922,862.7321138777927,South,Widget
12,34,144,54220.05026827793,660.9852990940024,South,Widget
1,1,1,41149.25169660361,452.50756957104295,South,Gadget
2,4,14,58402.95257148908,557.667980031782,South,Gadget
3,7,27,57704.20443575039,480.7886545879073,South,Gadget
4,10,40,65831.04452725156,667.1058024352556,South,Gadget
5,13,53,45743.32427240752,643.1017033240946,South,Gadget
6,16,66,58082.20190782519,596.538725110762,South,Gadget
7,19,79,71993.25791614508,663.9104259127614,South,Gadget
8,22,92,52478.43176164954,665.0721408023855,South,Gadget
9,25,105,44036.87780367778,763.3717559700112,South,Gadget
10,28,118,70161.49792685508,639.5914641119148,South,Gadget
11,31,131,75577.48296045214,708.3763455712543,South,Gadget
12,34,144,73056.06450777702,713.8433069838782,South,Gadget
1,1,1,46670.47286264012,530.3324356310729,South,Gizmo
2,4,14,53271.89689715052,256.9665008291182,South,Gizmo
3,7,27,74671.93715055558,552.790545620702,South,Gizmo
4,10,40,58896.6202025588,628.6844826831842,South,Gizmo
5,13,53,48539.17451716538,581.9726486182608,South,Gizmo
6,16,66,52243.22058225581,583.6650161413388,South,Gizmo
7,19,79,49015.4060344366,581.1205625800711,South,Gizmo
8,22,92,61272.58498044833,734.2165103983659,South,Gizmo
9,25,105,66019.2697382322,844.440290964437,South,Gizmo
10,28,118,69757.47395633467,853.4053740831853,South,Gizmo
11,31,131,74309.59078017238,733.1193274424667,South,Gizmo
12,34,144,70064.21097810192,762.2893968213322,South,Gizmo
1,1,1,25389.549673506895,687.4217914360426,East,Widget
2,4,14,65542.52202334891,590.105946876365,East,Widget
3,7,27,46002.444134378384,719.0335569846065,East,Widget
4,10,40,49907.20837425432,707.2931515418188,East,Widget
5,13,53,57317.74536131916,605.3501433423655,East,Widget
6,16,66,66448.03332767492,616.0614020199347,East,Widget
7,19,79,71326.68663944837,605.9220378344253,East,Widget
8,22,92,70792.6623753673,710.0659974121629,East,Widget
9,25,105,74190.85634930982,716.8718014114896,East,Widget
10,28,118,71191.99415242046,693.4748056111018,East,Widget
11,31,131,71807.6878999976,685.0505349048758,East,Widget
12,34,144,80384.74180987944,823.3747886619116,East,Widget
1,1,1,38934.52066337524,443.8723092775084,East,Gadget
2,4,14,50302.78556370103,692.7276086892812,East,Gadget
3,7,27,58165.645525937805,656.8607441536528,East,Gadget
4,10,40,56766.85990236078,349.3687579013931,East,Gadget
5,13,53,52875.750130489236,390.5190229398829,East,Gadget
6,16,66,59569.124664445924,602.0036571180658,East,Gadget
7,19,79,77618.79041057471,495.7925824230305,East,Gadget
8,22,92,56997.866220592594,666.969675503794,East,Gadget
9,25,105,53511.889464694075,693.9775807926172,East,Gadget
10,28,118,67456.62267655996,558.1792597586484,East,Gadget
11,31,131,67165.69788850701,625.544427994462,East,Gadget
12,34,144,56683.207621958485,882.4601750056598,East,Gadget
1,1,1,69909.42819525731,495.24826140031894,East,Gizmo
2,4,14,60652.67332415289,480.27688467507375,East,Gizmo
3,7,27,44472.60430540252,521.100211015936,East,Gizmo
4,10,40,73137.63830733486,616.5267061976378,East,Gizmo
5,13,53,65412.28339885027,683.753708758151,East,Gizmo
6,16,66,63855.131746296836,616.7044237765003,East,Gizmo
7,19,79,73142.45827223817,877.1482925143871,East,Gizmo
8,22,92,53923.90974783261,818.2333432225778,East,Gizmo
9,25,105,56878.38870776203,606.7995204045171,East,Gizmo
10,28,118,66221.83404640997,684.6929801309622,East,Gizmo
11,31,131,77881.88276135846,696.0783299692671,East,Gizmo
12,34,144,67251.8420301661,655.805643899863,East,Gizmo

</script><script type="text/plain" id="grid_sales" data-format="csv_embedded" data-src="">
Month,Sales,Product,Region,Segment
1,36046.976772548085,Product X,East,Segment 1
2,43541.33537345861,Product X,East,Segment 1
3,58580.89655533582,Product X,East,Segment 1
4,51468.400820755,Product X,East,Segment 1
5,59289.52567556935,Product X,East,Segment 1
6,69208.3536964361,Product X,East,Segment 1
1,71869.84571508516,Product X,East,Segment 2
2,46388.52635340507,Product X,East,Segment 2
3,58444.88326698679,Product X,East,Segment 2
4,51956.284591547796,Product X,East,Segment 2
5,68141.57213315114,Product X,East,Segment 2
6,61919.36251149604,Product X,East,Segment 2
1,55748.995842683675,Product X,West,Segment 1
2,35321.01550580826,Product X,West,Segment 1
3,64414.1553385911,Product X,West,Segment 1
4,62587.74167968533,Product X,West,Segment 1
5,77896.23585152616,Product X,West,Segment 1
6,78670.96274043791,Product X,West,Segment 1
1,51956.11127592655,Product X,West,Segment 2
2,48152.29292833831,Product X,West,Segment 2
3,55829.53715383615,Product X,West,Segment 2
4,56771.43307594346,Product X,West,Segment 2
5,54893.50240074937,Product X,West,Segment 2
6,65275.71286574617,Product X,West,Segment 2
1,46256.404462341656,Product Y,East,Segment 1
2,69788.40337960642,Product Y,East,Segment 1
3,53488.70015146034,Product Y,East,Segment 1
4,42879.64410189974,Product Y,East,Segment 1
5,52271.709132160606,Product Y,East,Segment 1
6,63225.14276802736,Product Y,East,Segment 1
1,50056.48670285362,Product Y,East,Segment 2
2,62056.84845610755,Product Y,East,Segment 2
3,48157.33613999103,Product Y,East,Segment 2
4,66066.37222462526,Product Y,East,Segment 2
5,55167.615796277816,Product Y,East,Segment 2
6,52407.09261073251,Product Y,East,Segment 2
1,57820.41639164868,Product Y,West,Segment 1
2,65729.48045628268,Product Y,West,Segment 1
3,37736.25685862609,Product Y,West,Segment 1
4,50595.13784420311,Product Y,West,Segment 1
5,66875.77948911171,Product Y,West,Segment 1
6,65383.46287132241,Product Y,West,Segment 1
1,60788.90027413891,Product Y,West,Segment 2
2,59605.51008548443,Product Y,West,Segment 2
3,68734.84883067798,Product Y,West,Segment 2
4,71476.92239665272,Product Y,West,Segment 2
5,57129.56067873115,Product Y,West,Segment 2
6,55966.25248784129,Product Y,West,Segment 2

</script><script type="text/plain" id="headcount_data" data-format="csv_embedded" data-src="">
Department,Headcount,Team
Engineering,23,Team A
Engineering,18,Team B
Engineering,7,Team C
Sales,16,Team A
Sales,6,Team B
Sales,14,Team C
Marketing,21,Team A
Marketing,11,Team B
Marketing,17,Team C
Operations,20,Team A
Operations,9,Team B
Operations,17,Team C
HR,14,Team A
HR,5,Team B
HR,6,Team C

</script><script type="text/plain" id="market_share" data-format="csv_embedded" data-src="">
Month,MarketShare,Category
1,39.02064270720871,Category A
2,9.248901645855234,Category A
3,12.246826539476935,Category A
4,22.221354721980745,Category A
5,32.384576662156846,Category A
6,20.225005375864143,Category A
7,9.393863202702216,Category A
8,19.894765207997533,Category A
9,17.351447003849838,Category A
10,22.1700341707795,Category A
11,21.528631978788532,Category A
12,17.969429972726093,Category A
1,21.99796766713936,Category B
2,25.91626024880205,Category B
3,24.697360801916293,Category B
4,23.834454377986255,Category B
5,19.15530360971624,Category B
6,12.550437978157682,Category B
7,25.077893009555886,Category B
8,22.88495863085199,Category B
9,26.03955293109264,Category B
10,17.869961663832207,Category B
11,20.136478018274044,Category B
12,17.428761366594387,Category B
1,22.858601132023896,Category C
2,12.61446721268236,Category C
3,20.939999954289394,Category C
4,28.08081537833038,Category C
5,24.99084696474636,Category C
6,20.117667657216842,Category C
7,17.17398931857713,Category C
8,20.763594908312,Category C
9,15.718303070997486,Category C
10,11.815183236177424,Category C
11,21.402817995926437,Category C
12,27.30310521647552,Category C
1,28.715326074519453,Category D
2,15.585518740946867,Category D
3,26.709430027159534,Category D
4,13.039412885382134,Category D
5,24.783183394286944,Category D
6,20.794707281184373,Category D
7,23.556691795745664,Category D
8,26.935978180495354,Category D
9,23.6724429288465,Category D
10,21.789528800563325,Category D
11,26.753220455318047,Category D
12,20.508544409174068,Category D

</script><script type="text/plain" id="business_metrics" data-format="csv_embedded" data-src="">
Quarter,Revenue,Profit,Growth,Industry,CompanySize
1,63.09250860062127,31.85523725839545,9.95526882073147,Tech,Small
2,76.96260057165777,17.82933725901385,3.419069411901583,Tech,Small
3,116.09604165401353,18.457996648699805,2.4283484316630477,Tech,Small
4,73.23164661702516,22.35805308611482,5.67302307702384,Tech,Small
1,107.40487762991198,23.61576312391867,8.114219066974542,Tech,Medium
2,115.42554886556368,16.49752703813218,7.0813937269182885,Tech,Medium
3,112.1285354234116,13.701193375107454,8.906300546649197,Tech,Medium
4,94.60297024782831,21.51259877271616,0.4354986477848177,Tech,Medium
1,110.10214946287172,21.184445931220218,4.96293124164624,Tech,Large
2,104.53538331565466,17.45601436258706,0.012284491104631812,Tech,Large
3,116.0655769549202,14.33943101055916,5.615136784211084,Tech,Large
4,115.14292994185928,19.76761770451545,1.7060790828287749,Tech,Large
1,109.173946879095,17.58129383270881,6.5594840284263425,Finance,Small
2,101.22742922587115,18.401336654669706,5.080293357281874,Finance,Small
3,80.7459284295812,14.764624106567569,10.537015557566582,Finance,Small
4,111.15807194803334,23.42659465025648,5.927361343261945,Finance,Small
1,75.3007738829186,20.14616259513904,6.105153917879229,Finance,Medium
2,129.0134864671695,18.812044172497952,1.4699756153915757,Finance,Medium
3,89.27047933355365,26.888407681090758,3.430516435221289,Finance,Medium
4,157.43387251201506,17.76401944970274,5.478986055299444,Finance,Medium
1,105.74597288227176,20.660129810742625,0.9485993815285418,Finance,Large
2,97.19739917391914,21.636897945782987,5.701639094885234,Finance,Large
3,96.68478223173342,32.21815870030392,4.392828316040838,Finance,Large
4,77.74844425480137,16.372653234719053,4.744862870911971,Finance,Large
1,106.991738874415,17.579298166483593,0.9130292958723203,Healthcare,Small
2,94.85198770196237,26.30157269955874,2.7552018647959837,Healthcare,Small
3,112.51174835128639,11.44709125031366,3.876287330715441,Healthcare,Small
4,63.48423765990957,22.117571511969324,7.794239233712055,Healthcare,Small
1,103.81369082367875,26.31500592984836,1.2926970000437477,Healthcare,Medium
2,95.02759709160647,26.449692990925044,4.218722429115536,Healthcare,Medium
3,82.89393270136291,18.56961288532291,7.442278706047402,Healthcare,Medium
4,110.48141798083726,22.946249147933397,6.576411836031838,Healthcare,Medium
1,87.95814108484187,17.15918751452318,5.910308235732036,Healthcare,Large
2,96.11631700583264,17.412375671014875,5.9270427103635885,Healthcare,Large
3,99.73218744484261,26.331809229723568,0.45047938932926446,Healthcare,Large
4,105.72769853575487,19.563160032629,6.3866361240305265,Healthcare,Large

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/areachart_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>AreaChart Examples</h1>
<p>This page demonstrates the key features of AreaChart plots in JSPlots.</p>
<ul>
    <li><strong>Continuous areas:</strong> Smooth filled areas for continuous x values (like dates)</li>
    <li><strong>Discrete areas:</strong> Bar-style areas for categorical x values</li>
    <li><strong>Stack modes:</strong> Unstack (overlapping), stack (cumulative), and normalized stack (percentage)</li>
    <li><strong>Grouping:</strong> Multiple series with automatic color assignment and legend</li>
    <li><strong>Interactive filters:</strong> Dropdown menus to filter data dynamically</li>
    <li><strong>Dynamic controls:</strong> Change X-axis, grouping, stacking, and faceting on the fly</li>
    <li><strong>Faceting:</strong> Facet wrap (1 variable) and facet grid (2 variables)</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Example 1: Regional Sales Over Time (Stacked Area Chart)</h2>
<p>Continuous time series with dates on x-axis. Stacked areas show cumulative sales across regions.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_stacked_area">Stack mode: </label>
            <select id="stack_mode_select_stacked_area" onchange="updatePlot_stacked_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="stacked_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_by_region</p><br>
<hr>
<br>
<h2>Example 2: Product Values - Continuous Unstack</h2>
<p>Continuous x-axis (numeric). Overlapping areas with transparency allow comparison of individual trends.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_unstacked_area">Stack mode: </label>
            <select id="stack_mode_select_unstacked_area" onchange="updatePlot_unstacked_area()">
                <option value="unstack" selected>unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="unstacked_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: product_values</p><br>
<hr>
<br>
<h2>Example 3: Market Share Distribution (Normalized Stack)</h2>
<p>Continuous numeric x-axis. Normalized stacking shows relative proportions - total always reaches 100%.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_normalized_area">Stack mode: </label>
            <select id="stack_mode_select_normalized_area" onchange="updatePlot_normalized_area()">
                <option value="unstack">unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack" selected>normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="normalized_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: market_share</p><br>
<hr>
<br>
<h2>Example 4: Headcount by Department (Discrete/Stacked Bars)</h2>
<p>Categorical x-axis. When x values are discrete, areas automatically become stacked bars.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_discrete_area">Stack mode: </label>
            <select id="stack_mode_select_discrete_area" onchange="updatePlot_discrete_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="discrete_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: headcount_data</p><br>
<hr>
<br>
<h2>Example 5: Revenue by Channel with Filters</h2>
<p>Continuous date axis with interactive filters. Select different years and regions to update the view.</p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0;">Filters</h4>
            <div style="margin: 10px;">
            <label for="Year_select_filtered_area">Year: </label>
            <select id="Year_select_filtered_area" multiple onchange="updatePlot_filtered_area()">
                <option value="2022">2022</option>
                <option value="2023">2023</option>
                <option value="2024" selected>2024</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="Region_select_filtered_area">Region: </label>
            <select id="Region_select_filtered_area" multiple onchange="updatePlot_filtered_area()">
                <option value="North" selected>North</option>
                <option value="South">South</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_filtered_area">Stack mode: </label>
            <select id="stack_mode_select_filtered_area" onchange="updatePlot_filtered_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="filtered_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: channel_revenue</p><br>
<hr>
<br>
<h2>Example 6: Metrics by Source (Facet Wrap)</h2>
<p>Continuous x-axis with faceting. Each facet shows one metric with stacked sources.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_facet_wrap_area">Stack mode: </label>
            <select id="stack_mode_select_facet_wrap_area" onchange="updatePlot_facet_wrap_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px;">
            <label for="facet1_select_facet_wrap_area">Facet by: </label>
            <select id="facet1_select_facet_wrap_area" onchange="updatePlot_facet_wrap_area()">
                <option value="None">None</option>
                <option value="Metric" selected>Metric</option>
            </select>
        </div>
        
</div>

<!-- Chart -->
<div id="facet_wrap_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: metrics_data</p><br>
<hr>
<br>
<h2>Example 7: Sales by Product and Region (Facet Grid)</h2>
<p>Continuous x-axis with 2D facet grid. Products in rows, Regions in columns.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_facet_grid_area">Stack mode: </label>
            <select id="stack_mode_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px;">
            <label for="facet1_select_facet_grid_area">Facet 1: </label>
            <select id="facet1_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="None">None</option>
                <option value="Product" selected>Product</option>
                <option value="Region">Region</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_facet_grid_area">Facet 2: </label>
            <select id="facet2_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="None">None</option>
                <option value="Product">Product</option>
                <option value="Region" selected>Region</option>
            </select>
        </div>
        
</div>

<!-- Chart -->
<div id="facet_grid_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: grid_sales</p><br>
<hr>
<br>
<h2>Example 8: Business Metrics with Dynamic Controls</h2>
<p>Continuous x-axis. Use dropdowns to dynamically change: Y metric, grouping variable, stack mode, and faceting.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="y_col_select_dynamic_grouping">Y dimension: </label>
            <select id="y_col_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="Revenue" selected>Revenue</option>
                <option value="Profit">Profit</option>
                <option value="Growth">Growth</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="color_col_select_dynamic_grouping">Color by: </label>
            <select id="color_col_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="Industry" selected>Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="stack_mode_select_dynamic_grouping">Stack mode: </label>
            <select id="stack_mode_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
            <div style="margin: 10px;">
            <label for="facet1_select_dynamic_grouping">Facet 1: </label>
            <select id="facet1_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="None" selected>None</option>
                <option value="Industry">Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_dynamic_grouping">Facet 2: </label>
            <select id="facet2_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="None" selected>None</option>
                <option value="Industry">Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
        
</div>

<!-- Chart -->
<div id="dynamic_grouping"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: business_metrics</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Stack Mode Comparison</h2>
<p>The following three charts use the same data but different stack modes to illustrate their differences:</p>

    </div>
<br>
<hr>
<br>
<h2>Stack Mode: UNSTACK</h2>
<p>Areas overlap with transparency - see individual trends clearly</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_unstack_mode">Stack mode: </label>
            <select id="stack_mode_select_unstack_mode" onchange="updatePlot_unstack_mode()">
                <option value="unstack" selected>unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="unstack_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
<h2>Stack Mode: STACK</h2>
<p>Areas are stacked - shows cumulative total and individual contributions</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_stack_mode">Stack mode: </label>
            <select id="stack_mode_select_stack_mode" onchange="updatePlot_stack_mode()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="stack_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
<h2>Stack Mode: NORMALIZED STACK</h2>
<p>Areas are stacked and normalized to 100% - shows relative proportions over time</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="stack_mode_select_normalized_mode">Stack mode: </label>
            <select id="stack_mode_select_normalized_mode" onchange="updatePlot_normalized_mode()">
                <option value="unstack">unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack" selected>normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="normalized_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Dynamic X-Axis Selection</h2>
<p>This example demonstrates how to dynamically change the X-axis dimension from within the HTML page.</p>
<p>Try switching between Quarter, Month, and Week views using the dropdown control!</p>

    </div>
<br>
<hr>
<br>
<h2>Example 10: Sales with Dynamic X-Axis Selection</h2>
<p>Use the X-Axis dropdown to switch between different time granularities (Quarter/Month/Week). Also switch between Revenue and Units on Y-axis.</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="x_col_select_dynamic_x_axis">X dimension: </label>
            <select id="x_col_select_dynamic_x_axis" onchange="updatePlot_dynamic_x_axis()">
                <option value="Quarter" selected>Quarter</option>
                <option value="Month">Month</option>
                <option value="Week">Week</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="y_col_select_dynamic_x_axis">Y dimension: </label>
            <select id="y_col_select_dynamic_x_axis" onchange="updatePlot_dynamic_x_axis()">
                <option value="Revenue" selected>Revenue</option>
                <option value="Units">Units</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="stack_mode_select_dynamic_x_axis">Stack mode: </label>
            <select id="stack_mode_select_dynamic_x_axis" onchange="updatePlot_dynamic_x_axis()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalised_stack</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="dynamic_x_axis"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data_x</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Key Features Summary</h2>
<ul>
    <li><strong>Automatic discrete/continuous detection:</strong> Continuous x values (dates, numeric) create smooth areas; discrete x values (categories) create stacked bars</li>
    <li><strong>Three stack modes:</strong>
        <ul>
            <li><em>Unstack:</em> Overlapping areas with transparency - best for comparing trends</li>
            <li><em>Stack:</em> Cumulative areas - best for showing total and parts</li>
            <li><em>Normalized stack:</em> Percentage areas - best for showing proportions</li>
        </ul>
    </li>
    <li><strong>Dynamic X-axis selection:</strong> Switch between different X-axis dimensions (e.g., Quarter/Month/Week) from dropdown</li>
    <li><strong>Dynamic grouping:</strong> Choose which variable to group/color by from dropdown</li>
    <li><strong>Interactive filters:</strong> Filter data dynamically with dropdown menus</li>
    <li><strong>Faceting:</strong> Create small multiples with 1 or 2 faceting variables</li>
    <li><strong>Customization:</strong> Control opacity, titles, and stack modes</li>
    <li><strong>Date support:</strong> Automatic formatting and proper handling of date-based time series</li>
</ul>
<p><strong>Tip:</strong> Hover over areas to see detailed values. Use the dropdown controls to explore different views of your data!</p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
