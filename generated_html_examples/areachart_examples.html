<!DOCTYPE html>
<html>
<head>
    <title>AreaChart Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>
</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                resolve(results.data);
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                resolve(data);
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        resolve(results.data);
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Date'];
    const Y_COLS = ['Sales'];
    const GROUP_COLS = ['Region'];
    const COLOR_MAPS = {'Region': {'East': '#00cc96', 'West': '#ab63fa', 'North': '#636efa', 'South': '#EF553B'}};
    const GROUP_ORDER = {'Region': ['North', 'South', 'East', 'West']};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_GROUP_COL = 'Region';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_stacked_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stacked_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stacked_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_stacked_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_stacked_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stacked_area');
        const facet2Select = document.getElementById('facet2_select_stacked_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_by_region').then(function(data) {
        allData = data;
        window.updatePlot_stacked_area();
    }).catch(function(error) {
        console.error('Error loading data for chart stacked_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Product'];
    const COLOR_MAPS = {'Product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product B': '#EF553B'}};
    const GROUP_ORDER = {'Product': ['Product A', 'Product B', 'Product C']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Product';
    const FILL_OPACITY = 0.4;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_unstacked_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_unstacked_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_unstacked_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_unstacked_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_unstacked_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'unstack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_unstacked_area');
        const facet2Select = document.getElementById('facet2_select_unstacked_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('product_values').then(function(data) {
        allData = data;
        window.updatePlot_unstacked_area();
    }).catch(function(error) {
        console.error('Error loading data for chart unstacked_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['MarketShare'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Category D': '#ab63fa', 'Category C': '#00cc96', 'Category B': '#EF553B', 'Category A': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Category A', 'Category B', 'Category C', 'Category D']};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'MarketShare';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_normalized_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_normalized_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_normalized_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_normalized_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_normalized_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'normalised_stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_normalized_area');
        const facet2Select = document.getElementById('facet2_select_normalized_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('market_share').then(function(data) {
        allData = data;
        window.updatePlot_normalized_area();
    }).catch(function(error) {
        console.error('Error loading data for chart normalized_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Department'];
    const Y_COLS = ['Headcount'];
    const GROUP_COLS = ['Team'];
    const COLOR_MAPS = {'Team': {'Team C': '#00cc96', 'Team B': '#EF553B', 'Team A': '#636efa'}};
    const GROUP_ORDER = {'Team': ['Team A', 'Team B', 'Team C']};
    const DEFAULT_X_COL = 'Department';
    const DEFAULT_Y_COL = 'Headcount';
    const DEFAULT_GROUP_COL = 'Team';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_discrete_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_discrete_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_discrete_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_discrete_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_discrete_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_discrete_area');
        const facet2Select = document.getElementById('facet2_select_discrete_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('headcount_data').then(function(data) {
        allData = data;
        window.updatePlot_discrete_area();
    }).catch(function(error) {
        console.error('Error loading data for chart discrete_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['Year', 'Region'];
    const X_COLS = ['Date'];
    const Y_COLS = ['Revenue'];
    const GROUP_COLS = ['Channel'];
    const COLOR_MAPS = {'Channel': {'Retail': '#EF553B', 'Online': '#636efa', 'Wholesale': '#00cc96'}};
    const GROUP_ORDER = {'Channel': ['Online', 'Retail', 'Wholesale']};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_GROUP_COL = 'Channel';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_filtered_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_filtered_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_filtered_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_filtered_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_filtered_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_filtered_area');
        const facet2Select = document.getElementById('facet2_select_filtered_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('channel_revenue').then(function(data) {
        allData = data;
        window.updatePlot_filtered_area();
    }).catch(function(error) {
        console.error('Error loading data for chart filtered_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Week'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Source'];
    const COLOR_MAPS = {'Source': {'Source 1': '#636efa', 'Source 2': '#EF553B', 'Source 3': '#00cc96'}};
    const GROUP_ORDER = {'Source': ['Source 1', 'Source 2', 'Source 3']};
    const DEFAULT_X_COL = 'Week';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Source';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_facet_wrap_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_wrap_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_wrap_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_facet_wrap_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_facet_wrap_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_wrap_area');
        const facet2Select = document.getElementById('facet2_select_facet_wrap_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('metrics_data').then(function(data) {
        allData = data;
        window.updatePlot_facet_wrap_area();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_wrap_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const GROUP_COLS = ['Segment'];
    const COLOR_MAPS = {'Segment': {'Segment 1': '#636efa', 'Segment 2': '#EF553B'}};
    const GROUP_ORDER = {'Segment': ['Segment 1', 'Segment 2']};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_GROUP_COL = 'Segment';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_facet_grid_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_grid_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_grid_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_facet_grid_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_facet_grid_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_grid_area');
        const facet2Select = document.getElementById('facet2_select_facet_grid_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('grid_sales').then(function(data) {
        allData = data;
        window.updatePlot_facet_grid_area();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_grid_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Quarter'];
    const Y_COLS = ['Revenue', 'Profit', 'Growth'];
    const GROUP_COLS = ['Industry', 'CompanySize'];
    const COLOR_MAPS = {'Industry': {'Finance': '#EF553B', 'Healthcare': '#00cc96', 'Tech': '#636efa'}, 'CompanySize': {'Medium': '#EF553B', 'Small': '#636efa', 'Large': '#00cc96'}};
    const GROUP_ORDER = {'Industry': ['Tech', 'Finance', 'Healthcare'], 'CompanySize': ['Small', 'Medium', 'Large']};
    const DEFAULT_X_COL = 'Quarter';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_GROUP_COL = 'Industry';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_dynamic_grouping = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_dynamic_grouping');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_dynamic_grouping');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_dynamic_grouping');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_dynamic_grouping');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_dynamic_grouping');
        const facet2Select = document.getElementById('facet2_select_dynamic_grouping');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('business_metrics').then(function(data) {
        allData = data;
        window.updatePlot_dynamic_grouping();
    }).catch(function(error) {
        console.error('Error loading data for chart dynamic_grouping:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.5;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_unstack_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_unstack_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_unstack_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_unstack_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_unstack_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'unstack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_unstack_mode');
        const facet2Select = document.getElementById('facet2_select_unstack_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_unstack_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart unstack_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_stack_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stack_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stack_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_stack_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_stack_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stack_mode');
        const facet2Select = document.getElementById('facet2_select_stack_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_stack_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart stack_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_normalized_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_normalized_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_normalized_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_normalized_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_normalized_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'normalised_stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_normalized_mode');
        const facet2Select = document.getElementById('facet2_select_normalized_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_normalized_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart normalized_mode:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="channel_revenue" data-format="csv_embedded" data-src="">
Date,Revenue,Channel,Region,Year
2024-01-01,66044.18360670106,Online,North,2022
2024-01-08,112115.65168005369,Online,North,2022
2024-01-15,125239.86912726931,Online,North,2022
2024-01-22,92292.81921570025,Online,North,2022
2024-01-29,98346.94813656427,Online,North,2022
2024-02-05,121659.23313789105,Online,North,2022
2024-02-12,101800.08910432272,Online,North,2022
2024-02-19,65566.3753836441,Online,North,2022
2024-02-26,96563.84989739518,Online,North,2022
2024-03-04,101960.08950610386,Online,North,2022
2024-03-11,110208.04540621904,Online,North,2022
2024-03-18,121058.8390363192,Online,North,2022
2024-03-25,120509.33958830866,Online,North,2022
2024-04-01,141758.8236063987,Online,North,2022
2024-04-08,102556.61795138675,Online,North,2022
2024-04-15,96773.48098881065,Online,North,2022
2024-04-22,112482.02144202971,Online,North,2022
2024-04-29,113714.51788432275,Online,North,2022
2024-05-06,112173.42905587556,Online,North,2022
2024-05-13,90896.57405437077,Online,North,2022
2024-05-20,146142.21523880243,Online,North,2022
2024-05-27,125994.04780893598,Online,North,2022
2024-06-03,130967.04638887211,Online,North,2022
2024-06-10,158459.2479880711,Online,North,2022
2024-06-17,132308.9650461999,Online,North,2022
2024-06-24,139959.5073324471,Online,North,2022
2024-07-01,132024.4175586676,Online,North,2022
2024-07-08,160865.7910856106,Online,North,2022
2024-07-15,123969.91337859712,Online,North,2022
2024-07-22,124620.62259353786,Online,North,2022
2024-07-29,123622.78776953371,Online,North,2022
2024-08-05,155619.68386887416,Online,North,2022
2024-08-12,116842.16627014101,Online,North,2022
2024-08-19,122338.30217796462,Online,North,2022
2024-08-26,108502.62084871522,Online,North,2022
2024-09-02,118052.33700048932,Online,North,2022
2024-09-09,138025.42550070258,Online,North,2022
2024-09-16,185216.40955522092,Online,North,2022
2024-09-23,112301.5207231016,Online,North,2022
2024-09-30,170642.69516175386,Online,North,2022
2024-10-07,133402.07300621876,Online,North,2022
2024-10-14,192258.94175675992,Online,North,2022
2024-10-21,140356.84931389906,Online,North,2022
2024-10-28,139203.26758063457,Online,North,2022
2024-11-04,157672.75812879298,Online,North,2022
2024-11-11,170271.2093908541,Online,North,2022
2024-11-18,155702.3385049038,Online,North,2022
2024-11-25,178371.3598619735,Online,North,2022
2024-12-02,165893.41058530938,Online,North,2022
2024-12-09,134221.55808974663,Online,North,2022
2024-12-16,143059.58110277384,Online,North,2022
2024-12-23,184488.8495045415,Online,North,2022
2024-12-30,107961.34369212588,Online,North,2022
2024-01-01,72974.74631575713,Online,South,2022
2024-01-08,120580.37024708431,Online,South,2022
2024-01-15,76065.12396874806,Online,South,2022
2024-01-22,113316.6879989728,Online,South,2022
2024-01-29,145328.57630734603,Online,South,2022
2024-02-05,117733.79693126488,Online,South,2022
2024-02-12,113931.60744045932,Online,South,2022
2024-02-19,94331.87700551673,Online,South,2022
2024-02-26,96204.10184593328,Online,South,2022
2024-03-04,84943.10101977865,Online,South,2022
2024-03-11,96744.208459597,Online,South,2022
2024-03-18,123494.74306947054,Online,South,2022
2024-03-25,108127.57105494339,Online,South,2022
2024-04-01,103568.95355762061,Online,South,2022
2024-04-08,109090.8121280953,Online,South,2022
2024-04-15,118373.27450155986,Online,South,2022
2024-04-22,108738.06286648584,Online,South,2022
2024-04-29,122990.46279586056,Online,South,2022
2024-05-06,110194.958199743,Online,South,2022
2024-05-13,129225.80232002617,Online,South,2022
2024-05-20,141220.30397472053,Online,South,2022
2024-05-27,158824.33826997434,Online,South,2022
2024-06-03,145322.0198444815,Online,South,2022
2024-06-10,100379.63493426755,Online,South,2022
2024-06-17,122001.77145475005,Online,South,2022
2024-06-24,146893.44693136658,Online,South,2022
2024-07-01,107362.84971223299,Online,South,2022
2024-07-08,151049.71508648008,Online,South,2022
2024-07-15,127173.15264358427,Online,South,2022
2024-07-22,107782.61968254688,Online,South,2022
2024-07-29,125269.72083389288,Online,South,2022
2024-08-05,146961.46425113236,Online,South,2022
2024-08-12,108028.3911624055,Online,South,2022
2024-08-19,135408.99581088897,Online,South,2022
2024-08-26,151176.73080714018,Online,South,2022
2024-09-02,166071.97552952598,Online,South,2022
2024-09-09,130954.85007128141,Online,South,2022
2024-09-16,123363.85064066086,Online,South,2022
2024-09-23,122217.14251165758,Online,South,2022
2024-09-30,130038.21095656467,Online,South,2022
2024-10-07,133389.00159876415,Online,South,2022
2024-10-14,168648.49239608218,Online,South,2022
2024-10-21,77601.89694155489,Online,South,2022
2024-10-28,129671.94359349132,Online,South,2022
2024-11-04,111121.09486540843,Online,South,2022
2024-11-11,142903.86560191022,Online,South,2022
2024-11-18,170495.83901771624,Online,South,2022
2024-11-25,137822.2289115151,Online,South,2022
2024-12-02,152201.6435457287,Online,South,2022
2024-12-09,136519.63600063464,Online,South,2022
2024-12-16,132867.3954134123,Online,South,2022
2024-12-23,186023.8552506959,Online,South,2022
2024-12-30,82905.20658930729,Online,South,2022
2024-01-01,112910.2076187818,Retail,North,2022
2024-01-08,128092.9086678129,Retail,North,2022
2024-01-15,107536.0476064041,Retail,North,2022
2024-01-22,132997.15760376904,Retail,North,2022
2024-01-29,86173.40925340462,Retail,North,2022
2024-02-05,101956.67452878172,Retail,North,2022
2024-02-12,82096.15266040865,Retail,North,2022
2024-02-19,100643.2291966814,Retail,North,2022
2024-02-26,115921.5552537846,Retail,North,2022
2024-03-04,116048.80109228528,Retail,North,2022
2024-03-11,119589.83199420577,Retail,North,2022
2024-03-18,108357.68443072811,Retail,North,2022
2024-03-25,113232.297121461,Retail,North,2022
2024-04-01,105473.07166720796,Retail,North,2022
2024-04-08,93485.86215345742,Retail,North,2022
2024-04-15,71830.0366865714,Retail,North,2022
2024-04-22,88207.47815916386,Retail,North,2022
2024-04-29,134489.64665765883,Retail,North,2022
2024-05-06,134027.72753443208,Retail,North,2022
2024-05-13,129405.05294234815,Retail,North,2022
2024-05-20,110420.03476178921,Retail,North,2022
2024-05-27,122047.74509014908,Retail,North,2022
2024-06-03,116685.734293733,Retail,North,2022
2024-06-10,95919.86557225556,Retail,North,2022
2024-06-17,146370.73934698084,Retail,North,2022
2024-06-24,137416.70462882708,Retail,North,2022
2024-07-01,135803.85718327388,Retail,North,2022
2024-07-08,140733.82254259387,Retail,North,2022
2024-07-15,184729.00189974948,Retail,North,2022
2024-07-22,142352.40270792326,Retail,North,2022
2024-07-29,100944.76457846884,Retail,North,2022
2024-08-05,135763.60545674086,Retail,North,2022
2024-08-12,155925.99238067298,Retail,North,2022
2024-08-19,126755.9491675876,Retail,North,2022
2024-08-26,147007.95620817316,Retail,North,2022
2024-09-02,95802.2176361144,Retail,North,2022
2024-09-09,156915.93862055131,Retail,North,2022
2024-09-16,137734.8444083627,Retail,North,2022
2024-09-23,160479.37255566893,Retail,North,2022
2024-09-30,125519.20645745334,Retail,North,2022
2024-10-07,129174.51737775943,Retail,North,2022
2024-10-14,144186.82974453966,Retail,North,2022
2024-10-21,154689.30936877662,Retail,North,2022
2024-10-28,130686.98750346019,Retail,North,2022
2024-11-04,137487.19315960738,Retail,North,2022
2024-11-11,162904.98681914088,Retail,North,2022
2024-11-18,141156.1087646305,Retail,North,2022
2024-11-25,137044.5206086368,Retail,North,2022
2024-12-02,129194.29305011795,Retail,North,2022
2024-12-09,149773.13212232594,Retail,North,2022
2024-12-16,121016.63159192928,Retail,North,2022
2024-12-23,174026.1484019659,Retail,North,2022
2024-12-30,124601.9223779779,Retail,North,2022
2024-01-01,93838.11133649797,Retail,South,2022
2024-01-08,103223.6492869802,Retail,South,2022
2024-01-15,90662.50958982926,Retail,South,2022
2024-01-22,112345.73456977945,Retail,South,2022
2024-01-29,93816.17943761339,Retail,South,2022
2024-02-05,108717.6912015727,Retail,South,2022
2024-02-12,109530.28443036396,Retail,South,2022
2024-02-19,104869.0258961139,Retail,South,2022
2024-02-26,90272.7324771974,Retail,South,2022
2024-03-04,137826.9748787494,Retail,South,2022
2024-03-11,91924.22912184626,Retail,South,2022
2024-03-18,103962.81391897076,Retail,South,2022
2024-03-25,76197.72679764037,Retail,South,2022
2024-04-01,119902.56375962129,Retail,South,2022
2024-04-08,139778.2451991887,Retail,South,2022
2024-04-15,103783.18456180778,Retail,South,2022
2024-04-22,117011.313186353,Retail,South,2022
2024-04-29,128534.42705599172,Retail,South,2022
2024-05-06,147658.50458075578,Retail,South,2022
2024-05-13,131610.95597042725,Retail,South,2022
2024-05-20,126410.66140115136,Retail,South,2022
2024-05-27,130592.1439408226,Retail,South,2022
2024-06-03,117340.15627799465,Retail,South,2022
2024-06-10,117595.18266338877,Retail,South,2022
2024-06-17,127063.45997568428,Retail,South,2022
2024-06-24,113545.46213592599,Retail,South,2022
2024-07-01,142640.68758954058,Retail,South,2022
2024-07-08,141483.69134034574,Retail,South,2022
2024-07-15,144735.52340706444,Retail,South,2022
2024-07-22,124697.9644514738,Retail,South,2022
2024-07-29,124275.6539737834,Retail,South,2022
2024-08-05,136007.04107521282,Retail,South,2022
2024-08-12,94691.49489602077,Retail,South,2022
2024-08-19,125751.23243739895,Retail,South,2022
2024-08-26,119922.35333632669,Retail,South,2022
2024-09-02,114452.87325383321,Retail,South,2022
2024-09-09,166448.00415228074,Retail,South,2022
2024-09-16,119358.90986865494,Retail,South,2022
2024-09-23,149868.82441433566,Retail,South,2022
2024-09-30,152650.48195533914,Retail,South,2022
2024-10-07,144791.6166347258,Retail,South,2022
2024-10-14,182410.25939929672,Retail,South,2022
2024-10-21,154413.10383535834,Retail,South,2022
2024-10-28,141773.55384805112,Retail,South,2022
2024-11-04,153285.96920062133,Retail,South,2022
2024-11-11,126971.11693971464,Retail,South,2022
2024-11-18,129303.5651185638,Retail,South,2022
2024-11-25,127242.36183928512,Retail,South,2022
2024-12-02,123648.47774998749,Retail,South,2022
2024-12-09,148347.63794311136,Retail,South,2022
2024-12-16,179841.55701447144,Retail,South,2022
2024-12-23,152495.40094111877,Retail,South,2022
2024-12-30,101948.91396365303,Retail,South,2022
2024-01-01,91416.51926795758,Wholesale,North,2022
2024-01-08,109354.87655487488,Wholesale,North,2022
2024-01-15,112127.21414303577,Wholesale,North,2022
2024-01-22,125761.96997590786,Wholesale,North,2022
2024-01-29,109272.68193610967,Wholesale,North,2022
2024-02-05,120747.53139483978,Wholesale,North,2022
2024-02-12,106486.77277467553,Wholesale,North,2022
2024-02-19,97053.25935894356,Wholesale,North,2022
2024-02-26,131322.2425193239,Wholesale,North,2022
2024-03-04,108574.22357294096,Wholesale,North,2022
2024-03-11,96105.5661667285,Wholesale,North,2022
2024-03-18,60296.241791224405,Wholesale,North,2022
2024-03-25,86437.49408309396,Wholesale,North,2022
2024-04-01,131271.0199001681,Wholesale,North,2022
2024-04-08,92830.58328366242,Wholesale,North,2022
2024-04-15,109004.62366523375,Wholesale,North,2022
2024-04-22,108904.05630335827,Wholesale,North,2022
2024-04-29,116741.04305587796,Wholesale,North,2022
2024-05-06,142130.30029259552,Wholesale,North,2022
2024-05-13,119440.72105045932,Wholesale,North,2022
2024-05-20,111669.70328250597,Wholesale,North,2022
2024-05-27,128585.80344511656,Wholesale,North,2022
2024-06-03,140552.80737389906,Wholesale,North,2022
2024-06-10,125295.51183265378,Wholesale,North,2022
2024-06-17,130892.14437688827,Wholesale,North,2022
2024-06-24,99776.65574352919,Wholesale,North,2022
2024-07-01,157532.38447677245,Wholesale,North,2022
2024-07-08,101436.96107895339,Wholesale,North,2022
2024-07-15,163047.20759455828,Wholesale,North,2022
2024-07-22,177278.68484399855,Wholesale,North,2022
2024-07-29,105128.66786053899,Wholesale,North,2022
2024-08-05,135904.26688190462,Wholesale,North,2022
2024-08-12,126396.96369631609,Wholesale,North,2022
2024-08-19,182161.52317624877,Wholesale,North,2022
2024-08-26,124539.77412343709,Wholesale,North,2022
2024-09-02,157574.53150939138,Wholesale,North,2022
2024-09-09,116160.17336696251,Wholesale,North,2022
2024-09-16,178535.91842512958,Wholesale,North,2022
2024-09-23,161340.19480554946,Wholesale,North,2022
2024-09-30,179885.49465213486,Wholesale,North,2022
2024-10-07,132676.75452284203,Wholesale,North,2022
2024-10-14,121307.47265990726,Wholesale,North,2022
2024-10-21,176782.31534244795,Wholesale,North,2022
2024-10-28,130351.1127481479,Wholesale,North,2022
2024-11-04,135490.38103056623,Wholesale,North,2022
2024-11-11,139575.37425323843,Wholesale,North,2022
2024-11-18,125137.17272958359,Wholesale,North,2022
2024-11-25,151851.47728641456,Wholesale,North,2022
2024-12-02,160698.14072034322,Wholesale,North,2022
2024-12-09,139606.0032278943,Wholesale,North,2022
2024-12-16,152127.8950856775,Wholesale,North,2022
2024-12-23,195226.08880395937,Wholesale,North,2022
2024-12-30,111538.71588775962,Wholesale,North,2022
2024-01-01,116603.43476582316,Wholesale,South,2022
2024-01-08,98665.03405784226,Wholesale,South,2022
2024-01-15,142886.56345022202,Wholesale,South,2022
2024-01-22,125486.75937445142,Wholesale,South,2022
2024-01-29,91181.85081855835,Wholesale,South,2022
2024-02-05,94246.12273037645,Wholesale,South,2022
2024-02-12,99997.08554966733,Wholesale,South,2022
2024-02-19,88675.55499591239,Wholesale,South,2022
2024-02-26,150822.22882505108,Wholesale,South,2022
2024-03-04,98213.07870607349,Wholesale,South,2022
2024-03-11,98117.3519523655,Wholesale,South,2022
2024-03-18,99110.23736937428,Wholesale,South,2022
2024-03-25,100723.40037330062,Wholesale,South,2022
2024-04-01,110309.88077361492,Wholesale,South,2022
2024-04-08,118563.62039518933,Wholesale,South,2022
2024-04-15,134270.54348283194,Wholesale,South,2022
2024-04-22,122606.91517649787,Wholesale,South,2022
2024-04-29,111435.05247669143,Wholesale,South,2022
2024-05-06,124571.8091752519,Wholesale,South,2022
2024-05-13,88863.73204490572,Wholesale,South,2022
2024-05-20,121912.88761180022,Wholesale,South,2022
2024-05-27,136715.65539766784,Wholesale,South,2022
2024-06-03,129306.04919787313,Wholesale,South,2022
2024-06-10,105220.28221325023,Wholesale,South,2022
2024-06-17,138080.75411703778,Wholesale,South,2022
2024-06-24,119075.7440702719,Wholesale,South,2022
2024-07-01,85338.8075254988,Wholesale,South,2022
2024-07-08,132365.52566978405,Wholesale,South,2022
2024-07-15,95227.80636646698,Wholesale,South,2022
2024-07-22,158502.245957657,Wholesale,South,2022
2024-07-29,101143.33652515175,Wholesale,South,2022
2024-08-05,146381.77086838282,Wholesale,South,2022
2024-08-12,162428.2761278462,Wholesale,South,2022
2024-08-19,145819.2026173737,Wholesale,South,2022
2024-08-26,122604.46578455396,Wholesale,South,2022
2024-09-02,118184.13108842671,Wholesale,South,2022
2024-09-09,149115.83727061417,Wholesale,South,2022
2024-09-16,108716.75214048341,Wholesale,South,2022
2024-09-23,164981.6810938411,Wholesale,South,2022
2024-09-30,138629.11183120607,Wholesale,South,2022
2024-10-07,166982.58466697717,Wholesale,South,2022
2024-10-14,139378.3900427351,Wholesale,South,2022
2024-10-21,121372.08335758542,Wholesale,South,2022
2024-10-28,149743.35969175308,Wholesale,South,2022
2024-11-04,173541.91260096736,Wholesale,South,2022
2024-11-11,131941.3612199242,Wholesale,South,2022
2024-11-18,136267.10510885436,Wholesale,South,2022
2024-11-25,164173.99943213392,Wholesale,South,2022
2024-12-02,143092.61673594028,Wholesale,South,2022
2024-12-09,138126.35547957505,Wholesale,South,2022
2024-12-16,126256.7471652395,Wholesale,South,2022
2024-12-23,164107.2614249311,Wholesale,South,2022
2024-12-30,100682.67789954696,Wholesale,South,2022
2024-01-01,111525.63188640709,Online,North,2023
2024-01-08,101794.34782482672,Online,North,2023
2024-01-15,144605.33237046428,Online,North,2023
2024-01-22,85070.42413910694,Online,North,2023
2024-01-29,92911.6690757178,Online,North,2023
2024-02-05,101745.55489130381,Online,North,2023
2024-02-12,137585.3738730495,Online,North,2023
2024-02-19,124604.77658799429,Online,North,2023
2024-02-26,116253.81654681373,Online,North,2023
2024-03-04,125039.57745041714,Online,North,2023
2024-03-11,109417.0183447955,Online,North,2023
2024-03-18,122794.87879251997,Online,North,2023
2024-03-25,91000.64706589992,Online,North,2023
2024-04-01,124049.29197125483,Online,North,2023
2024-04-08,117643.53157949893,Online,North,2023
2024-04-15,78025.13296436204,Online,North,2023
2024-04-22,125131.33751111587,Online,North,2023
2024-04-29,92762.25467110948,Online,North,2023
2024-05-06,109687.38892272864,Online,North,2023
2024-05-13,132119.94225608563,Online,North,2023
2024-05-20,144397.1166936131,Online,North,2023
2024-05-27,91426.14970476914,Online,North,2023
2024-06-03,90648.08618051253,Online,North,2023
2024-06-10,122064.02728734695,Online,North,2023
2024-06-17,111479.44430127295,Online,North,2023
2024-06-24,112835.67368242476,Online,North,2023
2024-07-01,98203.57615493838,Online,North,2023
2024-07-08,136827.87158844667,Online,North,2023
2024-07-15,110360.87925546893,Online,North,2023
2024-07-22,133845.2860750825,Online,North,2023
2024-07-29,128600.28617433565,Online,North,2023
2024-08-05,152501.63406142895,Online,North,2023
2024-08-12,141910.38612439684,Online,North,2023
2024-08-19,123092.66811896878,Online,North,2023
2024-08-26,111173.51437991085,Online,North,2023
2024-09-02,148493.32330299387,Online,North,2023
2024-09-09,141667.3438406248,Online,North,2023
2024-09-16,140401.5174252449,Online,North,2023
2024-09-23,146075.3451107795,Online,North,2023
2024-09-30,142208.61898772934,Online,North,2023
2024-10-07,139228.02594308468,Online,North,2023
2024-10-14,160875.99888285497,Online,North,2023
2024-10-21,162728.699562884,Online,North,2023
2024-10-28,142424.51107888,Online,North,2023
2024-11-04,119139.86033696886,Online,North,2023
2024-11-11,159296.74422944835,Online,North,2023
2024-11-18,167382.23457560776,Online,North,2023
2024-11-25,181471.6863141385,Online,North,2023
2024-12-02,154049.43481370655,Online,North,2023
2024-12-09,188658.86090275395,Online,North,2023
2024-12-16,175009.43705479108,Online,North,2023
2024-12-23,173864.1226333349,Online,North,2023
2024-12-30,131200.37735226133,Online,North,2023
2024-01-01,61348.275693563155,Online,South,2023
2024-01-08,97474.65570153904,Online,South,2023
2024-01-15,89689.56780348993,Online,South,2023
2024-01-22,135116.046225951,Online,South,2023
2024-01-29,134608.43075074966,Online,South,2023
2024-02-05,146374.84554938535,Online,South,2023
2024-02-12,92003.62713895483,Online,South,2023
2024-02-19,87286.88970786694,Online,South,2023
2024-02-26,115648.73347569624,Online,South,2023
2024-03-04,115251.17653198121,Online,South,2023
2024-03-11,85906.89546288163,Online,South,2023
2024-03-18,114990.15681183219,Online,South,2023
2024-03-25,102431.98266300597,Online,South,2023
2024-04-01,98525.73419195994,Online,South,2023
2024-04-08,108218.95347222775,Online,South,2023
2024-04-15,128359.32217847939,Online,South,2023
2024-04-22,155379.7206348537,Online,South,2023
2024-04-29,127248.10192707072,Online,South,2023
2024-05-06,129262.19903729616,Online,South,2023
2024-05-13,120980.7979604433,Online,South,2023
2024-05-20,90024.78613670036,Online,South,2023
2024-05-27,107039.68628218649,Online,South,2023
2024-06-03,105385.63549917712,Online,South,2023
2024-06-10,112299.46055583525,Online,South,2023
2024-06-17,120399.96031410467,Online,South,2023
2024-06-24,145883.61577769218,Online,South,2023
2024-07-01,122322.94462499245,Online,South,2023
2024-07-08,128559.8059413384,Online,South,2023
2024-07-15,132626.7227805322,Online,South,2023
2024-07-22,113003.87137024087,Online,South,2023
2024-07-29,126009.05451051131,Online,South,2023
2024-08-05,115514.13348583718,Online,South,2023
2024-08-12,136149.83368172066,Online,South,2023
2024-08-19,145393.68881889165,Online,South,2023
2024-08-26,130446.5383965412,Online,South,2023
2024-09-02,150075.81739457176,Online,South,2023
2024-09-09,129679.35990047368,Online,South,2023
2024-09-16,152093.14670035383,Online,South,2023
2024-09-23,122153.64232027042,Online,South,2023
2024-09-30,144693.86333038175,Online,South,2023
2024-10-07,118618.86023773464,Online,South,2023
2024-10-14,116870.94764403283,Online,South,2023
2024-10-21,172350.5865292147,Online,South,2023
2024-10-28,189940.3203927302,Online,South,2023
2024-11-04,173231.5511707164,Online,South,2023
2024-11-11,148548.84029715369,Online,South,2023
2024-11-18,165967.37491873102,Online,South,2023
2024-11-25,144594.7955413411,Online,South,2023
2024-12-02,139854.67961317938,Online,South,2023
2024-12-09,189557.00484600227,Online,South,2023
2024-12-16,153491.39031133396,Online,South,2023
2024-12-23,179180.1809143247,Online,South,2023
2024-12-30,107321.17447102671,Online,South,2023
2024-01-01,92186.58822984235,Retail,North,2023
2024-01-08,113586.56734769353,Retail,North,2023
2024-01-15,85152.29109176064,Retail,North,2023
2024-01-22,63830.079099612645,Retail,North,2023
2024-01-29,94673.29859994883,Retail,North,2023
2024-02-05,96037.17772244799,Retail,North,2023
2024-02-12,130317.87917151605,Retail,North,2023
2024-02-19,93083.3333072835,Retail,North,2023
2024-02-26,85678.22563687817,Retail,North,2023
2024-03-04,90452.10520862452,Retail,North,2023
2024-03-11,109177.50379155687,Retail,North,2023
2024-03-18,125473.8154020281,Retail,North,2023
2024-03-25,123173.25978224658,Retail,North,2023
2024-04-01,144227.41613476686,Retail,North,2023
2024-04-08,104233.24172045529,Retail,North,2023
2024-04-15,88197.91528130448,Retail,North,2023
2024-04-22,139047.48858345876,Retail,North,2023
2024-04-29,101933.43053911885,Retail,North,2023
2024-05-06,130820.94355712539,Retail,North,2023
2024-05-13,143944.3432735352,Retail,North,2023
2024-05-20,106634.74413717542,Retail,North,2023
2024-05-27,128870.06655510154,Retail,North,2023
2024-06-03,117781.04930331347,Retail,North,2023
2024-06-10,95365.08718308737,Retail,North,2023
2024-06-17,133955.94765320106,Retail,North,2023
2024-06-24,106183.27958916264,Retail,North,2023
2024-07-01,121324.48191718131,Retail,North,2023
2024-07-08,146781.29105070911,Retail,North,2023
2024-07-15,147204.62523784602,Retail,North,2023
2024-07-22,139888.53902399587,Retail,North,2023
2024-07-29,126757.15280885936,Retail,North,2023
2024-08-05,147528.7064792064,Retail,North,2023
2024-08-12,128555.9664841443,Retail,North,2023
2024-08-19,150600.81018545286,Retail,North,2023
2024-08-26,106020.1422815611,Retail,North,2023
2024-09-02,153398.55203243502,Retail,North,2023
2024-09-09,128658.08156507737,Retail,North,2023
2024-09-16,142964.1919077793,Retail,North,2023
2024-09-23,146456.59831072998,Retail,North,2023
2024-09-30,112272.40483158472,Retail,North,2023
2024-10-07,172303.00011909002,Retail,North,2023
2024-10-14,134596.42050917246,Retail,North,2023
2024-10-21,143233.16750548215,Retail,North,2023
2024-10-28,158491.10110247807,Retail,North,2023
2024-11-04,136710.68757916568,Retail,North,2023
2024-11-11,133950.05845777158,Retail,North,2023
2024-11-18,160428.94302860278,Retail,North,2023
2024-11-25,112267.98287951067,Retail,North,2023
2024-12-02,136896.8052816883,Retail,North,2023
2024-12-09,142848.68058677955,Retail,North,2023
2024-12-16,139445.38228850465,Retail,North,2023
2024-12-23,157919.1147277632,Retail,North,2023
2024-12-30,111264.60701295245,Retail,North,2023
2024-01-01,131479.35231546516,Retail,South,2023
2024-01-08,120381.48240206012,Retail,South,2023
2024-01-15,110551.26368035721,Retail,South,2023
2024-01-22,137744.94164638934,Retail,South,2023
2024-01-29,148886.9798751454,Retail,South,2023
2024-02-05,104166.31113461255,Retail,South,2023
2024-02-12,129857.33488411931,Retail,South,2023
2024-02-19,118727.11223154544,Retail,South,2023
2024-02-26,123870.31155040611,Retail,South,2023
2024-03-04,121703.61279004118,Retail,South,2023
2024-03-11,116808.72512887866,Retail,South,2023
2024-03-18,105827.08366781622,Retail,South,2023
2024-03-25,112684.90550169104,Retail,South,2023
2024-04-01,130349.27593988535,Retail,South,2023
2024-04-08,171333.69797647663,Retail,South,2023
2024-04-15,99243.06999308178,Retail,South,2023
2024-04-22,117518.55121769488,Retail,South,2023
2024-04-29,125068.52575853174,Retail,South,2023
2024-05-06,118296.70389690905,Retail,South,2023
2024-05-13,125637.3474536935,Retail,South,2023
2024-05-20,113054.00914719843,Retail,South,2023
2024-05-27,138971.26394647913,Retail,South,2023
2024-06-03,116095.78077221334,Retail,South,2023
2024-06-10,129628.80298057088,Retail,South,2023
2024-06-17,110825.48394088136,Retail,South,2023
2024-06-24,139332.22330328397,Retail,South,2023
2024-07-01,138294.57557551397,Retail,South,2023
2024-07-08,130423.90210719101,Retail,South,2023
2024-07-15,137137.11485585617,Retail,South,2023
2024-07-22,125909.03117733033,Retail,South,2023
2024-07-29,134317.70475446124,Retail,South,2023
2024-08-05,175326.3725503054,Retail,South,2023
2024-08-12,137156.29850982034,Retail,South,2023
2024-08-19,158451.79118658317,Retail,South,2023
2024-08-26,145166.99332248088,Retail,South,2023
2024-09-02,104686.39276588774,Retail,South,2023
2024-09-09,122167.33461243546,Retail,South,2023
2024-09-16,110707.85826351108,Retail,South,2023
2024-09-23,137855.19878745597,Retail,South,2023
2024-09-30,145725.26876641708,Retail,South,2023
2024-10-07,147611.17333957076,Retail,South,2023
2024-10-14,160056.1157142819,Retail,South,2023
2024-10-21,136121.4254124994,Retail,South,2023
2024-10-28,149488.50812820264,Retail,South,2023
2024-11-04,173078.4889789146,Retail,South,2023
2024-11-11,163716.20369293872,Retail,South,2023
2024-11-18,133898.65313973938,Retail,South,2023
2024-11-25,166881.0382010867,Retail,South,2023
2024-12-02,145919.85310073924,Retail,South,2023
2024-12-09,133567.997289093,Retail,South,2023
2024-12-16,139179.17290563852,Retail,South,2023
2024-12-23,151343.63168123836,Retail,South,2023
2024-12-30,87560.17165999378,Retail,South,2023
2024-01-01,102603.99870543685,Wholesale,North,2023
2024-01-08,137563.10773363448,Wholesale,North,2023
2024-01-15,109520.40645953294,Wholesale,North,2023
2024-01-22,107435.42741029184,Wholesale,North,2023
2024-01-29,83985.30307663478,Wholesale,North,2023
2024-02-05,110108.5754009654,Wholesale,North,2023
2024-02-12,111984.72996019699,Wholesale,North,2023
2024-02-19,76200.04896734102,Wholesale,North,2023
2024-02-26,59331.89424120069,Wholesale,North,2023
2024-03-04,87857.5437972598,Wholesale,North,2023
2024-03-11,128591.54935670704,Wholesale,North,2023
2024-03-18,125255.39526810862,Wholesale,North,2023
2024-03-25,91710.23021035104,Wholesale,North,2023
2024-04-01,103326.21573056126,Wholesale,North,2023
2024-04-08,108590.35400119529,Wholesale,North,2023
2024-04-15,123711.38558121656,Wholesale,North,2023
2024-04-22,99120.34376357762,Wholesale,North,2023
2024-04-29,120148.79500144678,Wholesale,North,2023
2024-05-06,125491.09173860138,Wholesale,North,2023
2024-05-13,123390.57958664351,Wholesale,North,2023
2024-05-20,80107.80803017221,Wholesale,North,2023
2024-05-27,93688.97556437188,Wholesale,North,2023
2024-06-03,144257.83849419642,Wholesale,North,2023
2024-06-10,87407.18690385559,Wholesale,North,2023
2024-06-17,111802.4755384727,Wholesale,North,2023
2024-06-24,123275.36202949077,Wholesale,North,2023
2024-07-01,127731.70946344202,Wholesale,North,2023
2024-07-08,133891.24516633537,Wholesale,North,2023
2024-07-15,154335.02745028608,Wholesale,North,2023
2024-07-22,124356.14198579833,Wholesale,North,2023
2024-07-29,149114.5439665156,Wholesale,North,2023
2024-08-05,152419.1449973038,Wholesale,North,2023
2024-08-12,156832.502300348,Wholesale,North,2023
2024-08-19,157621.7505349057,Wholesale,North,2023
2024-08-26,134474.08203440515,Wholesale,North,2023
2024-09-02,116906.226454116,Wholesale,North,2023
2024-09-09,166543.9424407706,Wholesale,North,2023
2024-09-16,149954.55209379102,Wholesale,North,2023
2024-09-23,162027.1267360262,Wholesale,North,2023
2024-09-30,112231.89238568558,Wholesale,North,2023
2024-10-07,171715.16796623578,Wholesale,North,2023
2024-10-14,135142.40037572262,Wholesale,North,2023
2024-10-21,130754.25545514486,Wholesale,North,2023
2024-10-28,177185.78640590998,Wholesale,North,2023
2024-11-04,164296.44378348778,Wholesale,North,2023
2024-11-11,112503.86902339314,Wholesale,North,2023
2024-11-18,137416.1065162067,Wholesale,North,2023
2024-11-25,116086.41969044438,Wholesale,North,2023
2024-12-02,128643.16332605542,Wholesale,North,2023
2024-12-09,116175.63486763297,Wholesale,North,2023
2024-12-16,190851.8163941715,Wholesale,North,2023
2024-12-23,165177.75628974865,Wholesale,North,2023
2024-12-30,91493.18612306555,Wholesale,North,2023
2024-01-01,112736.95310620854,Wholesale,South,2023
2024-01-08,100363.39783716132,Wholesale,South,2023
2024-01-15,89227.05920474217,Wholesale,South,2023
2024-01-22,90837.95950083002,Wholesale,South,2023
2024-01-29,81322.43815536558,Wholesale,South,2023
2024-02-05,91861.3561685073,Wholesale,South,2023
2024-02-12,160110.7848612669,Wholesale,South,2023
2024-02-19,73522.2385248793,Wholesale,South,2023
2024-02-26,122662.52351500625,Wholesale,South,2023
2024-03-04,140850.04011402288,Wholesale,South,2023
2024-03-11,91293.51410333537,Wholesale,South,2023
2024-03-18,102354.66280224349,Wholesale,South,2023
2024-03-25,66945.62911710622,Wholesale,South,2023
2024-04-01,108503.6701961318,Wholesale,South,2023
2024-04-08,111437.59180741294,Wholesale,South,2023
2024-04-15,113813.38297186763,Wholesale,South,2023
2024-04-22,97423.65805553804,Wholesale,South,2023
2024-04-29,123595.42746467963,Wholesale,South,2023
2024-05-06,84429.86670574779,Wholesale,South,2023
2024-05-13,138858.6469370348,Wholesale,South,2023
2024-05-20,83323.72893138335,Wholesale,South,2023
2024-05-27,115714.8888372653,Wholesale,South,2023
2024-06-03,97675.27826466034,Wholesale,South,2023
2024-06-10,137735.010862261,Wholesale,South,2023
2024-06-17,109087.29489751987,Wholesale,South,2023
2024-06-24,155925.29817131875,Wholesale,South,2023
2024-07-01,145800.73793306688,Wholesale,South,2023
2024-07-08,134937.55459979223,Wholesale,South,2023
2024-07-15,144987.6790881576,Wholesale,South,2023
2024-07-22,119559.41037197,Wholesale,South,2023
2024-07-29,98537.04441431887,Wholesale,South,2023
2024-08-05,130571.54525246813,Wholesale,South,2023
2024-08-12,137742.21678692044,Wholesale,South,2023
2024-08-19,142053.04891781622,Wholesale,South,2023
2024-08-26,124865.51452827148,Wholesale,South,2023
2024-09-02,131006.30505085785,Wholesale,South,2023
2024-09-09,169800.43418381806,Wholesale,South,2023
2024-09-16,92225.96823685101,Wholesale,South,2023
2024-09-23,118646.58456769894,Wholesale,South,2023
2024-09-30,134789.0372055855,Wholesale,South,2023
2024-10-07,138960.11527157197,Wholesale,South,2023
2024-10-14,91932.77580093394,Wholesale,South,2023
2024-10-21,151670.60454178526,Wholesale,South,2023
2024-10-28,148287.49336962408,Wholesale,South,2023
2024-11-04,135097.32922757108,Wholesale,South,2023
2024-11-11,136990.25496981625,Wholesale,South,2023
2024-11-18,138325.49322446552,Wholesale,South,2023
2024-11-25,157055.9360587963,Wholesale,South,2023
2024-12-02,140369.0364468987,Wholesale,South,2023
2024-12-09,122937.39133112792,Wholesale,South,2023
2024-12-16,145481.8562264848,Wholesale,South,2023
2024-12-23,170517.3186535736,Wholesale,South,2023
2024-12-30,75764.12953241324,Wholesale,South,2023
2024-01-01,94998.72919881929,Online,North,2024
2024-01-08,120931.310600456,Online,North,2024
2024-01-15,121125.33419157527,Online,North,2024
2024-01-22,94470.1281796598,Online,North,2024
2024-01-29,76054.70823592378,Online,North,2024
2024-02-05,118778.45693458048,Online,North,2024
2024-02-12,127756.30894794119,Online,North,2024
2024-02-19,117001.82215314344,Online,North,2024
2024-02-26,104369.56010447339,Online,North,2024
2024-03-04,93088.12739337338,Online,North,2024
2024-03-11,131355.08377189853,Online,North,2024
2024-03-18,99646.70669968633,Online,North,2024
2024-03-25,131567.3840008366,Online,North,2024
2024-04-01,125683.28917605623,Online,North,2024
2024-04-08,89907.80799232854,Online,North,2024
2024-04-15,117449.09756338922,Online,North,2024
2024-04-22,124125.42758245001,Online,North,2024
2024-04-29,112809.26203909544,Online,North,2024
2024-05-06,150800.36894417315,Online,North,2024
2024-05-13,86078.5894814175,Online,North,2024
2024-05-20,107953.61062273677,Online,North,2024
2024-05-27,116081.70073475255,Online,North,2024
2024-06-03,111201.85722787889,Online,North,2024
2024-06-10,128602.71708019868,Online,North,2024
2024-06-17,120112.15428673488,Online,North,2024
2024-06-24,104855.8257472456,Online,North,2024
2024-07-01,126053.7480601216,Online,North,2024
2024-07-08,118543.6763374786,Online,North,2024
2024-07-15,128123.64144768755,Online,North,2024
2024-07-22,126976.17466442788,Online,North,2024
2024-07-29,131589.72381102073,Online,North,2024
2024-08-05,97768.90270436292,Online,North,2024
2024-08-12,141317.9980799929,Online,North,2024
2024-08-19,115152.26031952331,Online,North,2024
2024-08-26,167017.81928439208,Online,North,2024
2024-09-02,140678.4066440663,Online,North,2024
2024-09-09,113773.7978114399,Online,North,2024
2024-09-16,203842.84540448664,Online,North,2024
2024-09-23,162537.69447558804,Online,North,2024
2024-09-30,167500.84900899598,Online,North,2024
2024-10-07,175640.6785672613,Online,North,2024
2024-10-14,166993.68863843428,Online,North,2024
2024-10-21,140409.01606505696,Online,North,2024
2024-10-28,143253.97080828497,Online,North,2024
2024-11-04,153901.12019552977,Online,North,2024
2024-11-11,136279.7929982673,Online,North,2024
2024-11-18,144262.5462920752,Online,North,2024
2024-11-25,170424.60824918462,Online,North,2024
2024-12-02,171461.2161502777,Online,North,2024
2024-12-09,136078.27176702052,Online,North,2024
2024-12-16,163756.97307858645,Online,North,2024
2024-12-23,124353.3149994237,Online,North,2024
2024-12-30,112139.31315705134,Online,North,2024
2024-01-01,91738.37925608459,Online,South,2024
2024-01-08,75037.93256709968,Online,South,2024
2024-01-15,63144.353871307314,Online,South,2024
2024-01-22,135256.59556999075,Online,South,2024
2024-01-29,84665.99464855401,Online,South,2024
2024-02-05,120056.08649668164,Online,South,2024
2024-02-12,141984.84283719474,Online,South,2024
2024-02-19,66880.03168192526,Online,South,2024
2024-02-26,115843.26034669051,Online,South,2024
2024-03-04,66791.13605193817,Online,South,2024
2024-03-11,94607.88753579788,Online,South,2024
2024-03-18,111168.96748386466,Online,South,2024
2024-03-25,121374.42719989578,Online,South,2024
2024-04-01,96237.93045282768,Online,South,2024
2024-04-08,177650.0234162269,Online,South,2024
2024-04-15,109329.5492721341,Online,South,2024
2024-04-22,119577.71580504,Online,South,2024
2024-04-29,110758.39958407858,Online,South,2024
2024-05-06,133833.77385092378,Online,South,2024
2024-05-13,135402.8797789109,Online,South,2024
2024-05-20,72554.8610471226,Online,South,2024
2024-05-27,108439.80846598042,Online,South,2024
2024-06-03,139763.4832893333,Online,South,2024
2024-06-10,101898.5035422304,Online,South,2024
2024-06-17,136034.2400945282,Online,South,2024
2024-06-24,112285.99310524407,Online,South,2024
2024-07-01,95096.17566138937,Online,South,2024
2024-07-08,141561.22487781866,Online,South,2024
2024-07-15,106058.2857616808,Online,South,2024
2024-07-22,161098.14619431327,Online,South,2024
2024-07-29,100200.81627533275,Online,South,2024
2024-08-05,82321.38315619587,Online,South,2024
2024-08-12,149719.17444395027,Online,South,2024
2024-08-19,142554.21311906853,Online,South,2024
2024-08-26,156271.86936033933,Online,South,2024
2024-09-02,126911.45310525324,Online,South,2024
2024-09-09,123278.19115938194,Online,South,2024
2024-09-16,127278.19495105902,Online,South,2024
2024-09-23,131638.66933418644,Online,South,2024
2024-09-30,157188.01377246605,Online,South,2024
2024-10-07,133652.74661592423,Online,South,2024
2024-10-14,138048.73289684564,Online,South,2024
2024-10-21,168183.52488877816,Online,South,2024
2024-10-28,144056.981494897,Online,South,2024
2024-11-04,111099.98409633568,Online,South,2024
2024-11-11,124741.80012706037,Online,South,2024
2024-11-18,170176.56071363087,Online,South,2024
2024-11-25,151229.44580191965,Online,South,2024
2024-12-02,161867.46828155726,Online,South,2024
2024-12-09,123638.31429608927,Online,South,2024
2024-12-16,157436.67274602552,Online,South,2024
2024-12-23,161088.74395301339,Online,South,2024
2024-12-30,80216.32024187832,Online,South,2024
2024-01-01,76927.69335720206,Retail,North,2024
2024-01-08,94881.75459635907,Retail,North,2024
2024-01-15,79023.75522964272,Retail,North,2024
2024-01-22,108382.50469508613,Retail,North,2024
2024-01-29,112966.88497543552,Retail,North,2024
2024-02-05,121059.05825225952,Retail,North,2024
2024-02-12,109535.4016674413,Retail,North,2024
2024-02-19,112370.23097436962,Retail,North,2024
2024-02-26,110489.96174640744,Retail,North,2024
2024-03-04,122425.55162359522,Retail,North,2024
2024-03-11,104592.09708940814,Retail,North,2024
2024-03-18,87258.60930474914,Retail,North,2024
2024-03-25,76772.50358473815,Retail,North,2024
2024-04-01,90879.8064397939,Retail,North,2024
2024-04-08,133011.8577917163,Retail,North,2024
2024-04-15,110184.59850172194,Retail,North,2024
2024-04-22,108565.92492709582,Retail,North,2024
2024-04-29,121381.47160854492,Retail,North,2024
2024-05-06,93643.15273091615,Retail,North,2024
2024-05-13,80572.59608672324,Retail,North,2024
2024-05-20,128137.1402933926,Retail,North,2024
2024-05-27,138677.44768643228,Retail,North,2024
2024-06-03,148679.1399695786,Retail,North,2024
2024-06-10,105092.12638921912,Retail,North,2024
2024-06-17,70327.48624452438,Retail,North,2024
2024-06-24,141921.14518602827,Retail,North,2024
2024-07-01,152657.71184842865,Retail,North,2024
2024-07-08,164891.9458931085,Retail,North,2024
2024-07-15,117385.44914010294,Retail,North,2024
2024-07-22,124344.55648801239,Retail,North,2024
2024-07-29,130992.70226813157,Retail,North,2024
2024-08-05,107835.13353869921,Retail,North,2024
2024-08-12,108005.97157886991,Retail,North,2024
2024-08-19,124228.16842842635,Retail,North,2024
2024-08-26,156722.1791736581,Retail,North,2024
2024-09-02,154534.65487768422,Retail,North,2024
2024-09-09,152538.18370023053,Retail,North,2024
2024-09-16,138392.93934613385,Retail,North,2024
2024-09-23,143478.3495820542,Retail,North,2024
2024-09-30,121603.01516658055,Retail,North,2024
2024-10-07,148681.49783841113,Retail,North,2024
2024-10-14,111961.4833493956,Retail,North,2024
2024-10-21,124710.22907255896,Retail,North,2024
2024-10-28,158590.85764444814,Retail,North,2024
2024-11-04,136063.96909938598,Retail,North,2024
2024-11-11,144358.58267918119,Retail,North,2024
2024-11-18,153290.15427437233,Retail,North,2024
2024-11-25,152329.8060630923,Retail,North,2024
2024-12-02,154039.85308907565,Retail,North,2024
2024-12-09,152962.7224696328,Retail,North,2024
2024-12-16,137245.95255590248,Retail,North,2024
2024-12-23,162657.7719922807,Retail,North,2024
2024-12-30,97581.56038455722,Retail,North,2024
2024-01-01,82128.30812892911,Retail,South,2024
2024-01-08,102318.54446488211,Retail,South,2024
2024-01-15,134358.424561135,Retail,South,2024
2024-01-22,68241.9458537836,Retail,South,2024
2024-01-29,83671.95933648967,Retail,South,2024
2024-02-05,56615.74349951394,Retail,South,2024
2024-02-12,108770.81774018303,Retail,South,2024
2024-02-19,107045.8586664436,Retail,South,2024
2024-02-26,120126.3288195841,Retail,South,2024
2024-03-04,99611.03755189414,Retail,South,2024
2024-03-11,111062.34725137506,Retail,South,2024
2024-03-18,127962.60387924741,Retail,South,2024
2024-03-25,97806.02230340624,Retail,South,2024
2024-04-01,71516.82577462072,Retail,South,2024
2024-04-08,137022.26777248003,Retail,South,2024
2024-04-15,120201.96639748567,Retail,South,2024
2024-04-22,114534.22131538353,Retail,South,2024
2024-04-29,96127.3646440282,Retail,South,2024
2024-05-06,119386.65775534691,Retail,South,2024
2024-05-13,103931.81401763269,Retail,South,2024
2024-05-20,125886.28514011826,Retail,South,2024
2024-05-27,112708.43638703767,Retail,South,2024
2024-06-03,96467.74737528471,Retail,South,2024
2024-06-10,107907.40414860542,Retail,South,2024
2024-06-17,123889.31747239621,Retail,South,2024
2024-06-24,113065.0907723118,Retail,South,2024
2024-07-01,110867.3606179784,Retail,South,2024
2024-07-08,157181.68481175942,Retail,South,2024
2024-07-15,135299.7329662722,Retail,South,2024
2024-07-22,141123.0853985995,Retail,South,2024
2024-07-29,158881.00411770638,Retail,South,2024
2024-08-05,132136.86760903132,Retail,South,2024
2024-08-12,140617.2212329608,Retail,South,2024
2024-08-19,125802.47817945933,Retail,South,2024
2024-08-26,126138.26063185862,Retail,South,2024
2024-09-02,165638.2920145452,Retail,South,2024
2024-09-09,131705.9105321482,Retail,South,2024
2024-09-16,158112.4013571149,Retail,South,2024
2024-09-23,163953.40423205934,Retail,South,2024
2024-09-30,107048.12655103805,Retail,South,2024
2024-10-07,133503.5668337008,Retail,South,2024
2024-10-14,155030.00429462883,Retail,South,2024
2024-10-21,132770.81739082345,Retail,South,2024
2024-10-28,158204.29343330517,Retail,South,2024
2024-11-04,112698.95446595349,Retail,South,2024
2024-11-11,156039.74679544297,Retail,South,2024
2024-11-18,120060.35829310099,Retail,South,2024
2024-11-25,141452.9868648481,Retail,South,2024
2024-12-02,167554.13513326267,Retail,South,2024
2024-12-09,152258.02933900215,Retail,South,2024
2024-12-16,131993.8700068568,Retail,South,2024
2024-12-23,189776.87947705478,Retail,South,2024
2024-12-30,76802.62944079266,Retail,South,2024
2024-01-01,84665.74398146375,Wholesale,North,2024
2024-01-08,81226.78209544778,Wholesale,North,2024
2024-01-15,73583.44774712571,Wholesale,North,2024
2024-01-22,106617.32172126065,Wholesale,North,2024
2024-01-29,77308.50756042005,Wholesale,North,2024
2024-02-05,105524.83856315736,Wholesale,North,2024
2024-02-12,124869.01421278884,Wholesale,North,2024
2024-02-19,79263.18021175273,Wholesale,North,2024
2024-02-26,119138.72700146804,Wholesale,North,2024
2024-03-04,97499.41272003127,Wholesale,North,2024
2024-03-11,100653.81692109111,Wholesale,North,2024
2024-03-18,113293.99534823057,Wholesale,North,2024
2024-03-25,103261.0824740002,Wholesale,North,2024
2024-04-01,141445.22524860245,Wholesale,North,2024
2024-04-08,142905.7187561465,Wholesale,North,2024
2024-04-15,100330.92658303257,Wholesale,North,2024
2024-04-22,110338.86208902221,Wholesale,North,2024
2024-04-29,92107.01708306401,Wholesale,North,2024
2024-05-06,99982.46282898851,Wholesale,North,2024
2024-05-13,142149.82873221854,Wholesale,North,2024
2024-05-20,137541.41452978883,Wholesale,North,2024
2024-05-27,99914.1897385905,Wholesale,North,2024
2024-06-03,120723.73836965437,Wholesale,North,2024
2024-06-10,146249.14974950324,Wholesale,North,2024
2024-06-17,120033.90447036529,Wholesale,North,2024
2024-06-24,100027.91497596452,Wholesale,North,2024
2024-07-01,82645.7417566982,Wholesale,North,2024
2024-07-08,124271.58444598994,Wholesale,North,2024
2024-07-15,136985.96306537706,Wholesale,North,2024
2024-07-22,103317.95514972905,Wholesale,North,2024
2024-07-29,144514.0208155634,Wholesale,North,2024
2024-08-05,124715.90560721041,Wholesale,North,2024
2024-08-12,162005.77018133696,Wholesale,North,2024
2024-08-19,137220.4814150585,Wholesale,North,2024
2024-08-26,153966.43842549357,Wholesale,North,2024
2024-09-02,140255.9208361719,Wholesale,North,2024
2024-09-09,192151.921622372,Wholesale,North,2024
2024-09-16,153726.49363962558,Wholesale,North,2024
2024-09-23,164675.33373258688,Wholesale,North,2024
2024-09-30,133089.7010172109,Wholesale,North,2024
2024-10-07,131746.37040620972,Wholesale,North,2024
2024-10-14,128863.2962851965,Wholesale,North,2024
2024-10-21,149003.16681817756,Wholesale,North,2024
2024-10-28,156186.21573261204,Wholesale,North,2024
2024-11-04,107625.1047520832,Wholesale,North,2024
2024-11-11,154745.56493175865,Wholesale,North,2024
2024-11-18,148904.23327647505,Wholesale,North,2024
2024-11-25,185822.1242955957,Wholesale,North,2024
2024-12-02,164395.8108369478,Wholesale,North,2024
2024-12-09,125181.58721187143,Wholesale,North,2024
2024-12-16,146417.18224405847,Wholesale,North,2024
2024-12-23,183250.6205161067,Wholesale,North,2024
2024-12-30,74076.53405159299,Wholesale,North,2024
2024-01-01,104820.74368574165,Wholesale,South,2024
2024-01-08,126802.01586783299,Wholesale,South,2024
2024-01-15,107402.82358280805,Wholesale,South,2024
2024-01-22,135107.237773476,Wholesale,South,2024
2024-01-29,105785.38554448556,Wholesale,South,2024
2024-02-05,99287.72925910796,Wholesale,South,2024
2024-02-12,94062.23436333126,Wholesale,South,2024
2024-02-19,134901.0114253519,Wholesale,South,2024
2024-02-26,95301.49186585266,Wholesale,South,2024
2024-03-04,112730.3897196706,Wholesale,South,2024
2024-03-11,134916.51936992427,Wholesale,South,2024
2024-03-18,138369.44067526015,Wholesale,South,2024
2024-03-25,161413.48767074602,Wholesale,South,2024
2024-04-01,131210.5459815316,Wholesale,South,2024
2024-04-08,120150.1554972501,Wholesale,South,2024
2024-04-15,93114.39811172355,Wholesale,South,2024
2024-04-22,140194.39872649583,Wholesale,South,2024
2024-04-29,126604.76489063926,Wholesale,South,2024
2024-05-06,111509.61103189533,Wholesale,South,2024
2024-05-13,119962.57226738875,Wholesale,South,2024
2024-05-20,125860.77061812383,Wholesale,South,2024
2024-05-27,116919.86099472392,Wholesale,South,2024
2024-06-03,105497.2722572778,Wholesale,South,2024
2024-06-10,90960.37326427727,Wholesale,South,2024
2024-06-17,100732.35017972685,Wholesale,South,2024
2024-06-24,185141.0546211489,Wholesale,South,2024
2024-07-01,121698.74056374312,Wholesale,South,2024
2024-07-08,116885.83994009296,Wholesale,South,2024
2024-07-15,119168.88085551519,Wholesale,South,2024
2024-07-22,155136.61065353436,Wholesale,South,2024
2024-07-29,140859.50390234508,Wholesale,South,2024
2024-08-05,109824.55409830985,Wholesale,South,2024
2024-08-12,157840.44776469487,Wholesale,South,2024
2024-08-19,145889.03384310778,Wholesale,South,2024
2024-08-26,151488.6486811757,Wholesale,South,2024
2024-09-02,99275.89894584494,Wholesale,South,2024
2024-09-09,136425.28077631647,Wholesale,South,2024
2024-09-16,131401.93050836844,Wholesale,South,2024
2024-09-23,119581.70149297718,Wholesale,South,2024
2024-09-30,135278.88957548424,Wholesale,South,2024
2024-10-07,146279.92426063665,Wholesale,South,2024
2024-10-14,131749.89028498647,Wholesale,South,2024
2024-10-21,160732.2771278203,Wholesale,South,2024
2024-10-28,168393.32216288638,Wholesale,South,2024
2024-11-04,146842.58347481975,Wholesale,South,2024
2024-11-11,162446.66866509285,Wholesale,South,2024
2024-11-18,171708.6076255691,Wholesale,South,2024
2024-11-25,119588.78205936347,Wholesale,South,2024
2024-12-02,165694.97343130835,Wholesale,South,2024
2024-12-09,166508.2344979376,Wholesale,South,2024
2024-12-16,130909.2396420192,Wholesale,South,2024
2024-12-23,140316.1672003921,Wholesale,South,2024
2024-12-30,112657.60402489695,Wholesale,South,2024

</script><script type="text/plain" id="sales_by_region" data-format="csv_embedded" data-src="">
Date,Sales,Region
2024-01-01,9544.77672437828,North
2024-01-02,11588.947141508344,North
2024-01-03,9757.518169268911,North
2024-01-04,10960.277315557112,North
2024-01-05,12731.191228422898,North
2024-01-06,9281.086474977728,North
2024-01-07,11036.73663450223,North
2024-01-08,12259.756809893386,North
2024-01-09,9872.66173167205,North
2024-01-10,8630.829852190096,North
2024-01-11,9555.480250090857,North
2024-01-12,8758.608189527084,North
2024-01-13,9097.276076255212,North
2024-01-14,8462.451270737158,North
2024-01-15,12387.558209796236,North
2024-01-16,9657.648370392786,North
2024-01-17,11965.752893806144,North
2024-01-18,11692.63146180618,North
2024-01-19,10225.134390835225,North
2024-01-20,11048.615955266392,North
2024-01-21,13213.484570405857,North
2024-01-22,12878.464213376994,North
2024-01-23,12230.614831520856,North
2024-01-24,12284.49394959902,North
2024-01-25,11352.053505339547,North
2024-01-26,11623.556433683701,North
2024-01-27,12438.296821229847,North
2024-01-28,13058.442733343949,North
2024-01-29,12621.51302425392,North
2024-01-30,9952.948299079484,North
2024-01-31,9772.132959089215,North
2024-02-01,14053.364128351364,North
2024-02-02,10760.215599440546,North
2024-02-03,12088.681755868523,North
2024-02-04,7273.774598244273,North
2024-02-05,14053.111652086436,North
2024-02-06,12938.888594019605,North
2024-02-07,8033.579440694125,North
2024-02-08,9090.382551454713,North
2024-02-09,11584.566598346422,North
2024-02-10,10046.393150275047,North
2024-02-11,11331.746961697567,North
2024-02-12,12407.729576483176,North
2024-02-13,12511.484140616683,North
2024-02-14,11030.058566009107,North
2024-02-15,12567.34406019308,North
2024-02-16,13817.720481892607,North
2024-02-17,11298.72368657233,North
2024-02-18,10974.098003613242,North
2024-02-19,12789.939392901462,North
2024-02-20,12905.739669629354,North
2024-02-21,13963.928630707755,North
2024-02-22,16348.731740514217,North
2024-02-23,11990.756247712858,North
2024-02-24,12244.663279900915,North
2024-02-25,13119.208545738154,North
2024-02-26,14912.207630664685,North
2024-02-27,11797.26234470808,North
2024-02-28,12681.884511557753,North
2024-02-29,14381.70632115744,North
2024-03-01,12445.534410166896,North
2024-03-02,13580.640851803077,North
2024-03-03,11938.13507891465,North
2024-03-04,12313.478737059982,North
2024-03-05,15774.296593425715,North
2024-03-06,10752.632096327216,North
2024-03-07,10934.082123960483,North
2024-03-08,14943.439123494736,North
2024-03-09,12874.72165713213,North
2024-03-10,15080.781026247598,North
2024-03-11,12592.238646375456,North
2024-03-12,11760.030474699372,North
2024-03-13,14089.76128929875,North
2024-03-14,14514.762180101432,North
2024-03-15,11638.135909469318,North
2024-03-16,13691.084459947679,North
2024-03-17,14692.622728333668,North
2024-03-18,15712.76880084668,North
2024-03-19,15070.792197922838,North
2024-03-20,11805.694061273902,North
2024-03-21,16981.72411468348,North
2024-03-22,13740.790072606782,North
2024-03-23,13699.402136886361,North
2024-03-24,14766.975762067636,North
2024-03-25,12830.604955105193,North
2024-03-26,11336.9481658623,North
2024-03-27,14101.278491045548,North
2024-03-28,16548.03287097378,North
2024-03-29,10448.034401342882,North
2024-03-30,16037.651562015142,North
2024-03-31,15271.90147832429,North
2024-04-01,13620.621335211925,North
2024-04-02,17242.689363402027,North
2024-04-03,14567.295438475663,North
2024-04-04,14186.304010570026,North
2024-04-05,14882.948675145346,North
2024-04-06,18073.50598320701,North
2024-04-07,15648.908619297914,North
2024-04-08,15447.49973305946,North
2024-04-09,15295.604907131543,North
2024-04-10,14555.473582435108,North
2024-04-11,15362.410947715181,North
2024-04-12,14975.902681226356,North
2024-04-13,20044.622802611884,North
2024-04-14,15273.715243521721,North
2024-04-15,18041.13191667736,North
2024-04-16,12606.65306918513,North
2024-04-17,15068.644934846841,North
2024-04-18,13092.661796518569,North
2024-04-19,15081.519701418509,North
2024-04-20,14355.43954812624,North
2024-04-21,17018.46678749479,North
2024-04-22,15422.481614419119,North
2024-04-23,13732.268584360974,North
2024-04-24,13595.783128190185,North
2024-04-25,15920.246012332173,North
2024-04-26,16144.71927393877,North
2024-04-27,13650.100294929965,North
2024-04-28,13085.01071970285,North
2024-04-29,16898.288518077992,North
2024-04-30,13879.855180214767,North
2024-05-01,20292.10403940635,North
2024-05-02,13135.741308945067,North
2024-05-03,16734.74808726827,North
2024-05-04,16780.30744118721,North
2024-05-05,14563.786368820596,North
2024-05-06,19033.65178911569,North
2024-05-07,19627.65033687509,North
2024-05-08,15430.17940506068,North
2024-05-09,14915.263735042765,North
2024-05-10,13378.98271355679,North
2024-05-11,18193.9839899254,North
2024-05-12,15605.088821190307,North
2024-05-13,15940.964546001735,North
2024-05-14,18433.650853170235,North
2024-05-15,17485.589989534805,North
2024-05-16,13933.930660509717,North
2024-05-17,14796.156428965127,North
2024-05-18,18908.125945587934,North
2024-05-19,15662.217918847642,North
2024-05-20,21416.194324318116,North
2024-05-21,12290.57359340617,North
2024-05-22,18162.432912511336,North
2024-05-23,15780.72865713135,North
2024-05-24,18729.510543919987,North
2024-05-25,18851.668219001098,North
2024-05-26,13048.878831258233,North
2024-05-27,18403.64061777896,North
2024-05-28,14682.835217453741,North
2024-05-29,20729.253936559893,North
2024-05-30,17829.028985349567,North
2024-05-31,14595.811269946955,North
2024-06-01,20157.35770741452,North
2024-06-02,15974.954882908056,North
2024-06-03,19626.430737451396,North
2024-06-04,17047.85378951912,North
2024-06-05,17798.886597382196,North
2024-06-06,17607.987332385303,North
2024-06-07,16871.178151309356,North
2024-06-08,17470.17531355461,North
2024-06-09,19431.739912669043,North
2024-06-10,16730.808743801073,North
2024-06-11,19012.241707244975,North
2024-06-12,18729.908037504196,North
2024-06-13,19250.71834876178,North
2024-06-14,22759.22105141416,North
2024-06-15,18565.310814016568,North
2024-06-16,17819.3705912516,North
2024-06-17,20925.740002318653,North
2024-06-18,16586.191775060823,North
2024-06-19,17638.271319581392,North
2024-06-20,18315.891027020225,North
2024-06-21,21621.82254129272,North
2024-06-22,17792.52341332813,North
2024-06-23,21646.573157308412,North
2024-06-24,15480.071704667924,North
2024-06-25,18141.386775044768,North
2024-06-26,20044.73620163917,North
2024-06-27,20686.48326572697,North
2024-06-28,19395.95176242438,North
2024-06-29,20610.595840234084,North
2024-06-30,20820.125033481643,North
2024-01-01,8015.6562849957445,South
2024-01-02,9943.346845488566,South
2024-01-03,13443.347466608415,South
2024-01-04,7212.713451567763,South
2024-01-05,13110.269992092397,South
2024-01-06,9687.279884339969,South
2024-01-07,11067.96909600334,South
2024-01-08,10486.8960183845,South
2024-01-09,12293.66151916209,South
2024-01-10,13194.974702641959,South
2024-01-11,10551.862825363296,South
2024-01-12,10984.633862654437,South
2024-01-13,7014.60352348344,South
2024-01-14,11174.687552633297,South
2024-01-15,15626.53690137522,South
2024-01-16,13159.507728121542,South
2024-01-17,10530.38056448102,South
2024-01-18,7626.74547418445,South
2024-01-19,9353.089059281303,South
2024-01-20,14748.967932075007,South
2024-01-21,12062.824704638166,South
2024-01-22,14980.607804893394,South
2024-01-23,14390.922332693715,South
2024-01-24,10970.96054996042,South
2024-01-25,13705.473189744569,South
2024-01-26,10779.004389707838,South
2024-01-27,9417.451510358022,South
2024-01-28,12575.886357976207,South
2024-01-29,13188.235126861055,South
2024-01-30,9923.879797378318,South
2024-01-31,9618.078522206652,South
2024-02-01,11128.563138090027,South
2024-02-02,11524.213230589838,South
2024-02-03,12810.010919283122,South
2024-02-04,14498.166439209615,South
2024-02-05,10606.121884075885,South
2024-02-06,14408.361240833403,South
2024-02-07,9294.582376938604,South
2024-02-08,8946.013767239405,South
2024-02-09,13369.87555774651,South
2024-02-10,14645.637202761718,South
2024-02-11,15792.335303339476,South
2024-02-12,11394.356185622868,South
2024-02-13,10031.654135797213,South
2024-02-14,10495.15392544839,South
2024-02-15,12078.684199176816,South
2024-02-16,12558.416238034097,South
2024-02-17,15302.298308728103,South
2024-02-18,9060.180471860755,South
2024-02-19,12142.83878181855,South
2024-02-20,13897.633750170642,South
2024-02-21,11586.212875032297,South
2024-02-22,12584.06665733974,South
2024-02-23,12005.707824510542,South
2024-02-24,14964.013737594383,South
2024-02-25,14607.252185114594,South
2024-02-26,14019.51848478838,South
2024-02-27,14438.029188373255,South
2024-02-28,15258.566554020816,South
2024-02-29,12309.586947865177,South
2024-03-01,15138.249829920493,South
2024-03-02,12588.30783958908,South
2024-03-03,9242.732306439497,South
2024-03-04,13064.142998415009,South
2024-03-05,12241.504024617849,South
2024-03-06,10021.616042490392,South
2024-03-07,11417.503037531334,South
2024-03-08,10868.212388556287,South
2024-03-09,12477.246041105216,South
2024-03-10,12804.194157207752,South
2024-03-11,15237.212830469894,South
2024-03-12,14244.747591142579,South
2024-03-13,14669.109389896166,South
2024-03-14,12895.514369450524,South
2024-03-15,13581.014212430919,South
2024-03-16,10762.550125531758,South
2024-03-17,14174.030881026925,South
2024-03-18,16773.026676447855,South
2024-03-19,14783.441001751438,South
2024-03-20,13345.777392380553,South
2024-03-21,14760.35481744673,South
2024-03-22,8338.389447570607,South
2024-03-23,12418.819199344161,South
2024-03-24,12845.08955552177,South
2024-03-25,14181.676570704816,South
2024-03-26,16717.257534056742,South
2024-03-27,15405.04633721348,South
2024-03-28,13647.777668464762,South
2024-03-29,11955.878192929511,South
2024-03-30,15449.25465519249,South
2024-03-31,14188.273731958921,South
2024-04-01,11667.735065824507,South
2024-04-02,17242.735013995836,South
2024-04-03,15283.081829696133,South
2024-04-04,15479.261203336995,South
2024-04-05,14905.791536952178,South
2024-04-06,15625.259987477188,South
2024-04-07,14973.545614189657,South
2024-04-08,15005.991506175626,South
2024-04-09,14354.986999631063,South
2024-04-10,12867.121846130487,South
2024-04-11,13539.425866038677,South
2024-04-12,12570.764503526849,South
2024-04-13,13509.383104299122,South
2024-04-14,13818.126269705175,South
2024-04-15,16715.350234509337,South
2024-04-16,13774.896533948291,South
2024-04-17,17743.9414211647,South
2024-04-18,16345.671375464046,South
2024-04-19,16396.313887640463,South
2024-04-20,15920.20947639401,South
2024-04-21,14254.566643131338,South
2024-04-22,16092.313578389276,South
2024-04-23,16061.435839569462,South
2024-04-24,17527.386920572746,South
2024-04-25,12849.938495334985,South
2024-04-26,15799.683187700191,South
2024-04-27,15907.415299573866,South
2024-04-28,15287.125721079241,South
2024-04-29,17213.84371783371,South
2024-04-30,16901.569039106944,South
2024-05-01,15304.131784052557,South
2024-05-02,16408.3834830991,South
2024-05-03,14669.433826724455,South
2024-05-04,14779.743771588706,South
2024-05-05,17157.106326498368,South
2024-05-06,18124.550701295728,South
2024-05-07,18168.62140022433,South
2024-05-08,15139.42693371567,South
2024-05-09,15129.294634761525,South
2024-05-10,18125.71914946076,South
2024-05-11,18252.48712296774,South
2024-05-12,17180.722911039302,South
2024-05-13,19264.190681467328,South
2024-05-14,15270.654567261774,South
2024-05-15,18415.11719358854,South
2024-05-16,16118.053313931016,South
2024-05-17,18006.385654764184,South
2024-05-18,19005.494495720537,South
2024-05-19,15337.616188947937,South
2024-05-20,15099.498542488109,South
2024-05-21,17736.24427993686,South
2024-05-22,16922.97148264236,South
2024-05-23,17215.088207527668,South
2024-05-24,16234.437903947399,South
2024-05-25,17446.897293761067,South
2024-05-26,17613.3658947491,South
2024-05-27,17361.825701609203,South
2024-05-28,15718.41721022714,South
2024-05-29,13963.299023327885,South
2024-05-30,15410.293567706989,South
2024-05-31,16181.934092865344,South
2024-06-01,16334.705148821502,South
2024-06-02,17986.56216558755,South
2024-06-03,17958.324257200224,South
2024-06-04,15839.559166090834,South
2024-06-05,17687.04812284613,South
2024-06-06,19237.252672301118,South
2024-06-07,19392.35472218463,South
2024-06-08,19539.583721729774,South
2024-06-09,15797.655588862413,South
2024-06-10,16351.451988384051,South
2024-06-11,18764.545316743428,South
2024-06-12,17642.364864383922,South
2024-06-13,17018.536631848663,South
2024-06-14,15459.63657771242,South
2024-06-15,17674.700069810067,South
2024-06-16,20610.95025250667,South
2024-06-17,15214.843780398887,South
2024-06-18,17769.797017624245,South
2024-06-19,16660.788098207642,South
2024-06-20,16447.523188640942,South
2024-06-21,19192.650567051107,South
2024-06-22,19454.264609433514,South
2024-06-23,17870.11303436032,South
2024-06-24,19675.05672672954,South
2024-06-25,21081.487024064198,South
2024-06-26,17124.476007848883,South
2024-06-27,20169.87238765948,South
2024-06-28,19715.60887565462,South
2024-06-29,15433.686929865667,South
2024-06-30,13302.904249261945,South
2024-01-01,8320.005419238512,East
2024-01-02,7583.011911368698,East
2024-01-03,7554.423105612361,East
2024-01-04,7068.460511325188,East
2024-01-05,11417.474335066414,East
2024-01-06,7201.138997497595,East
2024-01-07,10780.017631366221,East
2024-01-08,12523.125150156297,East
2024-01-09,8517.448290886601,East
2024-01-10,8865.590838785216,East
2024-01-11,11283.036648040916,East
2024-01-12,12017.842032938275,East
2024-01-13,11093.653204997489,East
2024-01-14,11146.155566363754,East
2024-01-15,13140.258231645988,East
2024-01-16,12841.430714771006,East
2024-01-17,12498.605184221236,East
2024-01-18,11651.632773369833,East
2024-01-19,9848.539327781533,East
2024-01-20,10588.818435110115,East
2024-01-21,9945.222332303067,East
2024-01-22,10081.910839037484,East
2024-01-23,10306.344264338435,East
2024-01-24,10631.996953419655,East
2024-01-25,15342.162276440646,East
2024-01-26,9324.363143170882,East
2024-01-27,11000.541335099751,East
2024-01-28,15234.751146090324,East
2024-01-29,12048.598533751692,East
2024-01-30,9156.219064044271,East
2024-01-31,11860.008817200276,East
2024-02-01,14397.672615688727,East
2024-02-02,10480.454080814585,East
2024-02-03,10055.12021606678,East
2024-02-04,12150.477025672808,East
2024-02-05,12725.298697467726,East
2024-02-06,12127.563183626435,East
2024-02-07,8661.489059598243,East
2024-02-08,11142.582607222757,East
2024-02-09,15288.845552608775,East
2024-02-10,13879.888632011522,East
2024-02-11,11578.265779431,East
2024-02-12,9803.924298994629,East
2024-02-13,14317.247598163078,East
2024-02-14,13215.03418474925,East
2024-02-15,14321.84153168972,East
2024-02-16,11601.821454513418,East
2024-02-17,9224.220817351219,East
2024-02-18,15395.684492426284,East
2024-02-19,11064.441996281905,East
2024-02-20,10652.948527555209,East
2024-02-21,11735.060350398091,East
2024-02-22,10606.852410284246,East
2024-02-23,10917.108424184044,East
2024-02-24,15645.970486947499,East
2024-02-25,16002.506675271443,East
2024-02-26,13995.309151980928,East
2024-02-27,12309.848950443173,East
2024-02-28,14692.132533218652,East
2024-02-29,12930.161786395845,East
2024-03-01,11834.667356785507,East
2024-03-02,14107.412130736484,East
2024-03-03,11458.135609774637,East
2024-03-04,11652.596577131018,East
2024-03-05,10958.292915969327,East
2024-03-06,12813.799486809043,East
2024-03-07,13088.003191959353,East
2024-03-08,17215.48641371933,East
2024-03-09,12281.848191868026,East
2024-03-10,12401.28436726428,East
2024-03-11,7366.134878256471,East
2024-03-12,11310.025719406724,East
2024-03-13,14773.77831633316,East
2024-03-14,11425.205487611984,East
2024-03-15,12142.565583652273,East
2024-03-16,15802.46042721618,East
2024-03-17,16016.229456546527,East
2024-03-18,13861.836510450863,East
2024-03-19,11694.334959356522,East
2024-03-20,13797.891944648205,East
2024-03-21,16703.800465895092,East
2024-03-22,13841.90753568015,East
2024-03-23,12886.781522472364,East
2024-03-24,14157.53998195992,East
2024-03-25,15509.58035990917,East
2024-03-26,11605.533369974297,East
2024-03-27,12529.218799081127,East
2024-03-28,18293.290949425947,East
2024-03-29,14916.681443740858,East
2024-03-30,13097.475234345462,East
2024-03-31,17025.673239929718,East
2024-04-01,15086.344680930793,East
2024-04-02,15404.452303592327,East
2024-04-03,11107.42756362615,East
2024-04-04,13922.976421648664,East
2024-04-05,15839.391420835223,East
2024-04-06,17462.27435939625,East
2024-04-07,15953.96331583258,East
2024-04-08,18719.77249299306,East
2024-04-09,14619.370005501105,East
2024-04-10,15762.974131291277,East
2024-04-11,12873.308268423592,East
2024-04-12,18460.5305999879,East
2024-04-13,17432.787505453918,East
2024-04-14,15088.485561029847,East
2024-04-15,19603.692915393876,East
2024-04-16,15931.188500030981,East
2024-04-17,18120.05320291033,East
2024-04-18,14697.584999834175,East
2024-04-19,15859.234548038898,East
2024-04-20,14770.585181223974,East
2024-04-21,15453.115001983584,East
2024-04-22,17429.450321673343,East
2024-04-23,16401.24706211422,East
2024-04-24,15190.26526013266,East
2024-04-25,16271.828442287404,East
2024-04-26,18004.00548367854,East
2024-04-27,15694.24412878844,East
2024-04-28,15561.442131276483,East
2024-04-29,16719.883765375977,East
2024-04-30,17650.24882018926,East
2024-05-01,16564.845661643325,East
2024-05-02,16536.922064137754,East
2024-05-03,15073.780971444394,East
2024-05-04,15796.45441940936,East
2024-05-05,19767.870638293134,East
2024-05-06,15347.166572193864,East
2024-05-07,18785.013406469472,East
2024-05-08,14496.054578604882,East
2024-05-09,14863.787571687888,East
2024-05-10,15921.306634112962,East
2024-05-11,14180.188994823842,East
2024-05-12,16629.052702035944,East
2024-05-13,20437.332259738043,East
2024-05-14,21727.177515307416,East
2024-05-15,15942.583686143533,East
2024-05-16,13366.307859178834,East
2024-05-17,19132.941566753492,East
2024-05-18,19830.13282514757,East
2024-05-19,16203.467662520583,East
2024-05-20,14707.667126628497,East
2024-05-21,16537.485681168087,East
2024-05-22,15871.359306598317,East
2024-05-23,19820.824690570527,East
2024-05-24,16232.03484205041,East
2024-05-25,20785.27623379803,East
2024-05-26,17816.961514607763,East
2024-05-27,17375.205897094904,East
2024-05-28,21252.098565965538,East
2024-05-29,17672.219250096547,East
2024-05-30,17056.536783220967,East
2024-05-31,18749.22456066525,East
2024-06-01,18142.232366114964,East
2024-06-02,19320.873408119536,East
2024-06-03,17887.320301828277,East
2024-06-04,15767.10484090937,East
2024-06-05,15810.678160637082,East
2024-06-06,16057.355390820165,East
2024-06-07,20793.142847960844,East
2024-06-08,17090.86526878613,East
2024-06-09,15614.56881486655,East
2024-06-10,18354.842078704605,East
2024-06-11,17882.58114642797,East
2024-06-12,18780.095879218476,East
2024-06-13,17565.01100780852,East
2024-06-14,16653.610170407817,East
2024-06-15,18247.89615256052,East
2024-06-16,21450.141333919102,East
2024-06-17,15527.71876338692,East
2024-06-18,15310.031678221821,East
2024-06-19,16166.25854769485,East
2024-06-20,19100.46856810453,East
2024-06-21,17756.360945949884,East
2024-06-22,21167.046569016093,East
2024-06-23,18740.059676516586,East
2024-06-24,19911.307475529364,East
2024-06-25,18329.74755815381,East
2024-06-26,21546.757283534975,East
2024-06-27,18465.56927898975,East
2024-06-28,19397.614195992934,East
2024-06-29,16394.956429221747,East
2024-06-30,16088.607263101307,East
2024-01-01,7747.151585725427,West
2024-01-02,7270.005398694966,West
2024-01-03,9589.740856389184,West
2024-01-04,8070.194793421453,West
2024-01-05,13964.471866276084,West
2024-01-06,8037.483760533781,West
2024-01-07,10797.115590156638,West
2024-01-08,10249.695416075654,West
2024-01-09,10770.285353757356,West
2024-01-10,10021.115355750877,West
2024-01-11,9579.987873083372,West
2024-01-12,14217.094980211743,West
2024-01-13,11820.69153591247,West
2024-01-14,11692.730833736723,West
2024-01-15,12441.170169279614,West
2024-01-16,11046.809796667554,West
2024-01-17,13848.310683839973,West
2024-01-18,9975.640494642766,West
2024-01-19,12548.575482546928,West
2024-01-20,12391.348716993536,West
2024-01-21,8355.769775625546,West
2024-01-22,10044.044264119586,West
2024-01-23,13088.192409545942,West
2024-01-24,12647.135434097365,West
2024-01-25,11494.729171059054,West
2024-01-26,12595.33937495603,West
2024-01-27,11521.846580425676,West
2024-01-28,13124.648704270297,West
2024-01-29,12021.197694164232,West
2024-01-30,12867.85614592023,West
2024-01-31,11660.893514935346,West
2024-02-01,10904.192087987623,West
2024-02-02,9637.715255797306,West
2024-02-03,11861.521654788465,West
2024-02-04,11466.418712983213,West
2024-02-05,8471.755782775565,West
2024-02-06,10423.850885948626,West
2024-02-07,9503.483182392689,West
2024-02-08,14603.393670407308,West
2024-02-09,14297.314995826537,West
2024-02-10,14916.539668982494,West
2024-02-11,11528.464257458882,West
2024-02-12,16419.890548121257,West
2024-02-13,13462.406467698653,West
2024-02-14,11721.138004570135,West
2024-02-15,11009.031819466965,West
2024-02-16,12387.710678149957,West
2024-02-17,11779.310574852672,West
2024-02-18,10119.396076067984,West
2024-02-19,11406.610549233827,West
2024-02-20,14546.815127851138,West
2024-02-21,13300.740782627663,West
2024-02-22,10687.984686001359,West
2024-02-23,13223.77517991518,West
2024-02-24,9494.250332925856,West
2024-02-25,10749.982764189324,West
2024-02-26,10644.608977346345,West
2024-02-27,14803.890991303992,West
2024-02-28,11527.712261324808,West
2024-02-29,13601.595574224988,West
2024-03-01,11217.081253210457,West
2024-03-02,14386.525138682946,West
2024-03-03,12205.314194762479,West
2024-03-04,10441.585287407617,West
2024-03-05,13030.679280068163,West
2024-03-06,14738.294574036254,West
2024-03-07,13563.324932244914,West
2024-03-08,14432.677503571806,West
2024-03-09,9959.468427562633,West
2024-03-10,11602.73701512232,West
2024-03-11,12501.500295378703,West
2024-03-12,13390.683871761636,West
2024-03-13,14796.19512476421,West
2024-03-14,9934.603588580112,West
2024-03-15,12715.4430753589,West
2024-03-16,14158.872541001343,West
2024-03-17,13774.872041935681,West
2024-03-18,13757.527556050449,West
2024-03-19,12359.99864292765,West
2024-03-20,14824.699266252977,West
2024-03-21,15958.33429256705,West
2024-03-22,15543.094504390081,West
2024-03-23,8977.040551002046,West
2024-03-24,13746.24553339005,West
2024-03-25,11849.865875044743,West
2024-03-26,12094.781914278581,West
2024-03-27,19874.002570004333,West
2024-03-28,12933.050199880323,West
2024-03-29,14751.157255278802,West
2024-03-30,11412.511188745648,West
2024-03-31,13391.569276875636,West
2024-04-01,14829.48448235226,West
2024-04-02,17691.67057450934,West
2024-04-03,14649.764846997956,West
2024-04-04,14294.010794840437,West
2024-04-05,12513.757034212034,West
2024-04-06,17240.539698106666,West
2024-04-07,13665.7308189132,West
2024-04-08,16763.582303747222,West
2024-04-09,16136.263785868077,West
2024-04-10,13581.477531561004,West
2024-04-11,15531.31082316872,West
2024-04-12,17233.046978733808,West
2024-04-13,12396.12602407145,West
2024-04-14,15680.779722156394,West
2024-04-15,15382.602577210546,West
2024-04-16,14189.587448721479,West
2024-04-17,11292.386101206619,West
2024-04-18,13356.721374112347,West
2024-04-19,16199.324083396777,West
2024-04-20,11950.641296403923,West
2024-04-21,13718.586769895406,West
2024-04-22,14421.88552595284,West
2024-04-23,14641.281909451978,West
2024-04-24,12887.674549409421,West
2024-04-25,17647.945557747822,West
2024-04-26,14552.241033665863,West
2024-04-27,12184.918098658993,West
2024-04-28,17455.16489033308,West
2024-04-29,15253.07454284064,West
2024-04-30,11750.449211544583,West
2024-05-01,17858.445034052424,West
2024-05-02,16872.525414838157,West
2024-05-03,14431.974877837836,West
2024-05-04,18255.03377306732,West
2024-05-05,14082.62977465336,West
2024-05-06,15794.6243052505,West
2024-05-07,12485.434271072205,West
2024-05-08,16275.419943252691,West
2024-05-09,15378.758046606908,West
2024-05-10,17269.091465312005,West
2024-05-11,16140.173336566642,West
2024-05-12,18565.984307014878,West
2024-05-13,19934.815505881277,West
2024-05-14,17393.578049677468,West
2024-05-15,15878.531972728888,West
2024-05-16,17927.20661753851,West
2024-05-17,15473.61222052217,West
2024-05-18,15732.83227189177,West
2024-05-19,13340.787269709515,West
2024-05-20,16929.10682711134,West
2024-05-21,20355.497968086747,West
2024-05-22,18323.13836047026,West
2024-05-23,18332.83834071848,West
2024-05-24,17563.129293907572,West
2024-05-25,16862.508269072594,West
2024-05-26,18520.95535802358,West
2024-05-27,19036.964952168586,West
2024-05-28,17101.143116483177,West
2024-05-29,19153.5273548559,West
2024-05-30,20284.622137091483,West
2024-05-31,14674.885321438102,West
2024-06-01,19292.051339418085,West
2024-06-02,18437.977362348596,West
2024-06-03,19960.146051239568,West
2024-06-04,16144.372481407618,West
2024-06-05,14415.747258242476,West
2024-06-06,19381.590463212244,West
2024-06-07,18689.990324950122,West
2024-06-08,21210.526998309473,West
2024-06-09,16830.206969270253,West
2024-06-10,19319.365930604512,West
2024-06-11,21783.985508916696,West
2024-06-12,18608.12651889286,West
2024-06-13,17827.085668224663,West
2024-06-14,18290.5359825048,West
2024-06-15,17565.663071240197,West
2024-06-16,17709.43412790054,West
2024-06-17,17827.184845305754,West
2024-06-18,18614.973300186997,West
2024-06-19,17315.71158299529,West
2024-06-20,16570.405681334145,West
2024-06-21,19454.945329265636,West
2024-06-22,21512.042509662468,West
2024-06-23,19335.336925932006,West
2024-06-24,19794.38244398236,West
2024-06-25,20284.686991509563,West
2024-06-26,20149.81324946302,West
2024-06-27,19828.927202165927,West
2024-06-28,19606.41702785765,West
2024-06-29,18888.126031422464,West
2024-06-30,20598.921334803046,West

</script><script type="text/plain" id="metrics_data" data-format="csv_embedded" data-src="">
Week,Value,Metric,Source
1,82.04787815218444,Metric A,Source 1
2,138.13280407016447,Metric A,Source 1
3,117.5603901384093,Metric A,Source 1
4,96.78751338352701,Metric A,Source 1
5,134.70238652719326,Metric A,Source 1
6,135.49180820066798,Metric A,Source 1
7,92.32560909551802,Metric A,Source 1
8,135.40698521514008,Metric A,Source 1
9,149.70125163384265,Metric A,Source 1
10,104.59971102178146,Metric A,Source 1
11,121.87350352029736,Metric A,Source 1
12,157.6283993910911,Metric A,Source 1
1,91.24468970281904,Metric A,Source 2
2,99.3321615553817,Metric A,Source 2
3,112.84353227160389,Metric A,Source 2
4,119.94209481966979,Metric A,Source 2
5,106.18928296983363,Metric A,Source 2
6,123.14096790791018,Metric A,Source 2
7,112.53973926394148,Metric A,Source 2
8,99.64922129902236,Metric A,Source 2
9,135.09646678753973,Metric A,Source 2
10,129.37754887775537,Metric A,Source 2
11,167.06192137475637,Metric A,Source 2
12,93.02896490145756,Metric A,Source 2
1,117.88231698075414,Metric A,Source 3
2,111.02908261827103,Metric A,Source 3
3,164.28978307562195,Metric A,Source 3
4,127.75992180902345,Metric A,Source 3
5,119.40201824741357,Metric A,Source 3
6,116.37811109429043,Metric A,Source 3
7,117.55082195873743,Metric A,Source 3
8,129.5184789434749,Metric A,Source 3
9,124.75373675361105,Metric A,Source 3
10,143.46571303651064,Metric A,Source 3
11,140.96731674425996,Metric A,Source 3
12,148.11281995208296,Metric A,Source 3
1,130.25891153106468,Metric B,Source 1
2,119.17309326849097,Metric B,Source 1
3,93.64385804653563,Metric B,Source 1
4,136.4926931527075,Metric B,Source 1
5,120.53269825884719,Metric B,Source 1
6,97.32396367118338,Metric B,Source 1
7,133.39028695511286,Metric B,Source 1
8,114.0247248104403,Metric B,Source 1
9,163.52073023856863,Metric B,Source 1
10,107.97095251502563,Metric B,Source 1
11,159.84868376596822,Metric B,Source 1
12,123.79250847840116,Metric B,Source 1
1,113.23739942559293,Metric B,Source 2
2,93.49368811523279,Metric B,Source 2
3,137.1253667965227,Metric B,Source 2
4,137.72469380085647,Metric B,Source 2
5,152.6256580393256,Metric B,Source 2
6,117.15329866663932,Metric B,Source 2
7,104.8011292790139,Metric B,Source 2
8,119.65947598977668,Metric B,Source 2
9,119.62039142960326,Metric B,Source 2
10,168.10443030263013,Metric B,Source 2
11,110.79845958963085,Metric B,Source 2
12,143.73898387603705,Metric B,Source 2
1,68.74795700979436,Metric B,Source 3
2,114.3785415383556,Metric B,Source 3
3,96.52060833471279,Metric B,Source 3
4,124.51789552122645,Metric B,Source 3
5,112.68162310425333,Metric B,Source 3
6,96.1173542106267,Metric B,Source 3
7,115.57983110931347,Metric B,Source 3
8,153.89624358148933,Metric B,Source 3
9,114.76880772571843,Metric B,Source 3
10,150.6201226715233,Metric B,Source 3
11,164.2695927355677,Metric B,Source 3
12,149.6580981342725,Metric B,Source 3
1,81.61041405206511,Metric C,Source 1
2,103.97295046782607,Metric C,Source 1
3,121.29622452521397,Metric C,Source 1
4,84.19592629233202,Metric C,Source 1
5,111.4192814645877,Metric C,Source 1
6,114.14892780015882,Metric C,Source 1
7,110.70623980193295,Metric C,Source 1
8,137.63222408987622,Metric C,Source 1
9,114.38023719454128,Metric C,Source 1
10,132.21208190677208,Metric C,Source 1
11,128.60757945880943,Metric C,Source 1
12,101.18143269490815,Metric C,Source 1
1,88.03095931423056,Metric C,Source 2
2,79.84702208086867,Metric C,Source 2
3,125.9425552253108,Metric C,Source 2
4,144.07807506092854,Metric C,Source 2
5,118.74161084886626,Metric C,Source 2
6,116.77719326494628,Metric C,Source 2
7,122.88205796218422,Metric C,Source 2
8,118.23353172440372,Metric C,Source 2
9,120.87565442593771,Metric C,Source 2
10,140.17765024331743,Metric C,Source 2
11,144.89800303694665,Metric C,Source 2
12,112.89799342926221,Metric C,Source 2
1,75.96480004751595,Metric C,Source 3
2,103.07503823613546,Metric C,Source 3
3,137.5947344154068,Metric C,Source 3
4,109.88687141081311,Metric C,Source 3
5,96.30036547686748,Metric C,Source 3
6,105.64738495731473,Metric C,Source 3
7,125.89899626411699,Metric C,Source 3
8,129.66462480541315,Metric C,Source 3
9,115.68245299610759,Metric C,Source 3
10,107.38609327467927,Metric C,Source 3
11,119.34521531915651,Metric C,Source 3
12,100.62608037052371,Metric C,Source 3
1,118.01825410641544,Metric D,Source 1
2,120.28349156217064,Metric D,Source 1
3,145.54007314941362,Metric D,Source 1
4,122.76446312171511,Metric D,Source 1
5,73.94721756484559,Metric D,Source 1
6,107.35838077784638,Metric D,Source 1
7,136.54054834274064,Metric D,Source 1
8,110.33590258016189,Metric D,Source 1
9,119.09645769263427,Metric D,Source 1
10,145.30655567605913,Metric D,Source 1
11,139.5847762081106,Metric D,Source 1
12,135.92491593766403,Metric D,Source 1
1,83.64925304575685,Metric D,Source 2
2,99.45519358098709,Metric D,Source 2
3,150.01385341228982,Metric D,Source 2
4,131.87073416782346,Metric D,Source 2
5,156.7334854204368,Metric D,Source 2
6,118.27195158949421,Metric D,Source 2
7,116.36886844746118,Metric D,Source 2
8,122.13056912938556,Metric D,Source 2
9,112.87121624103843,Metric D,Source 2
10,162.3224582531147,Metric D,Source 2
11,143.03567538520775,Metric D,Source 2
12,116.4293742997057,Metric D,Source 2
1,98.78868602343194,Metric D,Source 3
2,102.77099130092094,Metric D,Source 3
3,130.82373150175857,Metric D,Source 3
4,74.74365230503551,Metric D,Source 3
5,124.9871283009784,Metric D,Source 3
6,103.4563134991426,Metric D,Source 3
7,132.37261791095972,Metric D,Source 3
8,129.6719437972077,Metric D,Source 3
9,135.84505364700127,Metric D,Source 3
10,97.79745567290324,Metric D,Source 3
11,110.52607228334307,Metric D,Source 3
12,117.65432391631276,Metric D,Source 3

</script><script type="text/plain" id="compare_data" data-format="csv_embedded" data-src="">
Time,Value,Category
1,10.181792935683243,Cat 1
2,7.307946353354602,Cat 1
3,15.557433946841416,Cat 1
4,11.749222812564886,Cat 1
5,13.725923951554233,Cat 1
6,14.124093480340523,Cat 1
7,15.058416455785608,Cat 1
8,4.732512734379526,Cat 1
9,8.576698787116813,Cat 1
10,12.38917856526514,Cat 1
11,16.813671703518274,Cat 1
12,18.43339753585014,Cat 1
13,11.52820859153193,Cat 1
14,14.128510512299066,Cat 1
15,13.566380279767314,Cat 1
16,21.863726858649866,Cat 1
17,21.254575718757742,Cat 1
18,20.51041935824489,Cat 1
19,21.6060235490304,Cat 1
20,24.612235225780616,Cat 1
1,8.949973770640486,Cat 2
2,8.639091991862609,Cat 2
3,10.910358783144353,Cat 2
4,9.433329115600868,Cat 2
5,15.488103201179252,Cat 2
6,10.709009076115192,Cat 2
7,12.24070213425554,Cat 2
8,15.932749315553098,Cat 2
9,11.474432187799145,Cat 2
10,18.59470968282475,Cat 2
11,11.429357142947312,Cat 2
12,17.333853709533205,Cat 2
13,21.179338497576765,Cat 2
14,14.854912030118621,Cat 2
15,21.0520910193127,Cat 2
16,22.35667516450648,Cat 2
17,18.106329386706726,Cat 2
18,19.968774470264474,Cat 2
19,22.53734834682116,Cat 2
20,20.223241667738918,Cat 2
1,6.278085521542198,Cat 3
2,7.1053375985437395,Cat 3
3,13.863261326929583,Cat 3
4,12.779576031212091,Cat 3
5,12.050854628290304,Cat 3
6,16.29255796918326,Cat 3
7,13.444669101409016,Cat 3
8,18.719852214884423,Cat 3
9,10.368339478944577,Cat 3
10,7.536533945087172,Cat 3
11,19.003746225561358,Cat 3
12,17.453655759926566,Cat 3
13,16.90166892312793,Cat 3
14,17.684850298306934,Cat 3
15,24.060525615903458,Cat 3
16,19.30026317772289,Cat 3
17,14.077800806560578,Cat 3
18,15.360823816165869,Cat 3
19,18.00583043962336,Cat 3
20,18.804316549709785,Cat 3

</script><script type="text/plain" id="product_values" data-format="csv_embedded" data-src="">
Time,Value,Product
0.0,66.65316661708925,Product A
0.5,69.03117208796627,Product A
1.0,69.19966870953303,Product A
1.5,71.03973600102647,Product A
2.0,75.61840340358663,Product A
2.5,68.82106253653784,Product A
3.0,65.08737041436122,Product A
3.5,63.11523712840917,Product A
4.0,63.110666221054245,Product A
4.5,63.93498142753558,Product A
5.0,63.836652994569484,Product A
5.5,69.72084240617139,Product A
6.0,56.32930337826041,Product A
6.5,59.76756205010298,Product A
7.0,71.34636927864567,Product A
7.5,67.57639831528631,Product A
8.0,67.67974729447745,Product A
8.5,69.98583897946772,Product A
9.0,61.72960456092555,Product A
9.5,60.76177761438835,Product A
10.0,74.7334743017921,Product A
10.5,67.09656337399122,Product A
11.0,68.49211171897298,Product A
11.5,65.48822856819311,Product A
12.0,64.81001097614973,Product A
12.5,57.691076901851474,Product A
13.0,64.08231360757595,Product A
13.5,70.45925238573872,Product A
14.0,66.20630333408235,Product A
14.5,75.87068968370852,Product A
15.0,64.1537708021956,Product A
15.5,74.60022514839416,Product A
16.0,53.627497728004855,Product A
16.5,61.97878345845053,Product A
17.0,65.31089503148267,Product A
17.5,61.35308037689899,Product A
18.0,60.35418434867093,Product A
18.5,66.26780220713579,Product A
19.0,61.872816839568365,Product A
19.5,63.96603566531877,Product A
20.0,59.42821423933719,Product A
0.0,60.94459329641282,Product B
0.5,56.64832118664856,Product B
1.0,51.66282040648413,Product B
1.5,54.987791363612004,Product B
2.0,54.56464488517449,Product B
2.5,50.28646805014561,Product B
3.0,59.8551630660897,Product B
3.5,59.76584565467107,Product B
4.0,68.51168206847628,Product B
4.5,70.20321236418006,Product B
5.0,70.49554227817295,Product B
5.5,75.1344550137066,Product B
6.0,65.7689667393142,Product B
6.5,57.900320425979416,Product B
7.0,66.6451888951782,Product B
7.5,72.41424636276437,Product B
8.0,69.47576712723149,Product B
8.5,64.11312608909451,Product B
9.0,67.27842802285555,Product B
9.5,65.87346123659097,Product B
10.0,70.70645997782222,Product B
10.5,75.22568958879546,Product B
11.0,65.32262313482269,Product B
11.5,55.95697170718727,Product B
12.0,69.43318472411529,Product B
12.5,32.95240293375961,Product B
13.0,43.70077372533286,Product B
13.5,35.91687693477223,Product B
14.0,35.793537354584835,Product B
14.5,36.69749373102361,Product B
15.0,41.803649848820974,Product B
15.5,38.58855185532379,Product B
16.0,33.38040800877374,Product B
16.5,32.34475634090808,Product B
17.0,34.92673687426924,Product B
17.5,39.68764748665097,Product B
18.0,35.185369388517714,Product B
18.5,39.43235024267065,Product B
19.0,39.08176748321047,Product B
19.5,32.96860288559928,Product B
20.0,30.499743283251366,Product B
0.0,35.861266243896445,Product C
0.5,36.27830867628992,Product C
1.0,37.59614044796178,Product C
1.5,27.745968538583455,Product C
2.0,42.321551657670895,Product C
2.5,30.935630301322874,Product C
3.0,34.22563818238847,Product C
3.5,30.12579766777318,Product C
4.0,37.03592666471761,Product C
4.5,63.44001661537314,Product C
5.0,65.19976762009867,Product C
5.5,66.36873837712606,Product C
6.0,59.255213069995,Product C
6.5,64.03281057887982,Product C
7.0,66.66232631275085,Product C
7.5,63.16386895610558,Product C
8.0,64.50648765414186,Product C
8.5,64.36399963747364,Product C
9.0,68.90182155165651,Product C
9.5,67.82857527998053,Product C
10.0,64.755024682384,Product C
10.5,66.24601244888396,Product C
11.0,61.03222524757672,Product C
11.5,59.92777267841364,Product C
12.0,59.21593261945413,Product C
12.5,67.30601248813778,Product C
13.0,64.89241758689728,Product C
13.5,54.92094027230647,Product C
14.0,63.756689346920034,Product C
14.5,58.954895311436786,Product C
15.0,60.500602295659405,Product C
15.5,61.212266338411894,Product C
16.0,71.80501107726238,Product C
16.5,68.73041244240667,Product C
17.0,60.82397959901855,Product C
17.5,63.73471668220159,Product C
18.0,61.46230266577062,Product C
18.5,59.43072892619638,Product C
19.0,54.40303267240142,Product C
19.5,56.81680977624062,Product C
20.0,61.40647013773489,Product C

</script><script type="text/plain" id="grid_sales" data-format="csv_embedded" data-src="">
Month,Sales,Product,Region,Segment
1,57922.65367729653,Product X,East,Segment 1
2,37188.18092751892,Product X,East,Segment 1
3,53508.059686258275,Product X,East,Segment 1
4,43478.410376030406,Product X,East,Segment 1
5,49580.027150741356,Product X,East,Segment 1
6,46476.49466757474,Product X,East,Segment 1
1,61715.666392991545,Product X,East,Segment 2
2,35122.17518366457,Product X,East,Segment 2
3,61346.378083298456,Product X,East,Segment 2
4,58555.060450358345,Product X,East,Segment 2
5,50509.74366101081,Product X,East,Segment 2
6,58764.70974584862,Product X,East,Segment 2
1,66480.38872352327,Product X,West,Segment 1
2,60738.046997163576,Product X,West,Segment 1
3,45772.03758869723,Product X,West,Segment 1
4,60687.129352340315,Product X,West,Segment 1
5,73001.43943010317,Product X,West,Segment 1
6,56749.22847943809,Product X,West,Segment 1
1,63329.37502118356,Product X,West,Segment 2
2,40915.38266954534,Product X,West,Segment 2
3,64836.52723182697,Product X,West,Segment 2
4,41940.69829518975,Product X,West,Segment 2
5,65097.26250297855,Product X,West,Segment 2
6,56069.71580861847,Product X,West,Segment 2
1,71486.61970706197,Product Y,East,Segment 1
2,39996.9052969295,Product Y,East,Segment 1
3,52848.62595721997,Product Y,East,Segment 1
4,53365.71683933359,Product Y,East,Segment 1
5,76784.49003949936,Product Y,East,Segment 1
6,64696.4117976872,Product Y,East,Segment 1
1,44710.99080477706,Product Y,East,Segment 2
2,43864.48887268923,Product Y,East,Segment 2
3,75483.30555889575,Product Y,East,Segment 2
4,59542.85782449803,Product Y,East,Segment 2
5,53590.831824597706,Product Y,East,Segment 2
6,66260.0152781145,Product Y,East,Segment 2
1,64452.948204088556,Product Y,West,Segment 1
2,61510.50743353354,Product Y,West,Segment 1
3,62098.61037429164,Product Y,West,Segment 1
4,71718.99488099822,Product Y,West,Segment 1
5,64867.78299323028,Product Y,West,Segment 1
6,45230.54683356067,Product Y,West,Segment 1
1,49605.15584550458,Product Y,West,Segment 2
2,57677.030054645365,Product Y,West,Segment 2
3,61616.50714749799,Product Y,West,Segment 2
4,39095.598599131234,Product Y,West,Segment 2
5,70304.55152265506,Product Y,West,Segment 2
6,75988.79037157977,Product Y,West,Segment 2

</script><script type="text/plain" id="headcount_data" data-format="csv_embedded" data-src="">
Department,Headcount,Team
Engineering,6,Team A
Engineering,16,Team B
Engineering,9,Team C
Sales,23,Team A
Sales,25,Team B
Sales,18,Team C
Marketing,10,Team A
Marketing,11,Team B
Marketing,15,Team C
Operations,23,Team A
Operations,19,Team B
Operations,19,Team C
HR,17,Team A
HR,17,Team B
HR,13,Team C

</script><script type="text/plain" id="market_share" data-format="csv_embedded" data-src="">
Month,MarketShare,Category
1,12.772411494873792,Category A
2,19.75026331184171,Category A
3,19.86815617235975,Category A
4,26.287524631542688,Category A
5,21.034381269540468,Category A
6,23.972832934034777,Category A
7,8.725470792982007,Category A
8,12.92343535827909,Category A
9,19.894246017812556,Category A
10,22.090545174232506,Category A
11,25.366219250163965,Category A
12,13.989094075419484,Category A
1,14.591030720072233,Category B
2,15.92537042548782,Category B
3,16.23965011212974,Category B
4,21.399733650413868,Category B
5,17.52247380543629,Category B
6,18.80970583188795,Category B
7,30.125581714672094,Category B
8,21.87297352498392,Category B
9,19.60696261291789,Category B
10,31.73392841899103,Category B
11,19.646686187630404,Category B
12,14.866275260691262,Category B
1,14.43600862874376,Category C
2,19.547577931307956,Category C
3,16.146090598944234,Category C
4,23.437316042736228,Category C
5,27.92815765363503,Category C
6,26.180234436141575,Category C
7,20.199109667929104,Category C
8,13.07033952355128,Category C
9,17.514526533305496,Category C
10,12.436921944367075,Category C
11,15.60290012661683,Category C
12,19.160502036168246,Category C
1,17.469753539320802,Category D
2,20.54125303936122,Category D
3,11.787281020638115,Category D
4,19.768835423580825,Category D
5,27.99059950655145,Category D
6,23.984387791032315,Category D
7,16.960338203400255,Category D
8,19.72961473258083,Category D
9,20.379449215597802,Category D
10,11.78529220163974,Category D
11,21.096623497352176,Category D
12,10.297326275572857,Category D

</script><script type="text/plain" id="business_metrics" data-format="csv_embedded" data-src="">
Quarter,Revenue,Profit,Growth,Industry,CompanySize
1,73.0212705530764,17.222176755063433,8.944151296137102,Tech,Small
2,89.94720767185915,21.686069298969855,4.360422884390529,Tech,Small
3,134.74178018491483,7.3513767162737125,1.561060873347342,Tech,Small
4,100.52987046321333,22.13619152306192,4.902192670549527,Tech,Small
1,96.57238157287775,30.215508665787066,4.321683755718741,Tech,Medium
2,123.35959139241822,28.201996678739818,5.4802946703003785,Tech,Medium
3,107.25398467225644,19.816170668224448,1.7464520131743413,Tech,Medium
4,62.45777080438805,18.918221357587107,7.590464062279523,Tech,Medium
1,102.07149569926611,18.096286758962695,5.112041577499672,Tech,Large
2,78.12880443893803,20.65740270435355,11.085695939611048,Tech,Large
3,73.6791632490729,19.29182625079696,8.25935390357083,Tech,Large
4,82.35688242498837,16.220229492034832,6.972771269403749,Tech,Large
1,107.93071452505889,17.741890358967254,4.337205223461509,Finance,Small
2,71.39934702328469,21.36612723182384,4.901304932303084,Finance,Small
3,91.26687929890662,27.02531780994594,2.0506996216649824,Finance,Small
4,80.99806303585204,24.366173620679543,6.166005725144145,Finance,Small
1,87.06264532812037,24.478244812728047,6.803409605544756,Finance,Medium
2,105.41087417747133,32.46776599472868,10.065264253600818,Finance,Medium
3,61.42555590056981,26.96788317518154,4.998745366778937,Finance,Medium
4,74.39704256174588,18.66608269339428,6.869580361604717,Finance,Medium
1,109.54315482128159,21.24986869742882,4.307611183667831,Finance,Large
2,116.88792728224189,12.58029204232642,8.736321254491841,Finance,Large
3,95.58561772151505,20.442735436342748,4.018022129217773,Finance,Large
4,90.66046873695085,16.66613667509568,5.638347693375881,Finance,Large
1,37.98306516421696,15.24837679693828,2.9029972859905846,Healthcare,Small
2,83.66549333818988,15.970047373209676,7.959337913443079,Healthcare,Small
3,96.41271321686493,12.775347761353721,5.030058833372144,Healthcare,Small
4,97.96298429331992,16.556522311277437,1.1029143097658145,Healthcare,Small
1,90.89084622402112,24.00047724904422,9.065297790016373,Healthcare,Medium
2,80.90982327807357,18.250559383159242,9.299647128627626,Healthcare,Medium
3,124.24847094457915,24.115933787566643,0.6596093175664954,Healthcare,Medium
4,153.15611668050437,26.860551166636654,1.2111873283737769,Healthcare,Medium
1,99.26843947957839,24.064197332327318,7.485375614265823,Healthcare,Large
2,68.0438592258255,21.639840171739355,6.348046218446403,Healthcare,Large
3,128.19479991436936,18.128707766474232,7.828340809324342,Healthcare,Large
4,115.83659676170682,13.75368385164228,10.812659829061243,Healthcare,Large

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <h1>AreaChart Examples</h1>
<p>This page demonstrates the key features of AreaChart plots in JSPlots.</p>
<ul>
    <li><strong>Continuous areas:</strong> Smooth filled areas for continuous x values (like dates)</li>
    <li><strong>Discrete areas:</strong> Bar-style areas for categorical x values</li>
    <li><strong>Stack modes:</strong> Unstack (overlapping), stack (cumulative), and normalized stack (percentage)</li>
    <li><strong>Grouping:</strong> Multiple series with automatic color assignment and legend</li>
    <li><strong>Interactive filters:</strong> Dropdown menus to filter data dynamically</li>
    <li><strong>Dynamic controls:</strong> Change grouping, stacking, and faceting on the fly</li>
    <li><strong>Faceting:</strong> Facet wrap (1 variable) and facet grid (2 variables)</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Example 1: Regional Sales Over Time (Stacked Area Chart)</h2>
<p>Continuous time series with dates on x-axis. Stacked areas show cumulative sales across regions.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_stacked_area">Stack mode: </label>
        <select id="stack_mode_select_stacked_area" onchange="updatePlot_stacked_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="stacked_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_by_region</p><br>
<hr>
<br>
<h2>Example 2: Product Values - Continuous Unstack</h2>
<p>Continuous x-axis (numeric). Overlapping areas with transparency allow comparison of individual trends.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_unstacked_area">Stack mode: </label>
        <select id="stack_mode_select_unstacked_area" onchange="updatePlot_unstacked_area()">
                <option value="unstack" selected>unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="unstacked_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: product_values</p><br>
<hr>
<br>
<h2>Example 3: Market Share Distribution (Normalized Stack)</h2>
<p>Continuous numeric x-axis. Normalized stacking shows relative proportions - total always reaches 100%.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_normalized_area">Stack mode: </label>
        <select id="stack_mode_select_normalized_area" onchange="updatePlot_normalized_area()">
                <option value="unstack">unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack" selected>normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="normalized_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: market_share</p><br>
<hr>
<br>
<h2>Example 4: Headcount by Department (Discrete/Stacked Bars)</h2>
<p>Categorical x-axis. When x values are discrete, areas automatically become stacked bars.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_discrete_area">Stack mode: </label>
        <select id="stack_mode_select_discrete_area" onchange="updatePlot_discrete_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="discrete_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: headcount_data</p><br>
<hr>
<br>
<h2>Example 5: Revenue by Channel with Filters</h2>
<p>Continuous date axis with interactive filters. Select different years and regions to update the view.</p>

<!-- Filters (for data filtering) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f9f9f9;">
            <h4 style="margin-top: 0;">Filters</h4>
                    <div style="margin: 10px;">
            <label for="Year_select">Year: </label>
            <select id="Year_select" multiple style="min-width: 150px; height: 100px;" onchange="updatePlot_filtered_area()">
                <option value="2022">2022</option>
                <option value="2023">2023</option>
                <option value="2024" selected>2024</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="Region_select">Region: </label>
            <select id="Region_select" multiple style="min-width: 150px; height: 100px;" onchange="updatePlot_filtered_area()">
                <option value="North" selected>North</option>
                <option value="South">South</option>
            </select>
        </div>
        
        </div>

<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_filtered_area">Stack mode: </label>
        <select id="stack_mode_select_filtered_area" onchange="updatePlot_filtered_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="filtered_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: channel_revenue</p><br>
<hr>
<br>
<h2>Example 6: Metrics by Source (Facet Wrap)</h2>
<p>Continuous x-axis with faceting. Each facet shows one metric with stacked sources.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_facet_wrap_area">Stack mode: </label>
        <select id="stack_mode_select_facet_wrap_area" onchange="updatePlot_facet_wrap_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_facet_wrap_area">Facet by: </label>
            <select id="facet1_select_facet_wrap_area" onchange="updatePlot_facet_wrap_area()">
                <option value="None">None</option>
                <option value="Metric" selected>Metric</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="facet_wrap_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: metrics_data</p><br>
<hr>
<br>
<h2>Example 7: Sales by Product and Region (Facet Grid)</h2>
<p>Continuous x-axis with 2D facet grid. Products in rows, Regions in columns.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_facet_grid_area">Stack mode: </label>
        <select id="stack_mode_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_facet_grid_area">Facet 1: </label>
            <select id="facet1_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="None">None</option>
                <option value="Product" selected>Product</option>
                <option value="Region">Region</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_facet_grid_area">Facet 2: </label>
            <select id="facet2_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="None">None</option>
                <option value="Product">Product</option>
                <option value="Region" selected>Region</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="facet_grid_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: grid_sales</p><br>
<hr>
<br>
<h2>Example 8: Business Metrics with Dynamic Controls</h2>
<p>Continuous x-axis. Use dropdowns to dynamically change: Y metric, grouping variable, stack mode, and faceting.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                    <div style="margin: 10px;">
            <label for="y_col_select_dynamic_grouping">Y dimension: </label>
            <select id="y_col_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="Revenue" selected>Revenue</option>
                <option value="Profit">Profit</option>
                <option value="Growth">Growth</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="group_col_select_dynamic_grouping">Group by: </label>
            <select id="group_col_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="Industry" selected>Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
            <div style="margin: 10px;">
        <label for="stack_mode_select_dynamic_grouping">Stack mode: </label>
        <select id="stack_mode_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_dynamic_grouping">Facet 1: </label>
            <select id="facet1_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="None" selected>None</option>
                <option value="Industry">Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_dynamic_grouping">Facet 2: </label>
            <select id="facet2_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="None" selected>None</option>
                <option value="Industry">Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="dynamic_grouping"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: business_metrics</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Stack Mode Comparison</h2>
<p>The following three charts use the same data but different stack modes to illustrate their differences:</p>

    </div>
<br>
<hr>
<br>
<h2>Stack Mode: UNSTACK</h2>
<p>Areas overlap with transparency - see individual trends clearly</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_unstack_mode">Stack mode: </label>
        <select id="stack_mode_select_unstack_mode" onchange="updatePlot_unstack_mode()">
                <option value="unstack" selected>unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="unstack_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
<h2>Stack Mode: STACK</h2>
<p>Areas are stacked - shows cumulative total and individual contributions</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_stack_mode">Stack mode: </label>
        <select id="stack_mode_select_stack_mode" onchange="updatePlot_stack_mode()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="stack_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
<h2>Stack Mode: NORMALIZED STACK</h2>
<p>Areas are stacked and normalized to 100% - shows relative proportions over time</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_normalized_mode">Stack mode: </label>
        <select id="stack_mode_select_normalized_mode" onchange="updatePlot_normalized_mode()">
                <option value="unstack">unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack" selected>normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="normalized_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Key Features Summary</h2>
<ul>
    <li><strong>Automatic discrete/continuous detection:</strong> Continuous x values (dates, numeric) create smooth areas; discrete x values (categories) create stacked bars</li>
    <li><strong>Three stack modes:</strong>
        <ul>
            <li><em>Unstack:</em> Overlapping areas with transparency - best for comparing trends</li>
            <li><em>Stack:</em> Cumulative areas - best for showing total and parts</li>
            <li><em>Normalized stack:</em> Percentage areas - best for showing proportions</li>
        </ul>
    </li>
    <li><strong>Dynamic grouping:</strong> Choose which variable to group/color by from dropdown</li>
    <li><strong>Interactive filters:</strong> Filter data dynamically with dropdown menus</li>
    <li><strong>Faceting:</strong> Create small multiples with 1 or 2 faceting variables</li>
    <li><strong>Customization:</strong> Control opacity, titles, and stack modes</li>
    <li><strong>Date support:</strong> Automatic formatting and proper handling of date-based time series</li>
</ul>
<p><strong>Tip:</strong> Hover over areas to see detailed values. Use the dropdown controls to explore different views of your data!</p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
