<!DOCTYPE html>
<html>
<head>
    <title>AreaChart Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>
</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                resolve(results.data);
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                resolve(data);
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        resolve(results.data);
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Date'];
    const Y_COLS = ['Sales'];
    const GROUP_COLS = ['Region'];
    const COLOR_MAPS = {'Region': {'East': '#00cc96', 'West': '#ab63fa', 'North': '#636efa', 'South': '#EF553B'}};
    const GROUP_ORDER = {'Region': ['North', 'South', 'East', 'West']};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_GROUP_COL = 'Region';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_stacked_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stacked_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stacked_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_stacked_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_stacked_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stacked_area');
        const facet2Select = document.getElementById('facet2_select_stacked_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_by_region').then(function(data) {
        allData = data;
        window.updateChart_stacked_area();
    }).catch(function(error) {
        console.error('Error loading data for chart stacked_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Product'];
    const COLOR_MAPS = {'Product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product B': '#EF553B'}};
    const GROUP_ORDER = {'Product': ['Product A', 'Product B', 'Product C']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Product';
    const FILL_OPACITY = 0.4;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_unstacked_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_unstacked_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_unstacked_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_unstacked_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_unstacked_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'unstack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_unstacked_area');
        const facet2Select = document.getElementById('facet2_select_unstacked_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('product_values').then(function(data) {
        allData = data;
        window.updateChart_unstacked_area();
    }).catch(function(error) {
        console.error('Error loading data for chart unstacked_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['MarketShare'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Category D': '#ab63fa', 'Category C': '#00cc96', 'Category B': '#EF553B', 'Category A': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Category A', 'Category B', 'Category C', 'Category D']};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'MarketShare';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_normalized_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_normalized_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_normalized_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_normalized_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_normalized_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'normalised_stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_normalized_area');
        const facet2Select = document.getElementById('facet2_select_normalized_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('market_share').then(function(data) {
        allData = data;
        window.updateChart_normalized_area();
    }).catch(function(error) {
        console.error('Error loading data for chart normalized_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Department'];
    const Y_COLS = ['Headcount'];
    const GROUP_COLS = ['Team'];
    const COLOR_MAPS = {'Team': {'Team C': '#00cc96', 'Team B': '#EF553B', 'Team A': '#636efa'}};
    const GROUP_ORDER = {'Team': ['Team A', 'Team B', 'Team C']};
    const DEFAULT_X_COL = 'Department';
    const DEFAULT_Y_COL = 'Headcount';
    const DEFAULT_GROUP_COL = 'Team';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_discrete_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_discrete_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_discrete_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_discrete_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_discrete_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_discrete_area');
        const facet2Select = document.getElementById('facet2_select_discrete_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('headcount_data').then(function(data) {
        allData = data;
        window.updateChart_discrete_area();
    }).catch(function(error) {
        console.error('Error loading data for chart discrete_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['Year', 'Region'];
    const X_COLS = ['Date'];
    const Y_COLS = ['Revenue'];
    const GROUP_COLS = ['Channel'];
    const COLOR_MAPS = {'Channel': {'Retail': '#EF553B', 'Online': '#636efa', 'Wholesale': '#00cc96'}};
    const GROUP_ORDER = {'Channel': ['Online', 'Retail', 'Wholesale']};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_GROUP_COL = 'Channel';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_filtered_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_filtered_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_filtered_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_filtered_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_filtered_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_filtered_area');
        const facet2Select = document.getElementById('facet2_select_filtered_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('channel_revenue').then(function(data) {
        allData = data;
        window.updateChart_filtered_area();
    }).catch(function(error) {
        console.error('Error loading data for chart filtered_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Week'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Source'];
    const COLOR_MAPS = {'Source': {'Source 1': '#636efa', 'Source 2': '#EF553B', 'Source 3': '#00cc96'}};
    const GROUP_ORDER = {'Source': ['Source 1', 'Source 2', 'Source 3']};
    const DEFAULT_X_COL = 'Week';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Source';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_facet_wrap_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_wrap_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_wrap_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_facet_wrap_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_facet_wrap_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_wrap_area');
        const facet2Select = document.getElementById('facet2_select_facet_wrap_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('metrics_data').then(function(data) {
        allData = data;
        window.updateChart_facet_wrap_area();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_wrap_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const GROUP_COLS = ['Segment'];
    const COLOR_MAPS = {'Segment': {'Segment 1': '#636efa', 'Segment 2': '#EF553B'}};
    const GROUP_ORDER = {'Segment': ['Segment 1', 'Segment 2']};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_GROUP_COL = 'Segment';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_facet_grid_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_grid_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_grid_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_facet_grid_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_facet_grid_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_grid_area');
        const facet2Select = document.getElementById('facet2_select_facet_grid_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('grid_sales').then(function(data) {
        allData = data;
        window.updateChart_facet_grid_area();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_grid_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Quarter'];
    const Y_COLS = ['Revenue', 'Profit', 'Growth'];
    const GROUP_COLS = ['Industry', 'CompanySize'];
    const COLOR_MAPS = {'Industry': {'Finance': '#EF553B', 'Healthcare': '#00cc96', 'Tech': '#636efa'}, 'CompanySize': {'Medium': '#EF553B', 'Small': '#636efa', 'Large': '#00cc96'}};
    const GROUP_ORDER = {'Industry': ['Tech', 'Finance', 'Healthcare'], 'CompanySize': ['Small', 'Medium', 'Large']};
    const DEFAULT_X_COL = 'Quarter';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_GROUP_COL = 'Industry';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_dynamic_grouping = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_dynamic_grouping');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_dynamic_grouping');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_dynamic_grouping');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_dynamic_grouping');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_dynamic_grouping');
        const facet2Select = document.getElementById('facet2_select_dynamic_grouping');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('business_metrics').then(function(data) {
        allData = data;
        window.updateChart_dynamic_grouping();
    }).catch(function(error) {
        console.error('Error loading data for chart dynamic_grouping:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.5;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_unstack_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_unstack_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_unstack_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_unstack_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_unstack_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'unstack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_unstack_mode');
        const facet2Select = document.getElementById('facet2_select_unstack_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updateChart_unstack_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart unstack_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_stack_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stack_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stack_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_stack_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_stack_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stack_mode');
        const facet2Select = document.getElementById('facet2_select_stack_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updateChart_stack_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart stack_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updateChart_normalized_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_normalized_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_normalized_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_normalized_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_normalized_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'normalised_stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_normalized_mode');
        const facet2Select = document.getElementById('facet2_select_normalized_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updateChart_normalized_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart normalized_mode:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="channel_revenue" data-format="csv_embedded" data-src="">
Date,Revenue,Channel,Region,Year
2024-01-01,122573.20099839846,Online,North,2022
2024-01-08,123311.45867919447,Online,North,2022
2024-01-15,76619.14550319863,Online,North,2022
2024-01-22,100530.87005106153,Online,North,2022
2024-01-29,114984.01653370114,Online,North,2022
2024-02-05,100036.87457945285,Online,North,2022
2024-02-12,79687.46537295062,Online,North,2022
2024-02-19,98373.92872264251,Online,North,2022
2024-02-26,133054.35085366142,Online,North,2022
2024-03-04,111521.79266991287,Online,North,2022
2024-03-11,68393.4834451435,Online,North,2022
2024-03-18,98035.19204093028,Online,North,2022
2024-03-25,110700.18578744917,Online,North,2022
2024-04-01,118667.32665775759,Online,North,2022
2024-04-08,128064.5805141147,Online,North,2022
2024-04-15,152329.9547536564,Online,North,2022
2024-04-22,111046.1878894289,Online,North,2022
2024-04-29,122358.58559989573,Online,North,2022
2024-05-06,137653.29167301665,Online,North,2022
2024-05-13,141827.83405486098,Online,North,2022
2024-05-20,129085.53149170366,Online,North,2022
2024-05-27,99637.37848513693,Online,North,2022
2024-06-03,126275.52301184602,Online,North,2022
2024-06-10,76582.35111019679,Online,North,2022
2024-06-17,116208.42141977594,Online,North,2022
2024-06-24,128192.92909626463,Online,North,2022
2024-07-01,179059.08986719802,Online,North,2022
2024-07-08,110247.59625323594,Online,North,2022
2024-07-15,122639.61773103267,Online,North,2022
2024-07-22,157533.0447066031,Online,North,2022
2024-07-29,168711.274833203,Online,North,2022
2024-08-05,142478.10878128896,Online,North,2022
2024-08-12,139575.5149311163,Online,North,2022
2024-08-19,114927.70029301579,Online,North,2022
2024-08-26,130600.8659206338,Online,North,2022
2024-09-02,135730.19068427314,Online,North,2022
2024-09-09,142162.73953950708,Online,North,2022
2024-09-16,119017.04273928948,Online,North,2022
2024-09-23,133087.09678206092,Online,North,2022
2024-09-30,155192.79947316454,Online,North,2022
2024-10-07,154426.25007047743,Online,North,2022
2024-10-14,143128.72377892985,Online,North,2022
2024-10-21,126463.64167890222,Online,North,2022
2024-10-28,109772.0358469343,Online,North,2022
2024-11-04,135331.40939237698,Online,North,2022
2024-11-11,144674.62056243472,Online,North,2022
2024-11-18,174551.4600661602,Online,North,2022
2024-11-25,180225.3108954085,Online,North,2022
2024-12-02,156966.3442644226,Online,North,2022
2024-12-09,129112.10021478168,Online,North,2022
2024-12-16,125565.86337796962,Online,North,2022
2024-12-23,179689.54427329474,Online,North,2022
2024-12-30,119632.32195917264,Online,North,2022
2024-01-01,81987.23323292838,Online,South,2022
2024-01-08,114065.03873495445,Online,South,2022
2024-01-15,90739.72538090548,Online,South,2022
2024-01-22,99901.98104973066,Online,South,2022
2024-01-29,152214.32437910017,Online,South,2022
2024-02-05,108693.48306338607,Online,South,2022
2024-02-12,110016.21475895692,Online,South,2022
2024-02-19,109830.39496997578,Online,South,2022
2024-02-26,91376.69760422643,Online,South,2022
2024-03-04,106711.17634853443,Online,South,2022
2024-03-11,116951.45179090751,Online,South,2022
2024-03-18,125780.66873253575,Online,South,2022
2024-03-25,130618.39321130814,Online,South,2022
2024-04-01,128999.07945983863,Online,South,2022
2024-04-08,112375.8188524338,Online,South,2022
2024-04-15,85144.29780503435,Online,South,2022
2024-04-22,91917.91742788299,Online,South,2022
2024-04-29,121595.24057700095,Online,South,2022
2024-05-06,144576.971017784,Online,South,2022
2024-05-13,97317.82741860184,Online,South,2022
2024-05-20,105537.43358433255,Online,South,2022
2024-05-27,101279.308164224,Online,South,2022
2024-06-03,98621.04102537489,Online,South,2022
2024-06-10,96937.68716513668,Online,South,2022
2024-06-17,120244.4609200249,Online,South,2022
2024-06-24,134258.13424478628,Online,South,2022
2024-07-01,110255.29921473128,Online,South,2022
2024-07-08,147980.90847852774,Online,South,2022
2024-07-15,153696.03766151547,Online,South,2022
2024-07-22,129158.8922806638,Online,South,2022
2024-07-29,127078.73507016947,Online,South,2022
2024-08-05,95037.76672289672,Online,South,2022
2024-08-12,143337.28412210205,Online,South,2022
2024-08-19,168992.36338121348,Online,South,2022
2024-08-26,147711.27205284414,Online,South,2022
2024-09-02,113249.85343816943,Online,South,2022
2024-09-09,197367.54262621395,Online,South,2022
2024-09-16,144459.00139224326,Online,South,2022
2024-09-23,152121.40442874463,Online,South,2022
2024-09-30,98374.84977698248,Online,South,2022
2024-10-07,110208.4830561819,Online,South,2022
2024-10-14,150343.8916975715,Online,South,2022
2024-10-21,130765.72721762794,Online,South,2022
2024-10-28,155282.01359300534,Online,South,2022
2024-11-04,137078.76527779002,Online,South,2022
2024-11-11,135336.73621056695,Online,South,2022
2024-11-18,142381.1667406002,Online,South,2022
2024-11-25,138860.58032775158,Online,South,2022
2024-12-02,146284.70756991665,Online,South,2022
2024-12-09,157560.55616425327,Online,South,2022
2024-12-16,151018.01064071638,Online,South,2022
2024-12-23,185634.14814654193,Online,South,2022
2024-12-30,90690.47739607524,Online,South,2022
2024-01-01,91775.31167421988,Retail,North,2022
2024-01-08,101764.20093237149,Retail,North,2022
2024-01-15,135188.22505803057,Retail,North,2022
2024-01-22,116627.24748604058,Retail,North,2022
2024-01-29,110155.75066577511,Retail,North,2022
2024-02-05,87565.08035388814,Retail,North,2022
2024-02-12,132295.01253528259,Retail,North,2022
2024-02-19,125373.26598535055,Retail,North,2022
2024-02-26,86880.35220497205,Retail,North,2022
2024-03-04,110319.82922874171,Retail,North,2022
2024-03-11,102178.77079552904,Retail,North,2022
2024-03-18,118015.04620979221,Retail,North,2022
2024-03-25,89564.7072794181,Retail,North,2022
2024-04-01,130414.76986634679,Retail,North,2022
2024-04-08,96053.19719098043,Retail,North,2022
2024-04-15,138791.96852944902,Retail,North,2022
2024-04-22,126795.6093585151,Retail,North,2022
2024-04-29,138728.26337015966,Retail,North,2022
2024-05-06,114799.51069133305,Retail,North,2022
2024-05-13,95158.60675903298,Retail,North,2022
2024-05-20,155248.77614121514,Retail,North,2022
2024-05-27,121117.24081909918,Retail,North,2022
2024-06-03,94172.82288421661,Retail,North,2022
2024-06-10,94995.1991753604,Retail,North,2022
2024-06-17,102896.65322971983,Retail,North,2022
2024-06-24,134807.26576951722,Retail,North,2022
2024-07-01,132557.76965800917,Retail,North,2022
2024-07-08,140756.6390287936,Retail,North,2022
2024-07-15,132145.4765054825,Retail,North,2022
2024-07-22,120993.57091129011,Retail,North,2022
2024-07-29,180661.66743961643,Retail,North,2022
2024-08-05,112431.55880878252,Retail,North,2022
2024-08-12,121735.51048543226,Retail,North,2022
2024-08-19,132370.10162140214,Retail,North,2022
2024-08-26,131332.1029555729,Retail,North,2022
2024-09-02,113899.81744312089,Retail,North,2022
2024-09-09,134294.6969378149,Retail,North,2022
2024-09-16,174531.48764555677,Retail,North,2022
2024-09-23,157812.96351942487,Retail,North,2022
2024-09-30,128276.37491095571,Retail,North,2022
2024-10-07,135093.07497319914,Retail,North,2022
2024-10-14,145251.2526525437,Retail,North,2022
2024-10-21,161916.71912091726,Retail,North,2022
2024-10-28,137329.26063708757,Retail,North,2022
2024-11-04,141733.7507647511,Retail,North,2022
2024-11-11,158806.56493764714,Retail,North,2022
2024-11-18,157059.02543071052,Retail,North,2022
2024-11-25,149500.41972560395,Retail,North,2022
2024-12-02,140477.37187043641,Retail,North,2022
2024-12-09,164175.2543500957,Retail,North,2022
2024-12-16,136067.07263202773,Retail,North,2022
2024-12-23,176484.7963725088,Retail,North,2022
2024-12-30,102623.55548224144,Retail,North,2022
2024-01-01,106687.68551459297,Retail,South,2022
2024-01-08,122130.45182986779,Retail,South,2022
2024-01-15,78990.57971374433,Retail,South,2022
2024-01-22,71805.1087590851,Retail,South,2022
2024-01-29,126764.74698708471,Retail,South,2022
2024-02-05,69566.39318965291,Retail,South,2022
2024-02-12,124536.96661539903,Retail,South,2022
2024-02-19,111587.48133006487,Retail,South,2022
2024-02-26,76698.27917935666,Retail,South,2022
2024-03-04,104426.30215282174,Retail,South,2022
2024-03-11,126007.76422796636,Retail,South,2022
2024-03-18,142956.93888778568,Retail,South,2022
2024-03-25,98698.0351577947,Retail,South,2022
2024-04-01,91844.61703096688,Retail,South,2022
2024-04-08,102116.70676907248,Retail,South,2022
2024-04-15,106408.51875652978,Retail,South,2022
2024-04-22,160800.92768850538,Retail,South,2022
2024-04-29,108406.77145108978,Retail,South,2022
2024-05-06,122626.71223979193,Retail,South,2022
2024-05-13,123779.31456667793,Retail,South,2022
2024-05-20,144386.46141558766,Retail,South,2022
2024-05-27,114559.23970008754,Retail,South,2022
2024-06-03,97847.5672452154,Retail,South,2022
2024-06-10,126483.28142561417,Retail,South,2022
2024-06-17,122773.07238148528,Retail,South,2022
2024-06-24,150328.00654338737,Retail,South,2022
2024-07-01,143639.24542330275,Retail,South,2022
2024-07-08,124410.12114416347,Retail,South,2022
2024-07-15,91688.62116110785,Retail,South,2022
2024-07-22,115727.25610152501,Retail,South,2022
2024-07-29,106161.60763084351,Retail,South,2022
2024-08-05,129903.745930628,Retail,South,2022
2024-08-12,137911.55751384716,Retail,South,2022
2024-08-19,145340.55315582274,Retail,South,2022
2024-08-26,119438.39678452534,Retail,South,2022
2024-09-02,150999.8148344001,Retail,South,2022
2024-09-09,154231.19642641273,Retail,South,2022
2024-09-16,112877.283380218,Retail,South,2022
2024-09-23,124038.93405260399,Retail,South,2022
2024-09-30,140586.3703663611,Retail,South,2022
2024-10-07,128524.54267249389,Retail,South,2022
2024-10-14,168669.24907142087,Retail,South,2022
2024-10-21,190594.35227127612,Retail,South,2022
2024-10-28,147202.92811664703,Retail,South,2022
2024-11-04,117199.06238149863,Retail,South,2022
2024-11-11,166005.4050573011,Retail,South,2022
2024-11-18,143818.31376476894,Retail,South,2022
2024-11-25,174498.68044989387,Retail,South,2022
2024-12-02,129517.77328955857,Retail,South,2022
2024-12-09,103356.26109560044,Retail,South,2022
2024-12-16,148112.16676669064,Retail,South,2022
2024-12-23,169123.2869362943,Retail,South,2022
2024-12-30,77770.89895228932,Retail,South,2022
2024-01-01,95389.68706908243,Wholesale,North,2022
2024-01-08,125679.64611664014,Wholesale,North,2022
2024-01-15,100052.21613023082,Wholesale,North,2022
2024-01-22,102656.88214384955,Wholesale,North,2022
2024-01-29,147628.97754950548,Wholesale,North,2022
2024-02-05,88850.99889712203,Wholesale,North,2022
2024-02-12,114071.11262766486,Wholesale,North,2022
2024-02-19,91323.39688073126,Wholesale,North,2022
2024-02-26,86888.16454721215,Wholesale,North,2022
2024-03-04,71234.11202920886,Wholesale,North,2022
2024-03-11,144232.8520246,Wholesale,North,2022
2024-03-18,121228.29629185476,Wholesale,North,2022
2024-03-25,138137.5272521681,Wholesale,North,2022
2024-04-01,98980.68634138916,Wholesale,North,2022
2024-04-08,81469.04812067363,Wholesale,North,2022
2024-04-15,126033.50527336523,Wholesale,North,2022
2024-04-22,145201.1302030848,Wholesale,North,2022
2024-04-29,102929.06894389719,Wholesale,North,2022
2024-05-06,111621.72716638018,Wholesale,North,2022
2024-05-13,142526.53857126768,Wholesale,North,2022
2024-05-20,74332.49977701751,Wholesale,North,2022
2024-05-27,132241.5788501982,Wholesale,North,2022
2024-06-03,143073.50728124328,Wholesale,North,2022
2024-06-10,158299.1666023328,Wholesale,North,2022
2024-06-17,125289.20758540055,Wholesale,North,2022
2024-06-24,120933.4383235621,Wholesale,North,2022
2024-07-01,158866.3426768672,Wholesale,North,2022
2024-07-08,128790.06121600179,Wholesale,North,2022
2024-07-15,115136.77446430027,Wholesale,North,2022
2024-07-22,122551.04975653937,Wholesale,North,2022
2024-07-29,96533.72281847763,Wholesale,North,2022
2024-08-05,83018.16243955799,Wholesale,North,2022
2024-08-12,150148.6025512268,Wholesale,North,2022
2024-08-19,127960.48257221686,Wholesale,North,2022
2024-08-26,141807.3648183518,Wholesale,North,2022
2024-09-02,138293.34698326117,Wholesale,North,2022
2024-09-09,139409.337945148,Wholesale,North,2022
2024-09-16,112540.27698056429,Wholesale,North,2022
2024-09-23,149115.4981708782,Wholesale,North,2022
2024-09-30,132719.67728241303,Wholesale,North,2022
2024-10-07,136029.10418349598,Wholesale,North,2022
2024-10-14,140069.4256125686,Wholesale,North,2022
2024-10-21,150320.53057099937,Wholesale,North,2022
2024-10-28,150570.83043913526,Wholesale,North,2022
2024-11-04,152059.34590404516,Wholesale,North,2022
2024-11-11,148161.19899721566,Wholesale,North,2022
2024-11-18,122287.44653959648,Wholesale,North,2022
2024-11-25,157550.32781790488,Wholesale,North,2022
2024-12-02,133094.59593613236,Wholesale,North,2022
2024-12-09,126149.01488558209,Wholesale,North,2022
2024-12-16,130288.46534146322,Wholesale,North,2022
2024-12-23,108030.3506799192,Wholesale,North,2022
2024-12-30,115862.57467473936,Wholesale,North,2022
2024-01-01,56086.13912593125,Wholesale,South,2022
2024-01-08,106565.54674058137,Wholesale,South,2022
2024-01-15,91273.51794167714,Wholesale,South,2022
2024-01-22,109870.18464321663,Wholesale,South,2022
2024-01-29,100995.30453161361,Wholesale,South,2022
2024-02-05,73010.30702715652,Wholesale,South,2022
2024-02-12,107312.80188368121,Wholesale,South,2022
2024-02-19,115765.3359630634,Wholesale,South,2022
2024-02-26,103455.26192610533,Wholesale,South,2022
2024-03-04,137297.00713506318,Wholesale,South,2022
2024-03-11,75182.51077473868,Wholesale,South,2022
2024-03-18,154616.7485703967,Wholesale,South,2022
2024-03-25,116537.71266597173,Wholesale,South,2022
2024-04-01,118550.66066188365,Wholesale,South,2022
2024-04-08,114309.50288607042,Wholesale,South,2022
2024-04-15,95002.32313324885,Wholesale,South,2022
2024-04-22,118358.24659741914,Wholesale,South,2022
2024-04-29,83617.21199246055,Wholesale,South,2022
2024-05-06,113018.3816460362,Wholesale,South,2022
2024-05-13,129066.70527893663,Wholesale,South,2022
2024-05-20,108217.67546548559,Wholesale,South,2022
2024-05-27,96112.75351077427,Wholesale,South,2022
2024-06-03,145778.0682876687,Wholesale,South,2022
2024-06-10,124332.41073328521,Wholesale,South,2022
2024-06-17,121651.48322037893,Wholesale,South,2022
2024-06-24,129934.50543076385,Wholesale,South,2022
2024-07-01,123335.90538386603,Wholesale,South,2022
2024-07-08,139560.7095817768,Wholesale,South,2022
2024-07-15,117835.02357992918,Wholesale,South,2022
2024-07-22,133301.36701777426,Wholesale,South,2022
2024-07-29,120625.71226548443,Wholesale,South,2022
2024-08-05,144820.83431089576,Wholesale,South,2022
2024-08-12,100337.45010650106,Wholesale,South,2022
2024-08-19,135036.4203833564,Wholesale,South,2022
2024-08-26,139210.84426007696,Wholesale,South,2022
2024-09-02,113554.55179171008,Wholesale,South,2022
2024-09-09,112649.87697027727,Wholesale,South,2022
2024-09-16,146551.15157913405,Wholesale,South,2022
2024-09-23,161559.11085441837,Wholesale,South,2022
2024-09-30,122192.25430995549,Wholesale,South,2022
2024-10-07,124153.40638284515,Wholesale,South,2022
2024-10-14,142934.5691803728,Wholesale,South,2022
2024-10-21,174445.19720912442,Wholesale,South,2022
2024-10-28,146536.4743892374,Wholesale,South,2022
2024-11-04,103115.9143332816,Wholesale,South,2022
2024-11-11,114126.96979232243,Wholesale,South,2022
2024-11-18,134055.41927432714,Wholesale,South,2022
2024-11-25,154843.3036945437,Wholesale,South,2022
2024-12-02,138358.64457336772,Wholesale,South,2022
2024-12-09,147646.41247743566,Wholesale,South,2022
2024-12-16,131408.7086602199,Wholesale,South,2022
2024-12-23,137092.53382182316,Wholesale,South,2022
2024-12-30,121283.3383318623,Wholesale,South,2022
2024-01-01,76788.4067470511,Online,North,2023
2024-01-08,114284.23603504666,Online,North,2023
2024-01-15,63290.1683147997,Online,North,2023
2024-01-22,111987.24253493309,Online,North,2023
2024-01-29,102035.28759469301,Online,North,2023
2024-02-05,113785.98512545221,Online,North,2023
2024-02-12,116649.2032959687,Online,North,2023
2024-02-19,85022.59120100799,Online,North,2023
2024-02-26,112510.4333696042,Online,North,2023
2024-03-04,100448.46549431258,Online,North,2023
2024-03-11,129400.42399115907,Online,North,2023
2024-03-18,103842.15510884745,Online,North,2023
2024-03-25,109721.15356339594,Online,North,2023
2024-04-01,99565.10531119966,Online,North,2023
2024-04-08,110349.0086055719,Online,North,2023
2024-04-15,109457.53394286647,Online,North,2023
2024-04-22,117376.1159982005,Online,North,2023
2024-04-29,100688.40742847853,Online,North,2023
2024-05-06,100090.66247199949,Online,North,2023
2024-05-13,109812.48059623591,Online,North,2023
2024-05-20,90045.84897324402,Online,North,2023
2024-05-27,88932.70455895626,Online,North,2023
2024-06-03,90360.73860018149,Online,North,2023
2024-06-10,113522.61388914665,Online,North,2023
2024-06-17,171257.4166679943,Online,North,2023
2024-06-24,132763.4625913479,Online,North,2023
2024-07-01,93100.34211611445,Online,North,2023
2024-07-08,137704.86716355121,Online,North,2023
2024-07-15,99558.41302180152,Online,North,2023
2024-07-22,136426.0771988365,Online,North,2023
2024-07-29,109683.11185611808,Online,North,2023
2024-08-05,104852.54133723726,Online,North,2023
2024-08-12,144459.54733376595,Online,North,2023
2024-08-19,113270.82977445655,Online,North,2023
2024-08-26,100260.75193184821,Online,North,2023
2024-09-02,144547.51455404313,Online,North,2023
2024-09-09,126436.46169593738,Online,North,2023
2024-09-16,144884.595290813,Online,North,2023
2024-09-23,113848.32264562226,Online,North,2023
2024-09-30,127007.74771693107,Online,North,2023
2024-10-07,124067.9350031018,Online,North,2023
2024-10-14,114429.41623219904,Online,North,2023
2024-10-21,112009.65857705477,Online,North,2023
2024-10-28,122803.97615093384,Online,North,2023
2024-11-04,154787.5361258327,Online,North,2023
2024-11-11,169152.02228815545,Online,North,2023
2024-11-18,134004.16372420563,Online,North,2023
2024-11-25,170243.26166643712,Online,North,2023
2024-12-02,170947.39853988297,Online,North,2023
2024-12-09,155098.81987577202,Online,North,2023
2024-12-16,122650.96285796422,Online,North,2023
2024-12-23,140231.26720786034,Online,North,2023
2024-12-30,106902.33817428868,Online,North,2023
2024-01-01,106133.68306722077,Online,South,2023
2024-01-08,111968.51241604207,Online,South,2023
2024-01-15,83856.16289739628,Online,South,2023
2024-01-22,116935.59536428678,Online,South,2023
2024-01-29,111284.01391840554,Online,South,2023
2024-02-05,152374.36072530795,Online,South,2023
2024-02-12,134974.03262282413,Online,South,2023
2024-02-19,89538.51205131553,Online,South,2023
2024-02-26,117019.27366446175,Online,South,2023
2024-03-04,96299.40631986083,Online,South,2023
2024-03-11,123186.9195890408,Online,South,2023
2024-03-18,95861.560359925,Online,South,2023
2024-03-25,140961.74850343776,Online,South,2023
2024-04-01,109051.69456230907,Online,South,2023
2024-04-08,154202.1649543109,Online,South,2023
2024-04-15,128421.2610805806,Online,South,2023
2024-04-22,94451.23734293852,Online,South,2023
2024-04-29,136525.75753285672,Online,South,2023
2024-05-06,148670.594319732,Online,South,2023
2024-05-13,109738.52788185781,Online,South,2023
2024-05-20,101335.94760813555,Online,South,2023
2024-05-27,129885.96567093249,Online,South,2023
2024-06-03,153590.92164567194,Online,South,2023
2024-06-10,150122.97972543316,Online,South,2023
2024-06-17,117947.51197347313,Online,South,2023
2024-06-24,138692.15279223642,Online,South,2023
2024-07-01,99289.66457472582,Online,South,2023
2024-07-08,128268.61308338595,Online,South,2023
2024-07-15,122490.4633119576,Online,South,2023
2024-07-22,132091.7329777421,Online,South,2023
2024-07-29,144037.03454673482,Online,South,2023
2024-08-05,154676.80518031958,Online,South,2023
2024-08-12,124870.53449836092,Online,South,2023
2024-08-19,150823.7737381314,Online,South,2023
2024-08-26,146772.475508187,Online,South,2023
2024-09-02,126051.77199648252,Online,South,2023
2024-09-09,107176.26459513122,Online,South,2023
2024-09-16,138750.93507940724,Online,South,2023
2024-09-23,127790.19385440618,Online,South,2023
2024-09-30,144133.29180654485,Online,South,2023
2024-10-07,123647.55249527747,Online,South,2023
2024-10-14,118742.08909069872,Online,South,2023
2024-10-21,132604.02373149054,Online,South,2023
2024-10-28,138307.0520848092,Online,South,2023
2024-11-04,139787.63946013534,Online,South,2023
2024-11-11,151150.77018802468,Online,South,2023
2024-11-18,136949.5689177017,Online,South,2023
2024-11-25,164171.80457208224,Online,South,2023
2024-12-02,171412.1201807738,Online,South,2023
2024-12-09,155376.9498933623,Online,South,2023
2024-12-16,145382.35931980592,Online,South,2023
2024-12-23,139822.32202799805,Online,South,2023
2024-12-30,93580.02891489027,Online,South,2023
2024-01-01,86332.80240469133,Retail,North,2023
2024-01-08,134768.00305452748,Retail,North,2023
2024-01-15,102137.30255138128,Retail,North,2023
2024-01-22,130217.0480446835,Retail,North,2023
2024-01-29,153799.53687734442,Retail,North,2023
2024-02-05,59493.6092642061,Retail,North,2023
2024-02-12,98565.14308650757,Retail,North,2023
2024-02-19,95105.37880927439,Retail,North,2023
2024-02-26,119549.07953727646,Retail,North,2023
2024-03-04,89715.78936293906,Retail,North,2023
2024-03-11,96941.00439182513,Retail,North,2023
2024-03-18,143933.3134240412,Retail,North,2023
2024-03-25,113901.4027967641,Retail,North,2023
2024-04-01,98000.11849040446,Retail,North,2023
2024-04-08,111931.09385160285,Retail,North,2023
2024-04-15,105175.59125974932,Retail,North,2023
2024-04-22,129422.37212825823,Retail,North,2023
2024-04-29,111650.78563414812,Retail,North,2023
2024-05-06,117659.81197030496,Retail,North,2023
2024-05-13,95700.88173448775,Retail,North,2023
2024-05-20,93702.2260642585,Retail,North,2023
2024-05-27,141211.99951067285,Retail,North,2023
2024-06-03,154614.56769859255,Retail,North,2023
2024-06-10,115934.21348183819,Retail,North,2023
2024-06-17,138999.8892369082,Retail,North,2023
2024-06-24,98891.99493539776,Retail,North,2023
2024-07-01,145345.22345231578,Retail,North,2023
2024-07-08,103609.58681215376,Retail,North,2023
2024-07-15,143572.91490576311,Retail,North,2023
2024-07-22,136114.63123093126,Retail,North,2023
2024-07-29,122755.7088058291,Retail,North,2023
2024-08-05,129907.61240828835,Retail,North,2023
2024-08-12,102915.1941134255,Retail,North,2023
2024-08-19,123804.11038165107,Retail,North,2023
2024-08-26,143970.37897338337,Retail,North,2023
2024-09-02,151465.1197177859,Retail,North,2023
2024-09-09,103250.81530435247,Retail,North,2023
2024-09-16,130991.24440028156,Retail,North,2023
2024-09-23,134571.82662644252,Retail,North,2023
2024-09-30,111538.03588065233,Retail,North,2023
2024-10-07,120114.93758388713,Retail,North,2023
2024-10-14,149049.10871584187,Retail,North,2023
2024-10-21,127436.87867554036,Retail,North,2023
2024-10-28,114825.19597732252,Retail,North,2023
2024-11-04,164505.01067750488,Retail,North,2023
2024-11-11,146004.908909428,Retail,North,2023
2024-11-18,193214.91733300578,Retail,North,2023
2024-11-25,179356.32381004118,Retail,North,2023
2024-12-02,172235.36651402892,Retail,North,2023
2024-12-09,148001.99912481598,Retail,North,2023
2024-12-16,159562.42868443104,Retail,North,2023
2024-12-23,136666.79156677512,Retail,North,2023
2024-12-30,105429.1435479154,Retail,North,2023
2024-01-01,112188.12212804292,Retail,South,2023
2024-01-08,107497.5238991803,Retail,South,2023
2024-01-15,176280.416591161,Retail,South,2023
2024-01-22,58961.059187389474,Retail,South,2023
2024-01-29,89194.34760088104,Retail,South,2023
2024-02-05,118309.92410917021,Retail,South,2023
2024-02-12,105828.99040414115,Retail,South,2023
2024-02-19,90266.19399465439,Retail,South,2023
2024-02-26,101648.17586778938,Retail,South,2023
2024-03-04,96846.67998002864,Retail,South,2023
2024-03-11,116976.07568477001,Retail,South,2023
2024-03-18,98880.46216052503,Retail,South,2023
2024-03-25,98469.16359742587,Retail,South,2023
2024-04-01,131818.32453662896,Retail,South,2023
2024-04-08,117916.25370169606,Retail,South,2023
2024-04-15,124342.58867544615,Retail,South,2023
2024-04-22,77557.17179190376,Retail,South,2023
2024-04-29,95992.61611345068,Retail,South,2023
2024-05-06,95781.15480568855,Retail,South,2023
2024-05-13,86831.83661071176,Retail,South,2023
2024-05-20,97571.34676807145,Retail,South,2023
2024-05-27,124819.5049339778,Retail,South,2023
2024-06-03,124890.94858209674,Retail,South,2023
2024-06-10,92587.72064449001,Retail,South,2023
2024-06-17,145057.96510749136,Retail,South,2023
2024-06-24,149193.0475362144,Retail,South,2023
2024-07-01,131299.01961532544,Retail,South,2023
2024-07-08,125577.00153940261,Retail,South,2023
2024-07-15,126324.92803989923,Retail,South,2023
2024-07-22,145392.55624319514,Retail,South,2023
2024-07-29,172533.66281598306,Retail,South,2023
2024-08-05,122803.08341476088,Retail,South,2023
2024-08-12,123069.07353167969,Retail,South,2023
2024-08-19,130192.69577986503,Retail,South,2023
2024-08-26,157408.71152740213,Retail,South,2023
2024-09-02,112901.6647313971,Retail,South,2023
2024-09-09,104288.29464966472,Retail,South,2023
2024-09-16,145236.9346685037,Retail,South,2023
2024-09-23,151354.7485801077,Retail,South,2023
2024-09-30,171767.50176975553,Retail,South,2023
2024-10-07,140365.94185409253,Retail,South,2023
2024-10-14,103406.85859618534,Retail,South,2023
2024-10-21,93435.40813977117,Retail,South,2023
2024-10-28,152969.75938047527,Retail,South,2023
2024-11-04,117176.15515264608,Retail,South,2023
2024-11-11,185598.041314221,Retail,South,2023
2024-11-18,112935.216041493,Retail,South,2023
2024-11-25,175412.19433520685,Retail,South,2023
2024-12-02,148221.77610964567,Retail,South,2023
2024-12-09,165132.81942924537,Retail,South,2023
2024-12-16,117422.59049292038,Retail,South,2023
2024-12-23,176892.97312212852,Retail,South,2023
2024-12-30,112634.90279274533,Retail,South,2023
2024-01-01,123879.76435234319,Wholesale,North,2023
2024-01-08,90825.84864648548,Wholesale,North,2023
2024-01-15,109238.49501026592,Wholesale,North,2023
2024-01-22,102500.51866583126,Wholesale,North,2023
2024-01-29,122403.7710473208,Wholesale,North,2023
2024-02-05,112034.69548813463,Wholesale,North,2023
2024-02-12,106494.96220778914,Wholesale,North,2023
2024-02-19,120297.29686968918,Wholesale,North,2023
2024-02-26,113851.84560587877,Wholesale,North,2023
2024-03-04,62485.867892901064,Wholesale,North,2023
2024-03-11,100764.31753497821,Wholesale,North,2023
2024-03-18,72276.72122062686,Wholesale,North,2023
2024-03-25,117965.43998122655,Wholesale,North,2023
2024-04-01,113825.85228963295,Wholesale,North,2023
2024-04-08,72969.67593028763,Wholesale,North,2023
2024-04-15,112206.90183695093,Wholesale,North,2023
2024-04-22,109611.41520997726,Wholesale,North,2023
2024-04-29,111920.34499631602,Wholesale,North,2023
2024-05-06,106062.03586917839,Wholesale,North,2023
2024-05-13,138095.884661397,Wholesale,North,2023
2024-05-20,107645.8498674686,Wholesale,North,2023
2024-05-27,116077.98663823593,Wholesale,North,2023
2024-06-03,131422.26489288855,Wholesale,North,2023
2024-06-10,90174.31470307778,Wholesale,North,2023
2024-06-17,136922.09723141196,Wholesale,North,2023
2024-06-24,112015.12109486859,Wholesale,North,2023
2024-07-01,143691.2154789553,Wholesale,North,2023
2024-07-08,105566.549587927,Wholesale,North,2023
2024-07-15,165412.20148858655,Wholesale,North,2023
2024-07-22,156261.9237775568,Wholesale,North,2023
2024-07-29,115738.96689474811,Wholesale,North,2023
2024-08-05,129013.45925034826,Wholesale,North,2023
2024-08-12,123046.42332902757,Wholesale,North,2023
2024-08-19,82270.6426203477,Wholesale,North,2023
2024-08-26,149888.77808672946,Wholesale,North,2023
2024-09-02,116903.61169668156,Wholesale,North,2023
2024-09-09,107175.84873364745,Wholesale,North,2023
2024-09-16,187688.89610500645,Wholesale,North,2023
2024-09-23,147422.7454797075,Wholesale,North,2023
2024-09-30,110279.96417799836,Wholesale,North,2023
2024-10-07,175627.95090947227,Wholesale,North,2023
2024-10-14,120666.77260031435,Wholesale,North,2023
2024-10-21,122895.36012867653,Wholesale,North,2023
2024-10-28,129263.33805536931,Wholesale,North,2023
2024-11-04,159869.93374937848,Wholesale,North,2023
2024-11-11,189255.8934278711,Wholesale,North,2023
2024-11-18,143845.93730185286,Wholesale,North,2023
2024-11-25,156032.3098817941,Wholesale,North,2023
2024-12-02,144261.80995332357,Wholesale,North,2023
2024-12-09,138789.03592926252,Wholesale,North,2023
2024-12-16,179778.34528077184,Wholesale,North,2023
2024-12-23,151171.23596804537,Wholesale,North,2023
2024-12-30,77503.46847338733,Wholesale,North,2023
2024-01-01,76269.08877423429,Wholesale,South,2023
2024-01-08,85741.18674806847,Wholesale,South,2023
2024-01-15,114168.90218396627,Wholesale,South,2023
2024-01-22,105653.5796745827,Wholesale,South,2023
2024-01-29,137123.43987376284,Wholesale,South,2023
2024-02-05,96082.88513026372,Wholesale,South,2023
2024-02-12,80487.34707119578,Wholesale,South,2023
2024-02-19,113143.15872864207,Wholesale,South,2023
2024-02-26,120216.66990716463,Wholesale,South,2023
2024-03-04,120256.05514356436,Wholesale,South,2023
2024-03-11,118022.61549215189,Wholesale,South,2023
2024-03-18,106160.4559448988,Wholesale,South,2023
2024-03-25,138266.36397258527,Wholesale,South,2023
2024-04-01,84154.83169226906,Wholesale,South,2023
2024-04-08,124296.51066290359,Wholesale,South,2023
2024-04-15,69501.25662333533,Wholesale,South,2023
2024-04-22,132091.71635528578,Wholesale,South,2023
2024-04-29,154272.20853655282,Wholesale,South,2023
2024-05-06,142935.66730593453,Wholesale,South,2023
2024-05-13,121255.62881688258,Wholesale,South,2023
2024-05-20,112120.51752571411,Wholesale,South,2023
2024-05-27,108752.30126961965,Wholesale,South,2023
2024-06-03,88648.65193729947,Wholesale,South,2023
2024-06-10,167378.2461598907,Wholesale,South,2023
2024-06-17,121196.65534343642,Wholesale,South,2023
2024-06-24,100589.68778392897,Wholesale,South,2023
2024-07-01,135920.8651166343,Wholesale,South,2023
2024-07-08,102967.80030629494,Wholesale,South,2023
2024-07-15,146195.0012379157,Wholesale,South,2023
2024-07-22,141149.25481350144,Wholesale,South,2023
2024-07-29,132795.43851951536,Wholesale,South,2023
2024-08-05,149378.32601565757,Wholesale,South,2023
2024-08-12,103715.78725351006,Wholesale,South,2023
2024-08-19,122604.58048238534,Wholesale,South,2023
2024-08-26,140147.5160963102,Wholesale,South,2023
2024-09-02,138569.76199768975,Wholesale,South,2023
2024-09-09,130724.55164743174,Wholesale,South,2023
2024-09-16,141067.98630954654,Wholesale,South,2023
2024-09-23,131507.04381639254,Wholesale,South,2023
2024-09-30,134038.65191415133,Wholesale,South,2023
2024-10-07,130280.88690013488,Wholesale,South,2023
2024-10-14,128374.09942517862,Wholesale,South,2023
2024-10-21,129643.42438335253,Wholesale,South,2023
2024-10-28,128834.06009353936,Wholesale,South,2023
2024-11-04,134919.85368971206,Wholesale,South,2023
2024-11-11,122981.0744231946,Wholesale,South,2023
2024-11-18,135158.8294007055,Wholesale,South,2023
2024-11-25,136118.14660494996,Wholesale,South,2023
2024-12-02,188291.23385303482,Wholesale,South,2023
2024-12-09,159214.07580928027,Wholesale,South,2023
2024-12-16,148667.61400779465,Wholesale,South,2023
2024-12-23,118479.69404958378,Wholesale,South,2023
2024-12-30,127090.01017954815,Wholesale,South,2023
2024-01-01,108840.857102228,Online,North,2024
2024-01-08,95289.77777275635,Online,North,2024
2024-01-15,127189.86390186637,Online,North,2024
2024-01-22,114691.30558714915,Online,North,2024
2024-01-29,90730.24805051218,Online,North,2024
2024-02-05,101204.96938335168,Online,North,2024
2024-02-12,68323.3787033127,Online,North,2024
2024-02-19,109791.54210905114,Online,North,2024
2024-02-26,69828.59159186826,Online,North,2024
2024-03-04,123040.16819472848,Online,North,2024
2024-03-11,123143.60855250483,Online,North,2024
2024-03-18,131166.37457418244,Online,North,2024
2024-03-25,116224.3241099478,Online,North,2024
2024-04-01,107066.42575090921,Online,North,2024
2024-04-08,85850.16529854444,Online,North,2024
2024-04-15,99808.04018630409,Online,North,2024
2024-04-22,115436.24590661973,Online,North,2024
2024-04-29,108167.08290251408,Online,North,2024
2024-05-06,116446.06996313849,Online,North,2024
2024-05-13,96366.19812985574,Online,North,2024
2024-05-20,150282.85504107695,Online,North,2024
2024-05-27,102314.86847194187,Online,North,2024
2024-06-03,123521.02797775182,Online,North,2024
2024-06-10,127203.19637523062,Online,North,2024
2024-06-17,149977.6973417391,Online,North,2024
2024-06-24,101438.37018171052,Online,North,2024
2024-07-01,126535.12576291159,Online,North,2024
2024-07-08,109143.72982944598,Online,North,2024
2024-07-15,90090.34079460146,Online,North,2024
2024-07-22,121362.19877314586,Online,North,2024
2024-07-29,138888.69200227573,Online,North,2024
2024-08-05,122875.83510025335,Online,North,2024
2024-08-12,125766.636471278,Online,North,2024
2024-08-19,127275.02404655593,Online,North,2024
2024-08-26,140194.68834951537,Online,North,2024
2024-09-02,107321.66882189373,Online,North,2024
2024-09-09,158701.1856298974,Online,North,2024
2024-09-16,131992.02815649964,Online,North,2024
2024-09-23,116087.85134397178,Online,North,2024
2024-09-30,128014.23595241977,Online,North,2024
2024-10-07,127448.85543889529,Online,North,2024
2024-10-14,142260.61607405284,Online,North,2024
2024-10-21,126263.77691338603,Online,North,2024
2024-10-28,162874.01384918045,Online,North,2024
2024-11-04,164311.9868411731,Online,North,2024
2024-11-11,142967.86539809924,Online,North,2024
2024-11-18,129590.99365919898,Online,North,2024
2024-11-25,127680.04166362397,Online,North,2024
2024-12-02,153751.73253353045,Online,North,2024
2024-12-09,127620.34395297323,Online,North,2024
2024-12-16,148460.1129164026,Online,North,2024
2024-12-23,135507.56146773678,Online,North,2024
2024-12-30,59092.71020233067,Online,North,2024
2024-01-01,101412.6205138463,Online,South,2024
2024-01-08,91372.13370210948,Online,South,2024
2024-01-15,113015.7223937732,Online,South,2024
2024-01-22,110901.56836961537,Online,South,2024
2024-01-29,90310.80184631588,Online,South,2024
2024-02-05,108832.90386558384,Online,South,2024
2024-02-12,86851.07121606205,Online,South,2024
2024-02-19,69555.1816151478,Online,South,2024
2024-02-26,121118.36566204585,Online,South,2024
2024-03-04,142700.25462982885,Online,South,2024
2024-03-11,126444.49985408784,Online,South,2024
2024-03-18,82894.74716394786,Online,South,2024
2024-03-25,91087.99803085942,Online,South,2024
2024-04-01,109734.60521806583,Online,South,2024
2024-04-08,102630.31017867239,Online,South,2024
2024-04-15,103731.1534418477,Online,South,2024
2024-04-22,106082.3397706766,Online,South,2024
2024-04-29,135271.80502992103,Online,South,2024
2024-05-06,102412.5676982243,Online,South,2024
2024-05-13,97648.40925696872,Online,South,2024
2024-05-20,121971.45590008558,Online,South,2024
2024-05-27,99524.71746857722,Online,South,2024
2024-06-03,158625.3737009604,Online,South,2024
2024-06-10,118706.56450316856,Online,South,2024
2024-06-17,153616.73447288564,Online,South,2024
2024-06-24,144328.5825363733,Online,South,2024
2024-07-01,124217.95508094702,Online,South,2024
2024-07-08,110662.45806265852,Online,South,2024
2024-07-15,163222.25399955583,Online,South,2024
2024-07-22,110849.29453371126,Online,South,2024
2024-07-29,116086.17376663118,Online,South,2024
2024-08-05,120578.63332372456,Online,South,2024
2024-08-12,103525.0589289226,Online,South,2024
2024-08-19,146867.67896876967,Online,South,2024
2024-08-26,113804.86954176996,Online,South,2024
2024-09-02,109946.85181983348,Online,South,2024
2024-09-09,164197.28512740694,Online,South,2024
2024-09-16,76893.08845447548,Online,South,2024
2024-09-23,180076.85453673135,Online,South,2024
2024-09-30,143879.91486485658,Online,South,2024
2024-10-07,162156.41979380665,Online,South,2024
2024-10-14,125251.99732367705,Online,South,2024
2024-10-21,139829.1739683852,Online,South,2024
2024-10-28,180934.39393624503,Online,South,2024
2024-11-04,122065.42735213011,Online,South,2024
2024-11-11,156722.2697452561,Online,South,2024
2024-11-18,136549.34041103837,Online,South,2024
2024-11-25,112810.66350115948,Online,South,2024
2024-12-02,151912.8280793185,Online,South,2024
2024-12-09,152275.9987393565,Online,South,2024
2024-12-16,132235.71571958807,Online,South,2024
2024-12-23,140779.95396207282,Online,South,2024
2024-12-30,72574.53837702512,Online,South,2024
2024-01-01,81666.9362107513,Retail,North,2024
2024-01-08,93515.7613937005,Retail,North,2024
2024-01-15,56497.08618787,Retail,North,2024
2024-01-22,87624.15178992643,Retail,North,2024
2024-01-29,120459.97223291939,Retail,North,2024
2024-02-05,69219.86271149076,Retail,North,2024
2024-02-12,116333.57265433486,Retail,North,2024
2024-02-19,114351.9662829647,Retail,North,2024
2024-02-26,111750.36751474427,Retail,North,2024
2024-03-04,96572.68982036687,Retail,North,2024
2024-03-11,96870.02139168189,Retail,North,2024
2024-03-18,126494.32484383132,Retail,North,2024
2024-03-25,120104.03693925712,Retail,North,2024
2024-04-01,112719.022667617,Retail,North,2024
2024-04-08,120244.34513517022,Retail,North,2024
2024-04-15,90230.38497772254,Retail,North,2024
2024-04-22,155519.18127451368,Retail,North,2024
2024-04-29,106947.76708089226,Retail,North,2024
2024-05-06,110288.04555290457,Retail,North,2024
2024-05-13,107142.39447674276,Retail,North,2024
2024-05-20,107194.16855675975,Retail,North,2024
2024-05-27,94353.75468365355,Retail,North,2024
2024-06-03,132547.62036610238,Retail,North,2024
2024-06-10,148403.38230104337,Retail,North,2024
2024-06-17,148679.3156916255,Retail,North,2024
2024-06-24,133457.58404813433,Retail,North,2024
2024-07-01,131725.63042598183,Retail,North,2024
2024-07-08,152605.73742365825,Retail,North,2024
2024-07-15,162710.87297405454,Retail,North,2024
2024-07-22,133253.80261333068,Retail,North,2024
2024-07-29,143269.82834219438,Retail,North,2024
2024-08-05,164540.7367129596,Retail,North,2024
2024-08-12,165904.53940324162,Retail,North,2024
2024-08-19,134901.23558605803,Retail,North,2024
2024-08-26,110922.00277125768,Retail,North,2024
2024-09-02,129947.19700831072,Retail,North,2024
2024-09-09,137108.9087948397,Retail,North,2024
2024-09-16,166101.0047830308,Retail,North,2024
2024-09-23,150679.35435649537,Retail,North,2024
2024-09-30,118438.07378642964,Retail,North,2024
2024-10-07,148966.24980573897,Retail,North,2024
2024-10-14,110211.59966806049,Retail,North,2024
2024-10-21,136972.37893051427,Retail,North,2024
2024-10-28,162736.8496439376,Retail,North,2024
2024-11-04,146476.45593678034,Retail,North,2024
2024-11-11,139668.65821645496,Retail,North,2024
2024-11-18,125503.6660284929,Retail,North,2024
2024-11-25,155848.70265311858,Retail,North,2024
2024-12-02,137597.3769892066,Retail,North,2024
2024-12-09,156597.92718052707,Retail,North,2024
2024-12-16,166121.81172974984,Retail,North,2024
2024-12-23,146839.36244117474,Retail,North,2024
2024-12-30,116044.10532972662,Retail,North,2024
2024-01-01,113740.05341718279,Retail,South,2024
2024-01-08,118814.8032820081,Retail,South,2024
2024-01-15,100441.72612286516,Retail,South,2024
2024-01-22,78844.16224952886,Retail,South,2024
2024-01-29,120329.81581531296,Retail,South,2024
2024-02-05,75291.82785761004,Retail,South,2024
2024-02-12,135735.35254619835,Retail,South,2024
2024-02-19,114504.56387528876,Retail,South,2024
2024-02-26,112156.01636949946,Retail,South,2024
2024-03-04,115944.5385335949,Retail,South,2024
2024-03-11,90071.51084275916,Retail,South,2024
2024-03-18,84923.09781484281,Retail,South,2024
2024-03-25,137124.39373376739,Retail,South,2024
2024-04-01,106523.63098853819,Retail,South,2024
2024-04-08,132307.41886242904,Retail,South,2024
2024-04-15,90636.12222196817,Retail,South,2024
2024-04-22,118396.56760085977,Retail,South,2024
2024-04-29,134347.4218683283,Retail,South,2024
2024-05-06,152106.44648043287,Retail,South,2024
2024-05-13,103159.16360822358,Retail,South,2024
2024-05-20,109635.55031651643,Retail,South,2024
2024-05-27,137037.62807607936,Retail,South,2024
2024-06-03,122140.73185994718,Retail,South,2024
2024-06-10,138713.96273647223,Retail,South,2024
2024-06-17,123818.23562177297,Retail,South,2024
2024-06-24,115708.6424036356,Retail,South,2024
2024-07-01,162349.20644625463,Retail,South,2024
2024-07-08,122186.0233490466,Retail,South,2024
2024-07-15,107898.90737751772,Retail,South,2024
2024-07-22,159002.6847538694,Retail,South,2024
2024-07-29,129610.97271921803,Retail,South,2024
2024-08-05,121832.43670607147,Retail,South,2024
2024-08-12,127421.92018231488,Retail,South,2024
2024-08-19,152086.8072579696,Retail,South,2024
2024-08-26,138326.28651916116,Retail,South,2024
2024-09-02,140991.44186841222,Retail,South,2024
2024-09-09,131464.7502807748,Retail,South,2024
2024-09-16,138186.80774456463,Retail,South,2024
2024-09-23,115642.52962606178,Retail,South,2024
2024-09-30,154470.77821048192,Retail,South,2024
2024-10-07,170699.63551550615,Retail,South,2024
2024-10-14,120356.30941167379,Retail,South,2024
2024-10-21,136141.98347398802,Retail,South,2024
2024-10-28,125830.55031215178,Retail,South,2024
2024-11-04,161190.27925989992,Retail,South,2024
2024-11-11,161740.6470061881,Retail,South,2024
2024-11-18,121299.32350174725,Retail,South,2024
2024-11-25,151707.45581968714,Retail,South,2024
2024-12-02,145253.43553715062,Retail,South,2024
2024-12-09,157860.78342277108,Retail,South,2024
2024-12-16,157175.25464080134,Retail,South,2024
2024-12-23,154501.86780552578,Retail,South,2024
2024-12-30,101125.3787862819,Retail,South,2024
2024-01-01,109993.30784693312,Wholesale,North,2024
2024-01-08,77648.45637243561,Wholesale,North,2024
2024-01-15,89398.641405461,Wholesale,North,2024
2024-01-22,93917.10849216815,Wholesale,North,2024
2024-01-29,132168.06006894255,Wholesale,North,2024
2024-02-05,95893.6886397114,Wholesale,North,2024
2024-02-12,127769.78752976297,Wholesale,North,2024
2024-02-19,130386.7626255838,Wholesale,North,2024
2024-02-26,106665.27077940127,Wholesale,North,2024
2024-03-04,105426.45795349043,Wholesale,North,2024
2024-03-11,76717.28354139531,Wholesale,North,2024
2024-03-18,127919.976958393,Wholesale,North,2024
2024-03-25,105569.20382094811,Wholesale,North,2024
2024-04-01,69485.23460700216,Wholesale,North,2024
2024-04-08,111283.79570669179,Wholesale,North,2024
2024-04-15,129640.58024476202,Wholesale,North,2024
2024-04-22,154426.3008964675,Wholesale,North,2024
2024-04-29,149001.9487088489,Wholesale,North,2024
2024-05-06,134079.41315649028,Wholesale,North,2024
2024-05-13,118575.5040614006,Wholesale,North,2024
2024-05-20,117120.26783150395,Wholesale,North,2024
2024-05-27,104707.66621867788,Wholesale,North,2024
2024-06-03,105772.64174041493,Wholesale,North,2024
2024-06-10,124545.83106946466,Wholesale,North,2024
2024-06-17,133027.65956533756,Wholesale,North,2024
2024-06-24,121051.63102475565,Wholesale,North,2024
2024-07-01,167618.06028758475,Wholesale,North,2024
2024-07-08,114204.19393975772,Wholesale,North,2024
2024-07-15,145129.87739772187,Wholesale,North,2024
2024-07-22,157647.47555856803,Wholesale,North,2024
2024-07-29,119990.69134500882,Wholesale,North,2024
2024-08-05,150721.42849473626,Wholesale,North,2024
2024-08-12,127095.60283943717,Wholesale,North,2024
2024-08-19,110370.45214834446,Wholesale,North,2024
2024-08-26,146056.90345196583,Wholesale,North,2024
2024-09-02,128599.902476488,Wholesale,North,2024
2024-09-09,160380.99646228235,Wholesale,North,2024
2024-09-16,128244.64637047084,Wholesale,North,2024
2024-09-23,133829.97733335642,Wholesale,North,2024
2024-09-30,129581.15866236806,Wholesale,North,2024
2024-10-07,155907.7347100908,Wholesale,North,2024
2024-10-14,128303.84129491867,Wholesale,North,2024
2024-10-21,96093.79795441453,Wholesale,North,2024
2024-10-28,149305.44494713537,Wholesale,North,2024
2024-11-04,146891.80529522372,Wholesale,North,2024
2024-11-11,137715.95739061016,Wholesale,North,2024
2024-11-18,136569.33490070963,Wholesale,North,2024
2024-11-25,128420.43668547127,Wholesale,North,2024
2024-12-02,118107.25397388176,Wholesale,North,2024
2024-12-09,143221.74526514558,Wholesale,North,2024
2024-12-16,164040.76563361404,Wholesale,North,2024
2024-12-23,160753.71002842986,Wholesale,North,2024
2024-12-30,98042.83971737171,Wholesale,North,2024
2024-01-01,102776.29556572234,Wholesale,South,2024
2024-01-08,89784.71099287027,Wholesale,South,2024
2024-01-15,95197.30103374517,Wholesale,South,2024
2024-01-22,108688.9074324467,Wholesale,South,2024
2024-01-29,81107.04245082452,Wholesale,South,2024
2024-02-05,121329.22763311597,Wholesale,South,2024
2024-02-12,105739.60589208298,Wholesale,South,2024
2024-02-19,143939.04142631567,Wholesale,South,2024
2024-02-26,110723.89290166601,Wholesale,South,2024
2024-03-04,129701.95200248245,Wholesale,South,2024
2024-03-11,105314.18901086495,Wholesale,South,2024
2024-03-18,87496.33542511445,Wholesale,South,2024
2024-03-25,143274.7045312221,Wholesale,South,2024
2024-04-01,156944.82714346665,Wholesale,South,2024
2024-04-08,120825.6581957752,Wholesale,South,2024
2024-04-15,116807.86293644023,Wholesale,South,2024
2024-04-22,110123.22968190267,Wholesale,South,2024
2024-04-29,151746.53363638886,Wholesale,South,2024
2024-05-06,143163.29575543213,Wholesale,South,2024
2024-05-13,125098.82647395284,Wholesale,South,2024
2024-05-20,84370.63241640973,Wholesale,South,2024
2024-05-27,113565.08280704959,Wholesale,South,2024
2024-06-03,140514.15930069814,Wholesale,South,2024
2024-06-10,141206.36178506992,Wholesale,South,2024
2024-06-17,130517.30732066417,Wholesale,South,2024
2024-06-24,99709.54638370722,Wholesale,South,2024
2024-07-01,120599.8062285358,Wholesale,South,2024
2024-07-08,126246.99681950797,Wholesale,South,2024
2024-07-15,139002.69190830403,Wholesale,South,2024
2024-07-22,122008.54452693876,Wholesale,South,2024
2024-07-29,105261.64822943183,Wholesale,South,2024
2024-08-05,120509.62679397594,Wholesale,South,2024
2024-08-12,143612.96569817167,Wholesale,South,2024
2024-08-19,148995.75227925746,Wholesale,South,2024
2024-08-26,131039.43308886277,Wholesale,South,2024
2024-09-02,122503.68639062521,Wholesale,South,2024
2024-09-09,140200.260265472,Wholesale,South,2024
2024-09-16,140536.6848495119,Wholesale,South,2024
2024-09-23,101428.04269010125,Wholesale,South,2024
2024-09-30,122441.34880043844,Wholesale,South,2024
2024-10-07,163567.92131158098,Wholesale,South,2024
2024-10-14,135596.7175872312,Wholesale,South,2024
2024-10-21,121464.94174190798,Wholesale,South,2024
2024-10-28,134465.28594270092,Wholesale,South,2024
2024-11-04,167685.99336387537,Wholesale,South,2024
2024-11-11,140937.2597325143,Wholesale,South,2024
2024-11-18,127685.91506261972,Wholesale,South,2024
2024-11-25,145458.11235108736,Wholesale,South,2024
2024-12-02,173445.82768033264,Wholesale,South,2024
2024-12-09,152700.15384638382,Wholesale,South,2024
2024-12-16,117236.39245573274,Wholesale,South,2024
2024-12-23,147812.0059563634,Wholesale,South,2024
2024-12-30,81679.61174812354,Wholesale,South,2024

</script><script type="text/plain" id="sales_by_region" data-format="csv_embedded" data-src="">
Date,Sales,Region
2024-01-01,9203.968574643319,North
2024-01-02,4684.82438581709,North
2024-01-03,11779.653704512219,North
2024-01-04,10578.227646010171,North
2024-01-05,9576.272854000896,North
2024-01-06,9218.00493943481,North
2024-01-07,7996.336908958905,North
2024-01-08,11815.765937975188,North
2024-01-09,5971.977141307787,North
2024-01-10,8467.151352867677,North
2024-01-11,9300.278520371929,North
2024-01-12,9568.392981306522,North
2024-01-13,9643.603943722666,North
2024-01-14,7740.8547166178505,North
2024-01-15,8321.642913345217,North
2024-01-16,7336.382429871805,North
2024-01-17,11303.554810998514,North
2024-01-18,10420.70857406997,North
2024-01-19,13069.4013351533,North
2024-01-20,11830.84525654084,North
2024-01-21,7907.701168165993,North
2024-01-22,9403.513701896562,North
2024-01-23,9514.721035177505,North
2024-01-24,11177.189937205023,North
2024-01-25,8586.453712315171,North
2024-01-26,11313.287797727588,North
2024-01-27,12591.537534342313,North
2024-01-28,8980.983548762391,North
2024-01-29,13394.217367274594,North
2024-01-30,10897.485947217416,North
2024-01-31,10270.998176029729,North
2024-02-01,13832.568559877727,North
2024-02-02,13432.763020838885,North
2024-02-03,9362.043271333056,North
2024-02-04,11925.650733265817,North
2024-02-05,9907.789248284837,North
2024-02-06,10278.12886814263,North
2024-02-07,14912.482403690443,North
2024-02-08,11571.142839039425,North
2024-02-09,14707.27944660258,North
2024-02-10,12244.617315952979,North
2024-02-11,13826.655526445193,North
2024-02-12,14983.567379576321,North
2024-02-13,11714.2303072515,North
2024-02-14,14414.306152141504,North
2024-02-15,10813.757115090139,North
2024-02-16,11726.169824901395,North
2024-02-17,11110.641640499109,North
2024-02-18,15042.386233277113,North
2024-02-19,14005.371737932535,North
2024-02-20,11720.529376280314,North
2024-02-21,11854.665225163068,North
2024-02-22,9512.352802376921,North
2024-02-23,15802.899359130824,North
2024-02-24,12108.020929451523,North
2024-02-25,13622.736564007313,North
2024-02-26,15847.061103619908,North
2024-02-27,12299.026764750965,North
2024-02-28,13065.265574048806,North
2024-02-29,15225.494535423208,North
2024-03-01,13665.640667901826,North
2024-03-02,14623.513579155062,North
2024-03-03,9767.591853113461,North
2024-03-04,11085.536167015212,North
2024-03-05,15316.019452519526,North
2024-03-06,12688.869357626329,North
2024-03-07,13946.199936257073,North
2024-03-08,13093.008749605753,North
2024-03-09,14904.089073200763,North
2024-03-10,13517.698638360462,North
2024-03-11,15904.04593582386,North
2024-03-12,14530.107663762075,North
2024-03-13,14532.412571925306,North
2024-03-14,15728.262863348991,North
2024-03-15,12563.414736143146,North
2024-03-16,17355.11526004922,North
2024-03-17,18911.842290935958,North
2024-03-18,15193.501458023648,North
2024-03-19,11796.574251474243,North
2024-03-20,14016.935241406549,North
2024-03-21,16446.59738528069,North
2024-03-22,14885.494131518511,North
2024-03-23,16309.227942586267,North
2024-03-24,8844.31481724232,North
2024-03-25,12636.740337563273,North
2024-03-26,16783.958108505103,North
2024-03-27,14316.95913886307,North
2024-03-28,12584.537102837832,North
2024-03-29,19851.998754591055,North
2024-03-30,15329.367808459887,North
2024-03-31,11040.798964618343,North
2024-04-01,15510.630099592097,North
2024-04-02,13239.523490725602,North
2024-04-03,13168.687693698443,North
2024-04-04,15678.30285629744,North
2024-04-05,16644.133049481723,North
2024-04-06,16267.729473162999,North
2024-04-07,14717.531811465939,North
2024-04-08,17373.922739066915,North
2024-04-09,15370.354076681744,North
2024-04-10,16335.775483840316,North
2024-04-11,17205.303339654223,North
2024-04-12,18609.70429126033,North
2024-04-13,13394.0391491327,North
2024-04-14,13908.631260517037,North
2024-04-15,14362.329498504734,North
2024-04-16,19867.439578871305,North
2024-04-17,14235.45716195843,North
2024-04-18,15851.489172697447,North
2024-04-19,18654.471835074422,North
2024-04-20,14099.45146231365,North
2024-04-21,19705.055034040914,North
2024-04-22,8967.604957165462,North
2024-04-23,16899.224529241415,North
2024-04-24,18905.138111173605,North
2024-04-25,18657.962312256805,North
2024-04-26,17188.322436359635,North
2024-04-27,13552.921586372691,North
2024-04-28,13394.252222474584,North
2024-04-29,17540.52527504648,North
2024-04-30,17570.581939501106,North
2024-05-01,20250.715468106322,North
2024-05-02,14036.334214209828,North
2024-05-03,18312.495922928294,North
2024-05-04,14876.996292747604,North
2024-05-05,12093.32009280907,North
2024-05-06,15058.266043211697,North
2024-05-07,16214.55844757269,North
2024-05-08,18826.24870819193,North
2024-05-09,14725.639023990681,North
2024-05-10,14486.07367557556,North
2024-05-11,14184.66960978425,North
2024-05-12,13249.277791678864,North
2024-05-13,17415.887870107148,North
2024-05-14,14969.18339164271,North
2024-05-15,19148.47941687808,North
2024-05-16,13113.415155583589,North
2024-05-17,17435.97005750474,North
2024-05-18,15397.060885291941,North
2024-05-19,17888.138489435147,North
2024-05-20,19945.685193878595,North
2024-05-21,18868.808943223103,North
2024-05-22,17486.294952723238,North
2024-05-23,17632.167147016153,North
2024-05-24,17458.257880000274,North
2024-05-25,16543.615529277646,North
2024-05-26,18033.599905700317,North
2024-05-27,18232.477236297786,North
2024-05-28,15892.110188307668,North
2024-05-29,18943.403113781096,North
2024-05-30,18118.655554507775,North
2024-05-31,19803.927153555116,North
2024-06-01,18419.203875627056,North
2024-06-02,20338.648508492814,North
2024-06-03,20200.0962625815,North
2024-06-04,18121.738627559585,North
2024-06-05,18626.74170332373,North
2024-06-06,16944.488049574495,North
2024-06-07,19342.6945962821,North
2024-06-08,18669.697674869058,North
2024-06-09,15941.513216302563,North
2024-06-10,19043.608167912942,North
2024-06-11,15362.111271424177,North
2024-06-12,17457.442600899885,North
2024-06-13,16293.44970520895,North
2024-06-14,20423.160615154047,North
2024-06-15,17136.930586556442,North
2024-06-16,21106.451028173105,North
2024-06-17,16530.848291763214,North
2024-06-18,20199.135748712368,North
2024-06-19,16793.727052946164,North
2024-06-20,16665.06180313877,North
2024-06-21,18095.186123241197,North
2024-06-22,19953.370400060343,North
2024-06-23,16266.298141997697,North
2024-06-24,19619.110917813974,North
2024-06-25,23741.678702455552,North
2024-06-26,17270.249777933568,North
2024-06-27,18979.276193010326,North
2024-06-28,19942.978687564482,North
2024-06-29,16154.57684068957,North
2024-06-30,20509.323997623564,North
2024-01-01,10505.821842919177,South
2024-01-02,7062.098109339956,South
2024-01-03,12729.704779910147,South
2024-01-04,9483.353726537778,South
2024-01-05,10824.352896217424,South
2024-01-06,11030.51326172691,South
2024-01-07,11323.381187533085,South
2024-01-08,10164.462886516338,South
2024-01-09,11821.41131700387,South
2024-01-10,13679.760012000468,South
2024-01-11,9778.025684356398,South
2024-01-12,9007.09254576908,South
2024-01-13,10254.898613520689,South
2024-01-14,9637.60643788636,South
2024-01-15,11625.728178410172,South
2024-01-16,6991.5656163932235,South
2024-01-17,11156.857846453242,South
2024-01-18,10620.062736646463,South
2024-01-19,9832.806518883728,South
2024-01-20,9709.49774308243,South
2024-01-21,8627.316661222409,South
2024-01-22,10062.599547305894,South
2024-01-23,14656.626393540635,South
2024-01-24,11639.172468122873,South
2024-01-25,10735.07508293304,South
2024-01-26,13222.084847207967,South
2024-01-27,8693.874500244925,South
2024-01-28,12577.0875140019,South
2024-01-29,13548.202044377402,South
2024-01-30,10417.81133325804,South
2024-01-31,11207.73454050944,South
2024-02-01,12783.875571116714,South
2024-02-02,8334.680884822934,South
2024-02-03,14259.555053338607,South
2024-02-04,12254.258191017188,South
2024-02-05,10609.481554441976,South
2024-02-06,8057.628216947272,South
2024-02-07,14257.04649353437,South
2024-02-08,10887.003474401414,South
2024-02-09,11275.80593347332,South
2024-02-10,9216.602307697049,South
2024-02-11,9912.972726702847,South
2024-02-12,14066.920315904252,South
2024-02-13,8958.588965400515,South
2024-02-14,9269.172735416974,South
2024-02-15,10366.097700744003,South
2024-02-16,13667.654083837204,South
2024-02-17,15606.657077121004,South
2024-02-18,16513.842892439712,South
2024-02-19,11330.621258702347,South
2024-02-20,11849.787910998804,South
2024-02-21,11931.65143983407,South
2024-02-22,12019.839125331971,South
2024-02-23,15496.433812635076,South
2024-02-24,16214.583621273747,South
2024-02-25,12543.758202164317,South
2024-02-26,9909.640617799465,South
2024-02-27,14827.324867856498,South
2024-02-28,16189.2816983528,South
2024-02-29,11347.126556224675,South
2024-03-01,13356.65855365134,South
2024-03-02,12098.328380662017,South
2024-03-03,12183.204802416909,South
2024-03-04,14964.989953355049,South
2024-03-05,14827.115062862791,South
2024-03-06,12495.469886248831,South
2024-03-07,11143.052152202656,South
2024-03-08,13363.148963409481,South
2024-03-09,13447.782242043766,South
2024-03-10,11599.917591492484,South
2024-03-11,14716.6656095844,South
2024-03-12,13755.691631473153,South
2024-03-13,13553.906340389174,South
2024-03-14,14792.112347786971,South
2024-03-15,10400.932728946036,South
2024-03-16,11038.269013033929,South
2024-03-17,17541.830632077366,South
2024-03-18,13238.910958618319,South
2024-03-19,13429.210033230946,South
2024-03-20,17266.26533174785,South
2024-03-21,13483.696184428014,South
2024-03-22,13639.581303833276,South
2024-03-23,9982.876787397681,South
2024-03-24,9300.84158047583,South
2024-03-25,14612.484103502202,South
2024-03-26,13516.110514650223,South
2024-03-27,13396.864237917205,South
2024-03-28,15358.477121084845,South
2024-03-29,19180.28903458343,South
2024-03-30,15163.403077869898,South
2024-03-31,14632.17769720622,South
2024-04-01,14341.671720560074,South
2024-04-02,18167.3597145017,South
2024-04-03,12378.694861939968,South
2024-04-04,17121.560744937604,South
2024-04-05,17245.33689237519,South
2024-04-06,13365.794132375497,South
2024-04-07,13865.32310890824,South
2024-04-08,17009.793619024895,South
2024-04-09,13474.917952870954,South
2024-04-10,14760.938830179777,South
2024-04-11,15474.604400661272,South
2024-04-12,12786.266157258584,South
2024-04-13,9458.633362283279,South
2024-04-14,14677.618861766483,South
2024-04-15,17160.408148110477,South
2024-04-16,16608.57989006977,South
2024-04-17,18047.28930562576,South
2024-04-18,15341.113334451864,South
2024-04-19,14680.716558817525,South
2024-04-20,15068.739997256213,South
2024-04-21,13986.043884296447,South
2024-04-22,15725.60076785468,South
2024-04-23,15274.020837401435,South
2024-04-24,16159.59479792393,South
2024-04-25,17139.94952123675,South
2024-04-26,15418.849190710349,South
2024-04-27,13267.510597872264,South
2024-04-28,13637.561969469365,South
2024-04-29,16147.128793756245,South
2024-04-30,17909.20428615751,South
2024-05-01,16037.608321222328,South
2024-05-02,16691.643932511786,South
2024-05-03,18419.383547637794,South
2024-05-04,15737.254819753578,South
2024-05-05,14348.540960644801,South
2024-05-06,14917.963023734057,South
2024-05-07,14633.551958795957,South
2024-05-08,15964.142700108156,South
2024-05-09,20746.911686879568,South
2024-05-10,19822.472010242458,South
2024-05-11,15116.075813099953,South
2024-05-12,16152.763541378637,South
2024-05-13,16647.21563893168,South
2024-05-14,18616.16922220673,South
2024-05-15,15851.101971313596,South
2024-05-16,17395.23574695715,South
2024-05-17,19482.077972360363,South
2024-05-18,13594.643900238987,South
2024-05-19,19210.544487114177,South
2024-05-20,13409.981072261115,South
2024-05-21,19281.78630866781,South
2024-05-22,17352.633608251163,South
2024-05-23,20998.483491089155,South
2024-05-24,17919.39131396853,South
2024-05-25,21559.67335485849,South
2024-05-26,16581.12400702807,South
2024-05-27,15339.750493109685,South
2024-05-28,16914.726803220343,South
2024-05-29,19599.923552710272,South
2024-05-30,19721.119700532538,South
2024-05-31,21179.311216049515,South
2024-06-01,19405.09298684063,South
2024-06-02,18543.71047176838,South
2024-06-03,14982.621647481703,South
2024-06-04,18900.48406841199,South
2024-06-05,16063.028886632857,South
2024-06-06,17449.47367977215,South
2024-06-07,17601.558783069082,South
2024-06-08,19181.098595436168,South
2024-06-09,18126.550470768594,South
2024-06-10,17826.692749234593,South
2024-06-11,16573.04210111957,South
2024-06-12,16425.581050894354,South
2024-06-13,18347.598173629445,South
2024-06-14,14552.640428761186,South
2024-06-15,19046.132153791867,South
2024-06-16,18815.676490726128,South
2024-06-17,19043.500093778748,South
2024-06-18,17120.208219600598,South
2024-06-19,15722.491300618885,South
2024-06-20,16223.886084693766,South
2024-06-21,19367.366894186467,South
2024-06-22,22063.86565473254,South
2024-06-23,18191.468412314585,South
2024-06-24,16363.892632415378,South
2024-06-25,18592.556528201214,South
2024-06-26,17564.058804639222,South
2024-06-27,17432.23780213314,South
2024-06-28,15909.17623841658,South
2024-06-29,16949.610366114386,South
2024-06-30,21037.63202341836,South
2024-01-01,15103.664616376012,East
2024-01-02,10170.244797491212,East
2024-01-03,13508.630729649742,East
2024-01-04,9932.033723612722,East
2024-01-05,10257.65815852939,East
2024-01-06,9227.632710159283,East
2024-01-07,17766.34060847148,East
2024-01-08,11416.084027319219,East
2024-01-09,11450.641871817557,East
2024-01-10,12818.15175481287,East
2024-01-11,9165.55763744746,East
2024-01-12,12632.894082324323,East
2024-01-13,9722.219620588756,East
2024-01-14,9388.046712583919,East
2024-01-15,10214.471524672957,East
2024-01-16,13789.632553549352,East
2024-01-17,11867.94824234556,East
2024-01-18,14553.992138940586,East
2024-01-19,12515.23626680532,East
2024-01-20,9319.951364916891,East
2024-01-21,9106.476992321055,East
2024-01-22,9289.87556543549,East
2024-01-23,12321.796180303205,East
2024-01-24,16535.95585269178,East
2024-01-25,8657.06103101691,East
2024-01-26,11126.614301430072,East
2024-01-27,11681.801430391884,East
2024-01-28,12184.651270420904,East
2024-01-29,10438.354764032285,East
2024-01-30,10554.591310090102,East
2024-01-31,11122.488931184631,East
2024-02-01,10448.33722156541,East
2024-02-02,7302.080372483696,East
2024-02-03,12283.594209854162,East
2024-02-04,8835.04885352946,East
2024-02-05,12500.22088143209,East
2024-02-06,10772.728971397271,East
2024-02-07,11649.4931892677,East
2024-02-08,10566.847072837289,East
2024-02-09,11614.420933438201,East
2024-02-10,11316.854253303149,East
2024-02-11,12558.975757191327,East
2024-02-12,13773.328830299197,East
2024-02-13,10088.757689670667,East
2024-02-14,10387.081587953551,East
2024-02-15,13343.094935242581,East
2024-02-16,13578.588470065957,East
2024-02-17,13157.05460478328,East
2024-02-18,13621.134599808147,East
2024-02-19,13894.16474091946,East
2024-02-20,14560.10323391299,East
2024-02-21,13627.051749951595,East
2024-02-22,14621.271305687998,East
2024-02-23,12153.676295142863,East
2024-02-24,14366.0779376326,East
2024-02-25,10628.691816938997,East
2024-02-26,13194.130903146282,East
2024-02-27,13002.101222618985,East
2024-02-28,12464.170937206089,East
2024-02-29,12949.525724813637,East
2024-03-01,13015.199840675758,East
2024-03-02,17308.231035878125,East
2024-03-03,12072.915735838289,East
2024-03-04,11566.382544265163,East
2024-03-05,13532.387924917533,East
2024-03-06,15315.257498990042,East
2024-03-07,14914.67503871409,East
2024-03-08,13247.411671334074,East
2024-03-09,15121.14081042039,East
2024-03-10,10222.973177017617,East
2024-03-11,12542.48500603341,East
2024-03-12,14233.9006690173,East
2024-03-13,13589.467595786591,East
2024-03-14,12844.827068634904,East
2024-03-15,16566.618647843912,East
2024-03-16,11812.019583412704,East
2024-03-17,13835.161461410127,East
2024-03-18,14384.971012961632,East
2024-03-19,16151.967038693836,East
2024-03-20,11738.082234910162,East
2024-03-21,12210.61158114652,East
2024-03-22,14762.539083312875,East
2024-03-23,11692.236228715203,East
2024-03-24,17351.939231960838,East
2024-03-25,12132.213593765522,East
2024-03-26,12687.859735368505,East
2024-03-27,16737.881163336944,East
2024-03-28,13467.325646233217,East
2024-03-29,11967.877430276385,East
2024-03-30,12762.778210480406,East
2024-03-31,15077.93671378291,East
2024-04-01,12055.55612269573,East
2024-04-02,12072.79149469714,East
2024-04-03,14152.96954644086,East
2024-04-04,16914.710462130566,East
2024-04-05,16060.352096760227,East
2024-04-06,20117.30724057769,East
2024-04-07,12349.04004938322,East
2024-04-08,15124.666251272649,East
2024-04-09,12744.265687942556,East
2024-04-10,13503.460680612812,East
2024-04-11,14323.989666797268,East
2024-04-12,10928.988153726543,East
2024-04-13,14278.788424875152,East
2024-04-14,15809.965396386075,East
2024-04-15,17829.662129078886,East
2024-04-16,11745.994862661519,East
2024-04-17,18220.74735778908,East
2024-04-18,15340.093254330877,East
2024-04-19,17012.159439765943,East
2024-04-20,13876.850328227232,East
2024-04-21,17270.998564380316,East
2024-04-22,16544.279222863453,East
2024-04-23,10636.318297749996,East
2024-04-24,16307.6377705568,East
2024-04-25,19693.270575441133,East
2024-04-26,12159.71580472915,East
2024-04-27,12375.750559500733,East
2024-04-28,16267.129079678347,East
2024-04-29,17052.048393152094,East
2024-04-30,15095.987350946736,East
2024-05-01,14857.979183579837,East
2024-05-02,14235.598009102603,East
2024-05-03,16455.84539079701,East
2024-05-04,16405.46495178164,East
2024-05-05,15135.312476170624,East
2024-05-06,12995.143445496142,East
2024-05-07,16989.598532175383,East
2024-05-08,12858.553061546803,East
2024-05-09,19589.62030413819,East
2024-05-10,14390.011785173576,East
2024-05-11,17713.641746146357,East
2024-05-12,17926.050780677193,East
2024-05-13,13846.05914070903,East
2024-05-14,16685.155331057053,East
2024-05-15,16558.782842144865,East
2024-05-16,18081.518561354078,East
2024-05-17,19155.26858254763,East
2024-05-18,15589.037816903718,East
2024-05-19,19050.06778351569,East
2024-05-20,17294.690777185173,East
2024-05-21,19762.783830008902,East
2024-05-22,17086.12563898778,East
2024-05-23,16140.961035235036,East
2024-05-24,17700.852457066354,East
2024-05-25,15999.539111126896,East
2024-05-26,14977.441207523118,East
2024-05-27,13131.962138655239,East
2024-05-28,18137.731181983767,East
2024-05-29,19886.415118759265,East
2024-05-30,17584.02048677804,East
2024-05-31,18616.467891642526,East
2024-06-01,20044.864184668917,East
2024-06-02,14092.599925182123,East
2024-06-03,17777.066013773925,East
2024-06-04,16685.24894993622,East
2024-06-05,13448.722550488606,East
2024-06-06,17007.069116439357,East
2024-06-07,18863.65982739108,East
2024-06-08,18548.223319622677,East
2024-06-09,15235.153278629627,East
2024-06-10,19454.966951547787,East
2024-06-11,16114.822751041684,East
2024-06-12,21702.885927419542,East
2024-06-13,14183.579452252035,East
2024-06-14,19128.17514879831,East
2024-06-15,16523.47304344435,East
2024-06-16,17730.035325931392,East
2024-06-17,17189.30573681729,East
2024-06-18,20080.27246960798,East
2024-06-19,19200.115743704548,East
2024-06-20,19174.99157576116,East
2024-06-21,20038.62990213723,East
2024-06-22,20203.023621556425,East
2024-06-23,17676.820999521595,East
2024-06-24,16290.299902208242,East
2024-06-25,18051.143913180837,East
2024-06-26,21450.89140475363,East
2024-06-27,20001.77148897211,East
2024-06-28,18091.30138087505,East
2024-06-29,18622.328471564324,East
2024-06-30,19022.46942736709,East
2024-01-01,9401.083452928726,West
2024-01-02,11572.565997122327,West
2024-01-03,8418.369643447639,West
2024-01-04,13179.839808421179,West
2024-01-05,10369.371188171408,West
2024-01-06,5241.153669141931,West
2024-01-07,10932.181367517927,West
2024-01-08,14554.898907640829,West
2024-01-09,11692.981831063224,West
2024-01-10,10136.079573312938,West
2024-01-11,10060.623373147817,West
2024-01-12,11638.212757842457,West
2024-01-13,12519.670897814021,West
2024-01-14,11883.769576176712,West
2024-01-15,11512.071353569867,West
2024-01-16,8699.54526869035,West
2024-01-17,13273.716901774727,West
2024-01-18,8687.83444590297,West
2024-01-19,7936.374471263931,West
2024-01-20,14179.83890104593,West
2024-01-21,12331.025201010298,West
2024-01-22,12312.650145895946,West
2024-01-23,14153.011375826882,West
2024-01-24,11917.431254571804,West
2024-01-25,12529.054307714967,West
2024-01-26,11534.526260617777,West
2024-01-27,12350.872072265007,West
2024-01-28,10263.09807456115,West
2024-01-29,9061.559984225329,West
2024-01-30,8626.798996526866,West
2024-01-31,11388.543954561163,West
2024-02-01,9158.989546868048,West
2024-02-02,13263.583981171067,West
2024-02-03,13680.256035635546,West
2024-02-04,13877.627340889845,West
2024-02-05,11837.300673840467,West
2024-02-06,10387.908652148179,West
2024-02-07,15626.868260387677,West
2024-02-08,12948.842651634684,West
2024-02-09,11474.493118245633,West
2024-02-10,14163.957373891953,West
2024-02-11,11570.232255432526,West
2024-02-12,8071.439470257359,West
2024-02-13,10973.865658706214,West
2024-02-14,12761.189676526285,West
2024-02-15,9047.079872456805,West
2024-02-16,13479.753213655744,West
2024-02-17,12713.244674846437,West
2024-02-18,13641.127987209948,West
2024-02-19,10287.974819341294,West
2024-02-20,12212.583516296769,West
2024-02-21,12532.991553629903,West
2024-02-22,10747.678799447856,West
2024-02-23,12801.907568578208,West
2024-02-24,9640.228411577984,West
2024-02-25,12925.991370031155,West
2024-02-26,10326.57786871722,West
2024-02-27,11663.795489098437,West
2024-02-28,11002.630513200915,West
2024-02-29,12203.828599820685,West
2024-03-01,12768.202709270126,West
2024-03-02,11278.04058311596,West
2024-03-03,11257.807864380733,West
2024-03-04,12935.986061988406,West
2024-03-05,13689.093162533418,West
2024-03-06,14502.977326047712,West
2024-03-07,14447.872156633943,West
2024-03-08,12729.241078227828,West
2024-03-09,10485.102064524444,West
2024-03-10,15528.830024120867,West
2024-03-11,14090.761530272086,West
2024-03-12,10163.043764206253,West
2024-03-13,16035.349539623843,West
2024-03-14,10646.32650612665,West
2024-03-15,11997.4038771724,West
2024-03-16,14783.65300002494,West
2024-03-17,11826.093976292708,West
2024-03-18,13756.297048347089,West
2024-03-19,13253.657444540559,West
2024-03-20,14251.944795315872,West
2024-03-21,17099.443892266343,West
2024-03-22,12935.059699606029,West
2024-03-23,13965.340451538534,West
2024-03-24,15719.359326516758,West
2024-03-25,13180.0257024525,West
2024-03-26,16288.182922962304,West
2024-03-27,15098.520422122123,West
2024-03-28,14326.075926073492,West
2024-03-29,16008.694839503674,West
2024-03-30,14830.873618069367,West
2024-03-31,13323.097888367634,West
2024-04-01,16714.78995134639,West
2024-04-02,11101.204387321668,West
2024-04-03,11943.87123177233,West
2024-04-04,11982.708414210567,West
2024-04-05,15456.412180877378,West
2024-04-06,11392.628304378082,West
2024-04-07,17872.383027864886,West
2024-04-08,11222.271131820607,West
2024-04-09,14577.544964469736,West
2024-04-10,16170.276002881319,West
2024-04-11,16364.523405378945,West
2024-04-12,16890.6255403317,West
2024-04-13,13106.306912477577,West
2024-04-14,13937.7556553586,West
2024-04-15,16373.611342087985,West
2024-04-16,15536.796144239861,West
2024-04-17,17765.2101189909,West
2024-04-18,12890.067636713935,West
2024-04-19,13761.684052499542,West
2024-04-20,13802.452146320618,West
2024-04-21,17320.935044847316,West
2024-04-22,16846.218148220898,West
2024-04-23,13640.613473000465,West
2024-04-24,15488.879359848957,West
2024-04-25,14398.5140238665,West
2024-04-26,10761.182483585955,West
2024-04-27,14011.397295053588,West
2024-04-28,16952.145098389366,West
2024-04-29,17756.815604671927,West
2024-04-30,16833.52522740417,West
2024-05-01,17914.937414971537,West
2024-05-02,17498.641337837533,West
2024-05-03,14551.462152532027,West
2024-05-04,14342.872493989405,West
2024-05-05,18764.919125615772,West
2024-05-06,19032.322002704757,West
2024-05-07,16919.096482844518,West
2024-05-08,14883.7893326297,West
2024-05-09,13913.453878803797,West
2024-05-10,16815.95245477856,West
2024-05-11,14620.67701242568,West
2024-05-12,14928.789713898319,West
2024-05-13,18223.903242026907,West
2024-05-14,20597.03694512599,West
2024-05-15,18333.30131716648,West
2024-05-16,19147.32095087487,West
2024-05-17,18586.190032302005,West
2024-05-18,16097.923478000224,West
2024-05-19,18138.437385624748,West
2024-05-20,17744.760572021754,West
2024-05-21,16517.747991455042,West
2024-05-22,18925.13177122498,West
2024-05-23,18614.534760891867,West
2024-05-24,13559.675315201273,West
2024-05-25,18631.54290526206,West
2024-05-26,14334.681920100045,West
2024-05-27,16725.455895458865,West
2024-05-28,21754.092143185455,West
2024-05-29,19562.22616860588,West
2024-05-30,18617.717668268833,West
2024-05-31,17936.914462549474,West
2024-06-01,17841.538369823767,West
2024-06-02,15892.130980521395,West
2024-06-03,17226.088623337608,West
2024-06-04,18056.673861124873,West
2024-06-05,18015.505015495793,West
2024-06-06,21928.832585157634,West
2024-06-07,18616.959218176173,West
2024-06-08,16298.37341779114,West
2024-06-09,23863.82907841861,West
2024-06-10,20073.11272054709,West
2024-06-11,19755.5228843793,West
2024-06-12,18385.577468801137,West
2024-06-13,17235.308173082834,West
2024-06-14,18476.00003520963,West
2024-06-15,17048.864964639375,West
2024-06-16,16133.593083457403,West
2024-06-17,16491.270652149862,West
2024-06-18,19138.594149584886,West
2024-06-19,18837.803571681856,West
2024-06-20,19559.002228521604,West
2024-06-21,19222.79531557313,West
2024-06-22,20845.992067086827,West
2024-06-23,20042.750095549043,West
2024-06-24,17118.711579350565,West
2024-06-25,19955.742376597394,West
2024-06-26,18429.446767095287,West
2024-06-27,19013.99545640654,West
2024-06-28,19200.715514093827,West
2024-06-29,16555.43558657453,West
2024-06-30,21067.547343864542,West

</script><script type="text/plain" id="metrics_data" data-format="csv_embedded" data-src="">
Week,Value,Metric,Source
1,110.07392389600615,Metric A,Source 1
2,137.19000296527605,Metric A,Source 1
3,118.48559095032581,Metric A,Source 1
4,109.05107358211998,Metric A,Source 1
5,148.79175184355336,Metric A,Source 1
6,130.8530649115026,Metric A,Source 1
7,141.60134036778754,Metric A,Source 1
8,123.42909290065288,Metric A,Source 1
9,125.2130573541346,Metric A,Source 1
10,133.94490275880554,Metric A,Source 1
11,132.24820295388946,Metric A,Source 1
12,166.48872419177778,Metric A,Source 1
1,98.51180895652354,Metric A,Source 2
2,114.05632564463336,Metric A,Source 2
3,112.4291177573256,Metric A,Source 2
4,105.16262956733853,Metric A,Source 2
5,76.79174395142694,Metric A,Source 2
6,122.04507523963056,Metric A,Source 2
7,155.64304727630613,Metric A,Source 2
8,113.08987655377638,Metric A,Source 2
9,145.4479528633537,Metric A,Source 2
10,106.37482841920867,Metric A,Source 2
11,130.46358172272716,Metric A,Source 2
12,165.50397593679733,Metric A,Source 2
1,97.81166404309907,Metric A,Source 3
2,107.63227423231332,Metric A,Source 3
3,112.05710626821072,Metric A,Source 3
4,97.23950369766284,Metric A,Source 3
5,126.51045484934625,Metric A,Source 3
6,99.32557641876375,Metric A,Source 3
7,144.60621051158498,Metric A,Source 3
8,153.13608360860832,Metric A,Source 3
9,131.8689092988532,Metric A,Source 3
10,152.18605084739443,Metric A,Source 3
11,101.35083808007002,Metric A,Source 3
12,135.03021839572202,Metric A,Source 3
1,89.8319341525003,Metric B,Source 1
2,130.62969699545798,Metric B,Source 1
3,101.99598000825856,Metric B,Source 1
4,142.16497974367167,Metric B,Source 1
5,123.45310016993051,Metric B,Source 1
6,88.54721358562198,Metric B,Source 1
7,119.39458023604047,Metric B,Source 1
8,111.19225736744333,Metric B,Source 1
9,130.38881186273022,Metric B,Source 1
10,116.64005392809477,Metric B,Source 1
11,144.53575028890737,Metric B,Source 1
12,152.23357414954785,Metric B,Source 1
1,126.06055991142364,Metric B,Source 2
2,87.46421172530152,Metric B,Source 2
3,126.59780774955155,Metric B,Source 2
4,124.80349041119767,Metric B,Source 2
5,107.50009600424818,Metric B,Source 2
6,100.37906048367854,Metric B,Source 2
7,121.50240807475733,Metric B,Source 2
8,124.36886919149569,Metric B,Source 2
9,144.1382354903684,Metric B,Source 2
10,146.11813420547128,Metric B,Source 2
11,132.03423885711396,Metric B,Source 2
12,133.05293764282527,Metric B,Source 2
1,112.89123557722004,Metric B,Source 3
2,113.19234753451684,Metric B,Source 3
3,141.00833711310804,Metric B,Source 3
4,102.57386071125454,Metric B,Source 3
5,77.7762039297881,Metric B,Source 3
6,114.72583142528731,Metric B,Source 3
7,139.19975781108747,Metric B,Source 3
8,143.66656272395997,Metric B,Source 3
9,108.6987357140338,Metric B,Source 3
10,141.56393509386479,Metric B,Source 3
11,147.01932434711125,Metric B,Source 3
12,148.04196213066484,Metric B,Source 3
1,92.94206105784939,Metric C,Source 1
2,103.81733628387613,Metric C,Source 1
3,116.98932046723601,Metric C,Source 1
4,128.4626653565581,Metric C,Source 1
5,131.73008403586326,Metric C,Source 1
6,117.03550872467451,Metric C,Source 1
7,107.54763542821095,Metric C,Source 1
8,116.47738121137581,Metric C,Source 1
9,135.68024588853336,Metric C,Source 1
10,108.47573158996842,Metric C,Source 1
11,133.25969077591043,Metric C,Source 1
12,97.89280056432533,Metric C,Source 1
1,111.34249149887583,Metric C,Source 2
2,107.3392728530079,Metric C,Source 2
3,116.40748751078958,Metric C,Source 2
4,102.01968282979112,Metric C,Source 2
5,108.78200019079765,Metric C,Source 2
6,81.6606727186723,Metric C,Source 2
7,84.06067945579849,Metric C,Source 2
8,93.62120200916283,Metric C,Source 2
9,123.73865189500069,Metric C,Source 2
10,136.86701615654215,Metric C,Source 2
11,146.2551247667622,Metric C,Source 2
12,124.89945782821907,Metric C,Source 2
1,106.16241811619828,Metric C,Source 3
2,137.2324796447449,Metric C,Source 3
3,123.99722783405149,Metric C,Source 3
4,111.83891813351326,Metric C,Source 3
5,91.62244841261587,Metric C,Source 3
6,135.4978641768443,Metric C,Source 3
7,98.79432447402303,Metric C,Source 3
8,127.39788877099927,Metric C,Source 3
9,140.9831692032974,Metric C,Source 3
10,129.18571815347423,Metric C,Source 3
11,118.92012273537918,Metric C,Source 3
12,135.34405215389623,Metric C,Source 3
1,125.35335097846578,Metric D,Source 1
2,116.0507058388458,Metric D,Source 1
3,126.68455911386887,Metric D,Source 1
4,99.29018866384983,Metric D,Source 1
5,145.40217575593573,Metric D,Source 1
6,88.94709472923883,Metric D,Source 1
7,169.00029439884617,Metric D,Source 1
8,156.4837844292843,Metric D,Source 1
9,88.48048722717168,Metric D,Source 1
10,153.85368009430056,Metric D,Source 1
11,139.66647770572146,Metric D,Source 1
12,133.5357893684623,Metric D,Source 1
1,109.23257532672042,Metric D,Source 2
2,93.65629811817026,Metric D,Source 2
3,98.76918213540431,Metric D,Source 2
4,99.69781734065958,Metric D,Source 2
5,116.10528628329847,Metric D,Source 2
6,103.24825939296821,Metric D,Source 2
7,119.20803580422131,Metric D,Source 2
8,102.17821908791883,Metric D,Source 2
9,127.72260349452006,Metric D,Source 2
10,109.44581680184538,Metric D,Source 2
11,94.5469768748425,Metric D,Source 2
12,104.74933251716243,Metric D,Source 2
1,89.43894737058528,Metric D,Source 3
2,114.71214990656588,Metric D,Source 3
3,113.36081974874845,Metric D,Source 3
4,96.46120529231975,Metric D,Source 3
5,161.84455756602588,Metric D,Source 3
6,127.68991330783008,Metric D,Source 3
7,101.16337644428572,Metric D,Source 3
8,99.53746786078703,Metric D,Source 3
9,127.2446601300296,Metric D,Source 3
10,116.30552276824774,Metric D,Source 3
11,129.72344445036182,Metric D,Source 3
12,150.4319761431151,Metric D,Source 3

</script><script type="text/plain" id="compare_data" data-format="csv_embedded" data-src="">
Time,Value,Category
1,11.526606978001524,Cat 1
2,12.29915350636352,Cat 1
3,9.710405628577822,Cat 1
4,18.01248975612743,Cat 1
5,15.13084847031205,Cat 1
6,10.237822913845685,Cat 1
7,15.608867106155621,Cat 1
8,14.723148795635558,Cat 1
9,18.142032772681258,Cat 1
10,15.566679618073767,Cat 1
11,13.656690482049543,Cat 1
12,14.729640320183643,Cat 1
13,19.878179264980908,Cat 1
14,18.557880202521453,Cat 1
15,16.01807747574945,Cat 1
16,18.564273167802035,Cat 1
17,14.12293973350178,Cat 1
18,18.523674362101303,Cat 1
19,21.356121601914356,Cat 1
20,17.2344600261149,Cat 1
1,13.552633261262933,Cat 2
2,11.821188914620471,Cat 2
3,13.845484214064985,Cat 2
4,8.43782687173983,Cat 2
5,19.193771280850903,Cat 2
6,13.25301277564498,Cat 2
7,11.359762618310544,Cat 2
8,16.12313025992384,Cat 2
9,15.142697100575942,Cat 2
10,12.808177602222347,Cat 2
11,12.817207741633423,Cat 2
12,14.357817424453529,Cat 2
13,20.056834387274197,Cat 2
14,17.361393006529124,Cat 2
15,13.957307228098031,Cat 2
16,21.528790654013395,Cat 2
17,15.0310366885042,Cat 2
18,18.362247377263166,Cat 2
19,17.820881407964634,Cat 2
20,21.42341959988147,Cat 2
1,10.285682374582256,Cat 3
2,9.534862396080843,Cat 3
3,13.168051820575155,Cat 3
4,11.911093687710549,Cat 3
5,15.299711052777099,Cat 3
6,14.674412738620383,Cat 3
7,10.794777261815982,Cat 3
8,20.996677098510318,Cat 3
9,13.598687017404007,Cat 3
10,6.518037155120441,Cat 3
11,12.683433423667303,Cat 3
12,15.80930994930445,Cat 3
13,13.425630431473207,Cat 3
14,17.692554248104553,Cat 3
15,20.397158500265924,Cat 3
16,16.28251776585074,Cat 3
17,15.772119469852461,Cat 3
18,14.300803403505894,Cat 3
19,20.173030619402468,Cat 3
20,17.264165553113095,Cat 3

</script><script type="text/plain" id="product_values" data-format="csv_embedded" data-src="">
Time,Value,Product
0.0,71.2447576964093,Product A
0.5,73.87699271145908,Product A
1.0,66.74201964144348,Product A
1.5,69.05849498906655,Product A
2.0,69.8216385775253,Product A
2.5,58.23473742422452,Product A
3.0,58.516074757312445,Product A
3.5,70.92596346020228,Product A
4.0,67.59225216967587,Product A
4.5,65.07167058003333,Product A
5.0,69.45323551268733,Product A
5.5,67.29035210285167,Product A
6.0,65.21049906812539,Product A
6.5,68.7622421001801,Product A
7.0,59.45358079697017,Product A
7.5,68.69942340754842,Product A
8.0,70.09437239837283,Product A
8.5,65.15415234245631,Product A
9.0,74.94955703595014,Product A
9.5,68.1323479508513,Product A
10.0,61.920051790937336,Product A
10.5,58.06904177931992,Product A
11.0,64.14480523389658,Product A
11.5,61.92874581548011,Product A
12.0,72.55783159184313,Product A
12.5,67.50169116371679,Product A
13.0,67.34841321915617,Product A
13.5,76.23331196420915,Product A
14.0,69.44761139374712,Product A
14.5,57.16429276807381,Product A
15.0,65.62989809027698,Product A
15.5,71.9529358490509,Product A
16.0,52.118173089562816,Product A
16.5,60.22127473757683,Product A
17.0,56.95069716177925,Product A
17.5,60.58689349097748,Product A
18.0,67.71167939810492,Product A
18.5,50.535207014763614,Product A
19.0,59.19583987370472,Product A
19.5,53.68211397380681,Product A
20.0,56.339751570777665,Product A
0.0,61.92518265193077,Product B
0.5,55.98036224111614,Product B
1.0,68.59047444379306,Product B
1.5,61.51607536115514,Product B
2.0,60.22302701365159,Product B
2.5,61.961808759536794,Product B
3.0,51.714340436780894,Product B
3.5,52.95503256773036,Product B
4.0,65.56897741635532,Product B
4.5,66.42422222153344,Product B
5.0,65.70580716141666,Product B
5.5,71.19593288198853,Product B
6.0,63.94473567384177,Product B
6.5,74.68875071686477,Product B
7.0,65.68806415471283,Product B
7.5,77.0010916451267,Product B
8.0,62.14381460712319,Product B
8.5,68.86289258783813,Product B
9.0,57.376895855422106,Product B
9.5,70.86145646517997,Product B
10.0,85.7762564244569,Product B
10.5,74.24386984439138,Product B
11.0,59.39704712509516,Product B
11.5,65.46954778314036,Product B
12.0,70.42583380106778,Product B
12.5,30.86015302051075,Product B
13.0,38.339722124609104,Product B
13.5,29.20753676338621,Product B
14.0,38.45517147313023,Product B
14.5,41.10692923644603,Product B
15.0,38.47091381408517,Product B
15.5,36.937964936566544,Product B
16.0,36.693831462579475,Product B
16.5,43.75950703909028,Product B
17.0,41.40974558264132,Product B
17.5,35.34860473517435,Product B
18.0,34.03839075197829,Product B
18.5,41.24422260744864,Product B
19.0,41.565723790444515,Product B
19.5,37.07937110560861,Product B
20.0,41.4951155243012,Product B
0.0,37.249765231531036,Product C
0.5,28.444795404585747,Product C
1.0,37.238134666212254,Product C
1.5,35.67394101901213,Product C
2.0,32.32484735967516,Product C
2.5,30.78014572278626,Product C
3.0,35.888198870232685,Product C
3.5,30.032996422685688,Product C
4.0,34.73344800738362,Product C
4.5,59.256548148135735,Product C
5.0,67.93459527478092,Product C
5.5,64.835906998922,Product C
6.0,66.59811948806322,Product C
6.5,63.723358205824255,Product C
7.0,53.123321943990476,Product C
7.5,63.600660704534604,Product C
8.0,57.92793377063685,Product C
8.5,66.42110692531054,Product C
9.0,63.13840718498105,Product C
9.5,72.84551689368764,Product C
10.0,59.49962474933952,Product C
10.5,68.75551356344009,Product C
11.0,51.85218226742979,Product C
11.5,63.576654571054,Product C
12.0,60.016079192630166,Product C
12.5,67.87435344511195,Product C
13.0,57.12159525487053,Product C
13.5,63.54908082443063,Product C
14.0,61.435532135799,Product C
14.5,65.68607102842293,Product C
15.0,67.95208331355639,Product C
15.5,61.500662374938585,Product C
16.0,62.77366419064009,Product C
16.5,70.07957569353275,Product C
17.0,62.705976851628165,Product C
17.5,67.10046622950115,Product C
18.0,70.43313003090252,Product C
18.5,54.94163256307198,Product C
19.0,59.279084031888736,Product C
19.5,57.919685102439736,Product C
20.0,65.76635877903033,Product C

</script><script type="text/plain" id="grid_sales" data-format="csv_embedded" data-src="">
Month,Sales,Product,Region,Segment
1,61791.27005419174,Product X,East,Segment 1
2,58576.13410634908,Product X,East,Segment 1
3,61001.925758585894,Product X,East,Segment 1
4,54303.72669090674,Product X,East,Segment 1
5,55033.73364350809,Product X,East,Segment 1
6,48953.29302255665,Product X,East,Segment 1
1,61092.305334594195,Product X,East,Segment 2
2,55346.61252863842,Product X,East,Segment 2
3,40265.948080667935,Product X,East,Segment 2
4,54215.77336656123,Product X,East,Segment 2
5,48700.48122819078,Product X,East,Segment 2
6,56258.70360192592,Product X,East,Segment 2
1,63131.733523861854,Product X,West,Segment 1
2,48051.02890084374,Product X,West,Segment 1
3,48013.65047917969,Product X,West,Segment 1
4,84356.91426600174,Product X,West,Segment 1
5,76931.58830009631,Product X,West,Segment 1
6,54726.757906569466,Product X,West,Segment 1
1,41448.88981711563,Product X,West,Segment 2
2,43539.14067311317,Product X,West,Segment 2
3,55491.10926955371,Product X,West,Segment 2
4,62233.453785069556,Product X,West,Segment 2
5,65718.55408044474,Product X,West,Segment 2
6,68340.05861574868,Product X,West,Segment 2
1,46660.8167020976,Product Y,East,Segment 1
2,63593.513028807276,Product Y,East,Segment 1
3,65998.70658641402,Product Y,East,Segment 1
4,49450.42406546517,Product Y,East,Segment 1
5,59400.049043092724,Product Y,East,Segment 1
6,49823.95275858126,Product Y,East,Segment 1
1,63089.81657742362,Product Y,East,Segment 2
2,48985.076730609246,Product Y,East,Segment 2
3,34879.527017925226,Product Y,East,Segment 2
4,77839.1313845206,Product Y,East,Segment 2
5,58887.109444674934,Product Y,East,Segment 2
6,53966.737872547405,Product Y,East,Segment 2
1,74985.07812244407,Product Y,West,Segment 1
2,58571.14907757438,Product Y,West,Segment 1
3,73040.78361148156,Product Y,West,Segment 1
4,58826.69618186661,Product Y,West,Segment 1
5,66922.67430249363,Product Y,West,Segment 1
6,66239.32510558637,Product Y,West,Segment 1
1,62415.72661284018,Product Y,West,Segment 2
2,65155.400340118256,Product Y,West,Segment 2
3,65007.82095290457,Product Y,West,Segment 2
4,58842.28159612284,Product Y,West,Segment 2
5,69013.40355103472,Product Y,West,Segment 2
6,58192.72351848962,Product Y,West,Segment 2

</script><script type="text/plain" id="headcount_data" data-format="csv_embedded" data-src="">
Department,Headcount,Team
Engineering,23,Team A
Engineering,8,Team B
Engineering,22,Team C
Sales,23,Team A
Sales,19,Team B
Sales,20,Team C
Marketing,21,Team A
Marketing,8,Team B
Marketing,12,Team C
Operations,20,Team A
Operations,21,Team B
Operations,11,Team C
HR,21,Team A
HR,9,Team B
HR,24,Team C

</script><script type="text/plain" id="market_share" data-format="csv_embedded" data-src="">
Month,MarketShare,Category
1,20.03306579777936,Category A
2,19.04811742927625,Category A
3,15.111091897641872,Category A
4,26.55154529063948,Category A
5,17.529194853096296,Category A
6,28.87999275905773,Category A
7,21.059038685312093,Category A
8,16.73387492181616,Category A
9,12.521600751266197,Category A
10,9.21429111536682,Category A
11,32.98722910869278,Category A
12,23.82470045816872,Category A
1,17.459239602062098,Category B
2,17.97249874397224,Category B
3,21.04267063698864,Category B
4,21.809063703705174,Category B
5,14.362938801145738,Category B
6,16.09390210885501,Category B
7,18.755218494590615,Category B
8,10.80071053604401,Category B
9,22.039955753299864,Category B
10,25.065459264403053,Category B
11,19.667303918896327,Category B
12,15.663813963043467,Category B
1,17.91683886784138,Category C
2,13.519573003835111,Category C
3,13.977145506611613,Category C
4,22.370107963443065,Category C
5,10.200383879307271,Category C
6,21.511878647323673,Category C
7,19.608900221482802,Category C
8,20.217496556895714,Category C
9,6.940846616328395,Category C
10,28.69676913437511,Category C
11,19.12905816218332,Category C
12,23.289701139580146,Category C
1,33.36868313783364,Category D
2,24.362560513682926,Category D
3,18.299667067710015,Category D
4,23.46749126630897,Category D
5,18.569372855050645,Category D
6,9.096606802718053,Category D
7,14.99798676814125,Category D
8,24.27226353648485,Category D
9,14.94709835744086,Category D
10,28.322401911466045,Category D
11,22.245698890955293,Category D
12,27.75527406289912,Category D

</script><script type="text/plain" id="business_metrics" data-format="csv_embedded" data-src="">
Quarter,Revenue,Profit,Growth,Industry,CompanySize
1,88.7151440471021,20.753028528040925,6.550489412011727,Tech,Small
2,90.49578938360305,23.98491858255393,0.9980140672188842,Tech,Small
3,103.84687235117549,22.80273013520346,5.3869670066615996,Tech,Small
4,73.44278481903962,21.058074992623226,6.270510969564917,Tech,Small
1,91.27136533648384,20.357942688751024,0.28695810113561393,Tech,Medium
2,92.74265203607906,25.41825207906544,6.901160263947466,Tech,Medium
3,88.29791790655302,22.918674382796024,6.982232632715053,Tech,Medium
4,98.6099107845503,29.152918439442868,0.5485356325898003,Tech,Medium
1,105.07773011578847,20.594596320675024,6.3791528960849755,Tech,Large
2,125.48631810177685,18.021984711653374,5.58460774753568,Tech,Large
3,95.57663144278156,15.654313215287875,2.6018460491940925,Tech,Large
4,80.48609796917195,18.58686978091302,8.57797778630242,Tech,Large
1,123.63448360170014,18.55937732254588,3.6622983488824437,Finance,Small
2,118.04069603237343,27.353142787904844,4.24535490214421,Finance,Small
3,112.10334336909352,14.33202549125662,0.5425989099703541,Finance,Small
4,51.36082172940766,22.85998586735248,2.167648730482806,Finance,Small
1,98.04555518919618,22.156884461550778,8.74667975391511,Finance,Medium
2,90.8313982841652,15.926642384558864,4.730662552905988,Finance,Medium
3,128.94075084866378,12.632099095960584,8.750751762759881,Finance,Medium
4,111.65135735863245,22.048211000799046,7.104145823085007,Finance,Medium
1,118.72400006764752,12.021973552186488,10.152324595831004,Finance,Large
2,68.74428628029705,16.60627862598208,6.447608799801589,Finance,Large
3,83.98797863884049,16.61926751146624,3.785661859710784,Finance,Large
4,118.0338503051548,18.56178809215259,6.125401829766201,Finance,Large
1,105.21897127425385,23.51463748953185,2.4205348434936598,Healthcare,Small
2,81.15998854327992,21.525693906476338,0.6506215308239005,Healthcare,Small
3,92.47454706212471,19.924504507208397,8.92266519051521,Healthcare,Small
4,99.62783135909932,24.962667534793148,10.202630646724886,Healthcare,Small
1,139.8734243906969,25.321975886656716,5.259393923978779,Healthcare,Medium
2,104.00170938163137,26.355487828878363,6.044121728116816,Healthcare,Medium
3,125.60021858869068,22.87362476769617,8.464181698833999,Healthcare,Medium
4,65.95933299530122,18.679236144934723,7.420284233047015,Healthcare,Medium
1,87.73521237855729,16.626725971283644,10.38911009876511,Healthcare,Large
2,90.78911746591268,27.199833730188416,8.703240586281371,Healthcare,Large
3,100.96224994415996,14.005560460874545,3.432980400788884,Healthcare,Large
4,116.3795774162044,24.349337265641395,6.702342710446672,Healthcare,Large

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <h1>AreaChart Examples</h1>
<p>This page demonstrates the key features of AreaChart plots in JSPlots.</p>
<ul>
    <li><strong>Continuous areas:</strong> Smooth filled areas for continuous x values (like dates)</li>
    <li><strong>Discrete areas:</strong> Bar-style areas for categorical x values</li>
    <li><strong>Stack modes:</strong> Unstack (overlapping), stack (cumulative), and normalized stack (percentage)</li>
    <li><strong>Grouping:</strong> Multiple series with automatic color assignment and legend</li>
    <li><strong>Interactive filters:</strong> Dropdown menus to filter data dynamically</li>
    <li><strong>Dynamic controls:</strong> Change grouping, stacking, and faceting on the fly</li>
    <li><strong>Faceting:</strong> Facet wrap (1 variable) and facet grid (2 variables)</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Example 1: Regional Sales Over Time (Stacked Area Chart)</h2>
<p>Continuous time series with dates on x-axis. Stacked areas show cumulative sales across regions.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_stacked_area">Stack mode: </label>
        <select id="stack_mode_select_stacked_area" onchange="updateChart_stacked_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="stacked_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_by_region</p><br>
<hr>
<br>
<h2>Example 2: Product Values - Continuous Unstack</h2>
<p>Continuous x-axis (numeric). Overlapping areas with transparency allow comparison of individual trends.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_unstacked_area">Stack mode: </label>
        <select id="stack_mode_select_unstacked_area" onchange="updateChart_unstacked_area()">
                <option value="unstack" selected>unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="unstacked_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: product_values</p><br>
<hr>
<br>
<h2>Example 3: Market Share Distribution (Normalized Stack)</h2>
<p>Continuous numeric x-axis. Normalized stacking shows relative proportions - total always reaches 100%.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_normalized_area">Stack mode: </label>
        <select id="stack_mode_select_normalized_area" onchange="updateChart_normalized_area()">
                <option value="unstack">unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack" selected>normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="normalized_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: market_share</p><br>
<hr>
<br>
<h2>Example 4: Headcount by Department (Discrete/Stacked Bars)</h2>
<p>Categorical x-axis. When x values are discrete, areas automatically become stacked bars.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_discrete_area">Stack mode: </label>
        <select id="stack_mode_select_discrete_area" onchange="updateChart_discrete_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="discrete_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: headcount_data</p><br>
<hr>
<br>
<h2>Example 5: Revenue by Channel with Filters</h2>
<p>Continuous date axis with interactive filters. Select different years and regions to update the view.</p>

<!-- Filters (for data filtering) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f9f9f9;">
            <h4 style="margin-top: 0;">Filters</h4>
                    <div style="margin: 10px;">
            <label for="Year_select">Year: </label>
            <select id="Year_select" multiple style="min-width: 150px; height: 100px;" onchange="updateChart_filtered_area()">
                <option value="2022">2022</option>
                <option value="2023">2023</option>
                <option value="2024" selected>2024</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="Region_select">Region: </label>
            <select id="Region_select" multiple style="min-width: 150px; height: 100px;" onchange="updateChart_filtered_area()">
                <option value="North" selected>North</option>
                <option value="South">South</option>
            </select>
        </div>
        
        </div>

<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_filtered_area">Stack mode: </label>
        <select id="stack_mode_select_filtered_area" onchange="updateChart_filtered_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="filtered_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: channel_revenue</p><br>
<hr>
<br>
<h2>Example 6: Metrics by Source (Facet Wrap)</h2>
<p>Continuous x-axis with faceting. Each facet shows one metric with stacked sources.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_facet_wrap_area">Stack mode: </label>
        <select id="stack_mode_select_facet_wrap_area" onchange="updateChart_facet_wrap_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_facet_wrap_area">Facet by: </label>
            <select id="facet1_select_facet_wrap_area" onchange="updateChart_facet_wrap_area()">
                <option value="None">None</option>
                <option value="Metric" selected>Metric</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="facet_wrap_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: metrics_data</p><br>
<hr>
<br>
<h2>Example 7: Sales by Product and Region (Facet Grid)</h2>
<p>Continuous x-axis with 2D facet grid. Products in rows, Regions in columns.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_facet_grid_area">Stack mode: </label>
        <select id="stack_mode_select_facet_grid_area" onchange="updateChart_facet_grid_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_facet_grid_area">Facet 1: </label>
            <select id="facet1_select_facet_grid_area" onchange="updateChart_facet_grid_area()">
                <option value="None">None</option>
                <option value="Product" selected>Product</option>
                <option value="Region">Region</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_facet_grid_area">Facet 2: </label>
            <select id="facet2_select_facet_grid_area" onchange="updateChart_facet_grid_area()">
                <option value="None">None</option>
                <option value="Product">Product</option>
                <option value="Region" selected>Region</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="facet_grid_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: grid_sales</p><br>
<hr>
<br>
<h2>Example 8: Business Metrics with Dynamic Controls</h2>
<p>Continuous x-axis. Use dropdowns to dynamically change: Y metric, grouping variable, stack mode, and faceting.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                    <div style="margin: 10px;">
            <label for="y_col_select_dynamic_grouping">Y dimension: </label>
            <select id="y_col_select_dynamic_grouping" onchange="updateChart_dynamic_grouping()">
                <option value="Revenue" selected>Revenue</option>
                <option value="Profit">Profit</option>
                <option value="Growth">Growth</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="group_col_select_dynamic_grouping">Group by: </label>
            <select id="group_col_select_dynamic_grouping" onchange="updateChart_dynamic_grouping()">
                <option value="Industry" selected>Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
            <div style="margin: 10px;">
        <label for="stack_mode_select_dynamic_grouping">Stack mode: </label>
        <select id="stack_mode_select_dynamic_grouping" onchange="updateChart_dynamic_grouping()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_dynamic_grouping">Facet 1: </label>
            <select id="facet1_select_dynamic_grouping" onchange="updateChart_dynamic_grouping()">
                <option value="None" selected>None</option>
                <option value="Industry">Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_dynamic_grouping">Facet 2: </label>
            <select id="facet2_select_dynamic_grouping" onchange="updateChart_dynamic_grouping()">
                <option value="None" selected>None</option>
                <option value="Industry">Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="dynamic_grouping"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: business_metrics</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Stack Mode Comparison</h2>
<p>The following three charts use the same data but different stack modes to illustrate their differences:</p>

    </div>
<br>
<hr>
<br>
<h2>Stack Mode: UNSTACK</h2>
<p>Areas overlap with transparency - see individual trends clearly</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_unstack_mode">Stack mode: </label>
        <select id="stack_mode_select_unstack_mode" onchange="updateChart_unstack_mode()">
                <option value="unstack" selected>unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="unstack_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
<h2>Stack Mode: STACK</h2>
<p>Areas are stacked - shows cumulative total and individual contributions</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_stack_mode">Stack mode: </label>
        <select id="stack_mode_select_stack_mode" onchange="updateChart_stack_mode()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="stack_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
<h2>Stack Mode: NORMALIZED STACK</h2>
<p>Areas are stacked and normalized to 100% - shows relative proportions over time</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_normalized_mode">Stack mode: </label>
        <select id="stack_mode_select_normalized_mode" onchange="updateChart_normalized_mode()">
                <option value="unstack">unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack" selected>normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="normalized_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Key Features Summary</h2>
<ul>
    <li><strong>Automatic discrete/continuous detection:</strong> Continuous x values (dates, numeric) create smooth areas; discrete x values (categories) create stacked bars</li>
    <li><strong>Three stack modes:</strong>
        <ul>
            <li><em>Unstack:</em> Overlapping areas with transparency - best for comparing trends</li>
            <li><em>Stack:</em> Cumulative areas - best for showing total and parts</li>
            <li><em>Normalized stack:</em> Percentage areas - best for showing proportions</li>
        </ul>
    </li>
    <li><strong>Dynamic grouping:</strong> Choose which variable to group/color by from dropdown</li>
    <li><strong>Interactive filters:</strong> Filter data dynamically with dropdown menus</li>
    <li><strong>Faceting:</strong> Create small multiples with 1 or 2 faceting variables</li>
    <li><strong>Customization:</strong> Control opacity, titles, and stack modes</li>
    <li><strong>Date support:</strong> Automatic formatting and proper handling of date-based time series</li>
</ul>
<p><strong>Tip:</strong> Hover over areas to see detailed values. Use the dropdown controls to explore different views of your data!</p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
