<!DOCTYPE html>
<html>
<head>
    <title>AreaChart Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>
</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                resolve(results.data);
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                resolve(data);
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        resolve(results.data);
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Date'];
    const Y_COLS = ['Sales'];
    const GROUP_COLS = ['Region'];
    const COLOR_MAPS = {'Region': {'East': '#00cc96', 'West': '#ab63fa', 'North': '#636efa', 'South': '#EF553B'}};
    const GROUP_ORDER = {'Region': ['North', 'South', 'East', 'West']};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_GROUP_COL = 'Region';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_stacked_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stacked_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stacked_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_stacked_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_stacked_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stacked_area');
        const facet2Select = document.getElementById('facet2_select_stacked_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stacked_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_by_region').then(function(data) {
        allData = data;
        window.updatePlot_stacked_area();
    }).catch(function(error) {
        console.error('Error loading data for chart stacked_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Product'];
    const COLOR_MAPS = {'Product': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product B': '#EF553B'}};
    const GROUP_ORDER = {'Product': ['Product A', 'Product B', 'Product C']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Product';
    const FILL_OPACITY = 0.4;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_unstacked_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_unstacked_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_unstacked_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_unstacked_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_unstacked_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'unstack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_unstacked_area');
        const facet2Select = document.getElementById('facet2_select_unstacked_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('unstacked_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('product_values').then(function(data) {
        allData = data;
        window.updatePlot_unstacked_area();
    }).catch(function(error) {
        console.error('Error loading data for chart unstacked_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['MarketShare'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Category D': '#ab63fa', 'Category C': '#00cc96', 'Category B': '#EF553B', 'Category A': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Category A', 'Category B', 'Category C', 'Category D']};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'MarketShare';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_normalized_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_normalized_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_normalized_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_normalized_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_normalized_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'normalised_stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_normalized_area');
        const facet2Select = document.getElementById('facet2_select_normalized_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('normalized_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('market_share').then(function(data) {
        allData = data;
        window.updatePlot_normalized_area();
    }).catch(function(error) {
        console.error('Error loading data for chart normalized_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Department'];
    const Y_COLS = ['Headcount'];
    const GROUP_COLS = ['Team'];
    const COLOR_MAPS = {'Team': {'Team C': '#00cc96', 'Team B': '#EF553B', 'Team A': '#636efa'}};
    const GROUP_ORDER = {'Team': ['Team A', 'Team B', 'Team C']};
    const DEFAULT_X_COL = 'Department';
    const DEFAULT_Y_COL = 'Headcount';
    const DEFAULT_GROUP_COL = 'Team';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_discrete_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_discrete_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_discrete_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_discrete_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_discrete_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_discrete_area');
        const facet2Select = document.getElementById('facet2_select_discrete_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('discrete_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('headcount_data').then(function(data) {
        allData = data;
        window.updatePlot_discrete_area();
    }).catch(function(error) {
        console.error('Error loading data for chart discrete_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = ['Year', 'Region'];
    const X_COLS = ['Date'];
    const Y_COLS = ['Revenue'];
    const GROUP_COLS = ['Channel'];
    const COLOR_MAPS = {'Channel': {'Retail': '#EF553B', 'Online': '#636efa', 'Wholesale': '#00cc96'}};
    const GROUP_ORDER = {'Channel': ['Online', 'Retail', 'Wholesale']};
    const DEFAULT_X_COL = 'Date';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_GROUP_COL = 'Channel';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_filtered_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_filtered_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_filtered_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_filtered_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_filtered_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_filtered_area');
        const facet2Select = document.getElementById('facet2_select_filtered_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('filtered_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('channel_revenue').then(function(data) {
        allData = data;
        window.updatePlot_filtered_area();
    }).catch(function(error) {
        console.error('Error loading data for chart filtered_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Week'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Source'];
    const COLOR_MAPS = {'Source': {'Source 1': '#636efa', 'Source 2': '#EF553B', 'Source 3': '#00cc96'}};
    const GROUP_ORDER = {'Source': ['Source 1', 'Source 2', 'Source 3']};
    const DEFAULT_X_COL = 'Week';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Source';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_facet_wrap_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_wrap_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_wrap_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_facet_wrap_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_facet_wrap_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_wrap_area');
        const facet2Select = document.getElementById('facet2_select_facet_wrap_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_wrap_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('metrics_data').then(function(data) {
        allData = data;
        window.updatePlot_facet_wrap_area();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_wrap_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Month'];
    const Y_COLS = ['Sales'];
    const GROUP_COLS = ['Segment'];
    const COLOR_MAPS = {'Segment': {'Segment 1': '#636efa', 'Segment 2': '#EF553B'}};
    const GROUP_ORDER = {'Segment': ['Segment 1', 'Segment 2']};
    const DEFAULT_X_COL = 'Month';
    const DEFAULT_Y_COL = 'Sales';
    const DEFAULT_GROUP_COL = 'Segment';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_facet_grid_area = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_facet_grid_area');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_facet_grid_area');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_facet_grid_area');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_facet_grid_area');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_facet_grid_area');
        const facet2Select = document.getElementById('facet2_select_facet_grid_area');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('facet_grid_area', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('grid_sales').then(function(data) {
        allData = data;
        window.updatePlot_facet_grid_area();
    }).catch(function(error) {
        console.error('Error loading data for chart facet_grid_area:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Quarter'];
    const Y_COLS = ['Revenue', 'Profit', 'Growth'];
    const GROUP_COLS = ['Industry', 'CompanySize'];
    const COLOR_MAPS = {'Industry': {'Finance': '#EF553B', 'Healthcare': '#00cc96', 'Tech': '#636efa'}, 'CompanySize': {'Medium': '#EF553B', 'Small': '#636efa', 'Large': '#00cc96'}};
    const GROUP_ORDER = {'Industry': ['Tech', 'Finance', 'Healthcare'], 'CompanySize': ['Small', 'Medium', 'Large']};
    const DEFAULT_X_COL = 'Quarter';
    const DEFAULT_Y_COL = 'Revenue';
    const DEFAULT_GROUP_COL = 'Industry';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_dynamic_grouping = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_dynamic_grouping');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_dynamic_grouping');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_dynamic_grouping');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_dynamic_grouping');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_dynamic_grouping');
        const facet2Select = document.getElementById('facet2_select_dynamic_grouping');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('dynamic_grouping', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('business_metrics').then(function(data) {
        allData = data;
        window.updatePlot_dynamic_grouping();
    }).catch(function(error) {
        console.error('Error loading data for chart dynamic_grouping:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.5;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_unstack_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_unstack_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_unstack_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_unstack_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_unstack_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'unstack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_unstack_mode');
        const facet2Select = document.getElementById('facet2_select_unstack_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('unstack_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_unstack_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart unstack_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_stack_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stack_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stack_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_stack_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_stack_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stack_mode');
        const facet2Select = document.getElementById('facet2_select_stack_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stack_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_stack_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart stack_mode:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['Time'];
    const Y_COLS = ['Value'];
    const GROUP_COLS = ['Category'];
    const COLOR_MAPS = {'Category': {'Cat 3': '#00cc96', 'Cat 2': '#EF553B', 'Cat 1': '#636efa'}};
    const GROUP_ORDER = {'Category': ['Cat 1', 'Cat 2', 'Cat 3']};
    const DEFAULT_X_COL = 'Time';
    const DEFAULT_Y_COL = 'Value';
    const DEFAULT_GROUP_COL = 'Category';
    const FILL_OPACITY = 0.6;

    let allData = [];

    // Detect if x values are discrete or continuous
    function isDiscrete(values) {
        // Consider discrete if we have strings, or if numeric with small number of unique values
        const sample = values[0];
        if (typeof sample === 'string') return true;

        const uniqueVals = [...new Set(values)];
        // If less than 20 unique values and they look like categories, treat as discrete
        return uniqueVals.length < 20 && uniqueVals.every(v => Number.isInteger(v) || typeof v === 'string');
    }

    // Make it global so inline onchange can see it
    window.updatePlot_normalized_mode = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_normalized_mode');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_normalized_mode');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current group column
        const groupColSelect = document.getElementById('group_col_select_normalized_mode');
        const GROUP_COL = groupColSelect ? groupColSelect.value : DEFAULT_GROUP_COL;

        // Get current stack mode
        const stackModeSelect = document.getElementById('stack_mode_select_normalized_mode');
        const STACK_MODE = stackModeSelect ? stackModeSelect.value : 'normalised_stack';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_normalized_mode');
        const facet2Select = document.getElementById('facet2_select_normalized_mode');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map and group order for current selection
        const COLOR_MAP = COLOR_MAPS[GROUP_COL] || {};
        const GROUP_ORDER_ARRAY = GROUP_ORDER[GROUP_COL] || [];

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - create area chart
            const groupedData = {};
            filteredData.forEach(row => {
                const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                if (!groupedData[groupVal]) {
                    groupedData[groupVal] = [];
                }
                groupedData[groupVal].push(row);
            });

            // Get groups in order of appearance
            const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                Object.keys(groupedData);

            const traces = [];
            const discrete = isDiscrete(filteredData.map(row => row[X_COL]));

            for (let groupKey of orderedGroups) {
                const groupData = groupedData[groupKey];
                groupData.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];
                    if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                    return aVal - bVal;
                });

                const xValues = groupData.map(row => row[X_COL]);
                const yValues = groupData.map(row => row[Y_COL]);

                const color = COLOR_MAP[groupKey] || '#636efa';
                const trace = {
                    x: xValues,
                    y: yValues,
                    name: groupKey,
                    type: discrete ? 'bar' : 'scatter'
                };

                if (discrete) {
                    // Bar chart style
                    trace.marker = {color: color};
                } else {
                    // Area chart style
                    trace.mode = 'lines';
                    trace.line = {color: color, width: 0};
                }

                // Apply stacking mode
                if (STACK_MODE === 'unstack') {
                    if (!discrete) {
                        trace.fill = 'tozeroy';
                        // Convert hex to rgba
                        if (color.startsWith('#')) {
                            const r = parseInt(color.substr(1,2), 16);
                            const g = parseInt(color.substr(3,2), 16);
                            const b = parseInt(color.substr(5,2), 16);
                            trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                        }
                    } else {
                        trace.opacity = FILL_OPACITY;
                    }
                } else if (STACK_MODE === 'stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                    }
                } else if (STACK_MODE === 'normalised_stack') {
                    if (discrete) {
                        trace.type = 'bar';
                    } else {
                        trace.fill = 'tonexty';
                        trace.stackgroup = 'one';
                        trace.groupnorm = 'percent';
                    }
                }

                traces.push(trace);
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: {
                    title: STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL
                },
                hovermode: 'closest',
                showlegend: true,
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by group column within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                    if (!groupedData[groupVal]) {
                        groupedData[groupVal] = [];
                    }
                    groupedData[groupVal].push(row);
                });

                const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                    GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                    Object.keys(groupedData);

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                for (let groupKey of orderedGroups) {
                    const groupData = groupedData[groupKey];
                    groupData.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];
                        if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                        return aVal - bVal;
                    });

                    const xValues = groupData.map(row => row[X_COL]);
                    const yValues = groupData.map(row => row[Y_COL]);

                    const color = COLOR_MAP[groupKey] || '#636efa';
                    const legendGroup = groupKey;

                    const trace = {
                        x: xValues,
                        y: yValues,
                        name: groupKey,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        type: discrete ? 'bar' : 'scatter'
                    };

                    if (discrete) {
                        trace.marker = {color: color};
                    } else {
                        trace.mode = 'lines';
                        trace.line = {color: color, width: 0};
                    }

                    // Apply stacking mode
                    if (STACK_MODE === 'unstack') {
                        if (!discrete) {
                            trace.fill = 'tozeroy';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.substr(1,2), 16);
                                const g = parseInt(color.substr(3,2), 16);
                                const b = parseInt(color.substr(5,2), 16);
                                trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                            }
                        } else {
                            trace.opacity = FILL_OPACITY;
                        }
                    } else if (STACK_MODE === 'stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                        }
                    } else if (STACK_MODE === 'normalised_stack') {
                        if (!discrete) {
                            trace.fill = 'tonexty';
                            trace.stackgroup = 'one' + idx;
                            trace.groupnorm = 'percent';
                        }
                    }

                    traces.push(trace);
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'},
                barmode: STACK_MODE === 'stack' || STACK_MODE === 'normalised_stack' ? 'stack' : 'overlay',
                barnorm: STACK_MODE === 'normalised_stack' ? 'percent' : undefined
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by group column within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const groupVal = (GROUP_COL === '__no_group__') ? 'all' : String(row[GROUP_COL]);
                        if (!groupedData[groupVal]) {
                            groupedData[groupVal] = [];
                        }
                        groupedData[groupVal].push(row);
                    });

                    const orderedGroups = GROUP_ORDER_ARRAY.length > 0 ?
                        GROUP_ORDER_ARRAY.filter(g => groupedData[g]) :
                        Object.keys(groupedData);

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    const discrete = isDiscrete(facetData.map(row => row[X_COL]));

                    for (let groupKey of orderedGroups) {
                        const groupData = groupedData[groupKey];
                        groupData.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];
                            if (typeof aVal === 'string') return aVal.localeCompare(bVal);
                            return aVal - bVal;
                        });

                        const xValues = groupData.map(row => row[X_COL]);
                        const yValues = groupData.map(row => row[Y_COL]);

                        const color = COLOR_MAP[groupKey] || '#636efa';
                        const legendGroup = groupKey;

                        const trace = {
                            x: xValues,
                            y: yValues,
                            name: groupKey,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            type: discrete ? 'bar' : 'scatter'
                        };

                        if (discrete) {
                            trace.marker = {color: color};
                        } else {
                            trace.mode = 'lines';
                            trace.line = {color: color, width: 0};
                        }

                        // Apply stacking mode
                        if (STACK_MODE === 'unstack') {
                            if (!discrete) {
                                trace.fill = 'tozeroy';
                                if (color.startsWith('#')) {
                                    const r = parseInt(color.substr(1,2), 16);
                                    const g = parseInt(color.substr(3,2), 16);
                                    const b = parseInt(color.substr(5,2), 16);
                                    trace.fillcolor = `rgba(${r}, ${g}, ${b}, ${FILL_OPACITY})`;
                                }
                            } else {
                                trace.opacity = FILL_OPACITY;
                            }
                        } else if (STACK_MODE === 'stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                            }
                        } else if (STACK_MODE === 'normalised_stack') {
                            if (!discrete) {
                                trace.fill = 'tonexty';
                                trace.stackgroup = 'one' + idx;
                                trace.groupnorm = 'percent';
                            }
                        }

                        traces.push(trace);
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? (STACK_MODE === 'normalised_stack' ? Y_COL + ' (%)' : Y_COL) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('normalized_mode', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('compare_data').then(function(data) {
        allData = data;
        window.updatePlot_normalized_mode();
    }).catch(function(error) {
        console.error('Error loading data for chart normalized_mode:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="channel_revenue" data-format="csv_embedded" data-src="">
Date,Revenue,Channel,Region,Year
2024-01-01,91211.68979330476,Online,North,2022
2024-01-08,119152.1409020448,Online,North,2022
2024-01-15,50273.334285562,Online,North,2022
2024-01-22,105579.32035473167,Online,North,2022
2024-01-29,94012.35231845886,Online,North,2022
2024-02-05,103561.98766907839,Online,North,2022
2024-02-12,77968.48891978423,Online,North,2022
2024-02-19,109692.76788578453,Online,North,2022
2024-02-26,120511.650818625,Online,North,2022
2024-03-04,100007.59469647596,Online,North,2022
2024-03-11,86589.6603492471,Online,North,2022
2024-03-18,140914.75200603664,Online,North,2022
2024-03-25,123188.55474313736,Online,North,2022
2024-04-01,124404.05134131499,Online,North,2022
2024-04-08,112276.58266702801,Online,North,2022
2024-04-15,119226.66045691683,Online,North,2022
2024-04-22,133882.23315168754,Online,North,2022
2024-04-29,78045.91474322396,Online,North,2022
2024-05-06,146898.19162286987,Online,North,2022
2024-05-13,128260.82341098026,Online,North,2022
2024-05-20,117653.16595313889,Online,North,2022
2024-05-27,102194.8279487777,Online,North,2022
2024-06-03,118916.47483925207,Online,North,2022
2024-06-10,148858.65683425186,Online,North,2022
2024-06-17,120946.42618658845,Online,North,2022
2024-06-24,126910.5703790076,Online,North,2022
2024-07-01,157189.19812835797,Online,North,2022
2024-07-08,160613.5676150997,Online,North,2022
2024-07-15,131087.21781377733,Online,North,2022
2024-07-22,169149.69492252535,Online,North,2022
2024-07-29,121579.43245862695,Online,North,2022
2024-08-05,94183.19574236724,Online,North,2022
2024-08-12,131027.9508161264,Online,North,2022
2024-08-19,146213.91813633242,Online,North,2022
2024-08-26,134493.84014612358,Online,North,2022
2024-09-02,112004.96282162977,Online,North,2022
2024-09-09,134276.3410886012,Online,North,2022
2024-09-16,143365.84859467825,Online,North,2022
2024-09-23,165076.2137188966,Online,North,2022
2024-09-30,138663.46069340914,Online,North,2022
2024-10-07,122236.36162087577,Online,North,2022
2024-10-14,138202.5530219908,Online,North,2022
2024-10-21,106191.18593116212,Online,North,2022
2024-10-28,107656.58635275648,Online,North,2022
2024-11-04,142755.80020191663,Online,North,2022
2024-11-11,182900.0790833347,Online,North,2022
2024-11-18,131713.52082727064,Online,North,2022
2024-11-25,122562.00771354572,Online,North,2022
2024-12-02,170557.9309379274,Online,North,2022
2024-12-09,156228.58687012942,Online,North,2022
2024-12-16,116633.64763162189,Online,North,2022
2024-12-23,165324.34789160185,Online,North,2022
2024-12-30,106100.35082120216,Online,North,2022
2024-01-01,116945.62804253718,Online,South,2022
2024-01-08,86203.7162593896,Online,South,2022
2024-01-15,140799.26899411768,Online,South,2022
2024-01-22,114181.05241749414,Online,South,2022
2024-01-29,119555.98535889314,Online,South,2022
2024-02-05,92052.35890988441,Online,South,2022
2024-02-12,81504.16605111567,Online,South,2022
2024-02-19,101608.26840539096,Online,South,2022
2024-02-26,125242.71596078007,Online,South,2022
2024-03-04,106397.84358650207,Online,South,2022
2024-03-11,75281.4507629603,Online,South,2022
2024-03-18,78553.56088388019,Online,South,2022
2024-03-25,106331.23588906409,Online,South,2022
2024-04-01,96444.95225548993,Online,South,2022
2024-04-08,107653.82831282317,Online,South,2022
2024-04-15,98921.5897562118,Online,South,2022
2024-04-22,106303.77380954208,Online,South,2022
2024-04-29,113235.09116529465,Online,South,2022
2024-05-06,106572.14723587601,Online,South,2022
2024-05-13,115096.47865284377,Online,South,2022
2024-05-20,119299.30037705626,Online,South,2022
2024-05-27,142565.62225854927,Online,South,2022
2024-06-03,140831.17454492516,Online,South,2022
2024-06-10,119688.6377654569,Online,South,2022
2024-06-17,166036.14525153965,Online,South,2022
2024-06-24,157287.9401544311,Online,South,2022
2024-07-01,102643.47683849299,Online,South,2022
2024-07-08,128915.21496940115,Online,South,2022
2024-07-15,137924.4835035057,Online,South,2022
2024-07-22,143426.54828763078,Online,South,2022
2024-07-29,119638.74863805278,Online,South,2022
2024-08-05,122373.03718415168,Online,South,2022
2024-08-12,131877.13858356938,Online,South,2022
2024-08-19,141022.99358980847,Online,South,2022
2024-08-26,123208.1317017453,Online,South,2022
2024-09-02,98832.69720100529,Online,South,2022
2024-09-09,174916.81726542802,Online,South,2022
2024-09-16,121972.40529486354,Online,South,2022
2024-09-23,149327.64946652835,Online,South,2022
2024-09-30,129804.58078924974,Online,South,2022
2024-10-07,139505.55817822862,Online,South,2022
2024-10-14,127195.65038601584,Online,South,2022
2024-10-21,157747.9540573276,Online,South,2022
2024-10-28,140733.39734768853,Online,South,2022
2024-11-04,168996.45528233692,Online,South,2022
2024-11-11,144429.4291419165,Online,South,2022
2024-11-18,138757.30122164363,Online,South,2022
2024-11-25,163134.20371869818,Online,South,2022
2024-12-02,165382.78566007217,Online,South,2022
2024-12-09,146252.01520449365,Online,South,2022
2024-12-16,191964.65594409587,Online,South,2022
2024-12-23,184592.5789950119,Online,South,2022
2024-12-30,71166.71125434636,Online,South,2022
2024-01-01,117253.67006443026,Retail,North,2022
2024-01-08,99687.62324998163,Retail,North,2022
2024-01-15,91110.28110706201,Retail,North,2022
2024-01-22,117311.76742881164,Retail,North,2022
2024-01-29,120576.48189152825,Retail,North,2022
2024-02-05,112937.65796911698,Retail,North,2022
2024-02-12,98652.58320762595,Retail,North,2022
2024-02-19,127433.69068395061,Retail,North,2022
2024-02-26,124980.86895715732,Retail,North,2022
2024-03-04,91312.79024282609,Retail,North,2022
2024-03-11,100775.22342410099,Retail,North,2022
2024-03-18,115002.88339853079,Retail,North,2022
2024-03-25,109504.46764137354,Retail,North,2022
2024-04-01,126782.19823926286,Retail,North,2022
2024-04-08,122341.2462640274,Retail,North,2022
2024-04-15,98913.04043576134,Retail,North,2022
2024-04-22,133295.0829613138,Retail,North,2022
2024-04-29,122719.69093336973,Retail,North,2022
2024-05-06,119568.26991921617,Retail,North,2022
2024-05-13,145679.338526778,Retail,North,2022
2024-05-20,152603.47187704567,Retail,North,2022
2024-05-27,140298.3300949902,Retail,North,2022
2024-06-03,99971.67109473277,Retail,North,2022
2024-06-10,101099.38433878416,Retail,North,2022
2024-06-17,135016.19471682527,Retail,North,2022
2024-06-24,136011.24520564915,Retail,North,2022
2024-07-01,97908.60483362142,Retail,North,2022
2024-07-08,149152.4194361244,Retail,North,2022
2024-07-15,143840.36766999733,Retail,North,2022
2024-07-22,123108.91722023202,Retail,North,2022
2024-07-29,139312.2463505244,Retail,North,2022
2024-08-05,92189.580638118,Retail,North,2022
2024-08-12,113511.65914084435,Retail,North,2022
2024-08-19,120148.07297320456,Retail,North,2022
2024-08-26,128316.68462684628,Retail,North,2022
2024-09-02,124691.05765747238,Retail,North,2022
2024-09-09,153695.7322162341,Retail,North,2022
2024-09-16,122681.91759677637,Retail,North,2022
2024-09-23,148197.93877447667,Retail,North,2022
2024-09-30,158577.90577943844,Retail,North,2022
2024-10-07,178719.92806495354,Retail,North,2022
2024-10-14,125484.52228921326,Retail,North,2022
2024-10-21,116206.34655724335,Retail,North,2022
2024-10-28,166055.50192874554,Retail,North,2022
2024-11-04,141180.7028440897,Retail,North,2022
2024-11-11,157826.954179465,Retail,North,2022
2024-11-18,142906.59484585462,Retail,North,2022
2024-11-25,126027.59167983981,Retail,North,2022
2024-12-02,148565.8142282091,Retail,North,2022
2024-12-09,152336.50816633756,Retail,North,2022
2024-12-16,126264.85494775287,Retail,North,2022
2024-12-23,143465.85738099506,Retail,North,2022
2024-12-30,125674.07019192328,Retail,North,2022
2024-01-01,115930.61135805467,Retail,South,2022
2024-01-08,85602.37002332596,Retail,South,2022
2024-01-15,114178.65483700554,Retail,South,2022
2024-01-22,126974.33673815816,Retail,South,2022
2024-01-29,97858.63965900672,Retail,South,2022
2024-02-05,100397.14570533176,Retail,South,2022
2024-02-12,128299.67685387172,Retail,South,2022
2024-02-19,97230.04706974931,Retail,South,2022
2024-02-26,106004.817746941,Retail,South,2022
2024-03-04,82083.10725214591,Retail,South,2022
2024-03-11,106530.13948293473,Retail,South,2022
2024-03-18,112963.07244683646,Retail,South,2022
2024-03-25,108792.46456703945,Retail,South,2022
2024-04-01,107720.01420421989,Retail,South,2022
2024-04-08,123251.03426366381,Retail,South,2022
2024-04-15,104336.75727227518,Retail,South,2022
2024-04-22,119326.26409559188,Retail,South,2022
2024-04-29,107418.55702682362,Retail,South,2022
2024-05-06,126394.02768583178,Retail,South,2022
2024-05-13,136425.5798239019,Retail,South,2022
2024-05-20,126513.68306006555,Retail,South,2022
2024-05-27,122848.41462671633,Retail,South,2022
2024-06-03,128199.5212348672,Retail,South,2022
2024-06-10,123943.25929920815,Retail,South,2022
2024-06-17,139259.1927083958,Retail,South,2022
2024-06-24,142487.76165909445,Retail,South,2022
2024-07-01,93747.84729962511,Retail,South,2022
2024-07-08,129454.90943941876,Retail,South,2022
2024-07-15,123917.36436398374,Retail,South,2022
2024-07-22,138372.56240355878,Retail,South,2022
2024-07-29,133255.5995208822,Retail,South,2022
2024-08-05,139381.22198794328,Retail,South,2022
2024-08-12,131365.9334903747,Retail,South,2022
2024-08-19,138720.81233070078,Retail,South,2022
2024-08-26,174327.4803982224,Retail,South,2022
2024-09-02,124303.59618105058,Retail,South,2022
2024-09-09,143952.37723707553,Retail,South,2022
2024-09-16,131040.96239519285,Retail,South,2022
2024-09-23,102613.72941082803,Retail,South,2022
2024-09-30,141857.57562227387,Retail,South,2022
2024-10-07,101400.45329086683,Retail,South,2022
2024-10-14,100424.31792123234,Retail,South,2022
2024-10-21,160184.88640974628,Retail,South,2022
2024-10-28,125939.57153925541,Retail,South,2022
2024-11-04,140482.8351791464,Retail,South,2022
2024-11-11,145077.38896439306,Retail,South,2022
2024-11-18,116051.10881537515,Retail,South,2022
2024-11-25,191584.42966171043,Retail,South,2022
2024-12-02,118980.9760501988,Retail,South,2022
2024-12-09,121930.62251626186,Retail,South,2022
2024-12-16,158371.31290356792,Retail,South,2022
2024-12-23,139693.2729117862,Retail,South,2022
2024-12-30,122984.6348270389,Retail,South,2022
2024-01-01,107065.7026691617,Wholesale,North,2022
2024-01-08,124373.68397147708,Wholesale,North,2022
2024-01-15,106560.44751107457,Wholesale,North,2022
2024-01-22,123878.5147145568,Wholesale,North,2022
2024-01-29,80857.4533179765,Wholesale,North,2022
2024-02-05,72319.19788984698,Wholesale,North,2022
2024-02-12,92929.85581728566,Wholesale,North,2022
2024-02-19,96990.56699365331,Wholesale,North,2022
2024-02-26,130909.37843081867,Wholesale,North,2022
2024-03-04,101130.52858077688,Wholesale,North,2022
2024-03-11,112051.92157903546,Wholesale,North,2022
2024-03-18,112895.70298078406,Wholesale,North,2022
2024-03-25,102600.4041520927,Wholesale,North,2022
2024-04-01,77508.72625164014,Wholesale,North,2022
2024-04-08,156426.13720418862,Wholesale,North,2022
2024-04-15,144325.43590352876,Wholesale,North,2022
2024-04-22,100764.28977202921,Wholesale,North,2022
2024-04-29,97766.66318730773,Wholesale,North,2022
2024-05-06,127426.20700249048,Wholesale,North,2022
2024-05-13,123464.51577235949,Wholesale,North,2022
2024-05-20,79795.02867490557,Wholesale,North,2022
2024-05-27,125227.791870598,Wholesale,North,2022
2024-06-03,48737.56699459012,Wholesale,North,2022
2024-06-10,109773.72426977604,Wholesale,North,2022
2024-06-17,148869.26084385585,Wholesale,North,2022
2024-06-24,135745.5569421327,Wholesale,North,2022
2024-07-01,124632.82778737268,Wholesale,North,2022
2024-07-08,126664.11311619935,Wholesale,North,2022
2024-07-15,123732.14623999456,Wholesale,North,2022
2024-07-22,79000.56206066298,Wholesale,North,2022
2024-07-29,144747.4483947288,Wholesale,North,2022
2024-08-05,140516.32485849736,Wholesale,North,2022
2024-08-12,118163.47535882771,Wholesale,North,2022
2024-08-19,148417.42032096896,Wholesale,North,2022
2024-08-26,111322.1879158623,Wholesale,North,2022
2024-09-02,136588.11907611997,Wholesale,North,2022
2024-09-09,136435.35789512534,Wholesale,North,2022
2024-09-16,175730.10863178852,Wholesale,North,2022
2024-09-23,129846.99719745808,Wholesale,North,2022
2024-09-30,115130.84154983233,Wholesale,North,2022
2024-10-07,136580.22955021646,Wholesale,North,2022
2024-10-14,174241.5517207175,Wholesale,North,2022
2024-10-21,128180.1631046765,Wholesale,North,2022
2024-10-28,153550.79298667892,Wholesale,North,2022
2024-11-04,177002.74254369846,Wholesale,North,2022
2024-11-11,137282.2716444201,Wholesale,North,2022
2024-11-18,153489.10702592216,Wholesale,North,2022
2024-11-25,146523.1501529388,Wholesale,North,2022
2024-12-02,175008.2760438279,Wholesale,North,2022
2024-12-09,155284.0211043079,Wholesale,North,2022
2024-12-16,160530.802537332,Wholesale,North,2022
2024-12-23,140273.36382830367,Wholesale,North,2022
2024-12-30,95403.61431535074,Wholesale,North,2022
2024-01-01,109698.39284096217,Wholesale,South,2022
2024-01-08,90905.78098570721,Wholesale,South,2022
2024-01-15,111080.17490934655,Wholesale,South,2022
2024-01-22,116451.64592692975,Wholesale,South,2022
2024-01-29,152567.29187461664,Wholesale,South,2022
2024-02-05,111880.14529826811,Wholesale,South,2022
2024-02-12,117943.02667743419,Wholesale,South,2022
2024-02-19,137917.8343967431,Wholesale,South,2022
2024-02-26,117402.80249415516,Wholesale,South,2022
2024-03-04,109936.83647335779,Wholesale,South,2022
2024-03-11,92299.90744618593,Wholesale,South,2022
2024-03-18,116450.89065145772,Wholesale,South,2022
2024-03-25,116661.17035746115,Wholesale,South,2022
2024-04-01,130936.43292681496,Wholesale,South,2022
2024-04-08,134666.59523336223,Wholesale,South,2022
2024-04-15,118460.30825178145,Wholesale,South,2022
2024-04-22,82032.2478711462,Wholesale,South,2022
2024-04-29,114159.59944150479,Wholesale,South,2022
2024-05-06,97038.34787918154,Wholesale,South,2022
2024-05-13,92109.61611675116,Wholesale,South,2022
2024-05-20,98471.26837469584,Wholesale,South,2022
2024-05-27,117458.04784223718,Wholesale,South,2022
2024-06-03,125520.33488161063,Wholesale,South,2022
2024-06-10,117224.48415608272,Wholesale,South,2022
2024-06-17,125634.15159175736,Wholesale,South,2022
2024-06-24,113327.42861279512,Wholesale,South,2022
2024-07-01,131257.8598366361,Wholesale,South,2022
2024-07-08,131846.43297161697,Wholesale,South,2022
2024-07-15,148632.31943137525,Wholesale,South,2022
2024-07-22,150104.07425431738,Wholesale,South,2022
2024-07-29,157596.3318945273,Wholesale,South,2022
2024-08-05,139016.7742649258,Wholesale,South,2022
2024-08-12,146979.2483938458,Wholesale,South,2022
2024-08-19,140682.9306206408,Wholesale,South,2022
2024-08-26,165673.11759748874,Wholesale,South,2022
2024-09-02,133981.13640528443,Wholesale,South,2022
2024-09-09,159388.3614951037,Wholesale,South,2022
2024-09-16,127092.66874302222,Wholesale,South,2022
2024-09-23,125898.46092220972,Wholesale,South,2022
2024-09-30,132117.44359592564,Wholesale,South,2022
2024-10-07,131970.44072071643,Wholesale,South,2022
2024-10-14,124730.56195930488,Wholesale,South,2022
2024-10-21,121834.43659702415,Wholesale,South,2022
2024-10-28,164324.7130722063,Wholesale,South,2022
2024-11-04,187301.54264693303,Wholesale,South,2022
2024-11-11,167078.4438363262,Wholesale,South,2022
2024-11-18,176455.99437630927,Wholesale,South,2022
2024-11-25,195236.57440198923,Wholesale,South,2022
2024-12-02,156527.4288693334,Wholesale,South,2022
2024-12-09,170909.0509634837,Wholesale,South,2022
2024-12-16,181725.2116617635,Wholesale,South,2022
2024-12-23,151272.56116005537,Wholesale,South,2022
2024-12-30,98926.29236158475,Wholesale,South,2022
2024-01-01,118552.39726224414,Online,North,2023
2024-01-08,105092.325943956,Online,North,2023
2024-01-15,80850.34207145545,Online,North,2023
2024-01-22,122361.13996177856,Online,North,2023
2024-01-29,144785.87988566386,Online,North,2023
2024-02-05,82112.37479836938,Online,North,2023
2024-02-12,119615.38828211957,Online,North,2023
2024-02-19,108180.71942915913,Online,North,2023
2024-02-26,90040.75040068214,Online,North,2023
2024-03-04,118032.16276329926,Online,North,2023
2024-03-11,108156.17799517787,Online,North,2023
2024-03-18,137311.3980111871,Online,North,2023
2024-03-25,108673.03358320112,Online,North,2023
2024-04-01,122197.37386418397,Online,North,2023
2024-04-08,94909.68756960616,Online,North,2023
2024-04-15,110458.1788350694,Online,North,2023
2024-04-22,127589.38119885551,Online,North,2023
2024-04-29,108879.18452063875,Online,North,2023
2024-05-06,166648.37953506556,Online,North,2023
2024-05-13,105686.68074189452,Online,North,2023
2024-05-20,161657.00195576967,Online,North,2023
2024-05-27,108469.27530562968,Online,North,2023
2024-06-03,122433.20659673157,Online,North,2023
2024-06-10,119360.75134737346,Online,North,2023
2024-06-17,194838.62215566548,Online,North,2023
2024-06-24,90354.61583644158,Online,North,2023
2024-07-01,119150.7080541331,Online,North,2023
2024-07-08,121575.8552709402,Online,North,2023
2024-07-15,144642.55377634818,Online,North,2023
2024-07-22,117417.59536599186,Online,North,2023
2024-07-29,139674.45447369575,Online,North,2023
2024-08-05,134374.81199536752,Online,North,2023
2024-08-12,152929.2572110648,Online,North,2023
2024-08-19,143175.05288854046,Online,North,2023
2024-08-26,127286.7967543544,Online,North,2023
2024-09-02,140752.12848096044,Online,North,2023
2024-09-09,101382.8198759014,Online,North,2023
2024-09-16,156601.79032471846,Online,North,2023
2024-09-23,144789.44773835258,Online,North,2023
2024-09-30,143949.8802207352,Online,North,2023
2024-10-07,152451.04067196522,Online,North,2023
2024-10-14,159589.45103463752,Online,North,2023
2024-10-21,148516.27803771524,Online,North,2023
2024-10-28,166892.8127711587,Online,North,2023
2024-11-04,132954.8052401911,Online,North,2023
2024-11-11,136696.09865161625,Online,North,2023
2024-11-18,160695.73642548488,Online,North,2023
2024-11-25,164635.9068371054,Online,North,2023
2024-12-02,165581.2055988658,Online,North,2023
2024-12-09,160896.8174458965,Online,North,2023
2024-12-16,186396.63527703512,Online,North,2023
2024-12-23,149281.94314627344,Online,North,2023
2024-12-30,89926.50462157089,Online,North,2023
2024-01-01,94549.54125409521,Online,South,2023
2024-01-08,74146.3078922694,Online,South,2023
2024-01-15,125497.10204860399,Online,South,2023
2024-01-22,135945.3503014014,Online,South,2023
2024-01-29,68503.19089777661,Online,South,2023
2024-02-05,107450.24092766733,Online,South,2023
2024-02-12,96421.47397120393,Online,South,2023
2024-02-19,103412.50719679802,Online,South,2023
2024-02-26,123792.86533422777,Online,South,2023
2024-03-04,64418.577656827605,Online,South,2023
2024-03-11,99156.70939069519,Online,South,2023
2024-03-18,114192.17314642615,Online,South,2023
2024-03-25,108803.53135998,Online,South,2023
2024-04-01,130183.59255786879,Online,South,2023
2024-04-08,144343.71738733357,Online,South,2023
2024-04-15,106502.04258049333,Online,South,2023
2024-04-22,122250.79117649319,Online,South,2023
2024-04-29,137145.93507172514,Online,South,2023
2024-05-06,152835.73390054423,Online,South,2023
2024-05-13,152909.10404521553,Online,South,2023
2024-05-20,118258.78473954354,Online,South,2023
2024-05-27,143877.77307357715,Online,South,2023
2024-06-03,135609.02528690503,Online,South,2023
2024-06-10,138611.74151580094,Online,South,2023
2024-06-17,148699.9098432596,Online,South,2023
2024-06-24,97674.0354008885,Online,South,2023
2024-07-01,123991.91621502313,Online,South,2023
2024-07-08,130604.92321816312,Online,South,2023
2024-07-15,120712.4360839032,Online,South,2023
2024-07-22,146609.71246423086,Online,South,2023
2024-07-29,162222.64225127033,Online,South,2023
2024-08-05,124744.66163531254,Online,South,2023
2024-08-12,105195.6227975083,Online,South,2023
2024-08-19,154030.75763407024,Online,South,2023
2024-08-26,141327.44004496658,Online,South,2023
2024-09-02,133354.7902036286,Online,South,2023
2024-09-09,165413.78518212997,Online,South,2023
2024-09-16,138267.14910052682,Online,South,2023
2024-09-23,132798.74252221716,Online,South,2023
2024-09-30,130475.41115958524,Online,South,2023
2024-10-07,155323.5659662243,Online,South,2023
2024-10-14,152717.68970393704,Online,South,2023
2024-10-21,138884.4515416036,Online,South,2023
2024-10-28,144965.72354713513,Online,South,2023
2024-11-04,105170.82585452433,Online,South,2023
2024-11-11,192890.16405322772,Online,South,2023
2024-11-18,173538.1926936989,Online,South,2023
2024-11-25,148138.59439096376,Online,South,2023
2024-12-02,135235.25004810636,Online,South,2023
2024-12-09,153473.19116214407,Online,South,2023
2024-12-16,160209.3261738836,Online,South,2023
2024-12-23,102126.48696557636,Online,South,2023
2024-12-30,111983.09503364732,Online,South,2023
2024-01-01,112511.08014735166,Retail,North,2023
2024-01-08,98044.6235609226,Retail,North,2023
2024-01-15,93242.39810132007,Retail,North,2023
2024-01-22,114674.95494100748,Retail,North,2023
2024-01-29,148472.73994698346,Retail,North,2023
2024-02-05,96323.17030640719,Retail,North,2023
2024-02-12,126954.02716313193,Retail,North,2023
2024-02-19,137211.17725261106,Retail,North,2023
2024-02-26,112862.74414627874,Retail,North,2023
2024-03-04,146873.2818517491,Retail,North,2023
2024-03-11,114346.31655383704,Retail,North,2023
2024-03-18,120071.90168215739,Retail,North,2023
2024-03-25,114148.61528233645,Retail,North,2023
2024-04-01,107853.83920125368,Retail,North,2023
2024-04-08,109193.34922260823,Retail,North,2023
2024-04-15,98197.189038137,Retail,North,2023
2024-04-22,120172.82166553091,Retail,North,2023
2024-04-29,119537.14672689697,Retail,North,2023
2024-05-06,156639.19843596555,Retail,North,2023
2024-05-13,81522.39522646504,Retail,North,2023
2024-05-20,117527.73934010415,Retail,North,2023
2024-05-27,126538.08483191353,Retail,North,2023
2024-06-03,95699.8367568753,Retail,North,2023
2024-06-10,117009.46833460961,Retail,North,2023
2024-06-17,141287.26423548177,Retail,North,2023
2024-06-24,128831.61653029145,Retail,North,2023
2024-07-01,93740.25240279747,Retail,North,2023
2024-07-08,108784.93933998853,Retail,North,2023
2024-07-15,123992.33555633,Retail,North,2023
2024-07-22,125592.38921501511,Retail,North,2023
2024-07-29,109441.12344771874,Retail,North,2023
2024-08-05,128291.17492668437,Retail,North,2023
2024-08-12,119292.23690702388,Retail,North,2023
2024-08-19,144184.3540678317,Retail,North,2023
2024-08-26,128390.2598594899,Retail,North,2023
2024-09-02,114224.8199258556,Retail,North,2023
2024-09-09,138489.5629290414,Retail,North,2023
2024-09-16,130585.11268042403,Retail,North,2023
2024-09-23,164082.42187480253,Retail,North,2023
2024-09-30,149819.10235728443,Retail,North,2023
2024-10-07,80237.51885889814,Retail,North,2023
2024-10-14,148188.07750784198,Retail,North,2023
2024-10-21,152806.70852149848,Retail,North,2023
2024-10-28,126053.26339379072,Retail,North,2023
2024-11-04,160078.26246374345,Retail,North,2023
2024-11-11,157807.6874495648,Retail,North,2023
2024-11-18,131828.13258922735,Retail,North,2023
2024-11-25,131119.0184713969,Retail,North,2023
2024-12-02,138711.50091391994,Retail,North,2023
2024-12-09,137448.21187755966,Retail,North,2023
2024-12-16,124348.2886183956,Retail,North,2023
2024-12-23,154799.9837886814,Retail,North,2023
2024-12-30,92585.1112437669,Retail,North,2023
2024-01-01,140377.07273391023,Retail,South,2023
2024-01-08,129007.81995131925,Retail,South,2023
2024-01-15,109304.39263122881,Retail,South,2023
2024-01-22,114571.08458273871,Retail,South,2023
2024-01-29,92656.0704353241,Retail,South,2023
2024-02-05,136114.08534386716,Retail,South,2023
2024-02-12,128829.4521744076,Retail,South,2023
2024-02-19,107178.27475869862,Retail,South,2023
2024-02-26,114950.92332189201,Retail,South,2023
2024-03-04,103443.0054765135,Retail,South,2023
2024-03-11,85751.1009147565,Retail,South,2023
2024-03-18,96385.89846181116,Retail,South,2023
2024-03-25,71329.47072618105,Retail,South,2023
2024-04-01,133269.0799734101,Retail,South,2023
2024-04-08,122163.05475308125,Retail,South,2023
2024-04-15,110907.9148255295,Retail,South,2023
2024-04-22,128008.43833129812,Retail,South,2023
2024-04-29,111357.25766679911,Retail,South,2023
2024-05-06,95612.5217476479,Retail,South,2023
2024-05-13,123399.7025937223,Retail,South,2023
2024-05-20,146216.88444244303,Retail,South,2023
2024-05-27,120775.04811066571,Retail,South,2023
2024-06-03,128742.34624589623,Retail,South,2023
2024-06-10,80832.74189611766,Retail,South,2023
2024-06-17,135527.66081319598,Retail,South,2023
2024-06-24,118594.75672923998,Retail,South,2023
2024-07-01,136376.4375739321,Retail,South,2023
2024-07-08,148854.2108504535,Retail,South,2023
2024-07-15,144715.1362252254,Retail,South,2023
2024-07-22,157478.89747930653,Retail,South,2023
2024-07-29,134650.85162461532,Retail,South,2023
2024-08-05,102035.61926572755,Retail,South,2023
2024-08-12,147738.69709077856,Retail,South,2023
2024-08-19,167679.7404739149,Retail,South,2023
2024-08-26,111714.60224966158,Retail,South,2023
2024-09-02,149799.2382956007,Retail,South,2023
2024-09-09,133931.20562999218,Retail,South,2023
2024-09-16,134578.84008634498,Retail,South,2023
2024-09-23,113510.35593588866,Retail,South,2023
2024-09-30,117376.496224345,Retail,South,2023
2024-10-07,111935.27118004176,Retail,South,2023
2024-10-14,126050.17599562724,Retail,South,2023
2024-10-21,161343.97292374697,Retail,South,2023
2024-10-28,147401.1464307062,Retail,South,2023
2024-11-04,127837.22783499488,Retail,South,2023
2024-11-11,148393.7343736846,Retail,South,2023
2024-11-18,135746.54488633625,Retail,South,2023
2024-11-25,146999.29659054583,Retail,South,2023
2024-12-02,157396.9836160508,Retail,South,2023
2024-12-09,167420.21163650946,Retail,South,2023
2024-12-16,148945.120424649,Retail,South,2023
2024-12-23,133552.64698742647,Retail,South,2023
2024-12-30,121869.2729342366,Retail,South,2023
2024-01-01,113198.63734220782,Wholesale,North,2023
2024-01-08,154891.26731899704,Wholesale,North,2023
2024-01-15,147767.576961742,Wholesale,North,2023
2024-01-22,84668.85628851414,Wholesale,North,2023
2024-01-29,77613.53361028865,Wholesale,North,2023
2024-02-05,105693.84378205669,Wholesale,North,2023
2024-02-12,111825.28725086736,Wholesale,North,2023
2024-02-19,117302.23250389368,Wholesale,North,2023
2024-02-26,88410.26550968873,Wholesale,North,2023
2024-03-04,107433.51849337928,Wholesale,North,2023
2024-03-11,113697.9678181299,Wholesale,North,2023
2024-03-18,120347.0739572916,Wholesale,North,2023
2024-03-25,122771.73183344756,Wholesale,North,2023
2024-04-01,113955.59535649673,Wholesale,North,2023
2024-04-08,119815.44094484707,Wholesale,North,2023
2024-04-15,110308.39832854927,Wholesale,North,2023
2024-04-22,95248.67600213342,Wholesale,North,2023
2024-04-29,121246.95811229707,Wholesale,North,2023
2024-05-06,98637.29688129289,Wholesale,North,2023
2024-05-13,115381.21243267324,Wholesale,North,2023
2024-05-20,132558.96930483333,Wholesale,North,2023
2024-05-27,123311.24442882744,Wholesale,North,2023
2024-06-03,98294.73003595177,Wholesale,North,2023
2024-06-10,163867.14991928684,Wholesale,North,2023
2024-06-17,107762.61796860283,Wholesale,North,2023
2024-06-24,112189.21612837749,Wholesale,North,2023
2024-07-01,109140.60123333041,Wholesale,North,2023
2024-07-08,134775.23503964447,Wholesale,North,2023
2024-07-15,107053.87575651576,Wholesale,North,2023
2024-07-22,129343.96610339945,Wholesale,North,2023
2024-07-29,166854.62863666652,Wholesale,North,2023
2024-08-05,137286.71905490954,Wholesale,North,2023
2024-08-12,164412.9372080629,Wholesale,North,2023
2024-08-19,145015.76820907148,Wholesale,North,2023
2024-08-26,128182.1204435261,Wholesale,North,2023
2024-09-02,159156.83126211166,Wholesale,North,2023
2024-09-09,116258.53062374785,Wholesale,North,2023
2024-09-16,160601.60473812057,Wholesale,North,2023
2024-09-23,136850.1478773501,Wholesale,North,2023
2024-09-30,134027.841946006,Wholesale,North,2023
2024-10-07,141425.78089373442,Wholesale,North,2023
2024-10-14,128211.50294631084,Wholesale,North,2023
2024-10-21,145762.07303097832,Wholesale,North,2023
2024-10-28,143385.33479400421,Wholesale,North,2023
2024-11-04,158672.06646289187,Wholesale,North,2023
2024-11-11,142522.02250609105,Wholesale,North,2023
2024-11-18,180237.90522536368,Wholesale,North,2023
2024-11-25,154169.743971252,Wholesale,North,2023
2024-12-02,183689.99922344374,Wholesale,North,2023
2024-12-09,157974.95984804645,Wholesale,North,2023
2024-12-16,152866.3144833817,Wholesale,North,2023
2024-12-23,170981.42830577624,Wholesale,North,2023
2024-12-30,101418.70413596429,Wholesale,North,2023
2024-01-01,129783.90554427207,Wholesale,South,2023
2024-01-08,104266.49715464104,Wholesale,South,2023
2024-01-15,131401.07859337854,Wholesale,South,2023
2024-01-22,113606.36296545019,Wholesale,South,2023
2024-01-29,105559.3079640477,Wholesale,South,2023
2024-02-05,73617.10229022987,Wholesale,South,2023
2024-02-12,173413.7827304748,Wholesale,South,2023
2024-02-19,80311.29800594371,Wholesale,South,2023
2024-02-26,105357.57075085983,Wholesale,South,2023
2024-03-04,71812.44348415623,Wholesale,South,2023
2024-03-11,113311.28900859097,Wholesale,South,2023
2024-03-18,128518.18926211918,Wholesale,South,2023
2024-03-25,128474.01226685295,Wholesale,South,2023
2024-04-01,98390.41490188584,Wholesale,South,2023
2024-04-08,122146.61396653045,Wholesale,South,2023
2024-04-15,87786.67170866553,Wholesale,South,2023
2024-04-22,147579.07168337225,Wholesale,South,2023
2024-04-29,99973.67908147394,Wholesale,South,2023
2024-05-06,71778.19392511665,Wholesale,South,2023
2024-05-13,169479.1517352276,Wholesale,South,2023
2024-05-20,101094.91066767648,Wholesale,South,2023
2024-05-27,102799.50511153652,Wholesale,South,2023
2024-06-03,165354.24736791037,Wholesale,South,2023
2024-06-10,126909.32373576816,Wholesale,South,2023
2024-06-17,142827.4317047276,Wholesale,South,2023
2024-06-24,110212.43830043766,Wholesale,South,2023
2024-07-01,149393.82655025672,Wholesale,South,2023
2024-07-08,146608.76305389986,Wholesale,South,2023
2024-07-15,111833.12580453834,Wholesale,South,2023
2024-07-22,107237.87497149139,Wholesale,South,2023
2024-07-29,102898.98075566722,Wholesale,South,2023
2024-08-05,166368.56561088073,Wholesale,South,2023
2024-08-12,128189.02587854456,Wholesale,South,2023
2024-08-19,121583.08181910946,Wholesale,South,2023
2024-08-26,127903.30756824111,Wholesale,South,2023
2024-09-02,119833.2021036312,Wholesale,South,2023
2024-09-09,144090.62113134225,Wholesale,South,2023
2024-09-16,145818.9608107632,Wholesale,South,2023
2024-09-23,137191.18564708604,Wholesale,South,2023
2024-09-30,139299.85954540106,Wholesale,South,2023
2024-10-07,120445.29405741765,Wholesale,South,2023
2024-10-14,116644.27816251287,Wholesale,South,2023
2024-10-21,142902.01447473723,Wholesale,South,2023
2024-10-28,136479.22155113088,Wholesale,South,2023
2024-11-04,153918.09041217572,Wholesale,South,2023
2024-11-11,148371.18563531362,Wholesale,South,2023
2024-11-18,157352.3837558676,Wholesale,South,2023
2024-11-25,146727.38142488967,Wholesale,South,2023
2024-12-02,141747.19317305443,Wholesale,South,2023
2024-12-09,162352.70266704287,Wholesale,South,2023
2024-12-16,169261.87954988494,Wholesale,South,2023
2024-12-23,140578.372093889,Wholesale,South,2023
2024-12-30,108476.82726840508,Wholesale,South,2023
2024-01-01,111181.39869116945,Online,North,2024
2024-01-08,94867.87050294611,Online,North,2024
2024-01-15,130207.80412791116,Online,North,2024
2024-01-22,113466.2354505905,Online,North,2024
2024-01-29,80967.98036849816,Online,North,2024
2024-02-05,110166.86437430832,Online,North,2024
2024-02-12,130435.41339884387,Online,North,2024
2024-02-19,118665.03215356702,Online,North,2024
2024-02-26,123078.70534353075,Online,North,2024
2024-03-04,121656.70843971755,Online,North,2024
2024-03-11,117566.30999331089,Online,North,2024
2024-03-18,115743.3667022923,Online,North,2024
2024-03-25,114508.40183625856,Online,North,2024
2024-04-01,132757.5011769376,Online,North,2024
2024-04-08,114614.35537467222,Online,North,2024
2024-04-15,125812.40875789587,Online,North,2024
2024-04-22,106736.61317337735,Online,North,2024
2024-04-29,126376.1952696661,Online,North,2024
2024-05-06,138576.7611289334,Online,North,2024
2024-05-13,130838.81484091208,Online,North,2024
2024-05-20,124800.53212111074,Online,North,2024
2024-05-27,152949.85058543546,Online,North,2024
2024-06-03,78216.35870796494,Online,North,2024
2024-06-10,110825.3097457467,Online,North,2024
2024-06-17,127854.83394275318,Online,North,2024
2024-06-24,96952.6379095298,Online,North,2024
2024-07-01,153347.47518078168,Online,North,2024
2024-07-08,151764.26029386825,Online,North,2024
2024-07-15,124346.8634251864,Online,North,2024
2024-07-22,145749.8056161555,Online,North,2024
2024-07-29,122960.81464830149,Online,North,2024
2024-08-05,184178.93854832905,Online,North,2024
2024-08-12,125633.7807799099,Online,North,2024
2024-08-19,145470.1283371945,Online,North,2024
2024-08-26,130197.59547086243,Online,North,2024
2024-09-02,165107.19324773725,Online,North,2024
2024-09-09,177647.89742386466,Online,North,2024
2024-09-16,160707.17586214736,Online,North,2024
2024-09-23,130673.9983431859,Online,North,2024
2024-09-30,148865.65726014093,Online,North,2024
2024-10-07,163709.63654715416,Online,North,2024
2024-10-14,76816.03179998079,Online,North,2024
2024-10-21,170586.20587340146,Online,North,2024
2024-10-28,105951.5022192745,Online,North,2024
2024-11-04,165868.19257707716,Online,North,2024
2024-11-11,96812.77531890295,Online,North,2024
2024-11-18,111176.98609781655,Online,North,2024
2024-11-25,146012.86393240793,Online,North,2024
2024-12-02,174524.01462100857,Online,North,2024
2024-12-09,154123.60664039315,Online,North,2024
2024-12-16,151919.8226852789,Online,North,2024
2024-12-23,170424.95578540652,Online,North,2024
2024-12-30,76835.00015972182,Online,North,2024
2024-01-01,82044.58298784052,Online,South,2024
2024-01-08,89172.00553894343,Online,South,2024
2024-01-15,68510.70901040421,Online,South,2024
2024-01-22,97083.71175572755,Online,South,2024
2024-01-29,128134.60090926473,Online,South,2024
2024-02-05,124491.13667752492,Online,South,2024
2024-02-12,93014.51897084365,Online,South,2024
2024-02-19,120324.74762809939,Online,South,2024
2024-02-26,122366.1464803875,Online,South,2024
2024-03-04,126984.87574002886,Online,South,2024
2024-03-11,127227.26352890552,Online,South,2024
2024-03-18,104294.00554144502,Online,South,2024
2024-03-25,102632.10717323136,Online,South,2024
2024-04-01,106650.38852170366,Online,South,2024
2024-04-08,132563.01528627443,Online,South,2024
2024-04-15,107438.48963586686,Online,South,2024
2024-04-22,132315.6577761378,Online,South,2024
2024-04-29,91617.68728145333,Online,South,2024
2024-05-06,126056.82592676916,Online,South,2024
2024-05-13,84931.57174372708,Online,South,2024
2024-05-20,148787.1105799746,Online,South,2024
2024-05-27,149230.56970104805,Online,South,2024
2024-06-03,112172.79208502593,Online,South,2024
2024-06-10,126457.5794499458,Online,South,2024
2024-06-17,115579.54355056898,Online,South,2024
2024-06-24,127707.38906259731,Online,South,2024
2024-07-01,135897.35751781726,Online,South,2024
2024-07-08,99608.6171356308,Online,South,2024
2024-07-15,126389.35816848284,Online,South,2024
2024-07-22,95340.77768897869,Online,South,2024
2024-07-29,143431.28354274994,Online,South,2024
2024-08-05,135599.90930227004,Online,South,2024
2024-08-12,127712.75718042317,Online,South,2024
2024-08-19,93363.96535587555,Online,South,2024
2024-08-26,153626.98492576578,Online,South,2024
2024-09-02,129745.53012972465,Online,South,2024
2024-09-09,101777.15216046854,Online,South,2024
2024-09-16,141446.5633473174,Online,South,2024
2024-09-23,135119.78941204294,Online,South,2024
2024-09-30,161722.41270637157,Online,South,2024
2024-10-07,135813.45263053942,Online,South,2024
2024-10-14,152351.32430033,Online,South,2024
2024-10-21,150395.2210101682,Online,South,2024
2024-10-28,140328.84457611776,Online,South,2024
2024-11-04,120006.1347019501,Online,South,2024
2024-11-11,152371.69209849872,Online,South,2024
2024-11-18,153254.48797992797,Online,South,2024
2024-11-25,171077.3173570919,Online,South,2024
2024-12-02,139002.78041143282,Online,South,2024
2024-12-09,149816.19902304516,Online,South,2024
2024-12-16,173083.22171945963,Online,South,2024
2024-12-23,170564.62757260128,Online,South,2024
2024-12-30,86957.17262779386,Online,South,2024
2024-01-01,153580.3531001734,Retail,North,2024
2024-01-08,72654.26827425853,Retail,North,2024
2024-01-15,86010.16317475389,Retail,North,2024
2024-01-22,117373.88670557107,Retail,North,2024
2024-01-29,89697.66023573073,Retail,North,2024
2024-02-05,77779.31869200953,Retail,North,2024
2024-02-12,81113.17404519019,Retail,North,2024
2024-02-19,135300.12538472514,Retail,North,2024
2024-02-26,123047.48979690793,Retail,North,2024
2024-03-04,119808.59764913666,Retail,North,2024
2024-03-11,105686.5648813072,Retail,North,2024
2024-03-18,116787.24389923173,Retail,North,2024
2024-03-25,116010.26395477477,Retail,North,2024
2024-04-01,108993.29422200029,Retail,North,2024
2024-04-08,105167.04603685118,Retail,North,2024
2024-04-15,118897.18109827903,Retail,North,2024
2024-04-22,115424.99804473156,Retail,North,2024
2024-04-29,124602.10084565228,Retail,North,2024
2024-05-06,165241.06728738386,Retail,North,2024
2024-05-13,147053.69519582248,Retail,North,2024
2024-05-20,161419.1401753748,Retail,North,2024
2024-05-27,139907.18072202278,Retail,North,2024
2024-06-03,121097.35504697372,Retail,North,2024
2024-06-10,123986.29129935698,Retail,North,2024
2024-06-17,134193.98369730744,Retail,North,2024
2024-06-24,129617.31245926784,Retail,North,2024
2024-07-01,114770.92645784268,Retail,North,2024
2024-07-08,125403.2892606239,Retail,North,2024
2024-07-15,144132.08357836236,Retail,North,2024
2024-07-22,105778.27434169812,Retail,North,2024
2024-07-29,168226.11132552777,Retail,North,2024
2024-08-05,131627.53807196603,Retail,North,2024
2024-08-12,126475.9945189924,Retail,North,2024
2024-08-19,141046.66846741276,Retail,North,2024
2024-08-26,132609.96563586826,Retail,North,2024
2024-09-02,131151.22691186046,Retail,North,2024
2024-09-09,175030.18329580998,Retail,North,2024
2024-09-16,184864.23044323106,Retail,North,2024
2024-09-23,186123.3912038604,Retail,North,2024
2024-09-30,184106.06711324636,Retail,North,2024
2024-10-07,128519.10591737769,Retail,North,2024
2024-10-14,146097.6878609666,Retail,North,2024
2024-10-21,151535.50568963855,Retail,North,2024
2024-10-28,153015.25116077202,Retail,North,2024
2024-11-04,151011.32401871,Retail,North,2024
2024-11-11,131328.41396639013,Retail,North,2024
2024-11-18,99551.24685622231,Retail,North,2024
2024-11-25,133911.24088725817,Retail,North,2024
2024-12-02,148270.49716409302,Retail,North,2024
2024-12-09,134528.51117930427,Retail,North,2024
2024-12-16,159686.74152697477,Retail,North,2024
2024-12-23,171713.51462178183,Retail,North,2024
2024-12-30,76661.0898255175,Retail,North,2024
2024-01-01,96050.73142403283,Retail,South,2024
2024-01-08,103339.33790983517,Retail,South,2024
2024-01-15,130406.81944881819,Retail,South,2024
2024-01-22,100548.84509412023,Retail,South,2024
2024-01-29,115318.88531875184,Retail,South,2024
2024-02-05,102374.76410343571,Retail,South,2024
2024-02-12,121675.76348902866,Retail,South,2024
2024-02-19,122417.33803956019,Retail,South,2024
2024-02-26,84141.4196890473,Retail,South,2024
2024-03-04,96725.73871551394,Retail,South,2024
2024-03-11,120975.63260579559,Retail,South,2024
2024-03-18,84066.82464630812,Retail,South,2024
2024-03-25,83812.14848282756,Retail,South,2024
2024-04-01,115690.3508947197,Retail,South,2024
2024-04-08,128635.90986610099,Retail,South,2024
2024-04-15,101998.4676687183,Retail,South,2024
2024-04-22,135558.75686189544,Retail,South,2024
2024-04-29,136114.64348048397,Retail,South,2024
2024-05-06,121075.27760453596,Retail,South,2024
2024-05-13,113549.48944564018,Retail,South,2024
2024-05-20,129232.02834861277,Retail,South,2024
2024-05-27,130710.06357309913,Retail,South,2024
2024-06-03,113315.98795725744,Retail,South,2024
2024-06-10,135561.89524562075,Retail,South,2024
2024-06-17,137840.7360181553,Retail,South,2024
2024-06-24,146070.83055826635,Retail,South,2024
2024-07-01,127631.63234390639,Retail,South,2024
2024-07-08,130892.24821803013,Retail,South,2024
2024-07-15,115762.72087471135,Retail,South,2024
2024-07-22,141752.23347326036,Retail,South,2024
2024-07-29,177431.26767261236,Retail,South,2024
2024-08-05,139689.04747609195,Retail,South,2024
2024-08-12,122184.04594454904,Retail,South,2024
2024-08-19,107929.30820070356,Retail,South,2024
2024-08-26,128552.10322722369,Retail,South,2024
2024-09-02,133579.26172657483,Retail,South,2024
2024-09-09,165638.99057167905,Retail,South,2024
2024-09-16,124848.43076840011,Retail,South,2024
2024-09-23,134356.07049796582,Retail,South,2024
2024-09-30,148801.13156112612,Retail,South,2024
2024-10-07,147423.20417193294,Retail,South,2024
2024-10-14,163770.57687475835,Retail,South,2024
2024-10-21,151885.592373726,Retail,South,2024
2024-10-28,172007.36950776423,Retail,South,2024
2024-11-04,129061.45214786218,Retail,South,2024
2024-11-11,120270.3117226888,Retail,South,2024
2024-11-18,164713.50199906362,Retail,South,2024
2024-11-25,142908.6324014099,Retail,South,2024
2024-12-02,161950.3503868161,Retail,South,2024
2024-12-09,130463.62709380119,Retail,South,2024
2024-12-16,125309.2306706276,Retail,South,2024
2024-12-23,177796.12530769844,Retail,South,2024
2024-12-30,109208.26356573,Retail,South,2024
2024-01-01,82055.04797328297,Wholesale,North,2024
2024-01-08,74756.52016395555,Wholesale,North,2024
2024-01-15,99615.93299758433,Wholesale,North,2024
2024-01-22,64898.444439286126,Wholesale,North,2024
2024-01-29,89437.96957533159,Wholesale,North,2024
2024-02-05,98564.84140154348,Wholesale,North,2024
2024-02-12,151505.31442801378,Wholesale,North,2024
2024-02-19,95995.53628762499,Wholesale,North,2024
2024-02-26,123371.18544999018,Wholesale,North,2024
2024-03-04,108223.52159304335,Wholesale,North,2024
2024-03-11,77002.40096285858,Wholesale,North,2024
2024-03-18,80762.0919035559,Wholesale,North,2024
2024-03-25,102174.52983477483,Wholesale,North,2024
2024-04-01,115652.2722812769,Wholesale,North,2024
2024-04-08,124134.34614645757,Wholesale,North,2024
2024-04-15,157852.48652365286,Wholesale,North,2024
2024-04-22,100425.76150848955,Wholesale,North,2024
2024-04-29,85356.99519592858,Wholesale,North,2024
2024-05-06,105450.74988678982,Wholesale,North,2024
2024-05-13,144448.86537536525,Wholesale,North,2024
2024-05-20,130015.16101393776,Wholesale,North,2024
2024-05-27,122976.90514305086,Wholesale,North,2024
2024-06-03,161246.25625156995,Wholesale,North,2024
2024-06-10,122959.55405463738,Wholesale,North,2024
2024-06-17,120779.84623761535,Wholesale,North,2024
2024-06-24,101465.7786613909,Wholesale,North,2024
2024-07-01,111922.75376648549,Wholesale,North,2024
2024-07-08,151474.34787963322,Wholesale,North,2024
2024-07-15,152513.3495747752,Wholesale,North,2024
2024-07-22,108396.65004969912,Wholesale,North,2024
2024-07-29,100320.51973887297,Wholesale,North,2024
2024-08-05,139324.37424982304,Wholesale,North,2024
2024-08-12,120084.24467243052,Wholesale,North,2024
2024-08-19,127642.4888611069,Wholesale,North,2024
2024-08-26,133835.1978906675,Wholesale,North,2024
2024-09-02,143071.05492172993,Wholesale,North,2024
2024-09-09,111162.7181739898,Wholesale,North,2024
2024-09-16,150046.60488573377,Wholesale,North,2024
2024-09-23,153228.13581035263,Wholesale,North,2024
2024-09-30,168163.88596271415,Wholesale,North,2024
2024-10-07,122846.07729664029,Wholesale,North,2024
2024-10-14,140260.01333660996,Wholesale,North,2024
2024-10-21,134890.05386552797,Wholesale,North,2024
2024-10-28,149255.73901771446,Wholesale,North,2024
2024-11-04,123184.53553525344,Wholesale,North,2024
2024-11-11,162283.3741947345,Wholesale,North,2024
2024-11-18,154567.12538380217,Wholesale,North,2024
2024-11-25,148789.2300821343,Wholesale,North,2024
2024-12-02,164488.93309050938,Wholesale,North,2024
2024-12-09,146696.50230574975,Wholesale,North,2024
2024-12-16,151376.88014884214,Wholesale,North,2024
2024-12-23,165342.47206540965,Wholesale,North,2024
2024-12-30,109566.7888511231,Wholesale,North,2024
2024-01-01,96973.54271867535,Wholesale,South,2024
2024-01-08,101279.92777481952,Wholesale,South,2024
2024-01-15,107818.95547134917,Wholesale,South,2024
2024-01-22,76025.40539554332,Wholesale,South,2024
2024-01-29,147334.17146017877,Wholesale,South,2024
2024-02-05,129654.86835878254,Wholesale,South,2024
2024-02-12,103579.43356593561,Wholesale,South,2024
2024-02-19,120782.0932903213,Wholesale,South,2024
2024-02-26,93634.15599495001,Wholesale,South,2024
2024-03-04,85131.13549986135,Wholesale,South,2024
2024-03-11,121607.13855304764,Wholesale,South,2024
2024-03-18,97850.59651836801,Wholesale,South,2024
2024-03-25,130825.51320700522,Wholesale,South,2024
2024-04-01,112011.71296760597,Wholesale,South,2024
2024-04-08,99384.17104520097,Wholesale,South,2024
2024-04-15,99553.24186276307,Wholesale,South,2024
2024-04-22,119119.93975091956,Wholesale,South,2024
2024-04-29,153858.40806946805,Wholesale,South,2024
2024-05-06,104448.64560187238,Wholesale,South,2024
2024-05-13,114555.15467345888,Wholesale,South,2024
2024-05-20,146144.57520164596,Wholesale,South,2024
2024-05-27,128888.42080410567,Wholesale,South,2024
2024-06-03,106421.71494986238,Wholesale,South,2024
2024-06-10,139210.25519750075,Wholesale,South,2024
2024-06-17,126343.3019854674,Wholesale,South,2024
2024-06-24,106615.96271042367,Wholesale,South,2024
2024-07-01,91441.10459947979,Wholesale,South,2024
2024-07-08,119213.14054470384,Wholesale,South,2024
2024-07-15,124422.5755811916,Wholesale,South,2024
2024-07-22,121431.64429909142,Wholesale,South,2024
2024-07-29,159004.4026200947,Wholesale,South,2024
2024-08-05,131410.3562304746,Wholesale,South,2024
2024-08-12,154279.98286435375,Wholesale,South,2024
2024-08-19,146344.33890247918,Wholesale,South,2024
2024-08-26,157790.1481542597,Wholesale,South,2024
2024-09-02,117356.43946569282,Wholesale,South,2024
2024-09-09,148888.1261645428,Wholesale,South,2024
2024-09-16,125895.6725561196,Wholesale,South,2024
2024-09-23,129770.00316587764,Wholesale,South,2024
2024-09-30,153169.2918761893,Wholesale,South,2024
2024-10-07,82466.90740107758,Wholesale,South,2024
2024-10-14,142409.77069876064,Wholesale,South,2024
2024-10-21,148129.6141944928,Wholesale,South,2024
2024-10-28,179980.652507582,Wholesale,South,2024
2024-11-04,157478.90733649768,Wholesale,South,2024
2024-11-11,154280.22535061184,Wholesale,South,2024
2024-11-18,138769.83487770954,Wholesale,South,2024
2024-11-25,142267.42856798507,Wholesale,South,2024
2024-12-02,143158.37119128148,Wholesale,South,2024
2024-12-09,160489.3966660369,Wholesale,South,2024
2024-12-16,148464.32278245126,Wholesale,South,2024
2024-12-23,147003.57416940725,Wholesale,South,2024
2024-12-30,99794.97323475363,Wholesale,South,2024

</script><script type="text/plain" id="sales_by_region" data-format="csv_embedded" data-src="">
Date,Sales,Region
2024-01-01,10071.563954462172,North
2024-01-02,11421.363406598672,North
2024-01-03,12651.426530447843,North
2024-01-04,11355.482505581076,North
2024-01-05,9755.54775738247,North
2024-01-06,11508.070279853431,North
2024-01-07,14000.85146934226,North
2024-01-08,10733.118367142462,North
2024-01-09,10238.894641412147,North
2024-01-10,7440.741257192988,North
2024-01-11,12207.589425581225,North
2024-01-12,12186.004922249265,North
2024-01-13,15322.192189589054,North
2024-01-14,8690.33326329126,North
2024-01-15,10536.854189478681,North
2024-01-16,10131.361492784452,North
2024-01-17,11235.482089094836,North
2024-01-18,9609.54154841823,North
2024-01-19,11598.83732444483,North
2024-01-20,10957.06294942348,North
2024-01-21,13405.326472686615,North
2024-01-22,13188.29721357826,North
2024-01-23,11471.73379086261,North
2024-01-24,12393.222406234161,North
2024-01-25,13005.779985917623,North
2024-01-26,11993.939698705328,North
2024-01-27,10320.134696632942,North
2024-01-28,13901.545906860993,North
2024-01-29,13911.032071748625,North
2024-01-30,12397.603345813406,North
2024-01-31,11004.56741374895,North
2024-02-01,8786.457356749965,North
2024-02-02,9577.883487122772,North
2024-02-03,7738.045260400123,North
2024-02-04,13199.631329407226,North
2024-02-05,11336.965007094657,North
2024-02-06,11407.172290543862,North
2024-02-07,14976.45812264634,North
2024-02-08,13084.461579040073,North
2024-02-09,11622.70467644363,North
2024-02-10,10857.625944246673,North
2024-02-11,10615.867102600623,North
2024-02-12,9258.900935044252,North
2024-02-13,14517.502932023777,North
2024-02-14,10577.493588764739,North
2024-02-15,10634.442594344302,North
2024-02-16,12123.998614841961,North
2024-02-17,13496.019773398217,North
2024-02-18,10828.250654926635,North
2024-02-19,13538.443974457887,North
2024-02-20,10154.085931885013,North
2024-02-21,12576.257496570432,North
2024-02-22,12970.701034079997,North
2024-02-23,9471.38121458612,North
2024-02-24,12583.117936886161,North
2024-02-25,13412.230154181414,North
2024-02-26,12063.139631981509,North
2024-02-27,15189.50173224273,North
2024-02-28,11497.429758499517,North
2024-02-29,11234.0649329953,North
2024-03-01,14232.340244023084,North
2024-03-02,11727.341849992174,North
2024-03-03,10364.937969531604,North
2024-03-04,10572.933376249059,North
2024-03-05,15189.570118439682,North
2024-03-06,15475.664685277847,North
2024-03-07,15013.416827380443,North
2024-03-08,14515.088300076797,North
2024-03-09,14352.594673909072,North
2024-03-10,12123.200890772168,North
2024-03-11,13596.013137640803,North
2024-03-12,12343.703344486883,North
2024-03-13,13485.169830427616,North
2024-03-14,14760.685559638363,North
2024-03-15,15173.14696017706,North
2024-03-16,12709.006621239248,North
2024-03-17,9957.570462600253,North
2024-03-18,9946.466485215953,North
2024-03-19,16372.69078176653,North
2024-03-20,19006.502345883866,North
2024-03-21,13701.030297580743,North
2024-03-22,13501.794841763942,North
2024-03-23,17469.030575108598,North
2024-03-24,16452.10931496951,North
2024-03-25,16267.533620413986,North
2024-03-26,16851.526927572075,North
2024-03-27,14533.447842526071,North
2024-03-28,16041.295082244618,North
2024-03-29,14714.0882720453,North
2024-03-30,12575.789664245054,North
2024-03-31,15216.262884275375,North
2024-04-01,16268.500362854069,North
2024-04-02,13381.887349688175,North
2024-04-03,15381.463507406794,North
2024-04-04,12850.088021918764,North
2024-04-05,16827.677773248248,North
2024-04-06,16384.69740817089,North
2024-04-07,14758.82725383621,North
2024-04-08,19028.658827409614,North
2024-04-09,16212.611731697796,North
2024-04-10,12254.355731699936,North
2024-04-11,14666.43844656738,North
2024-04-12,14433.33335915839,North
2024-04-13,17147.867047351567,North
2024-04-14,15690.255693497898,North
2024-04-15,17898.94450698072,North
2024-04-16,16728.503440157132,North
2024-04-17,15486.755025361243,North
2024-04-18,16126.723945127433,North
2024-04-19,15369.617247229644,North
2024-04-20,19746.024180815086,North
2024-04-21,12816.274771429438,North
2024-04-22,17241.048254803543,North
2024-04-23,16071.887731887235,North
2024-04-24,12546.794818179995,North
2024-04-25,14745.584881139077,North
2024-04-26,15529.374766920746,North
2024-04-27,12968.14520857923,North
2024-04-28,13658.77823336309,North
2024-04-29,15959.309936269072,North
2024-04-30,16517.8296982036,North
2024-05-01,17261.393224738138,North
2024-05-02,17354.77011055735,North
2024-05-03,17182.49740733527,North
2024-05-04,15747.011703972921,North
2024-05-05,15080.591647790954,North
2024-05-06,23366.052079322428,North
2024-05-07,19924.59813585347,North
2024-05-08,16729.3071306168,North
2024-05-09,16430.071787497556,North
2024-05-10,16261.144034511097,North
2024-05-11,14966.690659247804,North
2024-05-12,17933.75991659705,North
2024-05-13,20123.516741559084,North
2024-05-14,13406.03497069943,North
2024-05-15,16883.19345636355,North
2024-05-16,15369.075072721096,North
2024-05-17,18313.471424911037,North
2024-05-18,18450.241898492382,North
2024-05-19,16587.963053514628,North
2024-05-20,18760.887446545537,North
2024-05-21,19264.881113342053,North
2024-05-22,19752.097097626316,North
2024-05-23,19837.432213111366,North
2024-05-24,12128.098819551573,North
2024-05-25,14474.70633257832,North
2024-05-26,15203.505827489795,North
2024-05-27,17839.54911894067,North
2024-05-28,16132.297389620624,North
2024-05-29,19696.66523088874,North
2024-05-30,17268.144626385583,North
2024-05-31,17523.796122823864,North
2024-06-01,19287.64792713424,North
2024-06-02,14940.113683897154,North
2024-06-03,23438.868664955637,North
2024-06-04,19448.037055119097,North
2024-06-05,20001.823932193212,North
2024-06-06,17483.763498281834,North
2024-06-07,18295.619977693856,North
2024-06-08,15532.650696679491,North
2024-06-09,17895.848225240454,North
2024-06-10,20678.714737758914,North
2024-06-11,19525.624658282235,North
2024-06-12,16185.789339533894,North
2024-06-13,16185.509654308546,North
2024-06-14,17719.11277209941,North
2024-06-15,17478.766846226797,North
2024-06-16,15559.002350588837,North
2024-06-17,18304.808610184024,North
2024-06-18,18281.83751882072,North
2024-06-19,16897.59516995437,North
2024-06-20,21438.501243331142,North
2024-06-21,16926.770207581947,North
2024-06-22,18659.940893820025,North
2024-06-23,20210.782684580874,North
2024-06-24,17750.198851003453,North
2024-06-25,18905.571466231468,North
2024-06-26,19703.59754661686,North
2024-06-27,19078.11458556634,North
2024-06-28,19041.90554774789,North
2024-06-29,16815.19548940538,North
2024-06-30,21654.25953819954,North
2024-01-01,10594.914915207615,South
2024-01-02,11129.497716477536,South
2024-01-03,8592.268306257241,South
2024-01-04,9808.553273688005,South
2024-01-05,10948.054748673387,South
2024-01-06,13098.253888396388,South
2024-01-07,10224.837741363212,South
2024-01-08,11048.272176330067,South
2024-01-09,7082.454274376189,South
2024-01-10,8729.695004916024,South
2024-01-11,9652.473710418972,South
2024-01-12,9492.939569725377,South
2024-01-13,8206.288200241803,South
2024-01-14,10892.914444134347,South
2024-01-15,9572.920871930639,South
2024-01-16,14122.877502461071,South
2024-01-17,13209.501821079306,South
2024-01-18,12493.241528167058,South
2024-01-19,8718.365968043101,South
2024-01-20,11395.204590335456,South
2024-01-21,12179.652552009116,South
2024-01-22,11863.147060335426,South
2024-01-23,13827.572199805403,South
2024-01-24,10994.488155117167,South
2024-01-25,10133.031039186857,South
2024-01-26,10385.745203997578,South
2024-01-27,14145.669246415273,South
2024-01-28,10606.699915121124,South
2024-01-29,11840.660728370422,South
2024-01-30,14472.082298958183,South
2024-01-31,11123.291213909453,South
2024-02-01,12310.07861056227,South
2024-02-02,10233.573164329331,South
2024-02-03,12869.327049431467,South
2024-02-04,9298.667663401786,South
2024-02-05,11339.181679709962,South
2024-02-06,12370.825802802721,South
2024-02-07,14690.194110636558,South
2024-02-08,11204.947791123483,South
2024-02-09,13208.14542244509,South
2024-02-10,9354.327586120955,South
2024-02-11,11405.512107081513,South
2024-02-12,11134.775014979285,South
2024-02-13,11665.93460947516,South
2024-02-14,11315.911744770532,South
2024-02-15,8153.169930482228,South
2024-02-16,14344.16189667192,South
2024-02-17,15440.128674107471,South
2024-02-18,18460.092119704,South
2024-02-19,15338.239089751954,South
2024-02-20,14443.468688172354,South
2024-02-21,11093.29201494858,South
2024-02-22,12259.505688127381,South
2024-02-23,11838.65927797716,South
2024-02-24,7539.224261570042,South
2024-02-25,10364.198926406716,South
2024-02-26,14152.775946062771,South
2024-02-27,11679.293724538576,South
2024-02-28,13938.0202056345,South
2024-02-29,15527.340362966912,South
2024-03-01,15058.743704288017,South
2024-03-02,14047.99458852867,South
2024-03-03,10024.24340921582,South
2024-03-04,16093.991629569839,South
2024-03-05,13141.62594134073,South
2024-03-06,13719.59845897807,South
2024-03-07,15512.050899880778,South
2024-03-08,9052.834747392442,South
2024-03-09,12978.893315856014,South
2024-03-10,15198.73986632914,South
2024-03-11,13750.00753157114,South
2024-03-12,10343.166718083781,South
2024-03-13,12504.432505567755,South
2024-03-14,13386.55226530438,South
2024-03-15,12779.031334610201,South
2024-03-16,11972.777678870709,South
2024-03-17,10229.600680640982,South
2024-03-18,15328.784768372483,South
2024-03-19,13270.639803604628,South
2024-03-20,13508.350576790237,South
2024-03-21,17420.30771139986,South
2024-03-22,14512.666582794467,South
2024-03-23,14831.891287733053,South
2024-03-24,16121.430296801713,South
2024-03-25,13490.134141457576,South
2024-03-26,13364.552637158855,South
2024-03-27,13253.937812877864,South
2024-03-28,14879.227922808252,South
2024-03-29,17759.90295039156,South
2024-03-30,13493.139031486928,South
2024-03-31,15498.038086021517,South
2024-04-01,13874.278830902995,South
2024-04-02,13320.099738062758,South
2024-04-03,15961.203747594753,South
2024-04-04,15729.804646129827,South
2024-04-05,10785.605583077457,South
2024-04-06,13298.43346175785,South
2024-04-07,12575.360320466383,South
2024-04-08,12622.782933158198,South
2024-04-09,15641.345749846954,South
2024-04-10,19290.62001130271,South
2024-04-11,13863.770090697333,South
2024-04-12,14332.802323566262,South
2024-04-13,10573.228148100992,South
2024-04-14,18390.40673145505,South
2024-04-15,16503.228559052495,South
2024-04-16,18888.666921338434,South
2024-04-17,16594.715120829744,South
2024-04-18,16970.514892695086,South
2024-04-19,13601.872936458225,South
2024-04-20,20415.820292880726,South
2024-04-21,17827.61779759685,South
2024-04-22,13833.269660647622,South
2024-04-23,15068.567005193523,South
2024-04-24,17212.794137744484,South
2024-04-25,18847.78697609272,South
2024-04-26,15162.966477549544,South
2024-04-27,17537.662903473396,South
2024-04-28,14503.888753658563,South
2024-04-29,15736.199476708754,South
2024-04-30,15925.600343149052,South
2024-05-01,14028.290664141994,South
2024-05-02,17098.68714972156,South
2024-05-03,14138.162987868825,South
2024-05-04,14698.861346960384,South
2024-05-05,18022.96089881378,South
2024-05-06,17009.10359315908,South
2024-05-07,13880.352096108429,South
2024-05-08,15801.634317560285,South
2024-05-09,17509.672711724066,South
2024-05-10,14441.417875910794,South
2024-05-11,14443.086809068669,South
2024-05-12,13867.408784055808,South
2024-05-13,18991.324626000645,South
2024-05-14,13338.137846799418,South
2024-05-15,20234.67172434579,South
2024-05-16,18118.780514506096,South
2024-05-17,15593.322380756197,South
2024-05-18,17761.567382639547,South
2024-05-19,16532.525598725322,South
2024-05-20,16588.98609686947,South
2024-05-21,19424.42734703744,South
2024-05-22,14115.655159158909,South
2024-05-23,14762.32323301088,South
2024-05-24,17198.22772824642,South
2024-05-25,17938.234724738955,South
2024-05-26,19653.313765238352,South
2024-05-27,18450.69947229285,South
2024-05-28,20041.380180609307,South
2024-05-29,15575.412875877395,South
2024-05-30,20698.719218541042,South
2024-05-31,16482.52710860618,South
2024-06-01,17206.00176049188,South
2024-06-02,17400.209788429776,South
2024-06-03,18691.65866279209,South
2024-06-04,15350.472246117217,South
2024-06-05,16357.06549224306,South
2024-06-06,18698.5940125136,South
2024-06-07,16189.960933556275,South
2024-06-08,17112.60915034847,South
2024-06-09,15100.069789311161,South
2024-06-10,15432.062270562255,South
2024-06-11,16776.436811459724,South
2024-06-12,17649.592411521255,South
2024-06-13,18156.006612232966,South
2024-06-14,16630.060285378273,South
2024-06-15,16802.963369711317,South
2024-06-16,13481.700118272372,South
2024-06-17,21031.827169953838,South
2024-06-18,18959.737986822314,South
2024-06-19,19483.20125148834,South
2024-06-20,19608.89542344176,South
2024-06-21,22798.30659836899,South
2024-06-22,18026.99852809151,South
2024-06-23,16716.79040493329,South
2024-06-24,15207.735579020233,South
2024-06-25,18497.72690628245,South
2024-06-26,19755.82413627022,South
2024-06-27,16306.219588049891,South
2024-06-28,21855.76479201852,South
2024-06-29,17830.410037673653,South
2024-06-30,17571.357502613377,South
2024-01-01,11893.602311867864,East
2024-01-02,12861.941271759988,East
2024-01-03,7878.80848549188,East
2024-01-04,13726.344714849001,East
2024-01-05,7246.421985326193,East
2024-01-06,6617.152332572137,East
2024-01-07,12462.832390616539,East
2024-01-08,10876.806663830677,East
2024-01-09,10280.977623284442,East
2024-01-10,9926.77232974426,East
2024-01-11,11154.36751823473,East
2024-01-12,11655.615155498968,East
2024-01-13,12741.945691354756,East
2024-01-14,8867.579045348497,East
2024-01-15,13001.069085938827,East
2024-01-16,11089.31741367036,East
2024-01-17,8151.921011884951,East
2024-01-18,12528.812766964551,East
2024-01-19,9595.6716767498,East
2024-01-20,10687.25087781371,East
2024-01-21,11012.02278977231,East
2024-01-22,11661.341725773955,East
2024-01-23,11248.181439839127,East
2024-01-24,12001.214832158958,East
2024-01-25,13556.505984098098,East
2024-01-26,13302.956842024256,East
2024-01-27,10697.299049374655,East
2024-01-28,14965.547185739568,East
2024-01-29,12538.297801180874,East
2024-01-30,9570.120448207324,East
2024-01-31,11633.031776901074,East
2024-02-01,11560.140496797385,East
2024-02-02,9445.559719774204,East
2024-02-03,15427.60965078065,East
2024-02-04,8035.5912455714115,East
2024-02-05,12133.652157352062,East
2024-02-06,13185.273804461702,East
2024-02-07,9497.71138180167,East
2024-02-08,13398.80469234359,East
2024-02-09,11522.827555665363,East
2024-02-10,11602.114351149477,East
2024-02-11,11143.286955106805,East
2024-02-12,14848.34165850638,East
2024-02-13,14999.165978775165,East
2024-02-14,14004.995452018307,East
2024-02-15,11406.476602439798,East
2024-02-16,13734.995630623296,East
2024-02-17,14581.931873096535,East
2024-02-18,11152.925291479314,East
2024-02-19,10646.173283608998,East
2024-02-20,12922.168784923719,East
2024-02-21,12814.215745691736,East
2024-02-22,11060.648685703536,East
2024-02-23,12627.997783497989,East
2024-02-24,11199.819655492978,East
2024-02-25,14353.47831143347,East
2024-02-26,12507.164219908755,East
2024-02-27,12314.32156926812,East
2024-02-28,12959.635666129017,East
2024-02-29,14438.910662306384,East
2024-03-01,12666.016176857338,East
2024-03-02,11440.85388799292,East
2024-03-03,16059.98814042491,East
2024-03-04,11435.559590856425,East
2024-03-05,16028.508712077608,East
2024-03-06,12922.129619898118,East
2024-03-07,11905.00142957544,East
2024-03-08,11536.58719276615,East
2024-03-09,12103.965086984908,East
2024-03-10,13065.028348552027,East
2024-03-11,15045.003127402604,East
2024-03-12,17293.053052429565,East
2024-03-13,14500.627005975959,East
2024-03-14,13232.825501720723,East
2024-03-15,10886.472604375143,East
2024-03-16,15243.496045329532,East
2024-03-17,12492.619345146011,East
2024-03-18,15120.86912083654,East
2024-03-19,14886.23482369648,East
2024-03-20,12210.116619827872,East
2024-03-21,11851.97840214347,East
2024-03-22,12925.675296119516,East
2024-03-23,11831.824878666612,East
2024-03-24,10277.777054688224,East
2024-03-25,12579.785262441603,East
2024-03-26,13638.354134121124,East
2024-03-27,14209.12650624039,East
2024-03-28,16082.830606195752,East
2024-03-29,13035.35788381395,East
2024-03-30,10616.76838871084,East
2024-03-31,12146.102742548888,East
2024-04-01,14614.486603490304,East
2024-04-02,15280.561612075222,East
2024-04-03,12999.228815070439,East
2024-04-04,16568.297011424682,East
2024-04-05,15613.857715290902,East
2024-04-06,15504.91048823229,East
2024-04-07,19530.19862999818,East
2024-04-08,13758.950103698546,East
2024-04-09,17248.83651227282,East
2024-04-10,13620.046658311052,East
2024-04-11,14944.244251836142,East
2024-04-12,17132.787313156292,East
2024-04-13,13979.644449357142,East
2024-04-14,15880.9499795058,East
2024-04-15,15392.338021878593,East
2024-04-16,16551.995762720584,East
2024-04-17,14851.427175088083,East
2024-04-18,18389.260911204892,East
2024-04-19,15600.004996731406,East
2024-04-20,17100.49564235428,East
2024-04-21,14819.569639153893,East
2024-04-22,14982.254817916793,East
2024-04-23,14486.083517533147,East
2024-04-24,13469.542222056574,East
2024-04-25,15231.246327248064,East
2024-04-26,14714.589609817318,East
2024-04-27,17862.340533725728,East
2024-04-28,16948.64340732581,East
2024-04-29,15194.502184252118,East
2024-04-30,15145.17484551904,East
2024-05-01,16096.499445768619,East
2024-05-02,14583.357938037698,East
2024-05-03,15770.809393473119,East
2024-05-04,15826.321731671262,East
2024-05-05,19281.960466135257,East
2024-05-06,18629.166724284558,East
2024-05-07,16236.517176437545,East
2024-05-08,19951.689159200745,East
2024-05-09,13897.545835490157,East
2024-05-10,13758.673174663212,East
2024-05-11,17700.271968350564,East
2024-05-12,16120.531834079007,East
2024-05-13,15326.68250302698,East
2024-05-14,17272.633582244747,East
2024-05-15,16862.001316939793,East
2024-05-16,18317.83908119441,East
2024-05-17,17082.644651196963,East
2024-05-18,14898.274172940779,East
2024-05-19,14725.28645238155,East
2024-05-20,19685.482733592824,East
2024-05-21,14224.566218971588,East
2024-05-22,13963.367178781427,East
2024-05-23,17551.840169640956,East
2024-05-24,19192.32272482103,East
2024-05-25,17465.003010986904,East
2024-05-26,14262.664973173063,East
2024-05-27,22040.068662144866,East
2024-05-28,16091.208230244076,East
2024-05-29,20862.585990695236,East
2024-05-30,16134.546316901804,East
2024-05-31,18485.866734256,East
2024-06-01,12923.797507553569,East
2024-06-02,17570.91361842923,East
2024-06-03,16991.886072564754,East
2024-06-04,19412.912432600173,East
2024-06-05,15799.18311276345,East
2024-06-06,18332.221952915883,East
2024-06-07,16972.925633929866,East
2024-06-08,16589.23544761721,East
2024-06-09,15319.657792572993,East
2024-06-10,19916.251805473392,East
2024-06-11,16708.410685123992,East
2024-06-12,19101.273442778,East
2024-06-13,16371.615463706681,East
2024-06-14,14070.926917091081,East
2024-06-15,15758.075727152634,East
2024-06-16,16436.0899460602,East
2024-06-17,19252.05377953433,East
2024-06-18,20352.32001737433,East
2024-06-19,17447.513030324364,East
2024-06-20,18808.837852263197,East
2024-06-21,17942.260276842528,East
2024-06-22,20089.352460546474,East
2024-06-23,19096.37628186783,East
2024-06-24,21874.35643170973,East
2024-06-25,20766.32058180451,East
2024-06-26,16835.052575421912,East
2024-06-27,16697.44585369463,East
2024-06-28,16841.959693139306,East
2024-06-29,21395.2738278579,East
2024-06-30,17617.16877645169,East
2024-01-01,11089.554491750292,West
2024-01-02,6293.657838019153,West
2024-01-03,12738.850588684154,West
2024-01-04,9881.180584928761,West
2024-01-05,9764.672289937125,West
2024-01-06,8711.634484838727,West
2024-01-07,13497.982472279318,West
2024-01-08,8380.487442929243,West
2024-01-09,10834.387579453953,West
2024-01-10,11505.31125371015,West
2024-01-11,9526.385462685485,West
2024-01-12,10689.34347408688,West
2024-01-13,9698.439365758763,West
2024-01-14,9379.342001843714,West
2024-01-15,7156.517739539451,West
2024-01-16,8962.016416380613,West
2024-01-17,12206.127381853526,West
2024-01-18,10822.444270688273,West
2024-01-19,13898.486698113706,West
2024-01-20,9463.020170660431,West
2024-01-21,11271.774496423188,West
2024-01-22,12029.087805959323,West
2024-01-23,11262.294151108877,West
2024-01-24,15772.217276963449,West
2024-01-25,10068.887743226465,West
2024-01-26,10152.484368281112,West
2024-01-27,13296.458882634817,West
2024-01-28,10257.350770404573,West
2024-01-29,13912.696884745934,West
2024-01-30,12496.281987884475,West
2024-01-31,9532.720339379845,West
2024-02-01,15935.26276871308,West
2024-02-02,8337.163639420643,West
2024-02-03,14919.079959597491,West
2024-02-04,9086.496236851444,West
2024-02-05,11141.40363838027,West
2024-02-06,11441.686207847113,West
2024-02-07,14347.653450183654,West
2024-02-08,8402.63479856066,West
2024-02-09,12079.684159553175,West
2024-02-10,11958.556126963827,West
2024-02-11,14808.350689978262,West
2024-02-12,12810.316738640498,West
2024-02-13,7881.7704050884,West
2024-02-14,11779.408881375219,West
2024-02-15,6688.880782282018,West
2024-02-16,10431.020984993222,West
2024-02-17,10704.714140256143,West
2024-02-18,10983.459101843688,West
2024-02-19,14691.640420279173,West
2024-02-20,10679.66380278095,West
2024-02-21,14765.619697089838,West
2024-02-22,16659.328888954435,West
2024-02-23,12674.010216838311,West
2024-02-24,11061.426704650848,West
2024-02-25,8959.400911047871,West
2024-02-26,16399.672381710807,West
2024-02-27,13904.374619200284,West
2024-02-28,14386.9690429063,West
2024-02-29,9041.745248089475,West
2024-03-01,14931.032700518694,West
2024-03-02,12157.72055163492,West
2024-03-03,14280.034880194777,West
2024-03-04,16487.127290093944,West
2024-03-05,14467.550246767154,West
2024-03-06,14188.017276949098,West
2024-03-07,8974.793405867826,West
2024-03-08,11019.656251192644,West
2024-03-09,17034.315519606025,West
2024-03-10,10607.639609779588,West
2024-03-11,9331.470022261801,West
2024-03-12,14366.46261029514,West
2024-03-13,10894.75858852756,West
2024-03-14,14929.149753352458,West
2024-03-15,18344.021883304842,West
2024-03-16,12795.412399020652,West
2024-03-17,9068.299241878276,West
2024-03-18,15789.7688681139,West
2024-03-19,12404.549243023182,West
2024-03-20,16421.264966062117,West
2024-03-21,14158.765412213594,West
2024-03-22,14896.382594182634,West
2024-03-23,12893.89218994879,West
2024-03-24,11881.35148195702,West
2024-03-25,14893.616105061947,West
2024-03-26,13313.381854696547,West
2024-03-27,14998.69000878726,West
2024-03-28,12079.17528798311,West
2024-03-29,13353.453046197572,West
2024-03-30,9061.84556495936,West
2024-03-31,11234.467513402793,West
2024-04-01,15398.551108423282,West
2024-04-02,16453.1365405784,West
2024-04-03,15975.736497811653,West
2024-04-04,16605.00451673383,West
2024-04-05,14267.687117791798,West
2024-04-06,12005.427413547743,West
2024-04-07,14823.055464736623,West
2024-04-08,16836.03870408493,West
2024-04-09,16665.468825638454,West
2024-04-10,16049.496271028473,West
2024-04-11,10009.134026023074,West
2024-04-12,17946.14746093114,West
2024-04-13,17191.44876771852,West
2024-04-14,18168.575585664963,West
2024-04-15,12344.301421730617,West
2024-04-16,16936.141825242412,West
2024-04-17,17217.281780614474,West
2024-04-18,15415.360973621246,West
2024-04-19,15116.01376416628,West
2024-04-20,18310.030299192054,West
2024-04-21,14515.660756926023,West
2024-04-22,17064.692314694796,West
2024-04-23,15918.891439087745,West
2024-04-24,12616.52834685597,West
2024-04-25,13773.645296288028,West
2024-04-26,17423.83326337193,West
2024-04-27,9674.566210617799,West
2024-04-28,16109.939972976706,West
2024-04-29,14205.26431266627,West
2024-04-30,18164.14033549458,West
2024-05-01,15850.316811727307,West
2024-05-02,19096.896490221126,West
2024-05-03,15662.854836569883,West
2024-05-04,18535.042764346195,West
2024-05-05,12891.165556560227,West
2024-05-06,12843.487234811622,West
2024-05-07,20134.28259525779,West
2024-05-08,17258.86451733233,West
2024-05-09,17014.808843154307,West
2024-05-10,16308.581054651335,West
2024-05-11,16895.410352070798,West
2024-05-12,17576.205099869185,West
2024-05-13,12234.323303871928,West
2024-05-14,17877.061019856876,West
2024-05-15,16725.781107412047,West
2024-05-16,19979.20481374712,West
2024-05-17,16242.510623712715,West
2024-05-18,16109.652534438834,West
2024-05-19,20376.000500543807,West
2024-05-20,14491.461030155577,West
2024-05-21,21366.415205256046,West
2024-05-22,15715.875813465394,West
2024-05-23,22465.398508525173,West
2024-05-24,17705.341101154318,West
2024-05-25,12514.594467268587,West
2024-05-26,13585.591451929558,West
2024-05-27,18770.816760987836,West
2024-05-28,16372.407990716008,West
2024-05-29,15643.712207650098,West
2024-05-30,19129.241927283278,West
2024-05-31,17777.228291329746,West
2024-06-01,17927.139504850056,West
2024-06-02,18784.226217974738,West
2024-06-03,18535.671749786678,West
2024-06-04,20811.1594581382,West
2024-06-05,20144.038313935373,West
2024-06-06,19919.294639641048,West
2024-06-07,14819.328810887704,West
2024-06-08,16825.96341972766,West
2024-06-09,18947.41294318505,West
2024-06-10,17991.568539146356,West
2024-06-11,16283.93170187387,West
2024-06-12,19287.32948135529,West
2024-06-13,21401.8388907697,West
2024-06-14,18755.153547944945,West
2024-06-15,18522.68796754859,West
2024-06-16,16419.513642928043,West
2024-06-17,21178.471255373915,West
2024-06-18,16176.12524008794,West
2024-06-19,13375.585132108625,West
2024-06-20,16934.499531757043,West
2024-06-21,17700.580549961916,West
2024-06-22,18093.594844324343,West
2024-06-23,18236.26693960681,West
2024-06-24,20470.849697466605,West
2024-06-25,17982.98470379983,West
2024-06-26,18400.16418999319,West
2024-06-27,18409.634490607354,West
2024-06-28,17295.706507087754,West
2024-06-29,16697.639561270447,West
2024-06-30,19692.856301682652,West

</script><script type="text/plain" id="metrics_data" data-format="csv_embedded" data-src="">
Week,Value,Metric,Source
1,100.62763221124223,Metric A,Source 1
2,103.67493972633198,Metric A,Source 1
3,91.08962687357887,Metric A,Source 1
4,126.71147894556296,Metric A,Source 1
5,107.96134945197888,Metric A,Source 1
6,107.14353715005585,Metric A,Source 1
7,120.36080285524956,Metric A,Source 1
8,109.53306671673094,Metric A,Source 1
9,123.45307454262414,Metric A,Source 1
10,80.04264592258723,Metric A,Source 1
11,124.361378291713,Metric A,Source 1
12,156.3734124535329,Metric A,Source 1
1,90.42520042442281,Metric A,Source 2
2,128.9214175195002,Metric A,Source 2
3,111.7095125065589,Metric A,Source 2
4,133.87555233049417,Metric A,Source 2
5,151.794786555183,Metric A,Source 2
6,102.25525988182443,Metric A,Source 2
7,109.14620637457325,Metric A,Source 2
8,124.73864467610528,Metric A,Source 2
9,130.40847616084113,Metric A,Source 2
10,110.42894975790337,Metric A,Source 2
11,157.32943116588044,Metric A,Source 2
12,145.30737922996286,Metric A,Source 2
1,100.35616959151506,Metric A,Source 3
2,84.73776461983559,Metric A,Source 3
3,110.4039259186555,Metric A,Source 3
4,101.8735591950983,Metric A,Source 3
5,143.05951309028399,Metric A,Source 3
6,109.2523238766328,Metric A,Source 3
7,116.46294467116608,Metric A,Source 3
8,124.32932755543409,Metric A,Source 3
9,128.7351218107152,Metric A,Source 3
10,113.21911717224178,Metric A,Source 3
11,135.89129795974463,Metric A,Source 3
12,180.87587470488882,Metric A,Source 3
1,92.10964849781647,Metric B,Source 1
2,90.50719132519825,Metric B,Source 1
3,83.37624684849952,Metric B,Source 1
4,110.3434057632589,Metric B,Source 1
5,120.62292523831226,Metric B,Source 1
6,142.31724604691345,Metric B,Source 1
7,92.57198900562172,Metric B,Source 1
8,66.57513571191308,Metric B,Source 1
9,102.94137508793135,Metric B,Source 1
10,130.04603670124897,Metric B,Source 1
11,153.058391642248,Metric B,Source 1
12,119.26551488658197,Metric B,Source 1
1,121.19350827607119,Metric B,Source 2
2,78.82824185405147,Metric B,Source 2
3,129.32555853619613,Metric B,Source 2
4,141.9459468632083,Metric B,Source 2
5,97.95092338701738,Metric B,Source 2
6,101.72066806203689,Metric B,Source 2
7,110.46041509195692,Metric B,Source 2
8,97.64572592320306,Metric B,Source 2
9,153.0750259948613,Metric B,Source 2
10,150.08399253894197,Metric B,Source 2
11,143.56976129876472,Metric B,Source 2
12,153.9458998488901,Metric B,Source 2
1,80.58742536680792,Metric B,Source 3
2,156.08242901385415,Metric B,Source 3
3,112.75825767849308,Metric B,Source 3
4,114.60197153090941,Metric B,Source 3
5,135.81153628997524,Metric B,Source 3
6,125.62529316920376,Metric B,Source 3
7,123.35042215955359,Metric B,Source 3
8,165.774237166005,Metric B,Source 3
9,143.23562715459116,Metric B,Source 3
10,123.39936105481681,Metric B,Source 3
11,124.17799758404294,Metric B,Source 3
12,128.7468512168284,Metric B,Source 3
1,109.83067701732041,Metric C,Source 1
2,98.67772412063987,Metric C,Source 1
3,90.07093315756994,Metric C,Source 1
4,137.93369936243093,Metric C,Source 1
5,132.06562328178993,Metric C,Source 1
6,94.92106350366859,Metric C,Source 1
7,146.17845701956145,Metric C,Source 1
8,117.3296786539486,Metric C,Source 1
9,149.47443946310057,Metric C,Source 1
10,149.70948570926686,Metric C,Source 1
11,159.04915197229678,Metric C,Source 1
12,87.97357767761655,Metric C,Source 1
1,112.74138810523685,Metric C,Source 2
2,129.29144110900202,Metric C,Source 2
3,122.11259659127154,Metric C,Source 2
4,99.84357141153694,Metric C,Source 2
5,118.22615579533655,Metric C,Source 2
6,126.0963027799092,Metric C,Source 2
7,153.57435033400256,Metric C,Source 2
8,113.09651309112898,Metric C,Source 2
9,105.28152580047416,Metric C,Source 2
10,143.53883677567467,Metric C,Source 2
11,136.07138324243732,Metric C,Source 2
12,142.5352743601015,Metric C,Source 2
1,99.98714578845929,Metric C,Source 3
2,112.24309924651826,Metric C,Source 3
3,182.5378534783172,Metric C,Source 3
4,96.4364733078424,Metric C,Source 3
5,81.25505180791359,Metric C,Source 3
6,133.4674885645606,Metric C,Source 3
7,102.39733807685882,Metric C,Source 3
8,87.67948325643965,Metric C,Source 3
9,123.21105600456313,Metric C,Source 3
10,94.9701365027553,Metric C,Source 3
11,154.11907268834682,Metric C,Source 3
12,141.3674370742462,Metric C,Source 3
1,60.9264001992479,Metric D,Source 1
2,107.82866291435434,Metric D,Source 1
3,87.2422484444334,Metric D,Source 1
4,108.39765478908976,Metric D,Source 1
5,78.07861585127866,Metric D,Source 1
6,87.52967703004614,Metric D,Source 1
7,113.22372381112693,Metric D,Source 1
8,133.76691553924036,Metric D,Source 1
9,125.17726734368617,Metric D,Source 1
10,128.9220629870005,Metric D,Source 1
11,120.34968209284725,Metric D,Source 1
12,111.11406131875614,Metric D,Source 1
1,101.44604713912274,Metric D,Source 2
2,119.7122554958862,Metric D,Source 2
3,102.04284421021808,Metric D,Source 2
4,93.95417414228955,Metric D,Source 2
5,120.12819315212197,Metric D,Source 2
6,117.2914083165882,Metric D,Source 2
7,120.34989193765736,Metric D,Source 2
8,131.9807453385538,Metric D,Source 2
9,128.5822092197667,Metric D,Source 2
10,147.03300282059445,Metric D,Source 2
11,110.44852478216939,Metric D,Source 2
12,121.29668403475145,Metric D,Source 2
1,110.35195963198306,Metric D,Source 3
2,110.91778987651816,Metric D,Source 3
3,137.86765212183246,Metric D,Source 3
4,106.18363863478118,Metric D,Source 3
5,133.02964900052172,Metric D,Source 3
6,114.60525871928188,Metric D,Source 3
7,87.86048490886536,Metric D,Source 3
8,110.209280780211,Metric D,Source 3
9,143.80370057833105,Metric D,Source 3
10,108.81774083180312,Metric D,Source 3
11,129.02517515926303,Metric D,Source 3
12,152.83278671042342,Metric D,Source 3

</script><script type="text/plain" id="compare_data" data-format="csv_embedded" data-src="">
Time,Value,Category
1,7.934089905204437,Cat 1
2,10.141767731193747,Cat 1
3,13.942278706047402,Cat 1
4,13.57221269712559,Cat 1
5,14.267749488760037,Cat 1
6,14.576411836031838,Cat 1
7,11.69372116272628,Cat 1
8,12.295512508713907,Cat 1
9,15.410308235732035,Cat 1
10,14.417447550874895,Cat 1
11,13.947425402608925,Cat 1
12,16.927042710363587,Cat 1
13,16.459828116726392,Cat 1
14,20.799085537834138,Cat 1
15,12.950479389329264,Cat 1
16,18.85915478036323,Cat 1
17,18.2378960195774,Cat 1
18,20.386636124030527,Cat 1
19,20.967080399780983,Cat 1
20,15.021390753085862,Cat 1
1,12.339773583839197,Cat 2
2,12.02440490300445,Cat 2
3,13.189095510157982,Cat 2
4,11.363067122926035,Cat 2
5,8.096431142977838,Cat 2
6,15.931685740361864,Cat 2
7,13.198828745620345,Cat 2
8,12.948839912015842,Cat 2
9,17.405717034341507,Cat 2
10,12.154238419159144,Cat 2
11,15.680551037714213,Cat 2
12,17.42871046457639,Cat 2
13,17.280606093072166,Cat 2
14,13.425256842003929,Cat 2
15,14.364342880394176,Cat 2
16,15.898403465271773,Cat 2
17,20.459148016779725,Cat 2
18,21.022889654176847,Cat 2
19,21.935299811663604,Cat 2
20,26.530563621150094,Cat 2
1,7.21410097111773,Cat 3
2,9.884628934438389,Cat 3
3,7.205485320131744,Cat 3
4,7.967814488886212,Cat 3
5,18.84602835309171,Cat 3
6,15.100350239473409,Cat 3
7,5.994227148133186,Cat 3
8,17.247725694485112,Cat 3
9,13.15034685285767,Cat 3
10,14.735516240420958,Cat 3
11,14.50283561100006,Cat 3
12,13.065690208286101,Cat 3
13,16.291568640304398,Cat 3
14,12.645989774435037,Cat 3
15,19.694917501477637,Cat 3
16,22.400237624393995,Cat 3
17,22.90441093790094,Cat 3
18,19.782528527764324,Cat 3
19,19.68431814985805,Cat 3
20,25.73341114286022,Cat 3

</script><script type="text/plain" id="product_values" data-format="csv_embedded" data-src="">
Time,Value,Product
0.0,62.55052931327036,Product A
0.5,69.06379229118593,Product A
1.0,61.73930135991943,Product A
1.5,69.14379441717485,Product A
2.0,73.10759269218265,Product A
2.5,71.43355837583401,Product A
3.0,71.52595940082807,Product A
3.5,73.28965964744228,Product A
4.0,74.90123558255593,Product A
4.5,68.84431966401463,Product A
5.0,59.92729415825747,Product A
5.5,70.14752191831971,Product A
6.0,69.04950660775252,Product A
6.5,73.7777680226415,Product A
7.0,72.84810476214015,Product A
7.5,61.17174819720693,Product A
8.0,70.56087573283986,Product A
8.5,70.57050356386176,Product A
9.0,72.21937473098744,Product A
9.5,77.69981365023875,Product A
10.0,72.56415083918482,Product A
10.5,73.28923617146997,Product A
11.0,69.8028659985627,Product A
11.5,74.21095678406064,Product A
12.0,73.15607225069076,Product A
12.5,72.32916974394507,Product A
13.0,61.94181481593233,Product A
13.5,65.84181084572721,Product A
14.0,62.38760201290534,Product A
14.5,63.818689692539564,Product A
15.0,68.72684498917984,Product A
15.5,60.397503167286466,Product A
16.0,66.24327060561143,Product A
16.5,45.71644468743205,Product A
17.0,67.10285502534364,Product A
17.5,65.35637368540858,Product A
18.0,53.55844971354765,Product A
18.5,57.55097029972909,Product A
19.0,64.97598136092967,Product A
19.5,53.226974340543485,Product A
20.0,54.836286064107576,Product A
0.0,54.205454618775754,Product B
0.5,53.15031941704279,Product B
1.0,44.03641445925639,Product B
1.5,66.36059776451788,Product B
2.0,50.53889764162329,Product B
2.5,54.337614009061,Product B
3.0,56.56882115077364,Product B
3.5,57.152118212170016,Product B
4.0,69.07174656236496,Product B
4.5,69.3216912402651,Product B
5.0,74.33584026640179,Product B
5.5,61.0092753309874,Product B
6.0,78.40369638615348,Product B
6.5,67.31961208054035,Product B
7.0,71.39149996820011,Product B
7.5,69.38764226512896,Product B
8.0,70.59689613973075,Product B
8.5,64.72373947072836,Product B
9.0,72.05468117405924,Product B
9.5,64.72721249491602,Product B
10.0,70.85550604252877,Product B
10.5,71.71053138584139,Product B
11.0,66.11911851732918,Product B
11.5,68.710453294297,Product B
12.0,62.42524856766281,Product B
12.5,35.88685876018703,Product B
13.0,40.043371816092474,Product B
13.5,40.88622845358117,Product B
14.0,42.2158427015705,Product B
14.5,41.763948802622444,Product B
15.0,41.85625974002638,Product B
15.5,45.90811576337845,Product B
16.0,33.51072980634262,Product B
16.5,31.506534789207844,Product B
17.0,41.60118525698405,Product B
17.5,34.790986995943456,Product B
18.0,38.73927450309498,Product B
18.5,33.806697222799926,Product B
19.0,42.67165419164006,Product B
19.5,37.012469098006974,Product B
20.0,46.74726303732144,Product B
0.0,30.086371841557757,Product C
0.5,33.52163447532588,Product C
1.0,33.418362935222575,Product C
1.5,35.90821851991103,Product C
2.0,36.30682749505989,Product C
2.5,27.95142538541033,Product C
3.0,34.296613425464784,Product C
3.5,33.68809705623389,Product C
4.0,32.97993602983415,Product C
4.5,55.77142866572188,Product C
5.0,55.12985576613776,Product C
5.5,68.05070430559256,Product C
6.0,67.11166448939053,Product C
6.5,70.2579008862711,Product C
7.0,61.666606307468605,Product C
7.5,63.1624857266713,Product C
8.0,70.60638957502944,Product C
8.5,70.9507290507576,Product C
9.0,61.54388730097955,Product C
9.5,67.35636237504171,Product C
10.0,71.30560714196402,Product C
10.5,64.8964166712621,Product C
11.0,62.12860044668729,Product C
11.5,63.337431738182715,Product C
12.0,73.62858582448878,Product C
12.5,67.55797476155429,Product C
13.0,66.97576865943134,Product C
13.5,61.76029386315613,Product C
14.0,65.73714041646379,Product C
14.5,71.8030573434442,Product C
15.0,58.20812295332509,Product C
15.5,66.63849553555629,Product C
16.0,60.02429874238927,Product C
16.5,71.12727498277467,Product C
17.0,66.92131684616265,Product C
17.5,67.3062938998331,Product C
18.0,64.30510766488719,Product C
18.5,57.46251699980379,Product C
19.0,53.88124441082948,Product C
19.5,60.679333416071536,Product C
20.0,56.41554881364987,Product C

</script><script type="text/plain" id="grid_sales" data-format="csv_embedded" data-src="">
Month,Sales,Product,Region,Segment
1,60760.86726745479,Product X,East,Segment 1
2,43253.505181539906,Product X,East,Segment 1
3,56995.16380727708,Product X,East,Segment 1
4,39539.69910094289,Product X,East,Segment 1
5,78324.02777181414,Product X,East,Segment 1
6,46119.51101703559,Product X,East,Segment 1
1,65364.00102362198,Product X,East,Segment 2
2,59386.1971642421,Product X,East,Segment 2
3,70391.59031347815,Product X,East,Segment 2
4,67612.49926700015,Product X,East,Segment 2
5,62615.376754484016,Product X,East,Segment 2
6,62737.79477296752,Product X,East,Segment 2
1,36819.85588523162,Product X,West,Segment 1
2,51285.02387492835,Product X,West,Segment 1
3,56131.09812479866,Product X,West,Segment 1
4,66232.88440680242,Product X,West,Segment 1
5,59479.00043313866,Product X,West,Segment 1
6,72917.91920772869,Product X,West,Segment 1
1,36046.976772548085,Product X,West,Segment 2
2,43541.33537345861,Product X,West,Segment 2
3,58580.89655533582,Product X,West,Segment 2
4,51468.400820755,Product X,West,Segment 2
5,59289.52567556935,Product X,West,Segment 2
6,69208.3536964361,Product X,West,Segment 2
1,71869.84571508516,Product Y,East,Segment 1
2,46388.52635340507,Product Y,East,Segment 1
3,58444.88326698679,Product Y,East,Segment 1
4,51956.284591547796,Product Y,East,Segment 1
5,68141.57213315114,Product Y,East,Segment 1
6,61919.36251149604,Product Y,East,Segment 1
1,55748.995842683675,Product Y,East,Segment 2
2,35321.01550580826,Product Y,East,Segment 2
3,64414.1553385911,Product Y,East,Segment 2
4,62587.74167968533,Product Y,East,Segment 2
5,77896.23585152616,Product Y,East,Segment 2
6,78670.96274043791,Product Y,East,Segment 2
1,51956.11127592655,Product Y,West,Segment 1
2,48152.29292833831,Product Y,West,Segment 1
3,55829.53715383615,Product Y,West,Segment 1
4,56771.43307594346,Product Y,West,Segment 1
5,54893.50240074937,Product Y,West,Segment 1
6,65275.71286574617,Product Y,West,Segment 1
1,46256.404462341656,Product Y,West,Segment 2
2,69788.40337960642,Product Y,West,Segment 2
3,53488.70015146034,Product Y,West,Segment 2
4,42879.64410189974,Product Y,West,Segment 2
5,52271.709132160606,Product Y,West,Segment 2
6,63225.14276802736,Product Y,West,Segment 2

</script><script type="text/plain" id="headcount_data" data-format="csv_embedded" data-src="">
Department,Headcount,Team
Engineering,18,Team A
Engineering,10,Team B
Engineering,5,Team C
Sales,19,Team A
Sales,17,Team B
Sales,20,Team C
Marketing,25,Team A
Marketing,12,Team B
Marketing,13,Team C
Operations,22,Team A
Operations,6,Team B
Operations,23,Team C
HR,16,Team A
HR,15,Team B
HR,12,Team C

</script><script type="text/plain" id="market_share" data-format="csv_embedded" data-src="">
Month,MarketShare,Category
1,39.02064270720871,Category A
2,9.248901645855234,Category A
3,12.246826539476935,Category A
4,22.221354721980745,Category A
5,32.384576662156846,Category A
6,20.225005375864143,Category A
7,9.393863202702216,Category A
8,19.894765207997533,Category A
9,17.351447003849838,Category A
10,22.1700341707795,Category A
11,21.528631978788532,Category A
12,17.969429972726093,Category A
1,21.99796766713936,Category B
2,25.91626024880205,Category B
3,24.697360801916293,Category B
4,23.834454377986255,Category B
5,19.15530360971624,Category B
6,12.550437978157682,Category B
7,25.077893009555886,Category B
8,22.88495863085199,Category B
9,26.03955293109264,Category B
10,17.869961663832207,Category B
11,20.136478018274044,Category B
12,17.428761366594387,Category B
1,22.858601132023896,Category C
2,12.61446721268236,Category C
3,20.939999954289394,Category C
4,28.08081537833038,Category C
5,24.99084696474636,Category C
6,20.117667657216842,Category C
7,17.17398931857713,Category C
8,20.763594908312,Category C
9,15.718303070997486,Category C
10,11.815183236177424,Category C
11,21.402817995926437,Category C
12,27.30310521647552,Category C
1,28.715326074519453,Category D
2,15.585518740946867,Category D
3,26.709430027159534,Category D
4,13.039412885382134,Category D
5,24.783183394286944,Category D
6,20.794707281184373,Category D
7,23.556691795745664,Category D
8,26.935978180495354,Category D
9,23.6724429288465,Category D
10,21.789528800563325,Category D
11,26.753220455318047,Category D
12,20.508544409174068,Category D

</script><script type="text/plain" id="business_metrics" data-format="csv_embedded" data-src="">
Quarter,Revenue,Profit,Growth,Industry,CompanySize
1,96.11297340570722,24.028424228053776,2.647200841997309,Tech,Small
2,116.13274444925052,17.583807898138907,2.122127783219751,Tech,Small
3,111.64083278329736,25.864740228141336,0.47912294241217435,Tech,Small
4,85.19027568840622,23.437889744555854,6.015038861396722,Tech,Small
1,117.57780054827782,22.802755042742213,8.820454649203391,Tech,Medium
2,126.95384479330545,18.564780339365576,3.189875746352387,Tech,Medium
3,63.09250860062127,31.85523725839545,9.95526882073147,Tech,Medium
4,76.96260057165777,17.82933725901385,3.419069411901583,Tech,Medium
1,116.09604165401353,18.457996648699805,2.4283484316630477,Tech,Large
2,73.23164661702516,22.35805308611482,5.67302307702384,Tech,Large
3,107.40487762991198,23.61576312391867,8.114219066974542,Tech,Large
4,115.42554886556368,16.49752703813218,7.0813937269182885,Tech,Large
1,112.1285354234116,13.701193375107454,8.906300546649197,Finance,Small
2,94.60297024782831,21.51259877271616,0.4354986477848177,Finance,Small
3,110.10214946287172,21.184445931220218,4.96293124164624,Finance,Small
4,104.53538331565466,17.45601436258706,0.012284491104631812,Finance,Small
1,116.0655769549202,14.33943101055916,5.615136784211084,Finance,Medium
2,115.14292994185928,19.76761770451545,1.7060790828287749,Finance,Medium
3,109.173946879095,17.58129383270881,6.5594840284263425,Finance,Medium
4,101.22742922587115,18.401336654669706,5.080293357281874,Finance,Medium
1,80.7459284295812,14.764624106567569,10.537015557566582,Finance,Large
2,111.15807194803334,23.42659465025648,5.927361343261945,Finance,Large
3,75.3007738829186,20.14616259513904,6.105153917879229,Finance,Large
4,129.0134864671695,18.812044172497952,1.4699756153915757,Finance,Large
1,89.27047933355365,26.888407681090758,3.430516435221289,Healthcare,Small
2,157.43387251201506,17.76401944970274,5.478986055299444,Healthcare,Small
3,105.74597288227176,20.660129810742625,0.9485993815285418,Healthcare,Small
4,97.19739917391914,21.636897945782987,5.701639094885234,Healthcare,Small
1,96.68478223173342,32.21815870030392,4.392828316040838,Healthcare,Medium
2,77.74844425480137,16.372653234719053,4.744862870911971,Healthcare,Medium
3,106.991738874415,17.579298166483593,0.9130292958723203,Healthcare,Medium
4,94.85198770196237,26.30157269955874,2.7552018647959837,Healthcare,Medium
1,112.51174835128639,11.44709125031366,3.876287330715441,Healthcare,Large
2,63.48423765990957,22.117571511969324,7.794239233712055,Healthcare,Large
3,103.81369082367875,26.31500592984836,1.2926970000437477,Healthcare,Large
4,95.02759709160647,26.449692990925044,4.218722429115536,Healthcare,Large

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <h1>AreaChart Examples</h1>
<p>This page demonstrates the key features of AreaChart plots in JSPlots.</p>
<ul>
    <li><strong>Continuous areas:</strong> Smooth filled areas for continuous x values (like dates)</li>
    <li><strong>Discrete areas:</strong> Bar-style areas for categorical x values</li>
    <li><strong>Stack modes:</strong> Unstack (overlapping), stack (cumulative), and normalized stack (percentage)</li>
    <li><strong>Grouping:</strong> Multiple series with automatic color assignment and legend</li>
    <li><strong>Interactive filters:</strong> Dropdown menus to filter data dynamically</li>
    <li><strong>Dynamic controls:</strong> Change grouping, stacking, and faceting on the fly</li>
    <li><strong>Faceting:</strong> Facet wrap (1 variable) and facet grid (2 variables)</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Example 1: Regional Sales Over Time (Stacked Area Chart)</h2>
<p>Continuous time series with dates on x-axis. Stacked areas show cumulative sales across regions.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_stacked_area">Stack mode: </label>
        <select id="stack_mode_select_stacked_area" onchange="updatePlot_stacked_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="stacked_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_by_region</p><br>
<hr>
<br>
<h2>Example 2: Product Values - Continuous Unstack</h2>
<p>Continuous x-axis (numeric). Overlapping areas with transparency allow comparison of individual trends.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_unstacked_area">Stack mode: </label>
        <select id="stack_mode_select_unstacked_area" onchange="updatePlot_unstacked_area()">
                <option value="unstack" selected>unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="unstacked_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: product_values</p><br>
<hr>
<br>
<h2>Example 3: Market Share Distribution (Normalized Stack)</h2>
<p>Continuous numeric x-axis. Normalized stacking shows relative proportions - total always reaches 100%.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_normalized_area">Stack mode: </label>
        <select id="stack_mode_select_normalized_area" onchange="updatePlot_normalized_area()">
                <option value="unstack">unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack" selected>normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="normalized_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: market_share</p><br>
<hr>
<br>
<h2>Example 4: Headcount by Department (Discrete/Stacked Bars)</h2>
<p>Categorical x-axis. When x values are discrete, areas automatically become stacked bars.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_discrete_area">Stack mode: </label>
        <select id="stack_mode_select_discrete_area" onchange="updatePlot_discrete_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="discrete_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: headcount_data</p><br>
<hr>
<br>
<h2>Example 5: Revenue by Channel with Filters</h2>
<p>Continuous date axis with interactive filters. Select different years and regions to update the view.</p>

<!-- Filters (for data filtering) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f9f9f9;">
            <h4 style="margin-top: 0;">Filters</h4>
                    <div style="margin: 10px;">
            <label for="Year_select">Year: </label>
            <select id="Year_select" multiple style="min-width: 150px; height: 100px;" onchange="updatePlot_filtered_area()">
                <option value="2022">2022</option>
                <option value="2023">2023</option>
                <option value="2024" selected>2024</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="Region_select">Region: </label>
            <select id="Region_select" multiple style="min-width: 150px; height: 100px;" onchange="updatePlot_filtered_area()">
                <option value="North" selected>North</option>
                <option value="South">South</option>
            </select>
        </div>
        
        </div>

<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_filtered_area">Stack mode: </label>
        <select id="stack_mode_select_filtered_area" onchange="updatePlot_filtered_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="filtered_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: channel_revenue</p><br>
<hr>
<br>
<h2>Example 6: Metrics by Source (Facet Wrap)</h2>
<p>Continuous x-axis with faceting. Each facet shows one metric with stacked sources.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_facet_wrap_area">Stack mode: </label>
        <select id="stack_mode_select_facet_wrap_area" onchange="updatePlot_facet_wrap_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_facet_wrap_area">Facet by: </label>
            <select id="facet1_select_facet_wrap_area" onchange="updatePlot_facet_wrap_area()">
                <option value="None">None</option>
                <option value="Metric" selected>Metric</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="facet_wrap_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: metrics_data</p><br>
<hr>
<br>
<h2>Example 7: Sales by Product and Region (Facet Grid)</h2>
<p>Continuous x-axis with 2D facet grid. Products in rows, Regions in columns.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_facet_grid_area">Stack mode: </label>
        <select id="stack_mode_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_facet_grid_area">Facet 1: </label>
            <select id="facet1_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="None">None</option>
                <option value="Product" selected>Product</option>
                <option value="Region">Region</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_facet_grid_area">Facet 2: </label>
            <select id="facet2_select_facet_grid_area" onchange="updatePlot_facet_grid_area()">
                <option value="None">None</option>
                <option value="Product">Product</option>
                <option value="Region" selected>Region</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="facet_grid_area"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: grid_sales</p><br>
<hr>
<br>
<h2>Example 8: Business Metrics with Dynamic Controls</h2>
<p>Continuous x-axis. Use dropdowns to dynamically change: Y metric, grouping variable, stack mode, and faceting.</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                    <div style="margin: 10px;">
            <label for="y_col_select_dynamic_grouping">Y dimension: </label>
            <select id="y_col_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="Revenue" selected>Revenue</option>
                <option value="Profit">Profit</option>
                <option value="Growth">Growth</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="group_col_select_dynamic_grouping">Group by: </label>
            <select id="group_col_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="Industry" selected>Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
            <div style="margin: 10px;">
        <label for="stack_mode_select_dynamic_grouping">Stack mode: </label>
        <select id="stack_mode_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff8f0;">
            <h4 style="margin-top: 0;">Faceting</h4>
                    <div style="margin: 10px;">
            <label for="facet1_select_dynamic_grouping">Facet 1: </label>
            <select id="facet1_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="None" selected>None</option>
                <option value="Industry">Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="facet2_select_dynamic_grouping">Facet 2: </label>
            <select id="facet2_select_dynamic_grouping" onchange="updatePlot_dynamic_grouping()">
                <option value="None" selected>None</option>
                <option value="Industry">Industry</option>
                <option value="CompanySize">CompanySize</option>
            </select>
        </div>
        
        </div>

<!-- Chart -->
<div id="dynamic_grouping"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: business_metrics</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Stack Mode Comparison</h2>
<p>The following three charts use the same data but different stack modes to illustrate their differences:</p>

    </div>
<br>
<hr>
<br>
<h2>Stack Mode: UNSTACK</h2>
<p>Areas overlap with transparency - see individual trends clearly</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_unstack_mode">Stack mode: </label>
        <select id="stack_mode_select_unstack_mode" onchange="updatePlot_unstack_mode()">
                <option value="unstack" selected>unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="unstack_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
<h2>Stack Mode: STACK</h2>
<p>Areas are stacked - shows cumulative total and individual contributions</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_stack_mode">Stack mode: </label>
        <select id="stack_mode_select_stack_mode" onchange="updatePlot_stack_mode()">
                <option value="unstack">unstack</option>
                <option value="stack" selected>stack</option>
                <option value="normalised_stack">normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="stack_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
<h2>Stack Mode: NORMALIZED STACK</h2>
<p>Areas are stacked and normalized to 100% - shows relative proportions over time</p>

<!-- Filters (for data filtering) -->


<!-- Plot Attributes (x, y, group, stack mode) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
            <h4 style="margin-top: 0;">Plot Attributes</h4>
                <div style="margin: 10px;">
        <label for="stack_mode_select_normalized_mode">Stack mode: </label>
        <select id="stack_mode_select_normalized_mode" onchange="updatePlot_normalized_mode()">
                <option value="unstack">unstack</option>
                <option value="stack">stack</option>
                <option value="normalised_stack" selected>normalized stack</option>
        </select>
    </div>
    
        </div>

<!-- Faceting -->


<!-- Chart -->
<div id="normalized_mode"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: compare_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Key Features Summary</h2>
<ul>
    <li><strong>Automatic discrete/continuous detection:</strong> Continuous x values (dates, numeric) create smooth areas; discrete x values (categories) create stacked bars</li>
    <li><strong>Three stack modes:</strong>
        <ul>
            <li><em>Unstack:</em> Overlapping areas with transparency - best for comparing trends</li>
            <li><em>Stack:</em> Cumulative areas - best for showing total and parts</li>
            <li><em>Normalized stack:</em> Percentage areas - best for showing proportions</li>
        </ul>
    </li>
    <li><strong>Dynamic grouping:</strong> Choose which variable to group/color by from dropdown</li>
    <li><strong>Interactive filters:</strong> Filter data dynamically with dropdown menus</li>
    <li><strong>Faceting:</strong> Create small multiples with 1 or 2 faceting variables</li>
    <li><strong>Customization:</strong> Control opacity, titles, and stack modes</li>
    <li><strong>Date support:</strong> Automatic formatting and proper handling of date-based time series</li>
</ul>
<p><strong>Tip:</strong> Hover over areas to see detailed values. Use the dropdown controls to explore different views of your data!</p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
