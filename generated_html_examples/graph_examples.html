<!DOCTYPE html>
<html>
<head>
    <title>JSPlots.jl</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    const scenarios = ["Short-term (60 days)","Long-term (250 days)","Volatility Correlations"];
    const hasScenarios = true;
    let currentScenario = "Short-term (60 days)";
    let selectedVars = ["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","WFC","JNJ","PFE","UNH","XOM","CVX","COP"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = [];
    const discreteCols = ["sector"];
    const colourMap = null;
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["sector"];
    const tooltipDiv = document.getElementById('tooltip_stock_network');

    // Load graph data
    loadDataset('stock_graph_data').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_stock_network');
                    const container = document.getElementById('corr_method_container_stock_network');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_stock_network();
        initializeGraph_stock_network();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_stock_network() {
        const select = document.getElementById('var_select_stock_network');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_stock_network() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_stock_network'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'cose'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_stock_network();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_stock_network();

        // Setup tooltips
        setupTooltips_stock_network();
    }

    function setupTooltips_stock_network() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_stock_network');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_stock_network() {
        const slider = document.getElementById('aspect_ratio_slider_stock_network');
        const label = document.getElementById('aspect_ratio_label_stock_network');
        const graphDiv = document.getElementById('graph_stock_network');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_stock_network = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_stock_network').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_stock_network');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_stock_network(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_stock_network = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_stock_network');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_stock_network').value);
        const showEdgeLabels = document.getElementById('show_edges_stock_network').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_stock_network(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_stock_network = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_stock_network');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_stock_network = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_stock_network').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_stock_network(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_stock_network(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_stock_network = function() {
        const showLabels = document.getElementById('show_edges_stock_network').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_stock_network(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_stock_network(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_stock_network(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_stock_network(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_stock_network(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_stock_network(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_stock_network(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_stock_network(color1);
        const c2 = parseHexColor_stock_network(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_stock_network(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_stock_network(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_stock_network').value);
        const showEdgeLabels = document.getElementById('show_edges_stock_network').checked;

        const colorBy = document.getElementById('color_select_stock_network').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_stock_network(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_stock_network(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_stock_network(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_stock_network(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_stock_network');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_stock_network(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();
(function() {
    const scenarios = ["Economic Indicators"];
    const hasScenarios = false;
    let currentScenario = "Economic Indicators";
    let selectedVars = ["New York","Boston","Philadelphia","Washington DC","Chicago","Detroit","Minneapolis","Los Angeles","San Francisco","Seattle","Portland","Miami","Atlanta","Houston"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = [];
    const discreteCols = ["region"];
    const colourMap = null;
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["region"];
    const tooltipDiv = document.getElementById('tooltip_city_network');

    // Load graph data
    loadDataset('city_graph_data').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_city_network');
                    const container = document.getElementById('corr_method_container_city_network');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_city_network();
        initializeGraph_city_network();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_city_network() {
        const select = document.getElementById('var_select_city_network');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_city_network() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_city_network'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'circle'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_city_network();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_city_network();

        // Setup tooltips
        setupTooltips_city_network();
    }

    function setupTooltips_city_network() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_city_network');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_city_network() {
        const slider = document.getElementById('aspect_ratio_slider_city_network');
        const label = document.getElementById('aspect_ratio_label_city_network');
        const graphDiv = document.getElementById('graph_city_network');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_city_network = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_city_network').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_city_network');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_city_network(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_city_network = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_city_network');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_city_network').value);
        const showEdgeLabels = document.getElementById('show_edges_city_network').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_city_network(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_city_network = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_city_network');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_city_network = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_city_network').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_city_network(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_city_network(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_city_network = function() {
        const showLabels = document.getElementById('show_edges_city_network').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_city_network(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_city_network(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_city_network(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_city_network(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_city_network(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_city_network(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_city_network(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_city_network(color1);
        const c2 = parseHexColor_city_network(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_city_network(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_city_network(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_city_network').value);
        const showEdgeLabels = document.getElementById('show_edges_city_network').checked;

        const colorBy = document.getElementById('color_select_city_network').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_city_network(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_city_network(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_city_network(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_city_network(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_city_network');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_city_network(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();
(function() {
    const scenarios = ["Social Connections"];
    const hasScenarios = false;
    let currentScenario = "Social Connections";
    let selectedVars = ["Alice","Bob","Carol","Dave","Eve","Frank","Grace","Henry","Iris","Jack","Kate","Leo"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = [];
    const discreteCols = ["Department","Team","Location"];
    const colourMap = null;
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["Department","Team","Location"];
    const tooltipDiv = document.getElementById('tooltip_social_network');

    // Load graph data
    loadDataset('social_graph_data').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_social_network');
                    const container = document.getElementById('corr_method_container_social_network');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_social_network();
        initializeGraph_social_network();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_social_network() {
        const select = document.getElementById('var_select_social_network');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_social_network() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_social_network'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'concentric'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_social_network();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_social_network();

        // Setup tooltips
        setupTooltips_social_network();
    }

    function setupTooltips_social_network() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_social_network');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_social_network() {
        const slider = document.getElementById('aspect_ratio_slider_social_network');
        const label = document.getElementById('aspect_ratio_label_social_network');
        const graphDiv = document.getElementById('graph_social_network');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_social_network = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_social_network').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_social_network');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_social_network(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_social_network = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_social_network');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_social_network').value);
        const showEdgeLabels = document.getElementById('show_edges_social_network').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_social_network(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_social_network = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_social_network');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_social_network = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_social_network').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_social_network(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_social_network(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_social_network = function() {
        const showLabels = document.getElementById('show_edges_social_network').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_social_network(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_social_network(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_social_network(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_social_network(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_social_network(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_social_network(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_social_network(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_social_network(color1);
        const c2 = parseHexColor_social_network(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_social_network(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_social_network(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_social_network').value);
        const showEdgeLabels = document.getElementById('show_edges_social_network').checked;

        const colorBy = document.getElementById('color_select_social_network').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_social_network(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_social_network(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_social_network(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_social_network(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_social_network');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_social_network(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();
(function() {
    const scenarios = ["Research Collaborations"];
    const hasScenarios = false;
    let currentScenario = "Research Collaborations";
    let selectedVars = ["Dr. Smith","Dr. Johnson","Dr. Williams","Dr. Brown","Dr. Jones","Dr. Garcia","Dr. Miller","Dr. Davis","Dr. Rodriguez","Dr. Martinez","Dr. Hernandez","Dr. Lopez"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = [];
    const discreteCols = ["Institution","Field"];
    const colourMap = null;
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["Institution","Field"];
    const tooltipDiv = document.getElementById('tooltip_research_network');

    // Load graph data
    loadDataset('research_graph_data').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_research_network');
                    const container = document.getElementById('corr_method_container_research_network');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_research_network();
        initializeGraph_research_network();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_research_network() {
        const select = document.getElementById('var_select_research_network');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_research_network() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_research_network'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'breadthfirst'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_research_network();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_research_network();

        // Setup tooltips
        setupTooltips_research_network();
    }

    function setupTooltips_research_network() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_research_network');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_research_network() {
        const slider = document.getElementById('aspect_ratio_slider_research_network');
        const label = document.getElementById('aspect_ratio_label_research_network');
        const graphDiv = document.getElementById('graph_research_network');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_research_network = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_research_network').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_research_network');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_research_network(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_research_network = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_research_network');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_research_network').value);
        const showEdgeLabels = document.getElementById('show_edges_research_network').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_research_network(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_research_network = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_research_network');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_research_network = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_research_network').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_research_network(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_research_network(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_research_network = function() {
        const showLabels = document.getElementById('show_edges_research_network').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_research_network(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_research_network(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_research_network(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_research_network(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_research_network(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_research_network(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_research_network(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_research_network(color1);
        const c2 = parseHexColor_research_network(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_research_network(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_research_network(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_research_network').value);
        const showEdgeLabels = document.getElementById('show_edges_research_network').checked;

        const colorBy = document.getElementById('color_select_research_network').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_research_network(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_research_network(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_research_network(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_research_network(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_research_network');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_research_network(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();
(function() {
    const scenarios = ["Product Co-occurrence"];
    const hasScenarios = false;
    let currentScenario = "Product Co-occurrence";
    let selectedVars = ["Laptop","Mouse","Keyboard","Monitor","Desk","Chair","Lamp","Notebook","Pen","Stapler","Coffee Mug","Water Bottle"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = [];
    const discreteCols = ["Category"];
    const colourMap = null;
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["Category"];
    const tooltipDiv = document.getElementById('tooltip_product_network');

    // Load graph data
    loadDataset('product_graph_data').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_product_network');
                    const container = document.getElementById('corr_method_container_product_network');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_product_network();
        initializeGraph_product_network();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_product_network() {
        const select = document.getElementById('var_select_product_network');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_product_network() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_product_network'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'grid'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_product_network();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_product_network();

        // Setup tooltips
        setupTooltips_product_network();
    }

    function setupTooltips_product_network() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_product_network');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_product_network() {
        const slider = document.getElementById('aspect_ratio_slider_product_network');
        const label = document.getElementById('aspect_ratio_label_product_network');
        const graphDiv = document.getElementById('graph_product_network');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_product_network = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_product_network').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_product_network');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_product_network(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_product_network = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_product_network');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_product_network').value);
        const showEdgeLabels = document.getElementById('show_edges_product_network').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_product_network(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_product_network = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_product_network');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_product_network = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_product_network').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_product_network(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_product_network(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_product_network = function() {
        const showLabels = document.getElementById('show_edges_product_network').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_product_network(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_product_network(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_product_network(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_product_network(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_product_network(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_product_network(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_product_network(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_product_network(color1);
        const c2 = parseHexColor_product_network(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_product_network(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_product_network(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_product_network').value);
        const showEdgeLabels = document.getElementById('show_edges_product_network').checked;

        const colorBy = document.getElementById('color_select_product_network').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_product_network(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_product_network(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_product_network(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_product_network(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_product_network');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_product_network(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();
(function() {
    const scenarios = ["Strategy Correlations"];
    const hasScenarios = false;
    let currentScenario = "Strategy Correlations";
    let selectedVars = ["Momentum","Mean Reversion","Trend Following","Pairs Trading","Statistical Arbitrage","Market Making","Volatility Arbitrage","Delta Hedging","Credit Spread","Yield Curve","Carry Trade","Breakout"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = ["sharpe_ratio"];
    const discreteCols = ["strategy_type"];
    const colourMap = {"0.0":"#FFFFFF","-1.0":"#FFFF99","-2.5":"#FF9999","2.5":"#99CCFF","1.0":"#99FF99"};
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["strategy_type","sharpe_ratio"];
    const tooltipDiv = document.getElementById('tooltip_strategy_network_global');

    // Load graph data
    loadDataset('strategy_graph_data_global').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_strategy_network_global');
                    const container = document.getElementById('corr_method_container_strategy_network_global');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_strategy_network_global();
        initializeGraph_strategy_network_global();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_strategy_network_global() {
        const select = document.getElementById('var_select_strategy_network_global');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_strategy_network_global() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_strategy_network_global'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'cose'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_strategy_network_global();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_strategy_network_global();

        // Setup tooltips
        setupTooltips_strategy_network_global();
    }

    function setupTooltips_strategy_network_global() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_strategy_network_global');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_strategy_network_global() {
        const slider = document.getElementById('aspect_ratio_slider_strategy_network_global');
        const label = document.getElementById('aspect_ratio_label_strategy_network_global');
        const graphDiv = document.getElementById('graph_strategy_network_global');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_strategy_network_global = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_strategy_network_global').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_strategy_network_global');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_strategy_network_global(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_strategy_network_global = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_strategy_network_global');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_strategy_network_global').value);
        const showEdgeLabels = document.getElementById('show_edges_strategy_network_global').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_strategy_network_global(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_strategy_network_global = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_strategy_network_global');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_strategy_network_global = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_strategy_network_global').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_strategy_network_global(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_strategy_network_global(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_strategy_network_global = function() {
        const showLabels = document.getElementById('show_edges_strategy_network_global').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_strategy_network_global(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_strategy_network_global(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_strategy_network_global(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_strategy_network_global(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_strategy_network_global(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_strategy_network_global(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_strategy_network_global(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_strategy_network_global(color1);
        const c2 = parseHexColor_strategy_network_global(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_strategy_network_global(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_strategy_network_global(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_strategy_network_global').value);
        const showEdgeLabels = document.getElementById('show_edges_strategy_network_global').checked;

        const colorBy = document.getElementById('color_select_strategy_network_global').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_strategy_network_global(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_strategy_network_global(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_strategy_network_global(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_strategy_network_global(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_strategy_network_global');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_strategy_network_global(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();
(function() {
    const scenarios = ["Multi-Metric Analysis"];
    const hasScenarios = false;
    let currentScenario = "Multi-Metric Analysis";
    let selectedVars = ["Momentum","Mean Reversion","Trend Following","Pairs Trading","Statistical Arbitrage","Market Making","Volatility Arbitrage","Delta Hedging","Credit Spread","Yield Curve","Carry Trade","Breakout"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = ["sharpe_ratio","return_pct","volatility_pct"];
    const discreteCols = ["strategy_type"];
    const colourMap = {"sharpe_ratio":{"0.0":"#FFFFFF","-1.0":"#FFFF99","-2.5":"#FF9999","2.5":"#99CCFF","1.0":"#99FF99"},"return_pct":{"0.0":"#FFFFFF","5.0":"#6666FF","-5.0":"#FF6666","20.0":"#0000AA"},"volatility_pct":{"15.0":"#FFFF00","20.0":"#FF8800","10.0":"#00FF00","30.0":"#FF0000"}};
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["strategy_type","sharpe_ratio","return_pct","volatility_pct"];
    const tooltipDiv = document.getElementById('tooltip_strategy_network_pervariable');

    // Load graph data
    loadDataset('strategy_graph_data_pervariable').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_strategy_network_pervariable');
                    const container = document.getElementById('corr_method_container_strategy_network_pervariable');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_strategy_network_pervariable();
        initializeGraph_strategy_network_pervariable();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_strategy_network_pervariable() {
        const select = document.getElementById('var_select_strategy_network_pervariable');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_strategy_network_pervariable() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_strategy_network_pervariable'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'cose'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_strategy_network_pervariable();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_strategy_network_pervariable();

        // Setup tooltips
        setupTooltips_strategy_network_pervariable();
    }

    function setupTooltips_strategy_network_pervariable() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_strategy_network_pervariable');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_strategy_network_pervariable() {
        const slider = document.getElementById('aspect_ratio_slider_strategy_network_pervariable');
        const label = document.getElementById('aspect_ratio_label_strategy_network_pervariable');
        const graphDiv = document.getElementById('graph_strategy_network_pervariable');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_strategy_network_pervariable = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_strategy_network_pervariable').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_strategy_network_pervariable');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_strategy_network_pervariable(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_strategy_network_pervariable = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_strategy_network_pervariable');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_strategy_network_pervariable').value);
        const showEdgeLabels = document.getElementById('show_edges_strategy_network_pervariable').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_strategy_network_pervariable(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_strategy_network_pervariable = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_strategy_network_pervariable');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_strategy_network_pervariable = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_strategy_network_pervariable').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_strategy_network_pervariable(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_strategy_network_pervariable(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_strategy_network_pervariable = function() {
        const showLabels = document.getElementById('show_edges_strategy_network_pervariable').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_strategy_network_pervariable(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_strategy_network_pervariable(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_strategy_network_pervariable(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_strategy_network_pervariable(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_strategy_network_pervariable(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_strategy_network_pervariable(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_strategy_network_pervariable(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_strategy_network_pervariable(color1);
        const c2 = parseHexColor_strategy_network_pervariable(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_strategy_network_pervariable(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_strategy_network_pervariable(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_strategy_network_pervariable').value);
        const showEdgeLabels = document.getElementById('show_edges_strategy_network_pervariable').checked;

        const colorBy = document.getElementById('color_select_strategy_network_pervariable').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_strategy_network_pervariable(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_strategy_network_pervariable(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_strategy_network_pervariable(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_strategy_network_pervariable(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_strategy_network_pervariable');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_strategy_network_pervariable(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();
(function() {
    const scenarios = ["African Markets 2025"];
    const hasScenarios = false;
    let currentScenario = "African Markets 2025";
    let selectedVars = ["Kenya","Rwanda","Tanzania","Uganda","Ethiopia","Nigeria","South Africa","Ghana"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = ["returns"];
    const discreteCols = ["industry"];
    const colourMap = null;
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["industry","returns","gdp_growth","population","market_cap"];
    const tooltipDiv = document.getElementById('tooltip_market_network_tooltips');

    // Load graph data
    loadDataset('market_graph_data').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_market_network_tooltips');
                    const container = document.getElementById('corr_method_container_market_network_tooltips');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_market_network_tooltips();
        initializeGraph_market_network_tooltips();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_market_network_tooltips() {
        const select = document.getElementById('var_select_market_network_tooltips');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_market_network_tooltips() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_market_network_tooltips'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'cose'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_market_network_tooltips();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_market_network_tooltips();

        // Setup tooltips
        setupTooltips_market_network_tooltips();
    }

    function setupTooltips_market_network_tooltips() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_market_network_tooltips');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_market_network_tooltips() {
        const slider = document.getElementById('aspect_ratio_slider_market_network_tooltips');
        const label = document.getElementById('aspect_ratio_label_market_network_tooltips');
        const graphDiv = document.getElementById('graph_market_network_tooltips');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_market_network_tooltips = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_market_network_tooltips').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_market_network_tooltips');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_market_network_tooltips(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_market_network_tooltips = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_market_network_tooltips');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_market_network_tooltips').value);
        const showEdgeLabels = document.getElementById('show_edges_market_network_tooltips').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_market_network_tooltips(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_market_network_tooltips = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_market_network_tooltips');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_market_network_tooltips = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_market_network_tooltips').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_market_network_tooltips(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_market_network_tooltips(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_market_network_tooltips = function() {
        const showLabels = document.getElementById('show_edges_market_network_tooltips').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_market_network_tooltips(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_market_network_tooltips(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_market_network_tooltips(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_market_network_tooltips(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_market_network_tooltips(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_market_network_tooltips(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_market_network_tooltips(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_market_network_tooltips(color1);
        const c2 = parseHexColor_market_network_tooltips(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_market_network_tooltips(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_market_network_tooltips(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_market_network_tooltips').value);
        const showEdgeLabels = document.getElementById('show_edges_market_network_tooltips').checked;

        const colorBy = document.getElementById('color_select_market_network_tooltips').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_market_network_tooltips(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_market_network_tooltips(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_market_network_tooltips(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_market_network_tooltips(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_market_network_tooltips');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_market_network_tooltips(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="product_graph_data" data-format="csv_embedded" data-src="">
node1,node2,strength,Category,scenario,correlation_method
Laptop,Mouse,0.44408525276310384,Electronics,Product Co-occurrence,cooccurrence
Laptop,Keyboard,0.6970510841787173,Electronics,Product Co-occurrence,cooccurrence
Laptop,Monitor,0.5747292059851671,Electronics,Product Co-occurrence,cooccurrence
Laptop,Desk,0.34544861269145194,Electronics,Product Co-occurrence,cooccurrence
Laptop,Chair,0.23280778706202945,Electronics,Product Co-occurrence,cooccurrence
Laptop,Lamp,0.02632590648743376,Electronics,Product Co-occurrence,cooccurrence
Laptop,Notebook,0.2504791447497559,Electronics,Product Co-occurrence,cooccurrence
Laptop,Pen,0.28893254860928563,Electronics,Product Co-occurrence,cooccurrence
Laptop,Stapler,0.22857644748325648,Electronics,Product Co-occurrence,cooccurrence
Laptop,Coffee Mug,0.3799752992344971,Electronics,Product Co-occurrence,cooccurrence
Laptop,Water Bottle,0.14238427350532926,Electronics,Product Co-occurrence,cooccurrence
Mouse,Keyboard,0.4052262324807225,Electronics,Product Co-occurrence,cooccurrence
Mouse,Monitor,0.6585302864253315,Electronics,Product Co-occurrence,cooccurrence
Mouse,Desk,0.10138095742610638,Electronics,Product Co-occurrence,cooccurrence
Mouse,Chair,0.012485913060576427,Electronics,Product Co-occurrence,cooccurrence
Mouse,Lamp,0.21409669264543557,Electronics,Product Co-occurrence,cooccurrence
Mouse,Notebook,0.3024249051479915,Electronics,Product Co-occurrence,cooccurrence
Mouse,Pen,0.06413788164532903,Electronics,Product Co-occurrence,cooccurrence
Mouse,Stapler,0.14195896757130785,Electronics,Product Co-occurrence,cooccurrence
Mouse,Coffee Mug,0.3342446661630323,Electronics,Product Co-occurrence,cooccurrence
Mouse,Water Bottle,0.10617769241272833,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Monitor,0.6213520410920228,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Desk,0.21662975520388683,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Chair,0.21510936127083957,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Lamp,0.0749950921357347,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Notebook,0.2880116916762163,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Pen,0.27476156200934776,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Stapler,0.2660276893106116,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Coffee Mug,0.21303237138515208,Electronics,Product Co-occurrence,cooccurrence
Keyboard,Water Bottle,0.18998491111615445,Electronics,Product Co-occurrence,cooccurrence
Monitor,Desk,0.05643309353902266,Electronics,Product Co-occurrence,cooccurrence
Monitor,Chair,0.3434235034516242,Electronics,Product Co-occurrence,cooccurrence
Monitor,Lamp,0.29835667347411354,Electronics,Product Co-occurrence,cooccurrence
Monitor,Notebook,0.024471679979659645,Electronics,Product Co-occurrence,cooccurrence
Monitor,Pen,0.1824416818477116,Electronics,Product Co-occurrence,cooccurrence
Monitor,Stapler,0.3846625771350367,Electronics,Product Co-occurrence,cooccurrence
Monitor,Coffee Mug,0.23512436726618458,Electronics,Product Co-occurrence,cooccurrence
Monitor,Water Bottle,0.31006836648477826,Electronics,Product Co-occurrence,cooccurrence
Desk,Chair,0.7079447692849273,Furniture,Product Co-occurrence,cooccurrence
Desk,Lamp,0.40959425365723034,Furniture,Product Co-occurrence,cooccurrence
Desk,Notebook,0.21894908467167948,Furniture,Product Co-occurrence,cooccurrence
Desk,Pen,0.21401346834978485,Furniture,Product Co-occurrence,cooccurrence
Desk,Stapler,0.32200754888196914,Furniture,Product Co-occurrence,cooccurrence
Desk,Coffee Mug,0.003079186821128399,Furniture,Product Co-occurrence,cooccurrence
Desk,Water Bottle,0.03914314918509074,Furniture,Product Co-occurrence,cooccurrence
Chair,Lamp,0.6076773966978203,Furniture,Product Co-occurrence,cooccurrence
Chair,Notebook,0.07130725476302367,Furniture,Product Co-occurrence,cooccurrence
Chair,Pen,0.21693143671050585,Furniture,Product Co-occurrence,cooccurrence
Chair,Stapler,0.19700501944270654,Furniture,Product Co-occurrence,cooccurrence
Chair,Coffee Mug,0.2668617227044819,Furniture,Product Co-occurrence,cooccurrence
Chair,Water Bottle,0.2270227539886725,Furniture,Product Co-occurrence,cooccurrence
Lamp,Notebook,0.14617936179941113,Furniture,Product Co-occurrence,cooccurrence
Lamp,Pen,0.27146612123971,Furniture,Product Co-occurrence,cooccurrence
Lamp,Stapler,0.3017307426241437,Furniture,Product Co-occurrence,cooccurrence
Lamp,Coffee Mug,0.2091992942835943,Furniture,Product Co-occurrence,cooccurrence
Lamp,Water Bottle,0.3805814680700319,Furniture,Product Co-occurrence,cooccurrence
Notebook,Pen,0.5798362576187949,Stationery,Product Co-occurrence,cooccurrence
Notebook,Stapler,0.6358764081311749,Stationery,Product Co-occurrence,cooccurrence
Notebook,Coffee Mug,0.33396694302715,Stationery,Product Co-occurrence,cooccurrence
Notebook,Water Bottle,0.008395741157221437,Stationery,Product Co-occurrence,cooccurrence
Pen,Stapler,0.49324522763362216,Stationery,Product Co-occurrence,cooccurrence
Pen,Coffee Mug,0.06389201065981016,Stationery,Product Co-occurrence,cooccurrence
Pen,Water Bottle,0.35876038883007433,Stationery,Product Co-occurrence,cooccurrence
Stapler,Coffee Mug,0.16112197181066207,Stationery,Product Co-occurrence,cooccurrence
Stapler,Water Bottle,0.37898977725789174,Stationery,Product Co-occurrence,cooccurrence
Coffee Mug,Water Bottle,0.8024835911251148,Kitchen,Product Co-occurrence,cooccurrence

</script><script type="text/plain" id="research_graph_data" data-format="csv_embedded" data-src="">
node1,node2,strength,Field,Institution,scenario,correlation_method
Dr. Smith,Dr. Johnson,0.9188472226625497,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Williams,0.6073022841066384,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Brown,0.35210554464115545,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Jones,0.5323991956164662,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Garcia,0.2849277306081042,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Miller,0.20343634693100976,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Davis,0.5627595260884406,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Rodriguez,0.35065025636087177,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Martinez,0.3580859887976653,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Hernandez,0.6121239579343025,AI,MIT,Research Collaborations,collaboration
Dr. Smith,Dr. Lopez,0.24236713644087327,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Williams,0.6265010438734051,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Brown,0.28262110456019496,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Jones,0.5300179992749733,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Garcia,0.28574987585308825,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Miller,0.2849103497852102,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Davis,0.6180384216132324,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Rodriguez,0.30916581130572496,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Martinez,0.25198252505700924,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Hernandez,0.6284356043775511,AI,MIT,Research Collaborations,collaboration
Dr. Johnson,Dr. Lopez,0.3886859659231421,AI,MIT,Research Collaborations,collaboration
Dr. Williams,Dr. Brown,0.728345135655515,AI,Stanford,Research Collaborations,collaboration
Dr. Williams,Dr. Jones,0.6881437257575002,AI,Stanford,Research Collaborations,collaboration
Dr. Williams,Dr. Garcia,0.2543408921445865,AI,Stanford,Research Collaborations,collaboration
Dr. Williams,Dr. Miller,0.2473607917057785,AI,Stanford,Research Collaborations,collaboration
Dr. Williams,Dr. Davis,0.5693287628792973,AI,Stanford,Research Collaborations,collaboration
Dr. Williams,Dr. Rodriguez,0.38609468384941775,AI,Stanford,Research Collaborations,collaboration
Dr. Williams,Dr. Martinez,0.21894072319224545,AI,Stanford,Research Collaborations,collaboration
Dr. Williams,Dr. Hernandez,0.3996779501270262,AI,Stanford,Research Collaborations,collaboration
Dr. Williams,Dr. Lopez,0.770359356187548,AI,Stanford,Research Collaborations,collaboration
Dr. Brown,Dr. Jones,0.2536005443698308,Robotics,Stanford,Research Collaborations,collaboration
Dr. Brown,Dr. Garcia,0.3457107898987921,Robotics,Stanford,Research Collaborations,collaboration
Dr. Brown,Dr. Miller,0.5496698246087823,Robotics,Stanford,Research Collaborations,collaboration
Dr. Brown,Dr. Davis,0.2836235846550312,Robotics,Stanford,Research Collaborations,collaboration
Dr. Brown,Dr. Rodriguez,0.27564868748405447,Robotics,Stanford,Research Collaborations,collaboration
Dr. Brown,Dr. Martinez,0.3323167269946324,Robotics,Stanford,Research Collaborations,collaboration
Dr. Brown,Dr. Hernandez,0.37540323445254203,Robotics,Stanford,Research Collaborations,collaboration
Dr. Brown,Dr. Lopez,0.7811100882366475,Robotics,Stanford,Research Collaborations,collaboration
Dr. Jones,Dr. Garcia,0.7075363023691785,AI,Berkeley,Research Collaborations,collaboration
Dr. Jones,Dr. Miller,0.39795523870216254,AI,Berkeley,Research Collaborations,collaboration
Dr. Jones,Dr. Davis,0.6996736084632554,AI,Berkeley,Research Collaborations,collaboration
Dr. Jones,Dr. Rodriguez,0.3782130883230806,AI,Berkeley,Research Collaborations,collaboration
Dr. Jones,Dr. Martinez,0.3810856704604264,AI,Berkeley,Research Collaborations,collaboration
Dr. Jones,Dr. Hernandez,0.3373946860673219,AI,Berkeley,Research Collaborations,collaboration
Dr. Jones,Dr. Lopez,0.31597075742571157,AI,Berkeley,Research Collaborations,collaboration
Dr. Garcia,Dr. Miller,0.2418099571923633,Networks,Berkeley,Research Collaborations,collaboration
Dr. Garcia,Dr. Davis,0.35000448728703637,Networks,Berkeley,Research Collaborations,collaboration
Dr. Garcia,Dr. Rodriguez,0.28406927342405985,Networks,Berkeley,Research Collaborations,collaboration
Dr. Garcia,Dr. Martinez,0.3005384782473855,Networks,Berkeley,Research Collaborations,collaboration
Dr. Garcia,Dr. Hernandez,0.6371102902480537,Networks,Berkeley,Research Collaborations,collaboration
Dr. Garcia,Dr. Lopez,0.6492061089706262,Networks,Berkeley,Research Collaborations,collaboration
Dr. Miller,Dr. Davis,0.7361657053729229,Robotics,CMU,Research Collaborations,collaboration
Dr. Miller,Dr. Rodriguez,0.3249327723894832,Robotics,CMU,Research Collaborations,collaboration
Dr. Miller,Dr. Martinez,0.344495503945411,Robotics,CMU,Research Collaborations,collaboration
Dr. Miller,Dr. Hernandez,0.38416254700791774,Robotics,CMU,Research Collaborations,collaboration
Dr. Miller,Dr. Lopez,0.37299034946125414,Robotics,CMU,Research Collaborations,collaboration
Dr. Davis,Dr. Rodriguez,0.28792222980262566,AI,CMU,Research Collaborations,collaboration
Dr. Davis,Dr. Martinez,0.3202867583126001,AI,CMU,Research Collaborations,collaboration
Dr. Davis,Dr. Hernandez,0.30109080203584293,AI,CMU,Research Collaborations,collaboration
Dr. Davis,Dr. Lopez,0.29729948524118366,AI,CMU,Research Collaborations,collaboration
Dr. Rodriguez,Dr. Martinez,1.0,Physics,Caltech,Research Collaborations,collaboration
Dr. Rodriguez,Dr. Hernandez,0.20248529724251274,Physics,Caltech,Research Collaborations,collaboration
Dr. Rodriguez,Dr. Lopez,0.20110201647113463,Physics,Caltech,Research Collaborations,collaboration
Dr. Martinez,Dr. Hernandez,0.36801740205222344,Physics,Caltech,Research Collaborations,collaboration
Dr. Martinez,Dr. Lopez,0.3015423940303797,Physics,Caltech,Research Collaborations,collaboration
Dr. Hernandez,Dr. Lopez,0.5123180943659709,Networks,MIT,Research Collaborations,collaboration

</script><script type="text/plain" id="social_graph_data" data-format="csv_embedded" data-src="">
node1,node2,strength,Location,Department,Team,scenario,correlation_method
Alice,Bob,0.8043076626467411,NYC,Engineering,Backend,Social Connections,similarity
Alice,Carol,0.710246983857075,NYC,Engineering,Backend,Social Connections,similarity
Alice,Dave,0.7007175293423309,NYC,Engineering,Backend,Social Connections,similarity
Alice,Eve,0.6628191697435933,NYC,Engineering,Backend,Social Connections,similarity
Alice,Frank,0.5313972882697728,NYC,Engineering,Backend,Social Connections,similarity
Alice,Grace,0.44498703892435826,NYC,Engineering,Backend,Social Connections,similarity
Alice,Henry,0.529192118746733,NYC,Engineering,Backend,Social Connections,similarity
Alice,Iris,0.677344928786093,NYC,Engineering,Backend,Social Connections,similarity
Alice,Jack,0.45451353652742055,NYC,Engineering,Backend,Social Connections,similarity
Alice,Kate,0.4485125152405903,NYC,Engineering,Backend,Social Connections,similarity
Alice,Leo,0.7104019978656555,NYC,Engineering,Backend,Social Connections,similarity
Bob,Carol,0.8080707960077728,NYC,Engineering,Backend,Social Connections,similarity
Bob,Dave,0.7628818392547121,NYC,Engineering,Backend,Social Connections,similarity
Bob,Eve,0.9332657926959228,NYC,Engineering,Backend,Social Connections,similarity
Bob,Frank,0.6217637776599881,NYC,Engineering,Backend,Social Connections,similarity
Bob,Grace,0.46786340043310004,NYC,Engineering,Backend,Social Connections,similarity
Bob,Henry,0.4520626891650631,NYC,Engineering,Backend,Social Connections,similarity
Bob,Iris,0.5938071556284459,NYC,Engineering,Backend,Social Connections,similarity
Bob,Jack,0.37991185710144787,NYC,Engineering,Backend,Social Connections,similarity
Bob,Kate,0.37594237833722083,NYC,Engineering,Backend,Social Connections,similarity
Bob,Leo,0.6054853782853495,NYC,Engineering,Backend,Social Connections,similarity
Carol,Dave,0.8082167281055511,NYC,Engineering,Frontend,Social Connections,similarity
Carol,Eve,0.7163277660385035,NYC,Engineering,Frontend,Social Connections,similarity
Carol,Frank,0.4565534507552784,NYC,Engineering,Frontend,Social Connections,similarity
Carol,Grace,0.4913988754950612,NYC,Engineering,Frontend,Social Connections,similarity
Carol,Henry,0.4283530193283457,NYC,Engineering,Frontend,Social Connections,similarity
Carol,Iris,0.509034042022135,NYC,Engineering,Frontend,Social Connections,similarity
Carol,Jack,0.47329412699093854,NYC,Engineering,Frontend,Social Connections,similarity
Carol,Kate,0.43656153397816333,NYC,Engineering,Frontend,Social Connections,similarity
Carol,Leo,0.5497460476095142,NYC,Engineering,Frontend,Social Connections,similarity
Dave,Eve,0.7045553140076913,SF,Engineering,Frontend,Social Connections,similarity
Dave,Frank,0.5211236009392141,SF,Engineering,Frontend,Social Connections,similarity
Dave,Grace,0.542938302319336,SF,Engineering,Frontend,Social Connections,similarity
Dave,Henry,0.35134998698213477,SF,Engineering,Frontend,Social Connections,similarity
Dave,Iris,0.36717178391329913,SF,Engineering,Frontend,Social Connections,similarity
Dave,Jack,0.6544614976467812,SF,Engineering,Frontend,Social Connections,similarity
Dave,Kate,0.483884883203359,SF,Engineering,Frontend,Social Connections,similarity
Dave,Leo,0.8857626371212243,SF,Engineering,Frontend,Social Connections,similarity
Eve,Frank,0.3988414020019503,SF,Engineering,Backend,Social Connections,similarity
Eve,Grace,0.5755119561217428,SF,Engineering,Backend,Social Connections,similarity
Eve,Henry,0.4621895640039826,SF,Engineering,Backend,Social Connections,similarity
Eve,Iris,0.5461423321179641,SF,Engineering,Backend,Social Connections,similarity
Eve,Jack,0.46691373593164065,SF,Engineering,Backend,Social Connections,similarity
Eve,Kate,0.479632783338382,SF,Engineering,Backend,Social Connections,similarity
Eve,Leo,0.7617384070385828,SF,Engineering,Backend,Social Connections,similarity
Frank,Grace,0.8358604481268025,NYC,Marketing,Digital,Social Connections,similarity
Frank,Henry,0.6259328176778169,NYC,Marketing,Digital,Social Connections,similarity
Frank,Iris,0.535977728152918,NYC,Marketing,Digital,Social Connections,similarity
Frank,Jack,0.4374036212383968,NYC,Marketing,Digital,Social Connections,similarity
Frank,Kate,0.5508207694818223,NYC,Marketing,Digital,Social Connections,similarity
Frank,Leo,0.506112665250402,NYC,Marketing,Digital,Social Connections,similarity
Grace,Henry,0.706187726002922,LA,Marketing,Digital,Social Connections,similarity
Grace,Iris,0.34544095527963137,LA,Marketing,Digital,Social Connections,similarity
Grace,Jack,0.5111014065846383,LA,Marketing,Digital,Social Connections,similarity
Grace,Kate,0.6357417564802119,LA,Marketing,Digital,Social Connections,similarity
Grace,Leo,0.4654906073114946,LA,Marketing,Digital,Social Connections,similarity
Henry,Iris,0.4010681118749976,LA,Marketing,Content,Social Connections,similarity
Henry,Jack,0.5131065103557704,LA,Marketing,Content,Social Connections,similarity
Henry,Kate,0.5031261140791673,LA,Marketing,Content,Social Connections,similarity
Henry,Leo,0.42163139023204654,LA,Marketing,Content,Social Connections,similarity
Iris,Jack,0.7756363057462577,NYC,Sales,Enterprise,Social Connections,similarity
Iris,Kate,0.6038563007977558,NYC,Sales,Enterprise,Social Connections,similarity
Iris,Leo,0.3770079924452961,NYC,Sales,Enterprise,Social Connections,similarity
Jack,Kate,0.5471527354439745,SF,Sales,Enterprise,Social Connections,similarity
Jack,Leo,0.41919108103861513,SF,Sales,Enterprise,Social Connections,similarity
Kate,Leo,0.4788213077355884,LA,Sales,SMB,Social Connections,similarity

</script><script type="text/plain" id="city_graph_data" data-format="csv_embedded" data-src="">
node1,node2,strength,region,correlation_method,scenario
New York,Boston,0.5702859352991675,Northeast,pearson,Economic Indicators
New York,Philadelphia,0.49190285960150115,Northeast,pearson,Economic Indicators
New York,Washington DC,0.6110985471158417,Northeast,pearson,Economic Indicators
New York,Chicago,0.613251942648242,Northeast,pearson,Economic Indicators
New York,Detroit,0.6350574338804235,Northeast,pearson,Economic Indicators
New York,Minneapolis,0.6429897099980181,Northeast,pearson,Economic Indicators
New York,Los Angeles,0.3079395765050166,Northeast,pearson,Economic Indicators
New York,San Francisco,0.39628419185414804,Northeast,pearson,Economic Indicators
New York,Seattle,0.29933474236731683,Northeast,pearson,Economic Indicators
New York,Portland,0.36908415931727123,Northeast,pearson,Economic Indicators
New York,Miami,0.5649657197205236,Northeast,pearson,Economic Indicators
New York,Atlanta,0.5502575168989763,Northeast,pearson,Economic Indicators
New York,Houston,0.5889297313965198,Northeast,pearson,Economic Indicators
Boston,Philadelphia,0.4537479067950908,Northeast,pearson,Economic Indicators
Boston,Washington DC,0.49016342980089617,Northeast,pearson,Economic Indicators
Boston,Chicago,0.6517075744625432,Northeast,pearson,Economic Indicators
Boston,Detroit,0.5750679152479762,Northeast,pearson,Economic Indicators
Boston,Minneapolis,0.6369012743605565,Northeast,pearson,Economic Indicators
Boston,Los Angeles,0.3440120877304144,Northeast,pearson,Economic Indicators
Boston,San Francisco,0.36608477974859605,Northeast,pearson,Economic Indicators
Boston,Seattle,0.30772782724932984,Northeast,pearson,Economic Indicators
Boston,Portland,0.37134323747403414,Northeast,pearson,Economic Indicators
Boston,Miami,0.5671315310521662,Northeast,pearson,Economic Indicators
Boston,Atlanta,0.550989258442784,Northeast,pearson,Economic Indicators
Boston,Houston,0.5892500182140888,Northeast,pearson,Economic Indicators
Philadelphia,Washington DC,0.5665456279231919,Northeast,pearson,Economic Indicators
Philadelphia,Chicago,0.7243892706336875,Northeast,pearson,Economic Indicators
Philadelphia,Detroit,0.6708471389711236,Northeast,pearson,Economic Indicators
Philadelphia,Minneapolis,0.6251694736572742,Northeast,pearson,Economic Indicators
Philadelphia,Los Angeles,0.3367405646157443,Northeast,pearson,Economic Indicators
Philadelphia,San Francisco,0.36864990920392116,Northeast,pearson,Economic Indicators
Philadelphia,Seattle,0.3684864824496871,Northeast,pearson,Economic Indicators
Philadelphia,Portland,0.3040614306563334,Northeast,pearson,Economic Indicators
Philadelphia,Miami,0.5807314113284132,Northeast,pearson,Economic Indicators
Philadelphia,Atlanta,0.5771638405181166,Northeast,pearson,Economic Indicators
Philadelphia,Houston,0.5684634162889786,Northeast,pearson,Economic Indicators
Washington DC,Chicago,0.6419536711340548,Northeast,pearson,Economic Indicators
Washington DC,Detroit,0.6448152925810522,Northeast,pearson,Economic Indicators
Washington DC,Minneapolis,0.6598626643850626,Northeast,pearson,Economic Indicators
Washington DC,Los Angeles,0.36599715740996874,Northeast,pearson,Economic Indicators
Washington DC,San Francisco,0.40893785590040455,Northeast,pearson,Economic Indicators
Washington DC,Seattle,0.30401394317706265,Northeast,pearson,Economic Indicators
Washington DC,Portland,0.37285839608961413,Northeast,pearson,Economic Indicators
Washington DC,Miami,0.4934540545827026,Northeast,pearson,Economic Indicators
Washington DC,Atlanta,0.5724068008730278,Northeast,pearson,Economic Indicators
Washington DC,Houston,0.4965918500709733,Northeast,pearson,Economic Indicators
Chicago,Detroit,0.7955127150333742,Midwest,pearson,Economic Indicators
Chicago,Minneapolis,0.7799570757202721,Midwest,pearson,Economic Indicators
Chicago,Los Angeles,0.3000110620857371,Midwest,pearson,Economic Indicators
Chicago,San Francisco,0.35278975598710377,Midwest,pearson,Economic Indicators
Chicago,Seattle,0.30965430509875447,Midwest,pearson,Economic Indicators
Chicago,Portland,0.2519441843311287,Midwest,pearson,Economic Indicators
Chicago,Miami,0.6916637416211716,Midwest,pearson,Economic Indicators
Chicago,Atlanta,0.6935296982914659,Midwest,pearson,Economic Indicators
Chicago,Houston,0.7112605801325642,Midwest,pearson,Economic Indicators
Detroit,Minneapolis,0.7585465557706166,Midwest,pearson,Economic Indicators
Detroit,Los Angeles,0.2572757447940419,Midwest,pearson,Economic Indicators
Detroit,San Francisco,0.30232826971854543,Midwest,pearson,Economic Indicators
Detroit,Seattle,0.18815928331481668,Midwest,pearson,Economic Indicators
Detroit,Portland,0.22715574511495948,Midwest,pearson,Economic Indicators
Detroit,Miami,0.7120707124488015,Midwest,pearson,Economic Indicators
Detroit,Atlanta,0.6875530216796439,Midwest,pearson,Economic Indicators
Detroit,Houston,0.6776191694284623,Midwest,pearson,Economic Indicators
Minneapolis,Los Angeles,0.24364117954578657,Midwest,pearson,Economic Indicators
Minneapolis,San Francisco,0.3329463919868951,Midwest,pearson,Economic Indicators
Minneapolis,Seattle,0.2896511103906391,Midwest,pearson,Economic Indicators
Minneapolis,Portland,0.2433420173368907,Midwest,pearson,Economic Indicators
Minneapolis,Miami,0.7012756801902211,Midwest,pearson,Economic Indicators
Minneapolis,Atlanta,0.7047388269811878,Midwest,pearson,Economic Indicators
Minneapolis,Houston,0.6320287747966945,Midwest,pearson,Economic Indicators
Los Angeles,San Francisco,0.4639699388169451,West,pearson,Economic Indicators
Los Angeles,Seattle,0.329627459181722,West,pearson,Economic Indicators
Los Angeles,Portland,0.4206639671392409,West,pearson,Economic Indicators
Los Angeles,Miami,0.25089266812428695,West,pearson,Economic Indicators
Los Angeles,Atlanta,0.33813039396266287,West,pearson,Economic Indicators
Los Angeles,Houston,0.19842185738994328,West,pearson,Economic Indicators
San Francisco,Seattle,0.40831421092837283,West,pearson,Economic Indicators
San Francisco,Portland,0.39922858566123054,West,pearson,Economic Indicators
San Francisco,Miami,0.3297492239141558,West,pearson,Economic Indicators
San Francisco,Atlanta,0.263490233565228,West,pearson,Economic Indicators
San Francisco,Houston,0.2966478143123519,West,pearson,Economic Indicators
Seattle,Portland,0.4166955066671063,West,pearson,Economic Indicators
Seattle,Miami,0.1914932498594171,West,pearson,Economic Indicators
Seattle,Atlanta,0.22775513351240034,West,pearson,Economic Indicators
Seattle,Houston,0.20248084444618852,West,pearson,Economic Indicators
Portland,Miami,0.25368545363896733,West,pearson,Economic Indicators
Portland,Atlanta,0.21796722461400947,West,pearson,Economic Indicators
Portland,Houston,0.14637380853901452,West,pearson,Economic Indicators
Miami,Atlanta,0.5655683265266407,Southeast,pearson,Economic Indicators
Miami,Houston,0.6537265991493293,Southeast,pearson,Economic Indicators
Atlanta,Houston,0.5472705417970031,Southeast,pearson,Economic Indicators
New York,Boston,0.5579749208953474,Northeast,spearman,Economic Indicators
New York,Philadelphia,0.49077991327786236,Northeast,spearman,Economic Indicators
New York,Washington DC,0.5952127036212351,Northeast,spearman,Economic Indicators
New York,Chicago,0.6033985702566506,Northeast,spearman,Economic Indicators
New York,Detroit,0.5925700222664947,Northeast,spearman,Economic Indicators
New York,Minneapolis,0.5802941521153169,Northeast,spearman,Economic Indicators
New York,Los Angeles,0.338122582913395,Northeast,spearman,Economic Indicators
New York,San Francisco,0.42201160201570365,Northeast,spearman,Economic Indicators
New York,Seattle,0.3310881284425172,Northeast,spearman,Economic Indicators
New York,Portland,0.38762451658267894,Northeast,spearman,Economic Indicators
New York,Miami,0.5495575999062462,Northeast,spearman,Economic Indicators
New York,Atlanta,0.5355179889839446,Northeast,spearman,Economic Indicators
New York,Houston,0.5445593577874135,Northeast,spearman,Economic Indicators
Boston,Philadelphia,0.4433845072073127,Northeast,spearman,Economic Indicators
Boston,Washington DC,0.5034688855033399,Northeast,spearman,Economic Indicators
Boston,Chicago,0.6384858783546231,Northeast,spearman,Economic Indicators
Boston,Detroit,0.5446970584788468,Northeast,spearman,Economic Indicators
Boston,Minneapolis,0.6120092581741473,Northeast,spearman,Economic Indicators
Boston,Los Angeles,0.40776690495722484,Northeast,spearman,Economic Indicators
Boston,San Francisco,0.38756299074182576,Northeast,spearman,Economic Indicators
Boston,Seattle,0.3561232860658619,Northeast,spearman,Economic Indicators
Boston,Portland,0.4323860307043243,Northeast,spearman,Economic Indicators
Boston,Miami,0.4987548341732098,Northeast,spearman,Economic Indicators
Boston,Atlanta,0.5129262861830539,Northeast,spearman,Economic Indicators
Boston,Houston,0.4954412281729754,Northeast,spearman,Economic Indicators
Philadelphia,Washington DC,0.5780821516465486,Northeast,spearman,Economic Indicators
Philadelphia,Chicago,0.6818821047697174,Northeast,spearman,Economic Indicators
Philadelphia,Detroit,0.6691345365053322,Northeast,spearman,Economic Indicators
Philadelphia,Minneapolis,0.6222723543888432,Northeast,spearman,Economic Indicators
Philadelphia,Los Angeles,0.34534161490683224,Northeast,spearman,Economic Indicators
Philadelphia,San Francisco,0.36170748857377233,Northeast,spearman,Economic Indicators
Philadelphia,Seattle,0.3720760576585022,Northeast,spearman,Economic Indicators
Philadelphia,Portland,0.28472694245868974,Northeast,spearman,Economic Indicators
Philadelphia,Miami,0.5540987929215984,Northeast,spearman,Economic Indicators
Philadelphia,Atlanta,0.5586165475213875,Northeast,spearman,Economic Indicators
Philadelphia,Houston,0.5640454705261924,Northeast,spearman,Economic Indicators
Washington DC,Chicago,0.6523116137349114,Northeast,spearman,Economic Indicators
Washington DC,Detroit,0.6398218680417203,Northeast,spearman,Economic Indicators
Washington DC,Minneapolis,0.6312053205203327,Northeast,spearman,Economic Indicators
Washington DC,Los Angeles,0.39250849642564156,Northeast,spearman,Economic Indicators
Washington DC,San Francisco,0.4269219500761748,Northeast,spearman,Economic Indicators
Washington DC,Seattle,0.3560646900269541,Northeast,spearman,Economic Indicators
Washington DC,Portland,0.43176784249384736,Northeast,spearman,Economic Indicators
Washington DC,Miami,0.46306984647837796,Northeast,spearman,Economic Indicators
Washington DC,Atlanta,0.5474774405250205,Northeast,spearman,Economic Indicators
Washington DC,Houston,0.5091556310793389,Northeast,spearman,Economic Indicators
Chicago,Detroit,0.7587366694011484,Midwest,spearman,Economic Indicators
Chicago,Minneapolis,0.6672008672213757,Midwest,spearman,Economic Indicators
Chicago,Los Angeles,0.3726708074534161,Midwest,spearman,Economic Indicators
Chicago,San Francisco,0.4072161021914918,Midwest,spearman,Economic Indicators
Chicago,Seattle,0.3703797023321223,Midwest,spearman,Economic Indicators
Chicago,Portland,0.3201628969881635,Midwest,spearman,Economic Indicators
Chicago,Miami,0.6894263447790928,Midwest,spearman,Economic Indicators
Chicago,Atlanta,0.6667115902964958,Midwest,spearman,Economic Indicators
Chicago,Houston,0.6749062463377474,Midwest,spearman,Economic Indicators
Detroit,Minneapolis,0.692180358607758,Midwest,spearman,Economic Indicators
Detroit,Los Angeles,0.31583850931677016,Midwest,spearman,Economic Indicators
Detroit,San Francisco,0.3262187976092816,Midwest,spearman,Economic Indicators
Detroit,Seattle,0.25137114731044174,Midwest,spearman,Economic Indicators
Detroit,Portland,0.26594398218680415,Midwest,spearman,Economic Indicators
Detroit,Miami,0.6919664830657446,Midwest,spearman,Economic Indicators
Detroit,Atlanta,0.6933639985936949,Midwest,spearman,Economic Indicators
Detroit,Houston,0.6488954646665884,Midwest,spearman,Economic Indicators
Minneapolis,Los Angeles,0.3200310559006211,Midwest,spearman,Economic Indicators
Minneapolis,San Francisco,0.36987284659557007,Midwest,spearman,Economic Indicators
Minneapolis,Seattle,0.3554113441931325,Midwest,spearman,Economic Indicators
Minneapolis,Portland,0.2912984882221961,Midwest,spearman,Economic Indicators
Minneapolis,Miami,0.6553498183522792,Midwest,spearman,Economic Indicators
Minneapolis,Atlanta,0.6662369623813429,Midwest,spearman,Economic Indicators
Minneapolis,Houston,0.574065393179421,Midwest,spearman,Economic Indicators
Los Angeles,San Francisco,0.48583440759404656,West,spearman,Economic Indicators
Los Angeles,Seattle,0.3287267080745341,West,spearman,Economic Indicators
Los Angeles,Portland,0.45633716160787524,West,spearman,Economic Indicators
Los Angeles,Miami,0.2752168053439587,West,spearman,Economic Indicators
Los Angeles,Atlanta,0.33131958279620294,West,spearman,Economic Indicators
Los Angeles,Houston,0.2257295206844017,West,spearman,Economic Indicators
San Francisco,Seattle,0.394782022735263,West,spearman,Economic Indicators
San Francisco,Portland,0.4398804640806281,West,spearman,Economic Indicators
San Francisco,Miami,0.32547755771709824,West,spearman,Economic Indicators
San Francisco,Atlanta,0.2599876948318293,West,spearman,Economic Indicators
San Francisco,Houston,0.31384917379585137,West,spearman,Economic Indicators
Seattle,Portland,0.46431794210711347,West,spearman,Economic Indicators
Seattle,Miami,0.2305666236962381,West,spearman,Economic Indicators
Seattle,Atlanta,0.2720848470643384,West,spearman,Economic Indicators
Seattle,Houston,0.23639985936950658,West,spearman,Economic Indicators
Portland,Miami,0.27403609515996713,West,spearman,Economic Indicators
Portland,Atlanta,0.24569612094222426,West,spearman,Economic Indicators
Portland,Houston,0.1953826321340677,West,spearman,Economic Indicators
Miami,Atlanta,0.5614438063986874,Southeast,spearman,Economic Indicators
Miami,Houston,0.5912135239657799,Southeast,spearman,Economic Indicators
Atlanta,Houston,0.5267285831477792,Southeast,spearman,Economic Indicators

</script><script type="text/plain" id="strategy_graph_data_global" data-format="csv_embedded" data-src="">
node1,node2,strength,strategy_type,sharpe_ratio,scenario,correlation_method
Momentum,Mean Reversion,0.4706873256780272,Equity,1.8,Strategy Correlations,pearson
Momentum,Trend Following,0.5304389237252323,Equity,1.8,Strategy Correlations,pearson
Momentum,Pairs Trading,0.4055944473258772,Equity,1.8,Strategy Correlations,pearson
Momentum,Statistical Arbitrage,0.4319445405944966,Equity,1.8,Strategy Correlations,pearson
Momentum,Market Making,0.058507186814920065,Equity,1.8,Strategy Correlations,pearson
Momentum,Volatility Arbitrage,0.08786324441761062,Equity,1.8,Strategy Correlations,pearson
Momentum,Delta Hedging,-0.02310103992362028,Equity,1.8,Strategy Correlations,pearson
Momentum,Credit Spread,0.020959725827032927,Equity,1.8,Strategy Correlations,pearson
Momentum,Yield Curve,-0.11226880438795456,Equity,1.8,Strategy Correlations,pearson
Momentum,Carry Trade,0.10010012037624633,Equity,1.8,Strategy Correlations,pearson
Momentum,Breakout,-0.08994070376455313,Equity,1.8,Strategy Correlations,pearson
Mean Reversion,Trend Following,0.5088503202860886,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Pairs Trading,0.5727828482633195,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Statistical Arbitrage,0.33746237356803466,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Market Making,0.01103432677663907,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Volatility Arbitrage,0.07819792970841216,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Delta Hedging,-0.19365015312747336,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Credit Spread,-0.11677192405349146,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Yield Curve,0.023931574176685455,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Carry Trade,0.12351389619882874,Equity,1.2,Strategy Correlations,pearson
Mean Reversion,Breakout,0.07059162341419567,Equity,1.2,Strategy Correlations,pearson
Trend Following,Pairs Trading,0.6030140684041536,Equity,0.9,Strategy Correlations,pearson
Trend Following,Statistical Arbitrage,0.5974291690297318,Equity,0.9,Strategy Correlations,pearson
Trend Following,Market Making,0.014109953228847949,Equity,0.9,Strategy Correlations,pearson
Trend Following,Volatility Arbitrage,-0.15913912581201412,Equity,0.9,Strategy Correlations,pearson
Trend Following,Delta Hedging,-0.026553352614702763,Equity,0.9,Strategy Correlations,pearson
Trend Following,Credit Spread,0.058617484589650826,Equity,0.9,Strategy Correlations,pearson
Trend Following,Yield Curve,-0.07299258485736299,Equity,0.9,Strategy Correlations,pearson
Trend Following,Carry Trade,-0.10494431121209678,Equity,0.9,Strategy Correlations,pearson
Trend Following,Breakout,-0.06781803717723262,Equity,0.9,Strategy Correlations,pearson
Pairs Trading,Statistical Arbitrage,0.6256629792547672,Equity,1.5,Strategy Correlations,pearson
Pairs Trading,Market Making,-0.14503387096402343,Equity,1.5,Strategy Correlations,pearson
Pairs Trading,Volatility Arbitrage,0.1525469818695444,Equity,1.5,Strategy Correlations,pearson
Pairs Trading,Delta Hedging,0.14341722876929908,Equity,1.5,Strategy Correlations,pearson
Pairs Trading,Credit Spread,-0.07373032628204382,Equity,1.5,Strategy Correlations,pearson
Pairs Trading,Yield Curve,0.05165313353241752,Equity,1.5,Strategy Correlations,pearson
Pairs Trading,Carry Trade,0.04311999945889272,Equity,1.5,Strategy Correlations,pearson
Pairs Trading,Breakout,-0.1004298209503519,Equity,1.5,Strategy Correlations,pearson
Statistical Arbitrage,Market Making,-0.14842093664100384,Equity,2.1,Strategy Correlations,pearson
Statistical Arbitrage,Volatility Arbitrage,0.011358638522432601,Equity,2.1,Strategy Correlations,pearson
Statistical Arbitrage,Delta Hedging,-0.03704243101451646,Equity,2.1,Strategy Correlations,pearson
Statistical Arbitrage,Credit Spread,-0.006372364092572191,Equity,2.1,Strategy Correlations,pearson
Statistical Arbitrage,Yield Curve,0.1812444383484209,Equity,2.1,Strategy Correlations,pearson
Statistical Arbitrage,Carry Trade,-0.1449183282775729,Equity,2.1,Strategy Correlations,pearson
Statistical Arbitrage,Breakout,-0.15844644682424427,Equity,2.1,Strategy Correlations,pearson
Market Making,Volatility Arbitrage,0.39613100213513597,Options,-0.3,Strategy Correlations,pearson
Market Making,Delta Hedging,0.622131183626647,Options,-0.3,Strategy Correlations,pearson
Market Making,Credit Spread,-0.0373350650346759,Options,-0.3,Strategy Correlations,pearson
Market Making,Yield Curve,0.1668044720987269,Options,-0.3,Strategy Correlations,pearson
Market Making,Carry Trade,-0.074344103768897,Options,-0.3,Strategy Correlations,pearson
Market Making,Breakout,0.17533302972204318,Options,-0.3,Strategy Correlations,pearson
Volatility Arbitrage,Delta Hedging,0.31392015017478503,Options,1.1,Strategy Correlations,pearson
Volatility Arbitrage,Credit Spread,0.15691516461432126,Options,1.1,Strategy Correlations,pearson
Volatility Arbitrage,Yield Curve,-0.04378837012727432,Options,1.1,Strategy Correlations,pearson
Volatility Arbitrage,Carry Trade,0.16805370805277348,Options,1.1,Strategy Correlations,pearson
Volatility Arbitrage,Breakout,-0.1859084453371601,Options,1.1,Strategy Correlations,pearson
Delta Hedging,Credit Spread,-0.051623233815797864,Options,0.5,Strategy Correlations,pearson
Delta Hedging,Yield Curve,0.01499317764513003,Options,0.5,Strategy Correlations,pearson
Delta Hedging,Carry Trade,0.030013988409741454,Options,0.5,Strategy Correlations,pearson
Delta Hedging,Breakout,-0.04016742823640512,Options,0.5,Strategy Correlations,pearson
Credit Spread,Yield Curve,0.569280132765688,Fixed Income,1.6,Strategy Correlations,pearson
Credit Spread,Carry Trade,-0.011176240685792649,Fixed Income,1.6,Strategy Correlations,pearson
Credit Spread,Breakout,0.09158509658475261,Fixed Income,1.6,Strategy Correlations,pearson
Yield Curve,Carry Trade,-0.03957242164385616,Fixed Income,0.8,Strategy Correlations,pearson
Yield Curve,Breakout,0.1257212691380814,Fixed Income,0.8,Strategy Correlations,pearson
Carry Trade,Breakout,0.15995735964363478,FX,1.3,Strategy Correlations,pearson

</script><script type="text/plain" id="strategy_graph_data_pervariable" data-format="csv_embedded" data-src="">
node1,node2,strength,strategy_type,sharpe_ratio,return_pct,volatility_pct,scenario,correlation_method
Momentum,Mean Reversion,0.4706873256780272,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Trend Following,0.5304389237252323,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Pairs Trading,0.4055944473258772,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Statistical Arbitrage,0.4319445405944966,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Market Making,0.058507186814920065,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Volatility Arbitrage,0.08786324441761062,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Delta Hedging,-0.02310103992362028,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Credit Spread,0.020959725827032927,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Yield Curve,-0.11226880438795456,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Carry Trade,0.10010012037624633,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Momentum,Breakout,-0.08994070376455313,Equity,1.8,12.5,15.0,Multi-Metric Analysis,pearson
Mean Reversion,Trend Following,0.5088503202860886,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Pairs Trading,0.5727828482633195,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Statistical Arbitrage,0.33746237356803466,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Market Making,0.01103432677663907,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Volatility Arbitrage,0.07819792970841216,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Delta Hedging,-0.19365015312747336,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Credit Spread,-0.11677192405349146,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Yield Curve,0.023931574176685455,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Carry Trade,0.12351389619882874,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Mean Reversion,Breakout,0.07059162341419567,Equity,1.2,8.3,12.5,Multi-Metric Analysis,pearson
Trend Following,Pairs Trading,0.6030140684041536,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Trend Following,Statistical Arbitrage,0.5974291690297318,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Trend Following,Market Making,0.014109953228847949,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Trend Following,Volatility Arbitrage,-0.15913912581201412,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Trend Following,Delta Hedging,-0.026553352614702763,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Trend Following,Credit Spread,0.058617484589650826,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Trend Following,Yield Curve,-0.07299258485736299,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Trend Following,Carry Trade,-0.10494431121209678,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Trend Following,Breakout,-0.06781803717723262,Equity,0.9,6.1,18.0,Multi-Metric Analysis,pearson
Pairs Trading,Statistical Arbitrage,0.6256629792547672,Equity,1.5,10.2,14.5,Multi-Metric Analysis,pearson
Pairs Trading,Market Making,-0.14503387096402343,Equity,1.5,10.2,14.5,Multi-Metric Analysis,pearson
Pairs Trading,Volatility Arbitrage,0.1525469818695444,Equity,1.5,10.2,14.5,Multi-Metric Analysis,pearson
Pairs Trading,Delta Hedging,0.14341722876929908,Equity,1.5,10.2,14.5,Multi-Metric Analysis,pearson
Pairs Trading,Credit Spread,-0.07373032628204382,Equity,1.5,10.2,14.5,Multi-Metric Analysis,pearson
Pairs Trading,Yield Curve,0.05165313353241752,Equity,1.5,10.2,14.5,Multi-Metric Analysis,pearson
Pairs Trading,Carry Trade,0.04311999945889272,Equity,1.5,10.2,14.5,Multi-Metric Analysis,pearson
Pairs Trading,Breakout,-0.1004298209503519,Equity,1.5,10.2,14.5,Multi-Metric Analysis,pearson
Statistical Arbitrage,Market Making,-0.14842093664100384,Equity,2.1,15.8,11.2,Multi-Metric Analysis,pearson
Statistical Arbitrage,Volatility Arbitrage,0.011358638522432601,Equity,2.1,15.8,11.2,Multi-Metric Analysis,pearson
Statistical Arbitrage,Delta Hedging,-0.03704243101451646,Equity,2.1,15.8,11.2,Multi-Metric Analysis,pearson
Statistical Arbitrage,Credit Spread,-0.006372364092572191,Equity,2.1,15.8,11.2,Multi-Metric Analysis,pearson
Statistical Arbitrage,Yield Curve,0.1812444383484209,Equity,2.1,15.8,11.2,Multi-Metric Analysis,pearson
Statistical Arbitrage,Carry Trade,-0.1449183282775729,Equity,2.1,15.8,11.2,Multi-Metric Analysis,pearson
Statistical Arbitrage,Breakout,-0.15844644682424427,Equity,2.1,15.8,11.2,Multi-Metric Analysis,pearson
Market Making,Volatility Arbitrage,0.39613100213513597,Options,-0.3,-2.1,22.0,Multi-Metric Analysis,pearson
Market Making,Delta Hedging,0.622131183626647,Options,-0.3,-2.1,22.0,Multi-Metric Analysis,pearson
Market Making,Credit Spread,-0.0373350650346759,Options,-0.3,-2.1,22.0,Multi-Metric Analysis,pearson
Market Making,Yield Curve,0.1668044720987269,Options,-0.3,-2.1,22.0,Multi-Metric Analysis,pearson
Market Making,Carry Trade,-0.074344103768897,Options,-0.3,-2.1,22.0,Multi-Metric Analysis,pearson
Market Making,Breakout,0.17533302972204318,Options,-0.3,-2.1,22.0,Multi-Metric Analysis,pearson
Volatility Arbitrage,Delta Hedging,0.31392015017478503,Options,1.1,7.5,16.5,Multi-Metric Analysis,pearson
Volatility Arbitrage,Credit Spread,0.15691516461432126,Options,1.1,7.5,16.5,Multi-Metric Analysis,pearson
Volatility Arbitrage,Yield Curve,-0.04378837012727432,Options,1.1,7.5,16.5,Multi-Metric Analysis,pearson
Volatility Arbitrage,Carry Trade,0.16805370805277348,Options,1.1,7.5,16.5,Multi-Metric Analysis,pearson
Volatility Arbitrage,Breakout,-0.1859084453371601,Options,1.1,7.5,16.5,Multi-Metric Analysis,pearson
Delta Hedging,Credit Spread,-0.051623233815797864,Options,0.5,3.8,19.0,Multi-Metric Analysis,pearson
Delta Hedging,Yield Curve,0.01499317764513003,Options,0.5,3.8,19.0,Multi-Metric Analysis,pearson
Delta Hedging,Carry Trade,0.030013988409741454,Options,0.5,3.8,19.0,Multi-Metric Analysis,pearson
Delta Hedging,Breakout,-0.04016742823640512,Options,0.5,3.8,19.0,Multi-Metric Analysis,pearson
Credit Spread,Yield Curve,0.569280132765688,Fixed Income,1.6,11.0,13.5,Multi-Metric Analysis,pearson
Credit Spread,Carry Trade,-0.011176240685792649,Fixed Income,1.6,11.0,13.5,Multi-Metric Analysis,pearson
Credit Spread,Breakout,0.09158509658475261,Fixed Income,1.6,11.0,13.5,Multi-Metric Analysis,pearson
Yield Curve,Carry Trade,-0.03957242164385616,Fixed Income,0.8,5.5,17.5,Multi-Metric Analysis,pearson
Yield Curve,Breakout,0.1257212691380814,Fixed Income,0.8,5.5,17.5,Multi-Metric Analysis,pearson
Carry Trade,Breakout,0.15995735964363478,FX,1.3,9.2,14.0,Multi-Metric Analysis,pearson

</script><script type="text/plain" id="market_graph_data" data-format="csv_embedded" data-src="">
node1,node2,strength,industry,returns,gdp_growth,population,market_cap,scenario,correlation_method
Kenya,Rwanda,0.6890879211467975,Mixed Economy,7.2,6.1,54.0,115.0,African Markets 2025,economic
Kenya,Tanzania,0.7429509729312648,Mixed Economy,7.2,6.1,54.0,115.0,African Markets 2025,economic
Kenya,Uganda,0.39483825765717395,Mixed Economy,7.2,6.1,54.0,115.0,African Markets 2025,economic
Kenya,Ethiopia,0.6274480349569447,Mixed Economy,7.2,6.1,54.0,115.0,African Markets 2025,economic
Kenya,Nigeria,0.35462745447524846,Mixed Economy,7.2,6.1,54.0,115.0,African Markets 2025,economic
Kenya,South Africa,0.40077719906309583,Mixed Economy,7.2,6.1,54.0,115.0,African Markets 2025,economic
Kenya,Ghana,0.5608275101738649,Mixed Economy,7.2,6.1,54.0,115.0,African Markets 2025,economic
Rwanda,Tanzania,0.618793273088613,Tourism & Services,5.8,8.2,13.0,12.5,African Markets 2025,economic
Rwanda,Uganda,0.6253868599563821,Tourism & Services,5.8,8.2,13.0,12.5,African Markets 2025,economic
Rwanda,Ethiopia,0.4261406460831141,Tourism & Services,5.8,8.2,13.0,12.5,African Markets 2025,economic
Rwanda,Nigeria,0.35277064861242907,Tourism & Services,5.8,8.2,13.0,12.5,African Markets 2025,economic
Rwanda,South Africa,0.7957158077158392,Tourism & Services,5.8,8.2,13.0,12.5,African Markets 2025,economic
Rwanda,Ghana,0.6058341228972615,Tourism & Services,5.8,8.2,13.0,12.5,African Markets 2025,economic
Tanzania,Uganda,0.6292036988690486,Agriculture & Mining,6.5,6.8,60.0,75.0,African Markets 2025,economic
Tanzania,Ethiopia,0.5037418336105222,Agriculture & Mining,6.5,6.8,60.0,75.0,African Markets 2025,economic
Tanzania,Nigeria,0.307260172346635,Agriculture & Mining,6.5,6.8,60.0,75.0,African Markets 2025,economic
Tanzania,South Africa,0.4784024236693001,Agriculture & Mining,6.5,6.8,60.0,75.0,African Markets 2025,economic
Tanzania,Ghana,0.5679972289544468,Agriculture & Mining,6.5,6.8,60.0,75.0,African Markets 2025,economic
Uganda,Ethiopia,0.47005412983511285,Agriculture,4.9,6.2,46.0,45.0,African Markets 2025,economic
Uganda,Nigeria,0.5927109567013827,Agriculture,4.9,6.2,46.0,45.0,African Markets 2025,economic
Uganda,South Africa,0.5593016891217253,Agriculture,4.9,6.2,46.0,45.0,African Markets 2025,economic
Uganda,Ghana,0.7613405904597755,Agriculture,4.9,6.2,46.0,45.0,African Markets 2025,economic
Ethiopia,Nigeria,0.2514754666008944,Agriculture & Manufacturing,8.1,7.5,120.0,95.0,African Markets 2025,economic
Ethiopia,South Africa,0.20848373276165966,Agriculture & Manufacturing,8.1,7.5,120.0,95.0,African Markets 2025,economic
Ethiopia,Ghana,0.3703068896952383,Agriculture & Manufacturing,8.1,7.5,120.0,95.0,African Markets 2025,economic
Nigeria,South Africa,0.5804992524148598,Oil & Services,3.2,5.8,220.0,440.0,African Markets 2025,economic
Nigeria,Ghana,0.5417145452361699,Oil & Services,3.2,5.8,220.0,440.0,African Markets 2025,economic
South Africa,Ghana,0.7945087597688172,Diversified,4.5,4.2,60.0,380.0,African Markets 2025,economic

</script><script type="text/plain" id="stock_graph_data" data-format="csv_embedded" data-src="">
node1,node2,strength,sector,scenario,correlation_method
AAPL,MSFT,0.7774124734944381,Technology,Short-term (60 days),pearson
AAPL,GOOGL,0.7282148236463197,Technology,Short-term (60 days),pearson
AAPL,AMZN,0.7169448937792479,Technology,Short-term (60 days),pearson
AAPL,TSLA,0.8134639136227855,Technology,Short-term (60 days),pearson
AAPL,JPM,-0.0824482281049433,Technology,Short-term (60 days),pearson
AAPL,BAC,0.03673762946233845,Technology,Short-term (60 days),pearson
AAPL,GS,-0.08458498611445675,Technology,Short-term (60 days),pearson
AAPL,WFC,-0.12096420565983071,Technology,Short-term (60 days),pearson
AAPL,JNJ,-0.03175925480345926,Technology,Short-term (60 days),pearson
AAPL,PFE,0.005774403799553523,Technology,Short-term (60 days),pearson
AAPL,UNH,0.041018282173004364,Technology,Short-term (60 days),pearson
AAPL,XOM,0.014615629794144835,Technology,Short-term (60 days),pearson
AAPL,CVX,0.1058473080474797,Technology,Short-term (60 days),pearson
AAPL,COP,-0.07615646093366377,Technology,Short-term (60 days),pearson
MSFT,GOOGL,0.7504699357520142,Technology,Short-term (60 days),pearson
MSFT,AMZN,0.779873270393533,Technology,Short-term (60 days),pearson
MSFT,TSLA,0.8635576598314216,Technology,Short-term (60 days),pearson
MSFT,JPM,-0.06500360154475553,Technology,Short-term (60 days),pearson
MSFT,BAC,0.01180685919103562,Technology,Short-term (60 days),pearson
MSFT,GS,-0.12543682639314577,Technology,Short-term (60 days),pearson
MSFT,WFC,-0.19593713801846535,Technology,Short-term (60 days),pearson
MSFT,JNJ,0.026121306876213238,Technology,Short-term (60 days),pearson
MSFT,PFE,0.026707219427540427,Technology,Short-term (60 days),pearson
MSFT,UNH,0.006529069619343859,Technology,Short-term (60 days),pearson
MSFT,XOM,-0.1334618113787656,Technology,Short-term (60 days),pearson
MSFT,CVX,0.04671942623340446,Technology,Short-term (60 days),pearson
MSFT,COP,-0.11938915326109004,Technology,Short-term (60 days),pearson
GOOGL,AMZN,0.7845778048620308,Technology,Short-term (60 days),pearson
GOOGL,TSLA,0.7768198798203378,Technology,Short-term (60 days),pearson
GOOGL,JPM,-0.11647115172885267,Technology,Short-term (60 days),pearson
GOOGL,BAC,-0.009400304883926704,Technology,Short-term (60 days),pearson
GOOGL,GS,-0.1682109497244296,Technology,Short-term (60 days),pearson
GOOGL,WFC,-0.16415394880067993,Technology,Short-term (60 days),pearson
GOOGL,JNJ,0.051495543020717544,Technology,Short-term (60 days),pearson
GOOGL,PFE,-0.07753016743607137,Technology,Short-term (60 days),pearson
GOOGL,UNH,0.07299428559554823,Technology,Short-term (60 days),pearson
GOOGL,XOM,-0.011878255553260475,Technology,Short-term (60 days),pearson
GOOGL,CVX,0.12252193494263013,Technology,Short-term (60 days),pearson
GOOGL,COP,-0.007287319638514604,Technology,Short-term (60 days),pearson
AMZN,TSLA,0.7634136611728671,Technology,Short-term (60 days),pearson
AMZN,JPM,-0.038318577709525965,Technology,Short-term (60 days),pearson
AMZN,BAC,-0.002915891819242129,Technology,Short-term (60 days),pearson
AMZN,GS,-0.1193110382922525,Technology,Short-term (60 days),pearson
AMZN,WFC,-0.20362260016681272,Technology,Short-term (60 days),pearson
AMZN,JNJ,-0.0359766527186055,Technology,Short-term (60 days),pearson
AMZN,PFE,0.038063638641858306,Technology,Short-term (60 days),pearson
AMZN,UNH,0.06639707319906123,Technology,Short-term (60 days),pearson
AMZN,XOM,-0.08937973865690697,Technology,Short-term (60 days),pearson
AMZN,CVX,0.0401522817440109,Technology,Short-term (60 days),pearson
AMZN,COP,-0.054084272509268276,Technology,Short-term (60 days),pearson
TSLA,JPM,-0.09015527554855148,Technology,Short-term (60 days),pearson
TSLA,BAC,0.0674780203251227,Technology,Short-term (60 days),pearson
TSLA,GS,-0.015501055237956956,Technology,Short-term (60 days),pearson
TSLA,WFC,-0.12968966625616324,Technology,Short-term (60 days),pearson
TSLA,JNJ,0.0248865956676091,Technology,Short-term (60 days),pearson
TSLA,PFE,-0.027964574798877352,Technology,Short-term (60 days),pearson
TSLA,UNH,-0.11904884615027914,Technology,Short-term (60 days),pearson
TSLA,XOM,-0.006873097842372978,Technology,Short-term (60 days),pearson
TSLA,CVX,0.203741614394474,Technology,Short-term (60 days),pearson
TSLA,COP,-0.02097287608420575,Technology,Short-term (60 days),pearson
JPM,BAC,0.6532003602508824,Finance,Short-term (60 days),pearson
JPM,GS,0.6221306592194814,Finance,Short-term (60 days),pearson
JPM,WFC,0.7034515780358142,Finance,Short-term (60 days),pearson
JPM,JNJ,-0.1919866714699895,Finance,Short-term (60 days),pearson
JPM,PFE,0.13868984196028075,Finance,Short-term (60 days),pearson
JPM,UNH,0.10946335455316268,Finance,Short-term (60 days),pearson
JPM,XOM,0.2011127589339887,Finance,Short-term (60 days),pearson
JPM,CVX,0.0066106103107645186,Finance,Short-term (60 days),pearson
JPM,COP,0.06537847999844626,Finance,Short-term (60 days),pearson
BAC,GS,0.7071160679233086,Finance,Short-term (60 days),pearson
BAC,WFC,0.6524071759500064,Finance,Short-term (60 days),pearson
BAC,JNJ,-0.022091466444796155,Finance,Short-term (60 days),pearson
BAC,PFE,0.14611449444089358,Finance,Short-term (60 days),pearson
BAC,UNH,0.05918315206659185,Finance,Short-term (60 days),pearson
BAC,XOM,0.30336195126546517,Finance,Short-term (60 days),pearson
BAC,CVX,0.07138116323979918,Finance,Short-term (60 days),pearson
BAC,COP,0.14132862557430514,Finance,Short-term (60 days),pearson
GS,WFC,0.6612950980899773,Finance,Short-term (60 days),pearson
GS,JNJ,-0.0711406127657379,Finance,Short-term (60 days),pearson
GS,PFE,0.02086636219468873,Finance,Short-term (60 days),pearson
GS,UNH,0.025828427633834708,Finance,Short-term (60 days),pearson
GS,XOM,0.16315603620440797,Finance,Short-term (60 days),pearson
GS,CVX,-0.0341460658536425,Finance,Short-term (60 days),pearson
GS,COP,-0.00228512693789985,Finance,Short-term (60 days),pearson
WFC,JNJ,-0.1695613336618138,Finance,Short-term (60 days),pearson
WFC,PFE,-0.1163062811378762,Finance,Short-term (60 days),pearson
WFC,UNH,0.017117952916904898,Finance,Short-term (60 days),pearson
WFC,XOM,0.25582964678330766,Finance,Short-term (60 days),pearson
WFC,CVX,0.10871030474708761,Finance,Short-term (60 days),pearson
WFC,COP,0.20114178527715607,Finance,Short-term (60 days),pearson
JNJ,PFE,0.3065178555226647,Healthcare,Short-term (60 days),pearson
JNJ,UNH,0.26272809127229485,Healthcare,Short-term (60 days),pearson
JNJ,XOM,0.0744669636825777,Healthcare,Short-term (60 days),pearson
JNJ,CVX,0.09788892305464394,Healthcare,Short-term (60 days),pearson
JNJ,COP,0.03936513248606498,Healthcare,Short-term (60 days),pearson
PFE,UNH,0.27212289778876536,Healthcare,Short-term (60 days),pearson
PFE,XOM,-0.08659946571787318,Healthcare,Short-term (60 days),pearson
PFE,CVX,-0.15738176559895176,Healthcare,Short-term (60 days),pearson
PFE,COP,-0.1885754557653039,Healthcare,Short-term (60 days),pearson
UNH,XOM,0.025240046405235615,Healthcare,Short-term (60 days),pearson
UNH,CVX,-0.15094183026053554,Healthcare,Short-term (60 days),pearson
UNH,COP,-0.1444242175967038,Healthcare,Short-term (60 days),pearson
XOM,CVX,0.7526947061189304,Energy,Short-term (60 days),pearson
XOM,COP,0.7784423556087865,Energy,Short-term (60 days),pearson
CVX,COP,0.7409240447699231,Energy,Short-term (60 days),pearson
AAPL,MSFT,0.7971928528389141,Technology,Long-term (250 days),pearson
AAPL,GOOGL,0.7247760416094113,Technology,Long-term (250 days),pearson
AAPL,AMZN,0.7463471511965406,Technology,Long-term (250 days),pearson
AAPL,TSLA,0.7679095459261811,Technology,Long-term (250 days),pearson
AAPL,JPM,-0.02920523153462166,Technology,Long-term (250 days),pearson
AAPL,BAC,0.05364934998720048,Technology,Long-term (250 days),pearson
AAPL,GS,-0.0003227711728646761,Technology,Long-term (250 days),pearson
AAPL,WFC,0.0762933395233198,Technology,Long-term (250 days),pearson
AAPL,JNJ,0.050900013726348316,Technology,Long-term (250 days),pearson
AAPL,PFE,-0.05389156633575425,Technology,Long-term (250 days),pearson
AAPL,UNH,-0.026547808816193185,Technology,Long-term (250 days),pearson
AAPL,XOM,-0.029123629379253627,Technology,Long-term (250 days),pearson
AAPL,CVX,0.01125632390545604,Technology,Long-term (250 days),pearson
AAPL,COP,-0.010236506359463536,Technology,Long-term (250 days),pearson
MSFT,GOOGL,0.7343396367677104,Technology,Long-term (250 days),pearson
MSFT,AMZN,0.7718259156129305,Technology,Long-term (250 days),pearson
MSFT,TSLA,0.7917808923259679,Technology,Long-term (250 days),pearson
MSFT,JPM,-0.00870692561366502,Technology,Long-term (250 days),pearson
MSFT,BAC,0.0715214263779739,Technology,Long-term (250 days),pearson
MSFT,GS,0.03271549329252431,Technology,Long-term (250 days),pearson
MSFT,WFC,0.0823862602976718,Technology,Long-term (250 days),pearson
MSFT,JNJ,0.055936069960647455,Technology,Long-term (250 days),pearson
MSFT,PFE,-0.03731433542195999,Technology,Long-term (250 days),pearson
MSFT,UNH,0.005662811148525698,Technology,Long-term (250 days),pearson
MSFT,XOM,-0.02826387699711945,Technology,Long-term (250 days),pearson
MSFT,CVX,0.03548943084188413,Technology,Long-term (250 days),pearson
MSFT,COP,0.01217401932451676,Technology,Long-term (250 days),pearson
GOOGL,AMZN,0.7457311058520281,Technology,Long-term (250 days),pearson
GOOGL,TSLA,0.748911401834707,Technology,Long-term (250 days),pearson
GOOGL,JPM,-0.04508259214384733,Technology,Long-term (250 days),pearson
GOOGL,BAC,0.06867885181363911,Technology,Long-term (250 days),pearson
GOOGL,GS,-0.01565683348375322,Technology,Long-term (250 days),pearson
GOOGL,WFC,0.03230706583840099,Technology,Long-term (250 days),pearson
GOOGL,JNJ,0.07128122441767899,Technology,Long-term (250 days),pearson
GOOGL,PFE,-0.08932321706367073,Technology,Long-term (250 days),pearson
GOOGL,UNH,0.02078069949812157,Technology,Long-term (250 days),pearson
GOOGL,XOM,0.028976041462998304,Technology,Long-term (250 days),pearson
GOOGL,CVX,0.030077643110931612,Technology,Long-term (250 days),pearson
GOOGL,COP,0.06779329765092718,Technology,Long-term (250 days),pearson
AMZN,TSLA,0.748373792294646,Technology,Long-term (250 days),pearson
AMZN,JPM,0.003794491456811667,Technology,Long-term (250 days),pearson
AMZN,BAC,0.07554866743331734,Technology,Long-term (250 days),pearson
AMZN,GS,0.023671373325188975,Technology,Long-term (250 days),pearson
AMZN,WFC,0.0474689604640582,Technology,Long-term (250 days),pearson
AMZN,JNJ,0.00823451055279486,Technology,Long-term (250 days),pearson
AMZN,PFE,-0.07402482608329262,Technology,Long-term (250 days),pearson
AMZN,UNH,0.010142996459516863,Technology,Long-term (250 days),pearson
AMZN,XOM,0.004058934080590599,Technology,Long-term (250 days),pearson
AMZN,CVX,0.04663791214496197,Technology,Long-term (250 days),pearson
AMZN,COP,0.029602737365675633,Technology,Long-term (250 days),pearson
TSLA,JPM,-0.05110227008061185,Technology,Long-term (250 days),pearson
TSLA,BAC,0.09608978458428288,Technology,Long-term (250 days),pearson
TSLA,GS,0.04275970510652299,Technology,Long-term (250 days),pearson
TSLA,WFC,0.05359024921733781,Technology,Long-term (250 days),pearson
TSLA,JNJ,0.07037621325282524,Technology,Long-term (250 days),pearson
TSLA,PFE,-0.08347606662236887,Technology,Long-term (250 days),pearson
TSLA,UNH,-0.04503433857318089,Technology,Long-term (250 days),pearson
TSLA,XOM,0.014463163387439013,Technology,Long-term (250 days),pearson
TSLA,CVX,0.08861489496675372,Technology,Long-term (250 days),pearson
TSLA,COP,0.05526990952710964,Technology,Long-term (250 days),pearson
JPM,BAC,0.6495409304937002,Finance,Long-term (250 days),pearson
JPM,GS,0.6932371046281164,Finance,Long-term (250 days),pearson
JPM,WFC,0.6975264449675336,Finance,Long-term (250 days),pearson
JPM,JNJ,-0.01653772827078526,Finance,Long-term (250 days),pearson
JPM,PFE,0.08675151378411221,Finance,Long-term (250 days),pearson
JPM,UNH,0.11449389086062364,Finance,Long-term (250 days),pearson
JPM,XOM,0.07327229046693322,Finance,Long-term (250 days),pearson
JPM,CVX,-0.01085966454263143,Finance,Long-term (250 days),pearson
JPM,COP,0.03334328795267473,Finance,Long-term (250 days),pearson
BAC,GS,0.6938833141413305,Finance,Long-term (250 days),pearson
BAC,WFC,0.671589834154253,Finance,Long-term (250 days),pearson
BAC,JNJ,-0.027734836255612693,Finance,Long-term (250 days),pearson
BAC,PFE,-0.047199866689018044,Finance,Long-term (250 days),pearson
BAC,UNH,-0.01796412040344664,Finance,Long-term (250 days),pearson
BAC,XOM,0.10860232118322895,Finance,Long-term (250 days),pearson
BAC,CVX,0.030394477508873495,Finance,Long-term (250 days),pearson
BAC,COP,0.04947947484711314,Finance,Long-term (250 days),pearson
GS,WFC,0.6966193586595394,Finance,Long-term (250 days),pearson
GS,JNJ,-0.006956772912747606,Finance,Long-term (250 days),pearson
GS,PFE,0.007449041329140483,Finance,Long-term (250 days),pearson
GS,UNH,0.01417360573225066,Finance,Long-term (250 days),pearson
GS,XOM,0.017013621808541,Finance,Long-term (250 days),pearson
GS,CVX,-0.038544223079879314,Finance,Long-term (250 days),pearson
GS,COP,0.013327314745586981,Finance,Long-term (250 days),pearson
WFC,JNJ,-0.010928928866613322,Finance,Long-term (250 days),pearson
WFC,PFE,-0.009986773604823293,Finance,Long-term (250 days),pearson
WFC,UNH,0.021471280570271582,Finance,Long-term (250 days),pearson
WFC,XOM,0.07820075785879692,Finance,Long-term (250 days),pearson
WFC,CVX,0.04712751139177629,Finance,Long-term (250 days),pearson
WFC,COP,0.07170737895918972,Finance,Long-term (250 days),pearson
JNJ,PFE,0.4597588328049435,Healthcare,Long-term (250 days),pearson
JNJ,UNH,0.4137280149638163,Healthcare,Long-term (250 days),pearson
JNJ,XOM,-0.1087393845945362,Healthcare,Long-term (250 days),pearson
JNJ,CVX,-0.1359289753274346,Healthcare,Long-term (250 days),pearson
JNJ,COP,-0.08097450879413332,Healthcare,Long-term (250 days),pearson
PFE,UNH,0.4483548859388633,Healthcare,Long-term (250 days),pearson
PFE,XOM,-0.06505050370757108,Healthcare,Long-term (250 days),pearson
PFE,CVX,-0.09594209243088796,Healthcare,Long-term (250 days),pearson
PFE,COP,-0.08455744935977456,Healthcare,Long-term (250 days),pearson
UNH,XOM,-0.08070978960290205,Healthcare,Long-term (250 days),pearson
UNH,CVX,-0.19700681059187766,Healthcare,Long-term (250 days),pearson
UNH,COP,-0.17382140130938034,Healthcare,Long-term (250 days),pearson
XOM,CVX,0.7845773499649997,Energy,Long-term (250 days),pearson
XOM,COP,0.7869506799853874,Energy,Long-term (250 days),pearson
CVX,COP,0.7880814898894273,Energy,Long-term (250 days),pearson
AAPL,MSFT,0.5753640605128552,Technology,Volatility Correlations,pearson
AAPL,GOOGL,0.4663687227586928,Technology,Volatility Correlations,pearson
AAPL,AMZN,0.44092903444174725,Technology,Volatility Correlations,pearson
AAPL,TSLA,0.5396476782296338,Technology,Volatility Correlations,pearson
AAPL,JPM,0.02467158948819663,Technology,Volatility Correlations,pearson
AAPL,BAC,0.05328226788273582,Technology,Volatility Correlations,pearson
AAPL,GS,0.00013954665532134336,Technology,Volatility Correlations,pearson
AAPL,WFC,0.061003307775767374,Technology,Volatility Correlations,pearson
AAPL,JNJ,-0.004589953821187733,Technology,Volatility Correlations,pearson
AAPL,PFE,0.0008341607091569686,Technology,Volatility Correlations,pearson
AAPL,UNH,-0.0023730007964161627,Technology,Volatility Correlations,pearson
AAPL,XOM,0.0239245443672293,Technology,Volatility Correlations,pearson
AAPL,CVX,-0.029488795469551174,Technology,Volatility Correlations,pearson
AAPL,COP,0.08745234676567014,Technology,Volatility Correlations,pearson
MSFT,GOOGL,0.46556854773294587,Technology,Volatility Correlations,pearson
MSFT,AMZN,0.47703993150062424,Technology,Volatility Correlations,pearson
MSFT,TSLA,0.5391962829196753,Technology,Volatility Correlations,pearson
MSFT,JPM,0.027383180579630753,Technology,Volatility Correlations,pearson
MSFT,BAC,0.05865028293166846,Technology,Volatility Correlations,pearson
MSFT,GS,0.10786332051799637,Technology,Volatility Correlations,pearson
MSFT,WFC,0.10560619417081717,Technology,Volatility Correlations,pearson
MSFT,JNJ,0.005368568875967387,Technology,Volatility Correlations,pearson
MSFT,PFE,0.05250858127349495,Technology,Volatility Correlations,pearson
MSFT,UNH,-0.058184366872540784,Technology,Volatility Correlations,pearson
MSFT,XOM,0.03305979073436712,Technology,Volatility Correlations,pearson
MSFT,CVX,-0.036242921384233455,Technology,Volatility Correlations,pearson
MSFT,COP,0.06450739029581648,Technology,Volatility Correlations,pearson
GOOGL,AMZN,0.46085189086642964,Technology,Volatility Correlations,pearson
GOOGL,TSLA,0.45246592570151545,Technology,Volatility Correlations,pearson
GOOGL,JPM,0.04793684072675736,Technology,Volatility Correlations,pearson
GOOGL,BAC,0.02549725670458709,Technology,Volatility Correlations,pearson
GOOGL,GS,0.10163403421610868,Technology,Volatility Correlations,pearson
GOOGL,WFC,0.036251226042097,Technology,Volatility Correlations,pearson
GOOGL,JNJ,-0.0007693682579228903,Technology,Volatility Correlations,pearson
GOOGL,PFE,0.03615314967687872,Technology,Volatility Correlations,pearson
GOOGL,UNH,-0.013028671569162155,Technology,Volatility Correlations,pearson
GOOGL,XOM,0.10186124352668938,Technology,Volatility Correlations,pearson
GOOGL,CVX,-0.0068737184292767305,Technology,Volatility Correlations,pearson
GOOGL,COP,0.1577272644946051,Technology,Volatility Correlations,pearson
AMZN,TSLA,0.47038614047075206,Technology,Volatility Correlations,pearson
AMZN,JPM,0.048148477996765915,Technology,Volatility Correlations,pearson
AMZN,BAC,0.02977144104029714,Technology,Volatility Correlations,pearson
AMZN,GS,0.04872907369934073,Technology,Volatility Correlations,pearson
AMZN,WFC,-0.0010416179013401617,Technology,Volatility Correlations,pearson
AMZN,JNJ,0.02269527073952346,Technology,Volatility Correlations,pearson
AMZN,PFE,-0.025156841682446744,Technology,Volatility Correlations,pearson
AMZN,UNH,-0.03310439749432319,Technology,Volatility Correlations,pearson
AMZN,XOM,0.05906906014159984,Technology,Volatility Correlations,pearson
AMZN,CVX,0.033231755990337015,Technology,Volatility Correlations,pearson
AMZN,COP,0.06353247572243952,Technology,Volatility Correlations,pearson
TSLA,JPM,0.11163714289525069,Technology,Volatility Correlations,pearson
TSLA,BAC,0.0532447647032371,Technology,Volatility Correlations,pearson
TSLA,GS,0.05122163701977548,Technology,Volatility Correlations,pearson
TSLA,WFC,-0.01261179599901188,Technology,Volatility Correlations,pearson
TSLA,JNJ,0.0003913068324057167,Technology,Volatility Correlations,pearson
TSLA,PFE,0.0025175804189954518,Technology,Volatility Correlations,pearson
TSLA,UNH,-0.09152418190660208,Technology,Volatility Correlations,pearson
TSLA,XOM,-0.012038541772814711,Technology,Volatility Correlations,pearson
TSLA,CVX,-0.014657778602780816,Technology,Volatility Correlations,pearson
TSLA,COP,0.10242058325559888,Technology,Volatility Correlations,pearson
JPM,BAC,0.40713243205130073,Finance,Volatility Correlations,pearson
JPM,GS,0.4969302793054016,Finance,Volatility Correlations,pearson
JPM,WFC,0.40425672221026077,Finance,Volatility Correlations,pearson
JPM,JNJ,0.06204472400108672,Finance,Volatility Correlations,pearson
JPM,PFE,-0.06333687270858121,Finance,Volatility Correlations,pearson
JPM,UNH,0.05281525439002768,Finance,Volatility Correlations,pearson
JPM,XOM,0.021677034441649968,Finance,Volatility Correlations,pearson
JPM,CVX,0.051366612096628614,Finance,Volatility Correlations,pearson
JPM,COP,0.008459245925738034,Finance,Volatility Correlations,pearson
BAC,GS,0.4979087624941997,Finance,Volatility Correlations,pearson
BAC,WFC,0.4103775803019631,Finance,Volatility Correlations,pearson
BAC,JNJ,0.07965147555224059,Finance,Volatility Correlations,pearson
BAC,PFE,-0.003238494594309696,Finance,Volatility Correlations,pearson
BAC,UNH,0.05532414498830564,Finance,Volatility Correlations,pearson
BAC,XOM,-0.04381570192535578,Finance,Volatility Correlations,pearson
BAC,CVX,0.026139651726316347,Finance,Volatility Correlations,pearson
BAC,COP,-0.10796600175885292,Finance,Volatility Correlations,pearson
GS,WFC,0.459930671439731,Finance,Volatility Correlations,pearson
GS,JNJ,0.11972559171266367,Finance,Volatility Correlations,pearson
GS,PFE,-0.0295665314950819,Finance,Volatility Correlations,pearson
GS,UNH,0.026901412182305497,Finance,Volatility Correlations,pearson
GS,XOM,-0.03698443219965643,Finance,Volatility Correlations,pearson
GS,CVX,-0.011705301210446639,Finance,Volatility Correlations,pearson
GS,COP,-0.015827817825825156,Finance,Volatility Correlations,pearson
WFC,JNJ,0.06464524321024413,Finance,Volatility Correlations,pearson
WFC,PFE,-0.045933278928399386,Finance,Volatility Correlations,pearson
WFC,UNH,-0.027186319432580083,Finance,Volatility Correlations,pearson
WFC,XOM,-0.015519632551983166,Finance,Volatility Correlations,pearson
WFC,CVX,-0.06305264597656965,Finance,Volatility Correlations,pearson
WFC,COP,-0.0008775740977646425,Finance,Volatility Correlations,pearson
JNJ,PFE,0.17981373691384034,Healthcare,Volatility Correlations,pearson
JNJ,UNH,0.17013439987292858,Healthcare,Volatility Correlations,pearson
JNJ,XOM,0.006353113092021442,Healthcare,Volatility Correlations,pearson
JNJ,CVX,-0.0006734348758861386,Healthcare,Volatility Correlations,pearson
JNJ,COP,-0.10196446018525021,Healthcare,Volatility Correlations,pearson
PFE,UNH,0.20867948259952787,Healthcare,Volatility Correlations,pearson
PFE,XOM,0.07722064876574193,Healthcare,Volatility Correlations,pearson
PFE,CVX,0.07186780160266634,Healthcare,Volatility Correlations,pearson
PFE,COP,0.07094693171537392,Healthcare,Volatility Correlations,pearson
UNH,XOM,0.002327487114228054,Healthcare,Volatility Correlations,pearson
UNH,CVX,0.05394080252179156,Healthcare,Volatility Correlations,pearson
UNH,COP,-0.001518635917862219,Healthcare,Volatility Correlations,pearson
XOM,CVX,0.5526891597288598,Energy,Volatility Correlations,pearson
XOM,COP,0.5684737220607466,Energy,Volatility Correlations,pearson
CVX,COP,0.546567277300785,Energy,Volatility Correlations,pearson

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/graph_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>Graph - Network Visualization Examples</h1>
<p>The Graph chart type displays interactive network graphs with nodes and edges. It can visualize:
<ul>
    <li><strong>Correlation networks:</strong> Show which variables are correlated</li>
    <li><strong>Distance networks:</strong> Display proximity relationships</li>
    <li><strong>Social networks:</strong> Visualize connections between entities</li>
    <li><strong>Any graph structure:</strong> Flexible node and edge data</li>
</ul>
</p>
<p><strong>Interactive features:</strong></p>
<ul>
    <li>Drag nodes to rearrange the layout</li>
    <li>Zoom and pan to explore large networks</li>
    <li>Toggle edge labels on/off</li>
    <li>Color nodes by categorical attributes</li>
    <li>Adjust connection strength cutoff</li>
    <li>Switch between different layout algorithms</li>
</ul>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 1: Stock Correlation Network with Multiple Scenarios</h2>
<p>This example shows correlations between stock returns across different time periods. Stocks are colored by sector to reveal industry clustering patterns.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Multiple scenarios (Short-term, Long-term, Volatility correlations)</li>
    <li>Scenario switching - edges update while nodes stay in place</li>
    <li>Correlation matrix input (high correlation = strong connection)</li>
    <li>Node coloring by sector</li>
    <li>Force-directed (COSE) layout</li>
    <li>Adjustable cutoff to filter weak correlations</li>
    <li>Smart cutoff calculation for optimal visualization</li>
</ul>
<p><strong>Try this:</strong> Switch between scenarios to see how correlations change across different time periods.
Notice how nodes stay in place while edges change - this makes it easy to identify robust correlations.
Adjust the cutoff slider to filter weak correlations. Stocks in the same sector (same color) often cluster together.</p>

    </div>
<br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-stock_network {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>Stock Correlation Network - Multiple Scenarios</h2>
    <p></p>
    <div style="margin-bottom: 10px;">
    <label for="scenario_select_stock_network"><strong>Scenario:</strong></label>
    <select id="scenario_select_stock_network" onchange="updateEdges_stock_network()">
        <option value="Short-term (60 days)">Short-term (60 days)</option>
                <option value="Long-term (250 days)">Long-term (250 days)</option>
                <option value="Volatility Correlations">Volatility Correlations</option>
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <label for="var_select_stock_network"><strong>Select Variables:</strong></label><br>
    <select id="var_select_stock_network" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_stock_network()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_stock_network" onclick="recalculateGraph_stock_network()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_stock_network" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_stock_network"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_stock_network" onchange="updateEdges_stock_network()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_stock_network"><strong>Color nodes by:</strong></label>
    <select id="color_select_stock_network" onchange="updateColors_stock_network()">
        <option value="none">None</option>
        <option value="sector" selected>sector (discrete)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_stock_network"><strong>Layout:</strong></label>
    <select id="layout_select_stock_network" onchange="recalculateGraph_stock_network()">
        <option value="cose" selected>Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_stock_network"
               
               onchange="updateEdgeLabels_stock_network()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_stock_network"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_stock_network">0.5</span>
    </label>
    <input type="range" id="cutoff_slider_stock_network"
           min="0" max="1" step="0.05" value="0.5"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_stock_network').textContent = this.value; updateEdges_stock_network()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_stock_network"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_stock_network">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_stock_network"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_stock_network" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_stock_network" class="graph-tooltip-stock_network"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: stock_graph_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 2: City Proximity Network with Correlation Methods</h2>
<p>This example shows similarity between cities based on their economic indicators, with both Pearson and Spearman correlations available.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Correlation method selector (Pearson vs Spearman)</li>
    <li>Node coloring by geographic region</li>
    <li>Circle layout showing regional grouping</li>
    <li>Dynamic edge filtering based on selected method</li>
</ul>
<p><strong>Try this:</strong> Switch between Pearson and Spearman correlation methods to see how the network changes.
Pearson measures linear relationships while Spearman measures rank-based relationships.</p>

    </div>
<br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-city_network {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>City Economic Similarity Network</h2>
    <p></p>
    
    <div style="margin-bottom: 15px;">
    <label for="var_select_city_network"><strong>Select Variables:</strong></label><br>
    <select id="var_select_city_network" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_city_network()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_city_network" onclick="recalculateGraph_city_network()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_city_network" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_city_network"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_city_network" onchange="updateEdges_city_network()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_city_network"><strong>Color nodes by:</strong></label>
    <select id="color_select_city_network" onchange="updateColors_city_network()">
        <option value="none">None</option>
        <option value="region" selected>region (discrete)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_city_network"><strong>Layout:</strong></label>
    <select id="layout_select_city_network" onchange="recalculateGraph_city_network()">
        <option value="cose" >Cose</option>
                <option value="circle" selected>Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_city_network"
               
               onchange="updateEdgeLabels_city_network()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_city_network"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_city_network">0.5</span>
    </label>
    <input type="range" id="cutoff_slider_city_network"
           min="0" max="1" step="0.05" value="0.5"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_city_network').textContent = this.value; updateEdges_city_network()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_city_network"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_city_network">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_city_network"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_city_network" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_city_network" class="graph-tooltip-city_network"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: city_graph_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 3: Social Network with Demographics</h2>
<p>This example shows a social network where people are connected based on similarity.
You can color nodes by different demographic attributes.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Multiple node coloring options (Department, Team, Location)</li>
    <li>Concentric layout organizing by centrality</li>
    <li>Edge labels showing connection strength</li>
    <li>Complex multi-attribute data</li>
</ul>
<p><strong>Try this:</strong> Switch between coloring by Department, Team, and Location to see different community patterns.</p>

    </div>
<br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-social_network {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>Social Network - Connection Patterns</h2>
    <p></p>
    
    <div style="margin-bottom: 15px;">
    <label for="var_select_social_network"><strong>Select Variables:</strong></label><br>
    <select id="var_select_social_network" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_social_network()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_social_network" onclick="recalculateGraph_social_network()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_social_network" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_social_network"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_social_network" onchange="updateEdges_social_network()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_social_network"><strong>Color nodes by:</strong></label>
    <select id="color_select_social_network" onchange="updateColors_social_network()">
        <option value="none">None</option>
        <option value="Department" selected>Department (discrete)</option>
                <option value="Team" >Team (discrete)</option>
                <option value="Location" >Location (discrete)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_social_network"><strong>Layout:</strong></label>
    <select id="layout_select_social_network" onchange="recalculateGraph_social_network()">
        <option value="cose" >Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" selected>Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_social_network"
               checked
               onchange="updateEdgeLabels_social_network()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_social_network"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_social_network">0.5</span>
    </label>
    <input type="range" id="cutoff_slider_social_network"
           min="0" max="1" step="0.05" value="0.5"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_social_network').textContent = this.value; updateEdges_social_network()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_social_network"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_social_network">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_social_network"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_social_network" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_social_network" class="graph-tooltip-social_network"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: social_graph_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 4: Research Collaboration Network</h2>
<p>This example shows collaboration patterns between researchers across different institutions and fields.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Breadth-first layout showing hierarchical structure</li>
    <li>Multiple coloring attributes (Institution and Field)</li>
    <li>Dense network with many connections</li>
    <li>Different cutoff sensitivity</li>
</ul>
<p><strong>Observation:</strong> Researchers at the same institution (same color) often collaborate more,
but there are also strong cross-institutional collaborations visible in the network.</p>

    </div>
<br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-research_network {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>Research Collaboration Network</h2>
    <p></p>
    
    <div style="margin-bottom: 15px;">
    <label for="var_select_research_network"><strong>Select Variables:</strong></label><br>
    <select id="var_select_research_network" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_research_network()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_research_network" onclick="recalculateGraph_research_network()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_research_network" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_research_network"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_research_network" onchange="updateEdges_research_network()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_research_network"><strong>Color nodes by:</strong></label>
    <select id="color_select_research_network" onchange="updateColors_research_network()">
        <option value="none">None</option>
        <option value="Institution" selected>Institution (discrete)</option>
                <option value="Field" >Field (discrete)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_research_network"><strong>Layout:</strong></label>
    <select id="layout_select_research_network" onchange="recalculateGraph_research_network()">
        <option value="cose" >Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" selected>Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_research_network"
               
               onchange="updateEdgeLabels_research_network()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_research_network"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_research_network">0.4</span>
    </label>
    <input type="range" id="cutoff_slider_research_network"
           min="0" max="1" step="0.05" value="0.4"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_research_network').textContent = this.value; updateEdges_research_network()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_research_network"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_research_network">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_research_network"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_research_network" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_research_network" class="graph-tooltip-research_network"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: research_graph_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 5: Product Similarity Network with Grid Layout</h2>
<p>This example demonstrates the grid layout option, organizing nodes in a regular grid pattern.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li>Grid layout for organized visualization</li>
    <li>Product categorization</li>
    <li>Lower cutoff showing more connections</li>
</ul>
<p><strong>Use case:</strong> Grid layouts are useful when you want a clean, organized view
of all nodes with connections overlaid.</p>

    </div>
<br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-product_network {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>Product Purchase Co-occurrence Network</h2>
    <p></p>
    
    <div style="margin-bottom: 15px;">
    <label for="var_select_product_network"><strong>Select Variables:</strong></label><br>
    <select id="var_select_product_network" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_product_network()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_product_network" onclick="recalculateGraph_product_network()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_product_network" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_product_network"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_product_network" onchange="updateEdges_product_network()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_product_network"><strong>Color nodes by:</strong></label>
    <select id="color_select_product_network" onchange="updateColors_product_network()">
        <option value="none">None</option>
        <option value="Category" selected>Category (discrete)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_product_network"><strong>Layout:</strong></label>
    <select id="layout_select_product_network" onchange="recalculateGraph_product_network()">
        <option value="cose" >Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" selected>Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_product_network"
               
               onchange="updateEdgeLabels_product_network()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_product_network"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_product_network">0.25</span>
    </label>
    <input type="range" id="cutoff_slider_product_network"
           min="0" max="1" step="0.05" value="0.25"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_product_network').textContent = this.value; updateEdges_product_network()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_product_network"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_product_network">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_product_network"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_product_network" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_product_network" class="graph-tooltip-product_network"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: product_graph_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 6: Trading Strategy Network with Sharpe Ratio Coloring (Global Gradient)</h2>
<p>This example demonstrates <strong>continuous color mapping</strong> with a global gradient.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li><strong>Continuous color mapping:</strong> Nodes colored by Sharpe Ratio using a continuous gradient</li>
    <li><strong>Global gradient specification:</strong> Single color gradient applied to all continuous variables</li>
    <li><strong>No extrapolation (default):</strong> Extreme values clamp to min/max gradient colors instead of getting darker</li>
    <li>Gradient stops: -2.5 (red) â -1 (light red) â 0 (white) â 1 (light green) â 2.5 (blue)</li>
</ul>
<p><strong>Use case:</strong> Trading strategies are nodes, connected by correlation in returns.
Sharpe Ratio is visualized with a continuous color gradient to show performance at a glance.</p>
<p><strong>Color extrapolation:</strong> By default, <code>extrapolate_colors=false</code>, which means values beyond the gradient stops
(e.g., Sharpe Ratio < -2.5 or > 2.5) will use the min/max gradient color. This prevents colors from becoming too dark
for extreme values. Set <code>extrapolate_colors=true</code> to continue the gradient beyond the stops.</p>
<p><strong>Try this:</strong>
<ul>
    <li>Select "sharpe_ratio (continuous)" from the color dropdown to see the gradient</li>
    <li>Compare with "strategy_type (discrete)" to see the difference</li>
    <li>Notice how strategies with extreme Sharpe ratios use the min/max gradient colors (no extrapolation)</li>
</ul>
</p>

    </div>
<br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-strategy_network_global {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>Trading Strategy Network - Continuous Color (Global Gradient)</h2>
    <p></p>
    
    <div style="margin-bottom: 15px;">
    <label for="var_select_strategy_network_global"><strong>Select Variables:</strong></label><br>
    <select id="var_select_strategy_network_global" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_strategy_network_global()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_strategy_network_global" onclick="recalculateGraph_strategy_network_global()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_strategy_network_global" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_strategy_network_global"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_strategy_network_global" onchange="updateEdges_strategy_network_global()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_strategy_network_global"><strong>Color nodes by:</strong></label>
    <select id="color_select_strategy_network_global" onchange="updateColors_strategy_network_global()">
        <option value="none">None</option>
        <option value="strategy_type" selected>strategy_type (discrete)</option>
                <option value="sharpe_ratio" >sharpe_ratio (continuous)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_strategy_network_global"><strong>Layout:</strong></label>
    <select id="layout_select_strategy_network_global" onchange="recalculateGraph_strategy_network_global()">
        <option value="cose" selected>Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_strategy_network_global"
               
               onchange="updateEdgeLabels_strategy_network_global()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_strategy_network_global"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_strategy_network_global">0.3</span>
    </label>
    <input type="range" id="cutoff_slider_strategy_network_global"
           min="0" max="1" step="0.05" value="0.3"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_strategy_network_global').textContent = this.value; updateEdges_strategy_network_global()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_strategy_network_global"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_strategy_network_global">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_strategy_network_global"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_strategy_network_global" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_strategy_network_global" class="graph-tooltip-strategy_network_global"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: strategy_graph_data_global</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 7: Strategy Network with Per-Variable Gradients and Tooltips</h2>
<p>This example demonstrates <strong>per-variable color gradients</strong> with multiple continuous metrics and <strong>interactive tooltips</strong>.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li><strong>Multiple continuous variables:</strong> Sharpe Ratio, Return (%), Volatility (%)</li>
    <li><strong>Per-variable gradients:</strong> Each continuous variable has its own color scale</li>
    <li><strong>Interactive tooltips:</strong> Hover over nodes to see all metrics</li>
    <li><strong>Sharpe:</strong> Red-white-green-blue scale (performance-based)</li>
    <li><strong>Return:</strong> Red-white-blue scale (negative-neutral-positive)</li>
    <li><strong>Volatility:</strong> Green-yellow-red scale (low-medium-high risk)</li>
</ul>
<p><strong>Use case:</strong> When analyzing strategies with multiple metrics, each metric can have
its own intuitive color scale. Low volatility is green (good), high volatility is red (risky).
Tooltips show all metric values at once for easy comparison.</p>
<p><strong>Try this:</strong>
<ul>
    <li>Switch between different continuous variables in the color dropdown</li>
    <li>Notice how each uses a different, contextually appropriate color gradient</li>
    <li><strong>Hover over any node</strong> to see a tooltip with all metrics (strategy type, Sharpe ratio, return %, volatility %)</li>
</ul>
</p>

    </div>
<br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-strategy_network_pervariable {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>Trading Strategy Network - Per-Variable Gradients</h2>
    <p></p>
    
    <div style="margin-bottom: 15px;">
    <label for="var_select_strategy_network_pervariable"><strong>Select Variables:</strong></label><br>
    <select id="var_select_strategy_network_pervariable" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_strategy_network_pervariable()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_strategy_network_pervariable" onclick="recalculateGraph_strategy_network_pervariable()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_strategy_network_pervariable" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_strategy_network_pervariable"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_strategy_network_pervariable" onchange="updateEdges_strategy_network_pervariable()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_strategy_network_pervariable"><strong>Color nodes by:</strong></label>
    <select id="color_select_strategy_network_pervariable" onchange="updateColors_strategy_network_pervariable()">
        <option value="none">None</option>
        <option value="strategy_type" selected>strategy_type (discrete)</option>
                <option value="sharpe_ratio" >sharpe_ratio (continuous)</option>
                <option value="return_pct" >return_pct (continuous)</option>
                <option value="volatility_pct" >volatility_pct (continuous)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_strategy_network_pervariable"><strong>Layout:</strong></label>
    <select id="layout_select_strategy_network_pervariable" onchange="recalculateGraph_strategy_network_pervariable()">
        <option value="cose" selected>Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_strategy_network_pervariable"
               
               onchange="updateEdgeLabels_strategy_network_pervariable()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_strategy_network_pervariable"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_strategy_network_pervariable">0.3</span>
    </label>
    <input type="range" id="cutoff_slider_strategy_network_pervariable"
           min="0" max="1" step="0.05" value="0.3"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_strategy_network_pervariable').textContent = this.value; updateEdges_strategy_network_pervariable()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_strategy_network_pervariable"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_strategy_network_pervariable">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_strategy_network_pervariable"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_strategy_network_pervariable" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_strategy_network_pervariable" class="graph-tooltip-strategy_network_pervariable"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: strategy_graph_data_pervariable</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 8: Market Network with Rich Tooltips</h2>
<p>This example demonstrates the <strong>tooltip_cols parameter</strong> for adding extra information to node tooltips.</p>
<p><strong>Features demonstrated:</strong></p>
<ul>
    <li><strong>color_cols:</strong> Variables shown in color dropdown AND tooltips (Industry, Returns %)</li>
    <li><strong>tooltip_cols:</strong> Additional variables shown ONLY in tooltips (GDP Growth, Population, Market Cap)</li>
    <li><strong>Information separation:</strong> Keep color dropdown clean while showing rich details on hover</li>
</ul>
<p><strong>How it works:</strong></p>
<ul>
    <li>The color dropdown only shows <code>color_cols</code> options (Industry and Returns %)</li>
    <li>Hovering over a node shows ALL information from <code>union(color_cols, tooltip_cols)</code></li>
    <li>This keeps the UI clean while providing detailed context on demand</li>
</ul>
<p><strong>Try this:</strong> Hover over any market node to see:
<ul>
    <li>Market name (node label)</li>
    <li>Industry (from color_cols)</li>
    <li>Returns % (from color_cols)</li>
    <li>GDP Growth % (from tooltip_cols - not in color dropdown)</li>
    <li>Population millions (from tooltip_cols - not in color dropdown)</li>
    <li>Market Cap billions (from tooltip_cols - not in color dropdown)</li>
</ul>
</p>
<p><strong>Use case:</strong> When you have many attributes but only want to color by a few key ones,
use tooltip_cols to provide additional context without cluttering the color selection dropdown.</p>

    </div>
<br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-market_network_tooltips {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>African Markets Network - Rich Tooltips Example</h2>
    <p></p>
    
    <div style="margin-bottom: 15px;">
    <label for="var_select_market_network_tooltips"><strong>Select Variables:</strong></label><br>
    <select id="var_select_market_network_tooltips" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_market_network_tooltips()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_market_network_tooltips" onclick="recalculateGraph_market_network_tooltips()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_market_network_tooltips" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_market_network_tooltips"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_market_network_tooltips" onchange="updateEdges_market_network_tooltips()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_market_network_tooltips"><strong>Color nodes by:</strong></label>
    <select id="color_select_market_network_tooltips" onchange="updateColors_market_network_tooltips()">
        <option value="none">None</option>
        <option value="industry" selected>industry (discrete)</option>
                <option value="returns" >returns (continuous)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_market_network_tooltips"><strong>Layout:</strong></label>
    <select id="layout_select_market_network_tooltips" onchange="recalculateGraph_market_network_tooltips()">
        <option value="cose" selected>Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_market_network_tooltips"
               
               onchange="updateEdgeLabels_market_network_tooltips()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_market_network_tooltips"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_market_network_tooltips">0.4</span>
    </label>
    <input type="range" id="cutoff_slider_market_network_tooltips"
           min="0" max="1" step="0.05" value="0.4"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_market_network_tooltips').textContent = this.value; updateEdges_market_network_tooltips()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_market_network_tooltips"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_market_network_tooltips">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_market_network_tooltips"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_market_network_tooltips" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_market_network_tooltips" class="graph-tooltip-market_network_tooltips"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: market_graph_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary</h2>
<p>The Graph chart type provides flexible network visualization with these key capabilities:</p>

<h3>Input Formats</h3>
<ul>
    <li><strong>Correlation matrices:</strong> High correlation = strong connection</li>
    <li><strong>Distance matrices:</strong> Low distance = strong connection</li>
    <li><strong>Any edge list:</strong> Flexible node-node-strength format</li>
</ul>

<h3>Layout Algorithms</h3>
<ul>
    <li><strong>COSE (Force-directed):</strong> Organizes nodes based on connection strength</li>
    <li><strong>Circle:</strong> Arranges nodes in a circle</li>
    <li><strong>Grid:</strong> Regular grid pattern</li>
    <li><strong>Concentric:</strong> Organizes by node centrality</li>
    <li><strong>Breadth-first:</strong> Hierarchical tree-like layout</li>
</ul>

<h3>Interactive Controls</h3>
<ul>
    <li><strong>Cutoff slider:</strong> Filter connections by strength</li>
    <li><strong>Edge labels:</strong> Show/hide connection strengths</li>
    <li><strong>Node coloring:</strong> Color by categorical (discrete) or numeric (continuous) attributes</li>
    <li><strong>Continuous coloring:</strong> Use custom color gradients for numeric variables</li>
    <li><strong>Interactive tooltips:</strong> Hover over nodes to see detailed information</li>
    <li><strong>Layout selection:</strong> Switch between different layouts</li>
    <li><strong>Drag nodes:</strong> Manually rearrange network</li>
    <li><strong>Zoom & pan:</strong> Explore large networks</li>
</ul>

<h3>Advanced Coloring</h3>
<ul>
    <li><strong>Discrete coloring:</strong> Categorical attributes (sector, department, etc.)</li>
    <li><strong>Continuous coloring:</strong> Numeric variables with gradient interpolation</li>
    <li><strong>Global gradient:</strong> Single gradient for all continuous variables</li>
    <li><strong>Per-variable gradients:</strong> Different color scales for each metric</li>
    <li><strong>Gradient customization:</strong> Define custom color stops for intuitive visualization</li>
    <li><strong>Color extrapolation control:</strong> Choose whether extreme values clamp to gradient boundaries (default) or extrapolate beyond them</li>
</ul>

<h3>Color Gradient Options</h3>
<ul>
    <li><strong>extrapolate_colors=false (default):</strong> Values beyond gradient stops use min/max colors (prevents too-dark colors)</li>
    <li><strong>extrapolate_colors=true:</strong> Colors continue to extrapolate beyond gradient stops for extreme values</li>
    <li><strong>Example:</strong> With gradient -2.5â2.5 and value=5.0, clamping uses the 2.5 color, extrapolation continues the trend</li>
</ul>

<h3>Tooltips</h3>
<ul>
    <li><strong>color_cols:</strong> Variables shown in color dropdown AND in tooltips when hovering over nodes</li>
    <li><strong>tooltip_cols:</strong> Additional variables shown ONLY in tooltips (not in color dropdown)</li>
    <li><strong>Automatic formatting:</strong> Numbers formatted with appropriate precision, column names capitalized</li>
    <li><strong>Use case:</strong> Keep color selection UI clean while providing rich contextual information on hover</li>
    <li><strong>Display:</strong> Tooltips show union(color_cols, tooltip_cols) for comprehensive node information</li>
</ul>

<h3>Use Cases</h3>
<ul>
    <li>Stock correlation analysis</li>
    <li>Social network analysis</li>
    <li>Geographic proximity networks</li>
    <li>Collaboration networks</li>
    <li>Product recommendation networks</li>
    <li>Any relationship data</li>
</ul>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.4.2.</small></p>
</body>
</html>
