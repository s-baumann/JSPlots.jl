using JSPlots, DataFrames, DataFramesMeta, Dates, StableRNGs, Statistics, OrderedCollections, VegaLite
using RefinedSlippage, HighFrequencyCovariance, Distributions, LinearAlgebra

# Introduction
intro = TextBlock("""
<p>JSPlots.jl creates interactive, standalone HTML visualizations that work in any browser. Build line charts, scatter plots, 3D visualizations, pivot tables, and more - all from Julia without any coding in JavaScript needed.

The closest comparison to what I am trying to build is probably Pluto notebooks or jupyter notebooks. The key difference is that the pages that you generate with JSPlots runnable anywhere with interactive plotting - you do not need Julia or anything else installed except for a webbrowser. This means too that the documents that are generated by JSPlots are intended to be immutable documents to present your data rather than something you develop with (as you get with the notebooks).</p>

You can see below an overview of all of the plots that are available. You can also see a discussion on the coding practices, data formats, etc.

All of this documentation was made in JSPlots.jl itself. <a href=\"https://github.com/s-baumann/JSPlots.jl/blob/main/examples/z_general_tutorial.jl\" style=\"color: blue; font-weight: bold;\">See here for the script that generates it</a>.
""")

### Theoretical Pages


# General Coding Patterns
coding_patterns = TextBlock("""
<h2>General Coding Patterns</h2>
<p>The arguments each chart type accepts are slightly different reflecting the nature of each plot.
However, there are some common elements found across many plot types:</p>

<h3>Filters</h3>
<p> Filters allow users to subset the data that is used to display the chart. The logic is that a datapoint is included if it satisfies ALL of the various filter conditions.</p>
<p>Filters can be specified with either a Dict or a Vector:</p>
<ul>
    <li><strong>Vector of Symbols:</strong> <code>filters = [:product_line, :country]</code> creates multi-select dropdown filters
    with all unique values selected by default. So if you have [:product_line, :country] then you will end up with two dropdown boxes allowing you to subset the data by country and by the product_line.</li>
    <li><strong>Dict:</strong> <code>filters = Dict(:country => ["Australia", "United Kingdom"], :product_line => nothing)</code> where each key
    is a column name and each value specifies the default selected values. This is a bit more flexible than the above as you can specify what filters are applied by default. In this case you will end up with the same filters being possible as in the above case but by default when a user first opens a page there will be filters applied for Australia and the UK.
    </li>
</ul>

<h3>Color Columns</h3>
<p><code>color_cols</code> are the options that affect the grouping and color of objects in the chart.
For instance in a KernelDensity plot, different colors can be used to show the distribution of different groups.
In a ScatterPlot, different colors can be used to show points from different groups.</p>

<h3>Facet Columns</h3>
<p><code>facet_cols</code> specify which columns can be used for faceting (creating small aligned multiples of the same plot).</p>
<p>Note that if only one facet_col is specified there will be one dropdown list for applying this faceting or not. If two or more are provided there will be two dropdown lists for the x and y dimensions of the facet_grid.</p>
<ul>
    <li><strong>facet_cols:</strong> Defines which columns are available for faceting. Can be a single Symbol or Vector of Symbols.</li>
    <li><strong>default_facet_cols:</strong> Specifies which facet columns should be used by default:
        <ul>
            <li>If <code>nothing</code>, no faceting will appear initially (but users can enable it if <code>facet_cols</code> is provided)</li>
            <li>If specified, the chart will start with faceting enabled using those columns</li>
        </ul>
    </li>
</ul>

<h3>Value Columns</h3>
<p>Many chart types accept <code>value_cols</code> which specify the columns containing the data to visualize.
For plots that can display multiple value columns (like DistPlot or KernelDensity), you can provide a vector
of column names and use dropdown controls to switch between them.</p>

<h3>x, y, z Columns</h3>
<p>Some chart types allow you to specify several columns that are used for x, y and z. In these cases you can swap them on the fly.</p>

<h3>Interactive Controls</h3>
<p>Several chart types have their own interactive controls that are quite specific to them. Some examples are:</p>
<ul>
    <li>The DistPlot has a button to turn on or off the rugplot;</li>
    <li>The ScatterPlot has buttons to turn on or off the density shading</li>
    <li>The KernelDensity has a slider beneath it to change the kernel bandwidth</li>
    <li>ScatterSurface3D has a button to change the regularisation of the surface from L2 to L1</li>
</ul>
and there are many more. For some details on these see the specific section on the plot in this documentation.
""")

coding_practices_theory_page = JSPlotPage(
    Dict{Symbol, Any}(),
    [coding_patterns],
    tab_title="General Coding Patterns",
    page_header = "General Coding Patterns",
    notes = "This gives an overview of the common coding patterns used across many chart types",
    dataformat = :csv_embedded
)


# Page about data formats
dataformat_theory = TextBlock("""
<h2>Data Storage Formats in JSPlots.jl</h2>

<h3>Specifying datasets</h3>
<p> For most charttypes you have some dataset that they should comsume.
As part of the constructor you give a symbol that identifies the dataset to be used. Then at the point when you construct a page you input a dict mapping these symbols to an object holding the data.
</p>

<p> These symbols can have a period in it in which case you are describing a subfield. For instance you might have an object like that below:</p>

<pre><code>struct ExampleStruct
    aa::DataFrame
    bb::DataFrame
end
example_struct = ExampleStruct(df1, df2)
</code></pre>
<p> Then if you have a chart that wants to use the aa dataset from this object then you can specify it with Symbol("example_struct.aa") and then later on you give the data in the dict as  Dict{Symbol,Any}(:example_struct => example_struct).</p>

<p> The point of this system is twofold. For one certain charts may require datasets and so it is easier in this case to have a struct to hold everything together (Currently this is only ExecutionChart but maybe in the future).
So if you wanted to put in a pivottable in the same page to show only the fills data you could do that without putting in the data twice.
The second reason is that using structs in this way will bunch the data in different subfolders in cases where an external data format is used (:parquet, :json_external or :csv_external as described below).</p>

<h3>Data Format</h3>
<p>JSPlots.jl supports multiple data storage formats for embedding data in HTML pages.
The format affects file size, loading speed, and browser compatibility.</p>

<h3>Available Formats</h3>

<h4>1. :parquet (Recommended)</h4>
<p><strong>Best for:</strong> Large datasets, multi-page reports, production use</p>
<ul>
    <li><strong>Compressed binary format</strong> - smallest file sizes (typically 5-10x smaller than CSV)</li>
    <li><strong>Fast loading</strong> - efficient decompression in browser</li>
    <li><strong>Modern browsers</strong> - requires JavaScript support</li>
    <li><strong>Column-oriented</strong> - excellent compression for tabular data</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :parquet)</code></pre>

<h4>2. :csv_embedded</h4>
<p><strong>Best for:</strong> Small datasets, maximum compatibility, debugging</p>
<ul>
    <li><strong>Text-based CSV format</strong> - human-readable in HTML source</li>
    <li><strong>Single file</strong> - data embedded directly in HTML</li>
    <li><strong>Compact format</strong> - smaller than JSON for tabular data</li>
    <li><strong>Universal compatibility</strong> - works everywhere</li>
    <li><strong>Easy debugging</strong> - can inspect data in HTML source</li>
    <li><strong>No deduplication</strong> - data embedded separately in each page</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :csv_embedded)</code></pre>

<h4>3. :csv_external</h4>
<p><strong>Best for:</strong> Sharing data files, version control, spreadsheet analysis</p>
<ul>
    <li><strong>Separate CSV files</strong> - one file per dataset in data/ subdirectory</li>
    <li><strong>Multiple files</strong> - HTML + CSV files</li>
    <li><strong>Enables deduplication</strong> - shared datasets only stored once</li>
    <li><strong>Data reusability</strong> - CSV files can be opened in Excel/spreadsheets</li>
    <li><strong>Better for git</strong> - separate data from HTML</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :csv_external)</code></pre>

<h4>4. :json_embedded</h4>
<p><strong>Best for:</strong> Small datasets, web developers, API-like structure</p>
<ul>
    <li><strong>JSON format</strong> - familiar to web developers</li>
    <li><strong>Single file</strong> - data embedded directly in HTML</li>
    <li><strong>Structured data</strong> - preserves data types (numbers, strings, booleans)</li>
    <li><strong>Larger than CSV</strong> - JSON is ~25% larger due to key names in each row</li>
    <li><strong>Fast browser parsing</strong> - native JSON.parse() is highly optimized</li>
    <li><strong>No deduplication</strong> - data embedded separately in each page</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :json_embedded)</code></pre>

<h4>5. :json_external</h4>
<p><strong>Best for:</strong> API consumption, web applications, data interchange</p>
<ul>
    <li><strong>Separate JSON files</strong> - one file per dataset in data/ subdirectory</li>
    <li><strong>Multiple files</strong> - HTML + JSON files</li>
    <li><strong>Enables deduplication</strong> - shared datasets only stored once</li>
    <li><strong>API-ready format</strong> - can be consumed by other web applications</li>
    <li><strong>Type preservation</strong> - maintains data types better than CSV</li>
    <li><strong>Web-friendly</strong> - easy to load from external servers</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :json_external)</code></pre>

<h3>Data Deduplication</h3>
<p><strong>Key Efficiency Feature:</strong> JSPlots.jl automatically detects when the same dataset
is used multiple times and only includes it once.</p>
<p>Note that thisData deduplication only works with external formats
Data deduplication only works with external formats - (<code>:parquet</code>, <code>:csv_external</code>, <code>:json_external</code>).
With embedded formats (<code>:csv_embedded</code>, <code>:json_embedded</code>),
data is embedded separately in each HTML page, so there's no deduplication benefit.</p>

<h4>How It Works</h4>
<p>When you create a multi-page report with <code>Pages</code>, datasets are identified by their
<code>Symbol</code> key in the data dictionary. <strong>The <code>Pages</code>-level dataformat setting
overrides any individual <code>JSPlotPage</code> dataformat settings.</strong></p>

<pre><code># Both pages use :sales_data
page1 = JSPlotPage(
    Dict(:sales_data => df),
    [chart1, chart2],
    dataformat = :csv_embedded  # This is ignored!
)

page2 = JSPlotPage(
    Dict(:sales_data => df),  # Same Symbol = reuses data!
    [chart3, chart4],
    dataformat = :json_embedded  # This is also ignored!
)

# Pages-level dataformat is what actually gets used
report = Pages(
    [intro],
    [page1, page2],
    dataformat = :parquet  # ← This overrides page-level settings!
)
# Result: One parquet file in data/sales_data.parquet shared by both pages</code></pre>

<h4>Benefits of Deduplication (External Formats Only)</h4>
<ul>
    <li><strong>Reduced File Size:</strong> Large datasets only stored once, not duplicated per page</li>
    <li><strong>Faster Loading:</strong> Less data to download and parse</li>
    <li><strong>Memory Efficiency:</strong> Browser loads dataset into memory once</li>
    <li><strong>Consistency:</strong> All pages use the exact same data</li>
</ul>

<h3>Format Comparison Table</h3>
<table border="1" cellpadding="8" style="border-collapse: collapse; margin: 20px 0; width: 100%;">
    <tr style="background-color: #f0f0f0;">
        <th>Feature</th>
        <th>:parquet</th>
        <th>:csv_embedded</th>
        <th>:csv_external</th>
        <th>:json_embedded</th>
        <th>:json_external</th>
    </tr>
    <tr>
        <td><strong>File Size</strong></td>
        <td style="color: green;">Smallest (5-10x smaller)</td>
        <td style="color: orange;">Medium</td>
        <td style="color: orange;">Medium</td>
        <td style="color: red;">Large (~25% bigger than CSV)</td>
        <td style="color: red;">Large (~25% bigger than CSV)</td>
    </tr>
    <tr>
        <td><strong>Loading Speed</strong></td>
        <td style="color: green;">Fast</td>
        <td style="color: orange;">Moderate</td>
        <td style="color: orange;">Moderate</td>
        <td style="color: green;">Fast (native JSON.parse)</td>
        <td style="color: green;">Fast (native JSON.parse)</td>
    </tr>
    <tr>
        <td><strong>Compatibility</strong></td>
        <td style="color: orange;">Modern browsers</td>
        <td style="color: green;">Universal</td>
        <td style="color: green;">Universal</td>
        <td style="color: green;">Universal</td>
        <td style="color: green;">Universal</td>
    </tr>
    <tr>
        <td><strong>Deduplication</strong></td>
        <td style="color: green;">Yes (in Pages)</td>
        <td style="color: red;">No (embedded)</td>
        <td style="color: green;">Yes (in Pages)</td>
        <td style="color: red;">No (embedded)</td>
        <td style="color: green;">Yes (in Pages)</td>
    </tr>
    <tr>
        <td><strong>Type Preservation</strong></td>
        <td style="color: green;">Excellent</td>
        <td style="color: orange;">Limited (strings)</td>
        <td style="color: orange;">Limited (strings)</td>
        <td style="color: green;">Good</td>
        <td style="color: green;">Good</td>
    </tr>
    <tr>
        <td><strong>Human Readable</strong></td>
        <td>No (binary)</td>
        <td>Yes (in HTML)</td>
        <td>Yes (separate files)</td>
        <td>Yes (in HTML)</td>
        <td>Yes (separate files)</td>
    </tr>
    <tr>
        <td><strong>File Structure</strong></td>
        <td>Single HTML + data/</td>
        <td>Single HTML</td>
        <td>HTML + data/ folder</td>
        <td>Single HTML</td>
        <td>HTML + data/ folder</td>
    </tr>
    <tr>
        <td><strong>Best For</strong></td>
        <td>Production, large data</td>
        <td>Small data, debugging</td>
        <td>Spreadsheet analysis</td>
        <td>Web developers</td>
        <td>API/web apps</td>
    </tr>
</table>

<h3>Setting Format Globally vs Per-Page</h3>
<pre><code># Set format for entire report (RECOMMENDED)
report = Pages(
    [intro],
    [page1, page2],
    dataformat = :parquet  # Overrides any page-level settings
)

# Individual pages (only for single-page JSPlotPage, not Pages)
page1 = JSPlotPage(data_dict, charts, dataformat = :parquet)
create_html(page1, "standalone_page.html")</code></pre>

<p><strong>Note:</strong> When using <code>Pages</code>, the Pages-level <code>dataformat</code>
overrides any <code>dataformat</code> settings in individual <code>JSPlotPage</code> objects.</p>

<h3>Launcher Scripts for External Formats</h3>
<p>When using external formats (<code>:parquet</code>, <code>:csv_external</code>, <code>:json_external</code>),
JSPlots.jl automatically generates launcher scripts to help with browser security restrictions:</p>

<ul>
    <li><strong>open.sh</strong> - Shell script for Linux/Mac that launches a local web server</li>
    <li><strong>open.bat</strong> - Batch script for Windows that opens with appropriate permissions</li>
    <li><strong>README.md</strong> - Instructions for opening the HTML files</li>
</ul>

<p><strong>Why launcher scripts?</strong> Modern browsers block loading external files (data/, pictures/, etc.)
from <code>file://</code> URLs for security reasons. The launcher scripts either:</p>
<ul>
    <li>Start a local web server (on Linux/Mac via Python's http.server)</li>
    <li>Launch the browser with flags to allow local file access (on Windows)</li>
</ul>

<p>For embedded formats (<code>:csv_embedded</code>, <code>:json_embedded</code>), you can open
the HTML file directly in a browser since all data is embedded - no launcher scripts needed!</p>
""")

dataformat_theory_page = JSPlotPage(
    Dict{Symbol, Any}(),
    [dataformat_theory],
    tab_title="Data Storage Formats",
    page_header = "Understanding Data Storage Formats",
    notes = "This shows the options for including data with the HTML",
    dataformat = :csv_embedded
)

pages_theory = TextBlock("""
<h2>Creating Multi-Page Reports with JSPlotPage and Pages</h2>

<h3>Overview</h3>
<p>JSPlots.jl makes it easy to create multi-page HTML reports. You create individual pages using <code>JSPlotPage</code>,
then combine them into a multi-page report using <code>Pages</code>.</p>

We have two examples that demonstrate the use of pages.
<a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/easy_report/easy_report.html\" style=\"color: blue; font-weight: bold;\">See here </a> and <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/annual_report/annual_report.html\" style=\"color: blue; font-weight: bold;\"> see here </a>
with <a href=\"https://github.com/s-baumann/JSPlots.jl/blob/main/examples/pages_examples.jl\" style=\"color: blue; font-weight: bold;\">this script</a> generating both of them.

<h3>Creating Individual Pages with JSPlotPage</h3>
<p>A <code>JSPlotPage</code> represents a single HTML page with charts, tables, and text content:</p>

<pre><code>page = JSPlotPage(
    Dict(:data_name => dataframe),  # Data dictionary
    [chart1, chart2, text_block],   # Content items
    tab_title = "My Page",          # Browser tab title
    page_header = "Analysis Report", # Page header
    dataformat = :parquet           # Data storage format
)</code></pre>

<h3>Combining Pages with the Pages Constructor</h3>
<p>The <code>Pages</code> constructor creates a multi-page report with automatic navigation:</p>

<pre><code># Easy constructor - automatically creates LinkList!
report = Pages(
    [coverpage_content],  # Items for the coverpage
    [page1, page2, page3], # Your JSPlotPage objects
    tab_title = "Report Home",
    page_header = "Business Report",
    dataformat = :parquet
)</code></pre>

<h3>Automatic LinkList Generation</h3>
<p><strong>Key Feature:</strong> The Pages constructor automatically generates a <code>LinkList</code> from your pages
and adds it to the coverpage!</p>

<ul>
    <li>Each page in the <code>[page1, page2, page3]</code> array becomes a link</li>
    <li>Link titles come from each page's <code>tab_title</code></li>
    <li>Link descriptions come from each page's <code>notes</code> field</li>
    <li>The LinkList is automatically appended to your coverpage content</li>
</ul>

<h3>Manual LinkList (Advanced)</h3>
<p>You can also create LinkLists manually for custom navigation:</p>

<pre><code>links = LinkList([
    ("Title 1", "page_1.html", "Description of page 1"),
    ("Title 2", "page_2.html", "Description of page 2")
])</code></pre>

<h3>Complete Example</h3>
<pre><code># Create individual pages
analysis_page = JSPlotPage(
    Dict(:sales => sales_df),
    [scatter_chart, line_chart],
    tab_title = "Sales Analysis",
    notes = "Detailed sales trends and patterns"
)

metrics_page = JSPlotPage(
    Dict(:kpis => kpi_df),
    [kde_chart, dist_chart],
    tab_title = "Key Metrics",
    notes = "Performance indicators and distributions"
)

# Create multi-page report with automatic LinkList
report = Pages(
    [TextBlock("&lt;h1&gt;Q4 Report&lt;/h1&gt;")],
    [analysis_page, metrics_page],
    tab_title = "Q4 2024 Report"
)

# Generate HTML
create_html(report, "my_report")
# Creates: my_report.html (coverpage with links)
#          page_1.html (Sales Analysis)
#          page_2.html (Key Metrics)</code></pre>

<h3>Benefits</h3>
<ul>
    <li><strong>Automatic Navigation:</strong> No need to manually create links between pages</li>
    <li><strong>Consistent Structure:</strong> All pages follow the same format</li>
    <li><strong>Easy Maintenance:</strong> Add/remove pages without updating navigation</li>
    <li><strong>Professional Output:</strong> Clean, navigable HTML reports</li>
</ul>

<h3>Opening Multi-Page Reports</h3>
<p>When you use external data formats (<code>:parquet</code>, <code>:csv_external</code>, <code>:json_external</code>),
JSPlots.jl automatically generates launcher scripts in the project directory:</p>

<ul>
    <li><strong>open.sh</strong> (Linux/Mac) - Starts a local web server and opens in browser</li>
    <li><strong>open.bat</strong> (Windows) - Opens with appropriate browser permissions</li>
    <li><strong>README.md</strong> - Detailed instructions</li>
</ul>

<p><strong>Why?</strong> Browsers block loading external files from <code>file://</code> URLs for security.
The launcher scripts solve this by either running a local web server or launching the browser
with flags to allow local file access.</p>
""")

pages_theory_page = JSPlotPage(
    Dict{Symbol, Any}(),
    [pages_theory],
    tab_title="Creating Multi-Page Reports",
    page_header = "How to Create Multi-Page Reports",
    notes = "Learn how to use JSPlotPage and Pages to create multi-page HTML reports with automatic navigation",
    dataformat = :csv_embedded
)

# ReportIndex page - explaining what it is and showing all examples
reportindex_theory = TextBlock("""
<h2>ReportIndex</h2>
<p>ReportIndex creates an interactive navigation component for browsing collections of HTML reports.
It reads from a CSV manifest file containing metadata about each report page, and generates a
searchable, sortable, and groupable index.</p>

<h3>Manifest Format</h3>
<p>The manifest CSV file should contain columns describing each report:</p>
<ul>
    <li><strong>path:</strong> Directory path to the HTML file</li>
    <li><strong>html_filename:</strong> Name of the HTML file</li>
    <li><strong>description:</strong> Human-readable description shown in the index</li>
    <li><strong>date:</strong> Date the report was created/updated</li>
    <li><strong>Additional columns:</strong> Any extra columns (like chart_type, page_type) can be used for grouping and filtering</li>
</ul>

<h3>Usage</h3>
<pre><code># Create a manifest entry when generating HTML
manifest_entry = ManifestEntry(
    path="..",
    html_filename="my_chart.html",
    description="My Chart Example",
    date=today(),
    extra_columns=Dict(:chart_type => "2D Charts", :page_type => "Chart Tutorial")
)
create_html(page, "generated_html_examples/my_chart.html";
    manifest="generated_html_examples/z_general_example/manifest.csv",
    manifest_entry=manifest_entry)

# Later, create an index page from the manifest
index = ReportIndex(:my_index, "path/to/manifest.csv",
    title = "My Reports",
    default_group_by = :chart_type,
    default_sort_by = :description
)</code></pre>

The useful feature of ReportIndex over LinkList is that because ReportIndex comes from an external csv file you can add to that external csv file on a regular basis. For instance you can do a new report every day. Then you can have a different document that will link to all of them.

<h2>JSPlots Example Files</h2>
<p>Below is an interactive index of all JSPlots example files generated using ReportIndex.
Click on any link to view the example. Use the dropdowns to group and sort the examples.</p>
""")

examples_index = ReportIndex(:examples_gallery, "manifest.csv",
    title = "Links to all example files",
    default_group_by = :page_type,
    default_then_group_by = :chart_type,
    default_sort_by = :description
)

reportindex_theory_page = JSPlotPage(
    Dict{Symbol, Any}(),
    [reportindex_theory, examples_index],
    tab_title="ReportIndex & Example Files",
    page_header = "ReportIndex & Example Files",
    notes = "ReportIndex creates interactive navigation for collections of HTML reports",
    dataformat = :csv_embedded
)


### Plot Types

# Generate comprehensive dataset
dataset_intro = TextBlock("""
<h2>Dataset Generation</h2>
<p>We'll create a business analytics dataset for use throughout this documentation to show off all of the plottypes. The dataset contains sales data for a company employing door to door salesmen accross a wide area and with a large set of possible products.</p>
<p> The code that generates this dataset is shown below as the example of the CodeBlock type.</p>
""")

function generate_comprehensive_data()
    rng = StableRNG(42)

    # Time period: One year of daily data
    start_date = Date(2024, 1, 1)
    dates = start_date:Day(1):(start_date + Day(700))
    n = length(dates)

    # Product categories
    products = ["Laptop", "Tablet", "Phone"]
    regions = ["North", "South", "West"]
    segments = ["Enterprise", "SMB", "Consumer"]

    # Generate sales data
    records = DataFrame[]

    for (i, date) in enumerate(dates)
        for product in products
            for region in regions
                # Base sales with trends and seasonality
                base = 10000 + 1000 * sin(2π * i / 365)
                trend = i * 10

                # Product-specific multipliers
                product_mult = Dict(
                    "Laptop" => 3.0, "Tablet" => 2.0, "Phone" => 4.0
                )[product]

                # Region-specific multipliers
                region_mult = Dict("North" => 1.2, "South" => 1.0, "West" => 1.1)[region]

                sales = (base + trend) * product_mult * region_mult * (1 + 0.2 * randn(rng))
                quantity = round(Int, sales / (100 + 50 * randn(rng)))
                cost = sales * (0.6 + 0.1 * randn(rng))
                profit = sales - cost

                # Customer metrics
                customers = round(Int, quantity * (0.3 + 0.1 * randn(rng)))
                satisfaction = 3.5 + 1.0 * randn(rng)

                # Geographic coordinates
                lat = 35.0 + Dict("North" => 10, "South" => -10, "West" => 0)[region] + randn(rng)
                lon = -95.0 + Dict("North" => 0, "South" => 0, "West" => -15)[region] + randn(rng)

                # Random segment assignment
                segment = rand(rng, segments)

                push!(records, DataFrame(
                    date = date,
                    product = product,
                    region = region,
                    segment = segment,
                    sales = max(0, sales),
                    quantity = max(0, quantity),
                    cost = max(0, cost),
                    profit = profit,
                    customers = max(0, customers),
                    satisfaction = clamp(satisfaction, 1, 5),
                    latitude = lat,
                    longitude = lon,
                    month = month(date),
                    quarter = (month(date) - 1) ÷ 3 + 1,
                    day_of_year = dayofyear(date)
                ))
            end
        end
    end

    return vcat(records...)
end

dataset_code = CodeBlock(generate_comprehensive_data,
    notes=" We can use a CodeBlock to show code snippets with syntax highlighting. We have correct Syntax highlighting for Julia, Python, R, JavaScript, Java, C, C++, SQL, pl/pgsql, Rust. For anything else it will all be black.")

df = dataset_code()

# PivotTable - with dataset selection to switch between multiple tables
pivot_chart = PivotTable(:PivotTable, [:sales_data, :product_summary],
    rows=[:product],
    cols=[:region],
    vals=:customers,
    aggregatorName = :Average,
    rendererName = :Heatmap,
    colour_map = Dict{Float64,String}([0.0, 50.0, 100.0, 150.0] .=>
                                      ["#ffffff", "#ccccff", "#99ccff", "#3366ff"]),
    extrapolate_colours = false,
    notes="PivotTables can do quite alot. Indeed many of the charttypes of this package would alternatively be doable just using a PivotTable so you might prefer doing that in some cases. <strong>Dataset Selection:</strong> This PivotTable demonstrates the ability to switch between multiple datasets - use the dropdown above the table to switch between 'sales_data' (detailed sales records) and 'product_summary' (aggregated product statistics). This is useful when you want to explore the same data at different levels of aggregation. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/pivottable_examples.html\" style=\"color: blue; font-weight: bold;\">See here for PivotTable examples</a>")

# Table

product_summary = @linq df |> groupby(:product) |> combine(:total_sales = sum(:sales),
    :total_quantity = sum(:quantity),
    :total_profit = sum(:profit))
sort!(product_summary, :total_sales, rev=true)

table_chart = Table(:Table, product_summary,
    notes="This just displays your DataFrame in a nice way on the html page. There is a download as csv button at the bottom of it. You could also just use a PivotTable but this is lighterweight for cases where a PivotTable is overkill. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/table_examples.html\" style=\"color: blue; font-weight: bold;\">See here for Table examples</a>")

# CodeBlock
code_chart = dataset_code

# LinkList
linklist_intro = TextBlock("""
<h1>LinkList</h1>
""")

od = OrderedCollections.OrderedDict{String, Vector{Tuple{String,String,String}}}()
od["OverView"] = [("GitHub Repository", "https://github.com/s-baumann/JSPlots.jl", "Source code"),
    ("Documentation", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/z_general_example/z_general_example.html", "General tutorial and overview"),
    ("Pages", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/annual_report.html", "Multi-page reports with navigation")]
od["Tabular Data and Text"] = [("PivotTable", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/pivottable_examples.html", "Interactive drag-and-drop pivot tables"),
    ("Table", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/table_examples.html", "Sortable data tables with CSV download"),
    ("TextBlock", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/textblock_examples.html", "Rich text and HTML content"),
    ("CodeBlock", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/codeblock_examples.html", "Syntax-highlighted code blocks"),
    ("LinkList", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linklist_examples.html", "Navigation and link lists")]
od["Multimedia"] = [
    ("Picture", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/picture_examples.html", "Display images, GIFs, and filtered charts from VegaLite, Plots.jl, or Makie"),
    ("Slides", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/slides_examples_embedded.html", "Slideshows and animations")]
od["2D Plots"] = [("LineChart", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linechart_examples.html", "Time series and trend visualization"),
    ("AreaChart", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/areachart_examples.html", "Stacked area charts"),
    ("ScatterPlot", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatterplot_examples.html", "2D scatter plots with marginal distributions"),
    ("Path", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/path_examples.html", "Trajectory visualization with direction arrows")]
od["Distributional Plots"] = [
    ("DistPlot", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/distplot_examples.html", "Histogram, box plot, and rug plot combined"),
    ("KernelDensity", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/kerneldensity_examples.html", "Smooth kernel density estimation"),
    ("PieChart", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/piechart_examples.html", "Pie charts with faceting and filtering"),
    ("BoxAndWhiskers", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/boxandwhiskers_examples.html", "Make horizontal Box and Whiskers plots showing distribution statistics (min, Q1, median, Q3, max) with mean and standard deviation overlays for grouped data.")]
od["3D Plots"] = [
    ("Scatter3D", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatter3d_examples.html", "3D scatter plots with PCA eigenvectors"),
    ("Surface3D", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/surface3d_examples.html", "3D surface visualization"),
    ("ScatterSurface3D", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scattersurface3d_example.html", "3D scatter with fitted surfaces")]
od["Variable Relationships"] = [("CorrPlot", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/corrplot_examples.html", "Make correlation plots with hierarchical clustering dendrograms showing Pearson and Spearman correlations."),
    ("Graph", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/graph_examples.html", "Network graphs showing relationships between entities with adjustable cutoffs and layouts"),
    ("TSNEPlot", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/tsneplot_examples/tsneplot_examples.html", "Interactive t-SNE dimensionality reduction with feature selection and configurable parameters")]
od["Situational Charts"] = [
    ("Waterfall", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/waterfall_examples.html", "Make Waterfall plots showing how positive and negative elements add up to an aggregate."),
    ("SanKey", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/sankey_examples.html", "Make SanKey plots showing how individuals change affiliation over multiple waves."),
    ("BumpChart", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/bumpchart_examples.html", "Rankings over time with dense ranking and cross-facet highlighting")]
od["Financial Charts"] = [
    ("CandlestickChart", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/candlestickchart_examples.html", "Candlestick candlestick charts with volume, renormalization, and time range controls")]


linklist_chart = LinkList(od, chart_title=:links, notes = "A LinkList shows you a list of links with optional descriptions. These are automatically generated if you make a Pages struct where there is a LinkList on the top page with links to the others. You can also make your own. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linklist_examples.html\" style=\"color: blue; font-weight: bold;\">See here for LinkList examples</a>")

# TextBlock
textblock_example = TextBlock("""
<h1>TextBlock</h1>
You can write whatever HTML you want and put it in a TextBlock which will put it in the resultant HTML.
<div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px;">
    <p><strong>TextBlock</strong> allows you to add rich text, HTML, and annotations to your reports.</p>
    <p>You can include <em>formatting</em>, <strong>styled text</strong>, and even <code>inline code</code>.</p>
    <p> See here for <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/textblock_examples.html" style="color: blue; font-weight: bold;">TextBlock examples</a>.</p>
</div>
""")

# Notes
notes_explanation = TextBlock("""
<h1>Notes</h1>
<p><strong>Notes</strong> provides editable text areas for adding commentary to your visualizations. When using external data formats (parquet, csv_external, json_external), Notes creates text files that you can edit after generating the HTML. Your edits will appear in the document when refreshed.</p>
<p> The idea is sometimes you will want to make a report, interpret it, and then store your observations as part of the report. You can always do this directly by editing the HTML but note is designed to make it easier.</p>
<p>After generating the HTML, edit the text file in the <code>notes/</code> folder and refresh the page to see your notes.</p>
<p>See the <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/notes_example/notes_example.html" style="color: blue; font-weight: bold;">Notes example</a> for a demonstration.</p>
""")

notes_example = Notes(
    template = "Add your observations about this tutorial here...",
    heading = "Tutorial Notes",
    textfilename = "tutorial_notes.txt"
)

# ===== 2D Plotting =====
plotting_2d_section = TextBlock("<h1>Two-Dimensional Plots</h1>")

# LineChart
daily_product = @linq df |> groupby( [:date, :product]) |> combine( :total_sales = sum(:sales))

line_chart = LineChart(:LineChart, df, :sales_data,
    x_cols=[:date, :quarter],
    y_cols=[:sales, :quantity, :profit, :customers, :satisfaction],
    color_cols=[:product, :region, :segment],
    facet_cols=[:region, :segment, :product, :month],
    notes="A linechart. There are optional controls to change the variables on the x and or y axis. It is also possible to change the faceting, the grouping variable, the aggregation variable (if there are multiple y values per x value) as well as filters. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linechart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for LineChart examples</a>")

# AreaChart
area_chart = AreaChart(:AreaChart, df, :sales_data,
    x_cols=[:date, :quarter],
    y_cols=[:sales, :quantity, :cost, :customers, :satisfaction],
    color_cols=[:product, :segment, :region],
    filters = Dict{Symbol,Any}(:product => unique(df.product), :segment => unique(df.segment), :region => unique(df.region)),
    facet_cols=[:region, :product, :segment],
    notes="Stacked Trends. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/areachart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for AreaChart examples</a>")

# ScatterPlot
scatter_chart = ScatterPlot(:scatter, df, :sales_data, [:profit, :sales, :quantity, :customers, :cost, :satisfaction];
    color_cols=[:product, :region, :segment, :month],
    facet_cols=[:region, :product, :segment],
    default_facet_cols=nothing,
    notes="Scatter plots show x vs y. There is a density colouring that can be applied or not depending on a slider. In addition the marginal distributions appear on the edges of the plot in cases when you do not apply faceting. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatterplot_examples.html\" style=\"color: blue; font-weight: bold;\">See here for ScatterPlot examples</a>")


# Path - Business Performance Trajectories
# Create business metrics dataset (same as used in Slides examples)
rng_path = StableRNG(333)
products_path = ["Widget", "Gadget", "Doohickey"]
regions_path = ["North", "South", "East", "West"]
segments_path = ["Consumer", "Enterprise", "Government"]

business_path_data = []
for product in products_path
    for region in regions_path
        for segment in segments_path
            for month in 1:12
                base_sales = product == "Widget" ? 500 : (product == "Gadget" ? 700 : 400)
                sales = base_sales + month * 20 + rand(rng_path, 50:300)
                cost = sales * (0.60 + rand(rng_path) * 0.10)
                profit = sales - cost

                push!(business_path_data, (
                    Product = product,
                    Region = region,
                    Segment = segment,
                    Month = month,
                    Sales = round(sales),
                    Cost = round(cost),
                    Profit = round(profit)
                ))
            end
        end
    end
end
df_business_path = DataFrame(business_path_data)

path_chart = Path(:path, df_business_path, :business_path_data;
    x_cols=[:Cost, :Profit, :Sales],
    y_cols=[:Profit, :Sales, :Cost],
    order_col=:Month,
    color_cols=[:Product, :Region, :Segment],
    filters = Dict{Symbol,Any}(:Region => "North", :Segment => "Consumer", :Product => unique(df_business_path.Product)),
    show_arrows=true,
    use_alpharange=true,
    notes="A Path chart shows trajectories through metric space over time. This example uses business data (Sales/Cost/Profit by Product/Region/Segment over 12 months) - the same dataset that will be used later in the Slides examples. Each path traces how a product's metrics evolve month-by-month. By default, it shows the North region and Consumer segment, with paths colored by Product. Use the filters to explore different regions and segments. The arrows and alpha gradient show the direction of time progression. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/path_examples.html\" style=\"color: blue; font-weight: bold;\">See here for Path examples</a>")

# More Exotic Plot Types
# Corrplot.
example5_text = TextBlock("""
<h2>Example 5: Advanced CorrPlot - Stock Market Analysis with Multiple Scenarios</h2>
<p>This example demonstrates the advanced CorrPlot features with multiple correlation scenarios:</p>
<ul>
    <li><strong>Multiple scenarios:</strong> Switch between different correlation analyses (Short-term, Long-term, Volatility)</li>
    <li><strong>Variable selection:</strong> Multi-select box to choose which stocks to display</li>
    <li><strong>Manual ordering:</strong> Toggle between dendrogram ordering and drag-drop manual ordering</li>
    <li>Interactive exploration of different time horizons and metrics</li>
</ul>
<p><strong>Try this:</strong></p>
<ol>
    <li>Switch scenarios using the dropdown to compare short-term vs long-term correlations</li>
    <li>Select specific stocks to focus on particular sectors</li>
    <li>Uncheck "Order by Dendrogram" and drag stocks to create your own ordering</li>
</ol>
""")

# Initialize random number generator for reproducibility
using Random
rng = Random.MersenneTwister(12345)

# Generate stock market data for different time horizons
n_days = 250  # Trading days
stock_symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "JPM", "BAC", "GS", "JNJ", "PFE"]
n_stocks = length(stock_symbols)

# Generate returns for each stock (correlated within sectors)
# Tech: AAPL, MSFT, GOOGL, AMZN, TSLA
# Finance: JPM, BAC, GS
# Healthcare: JNJ, PFE

stock_returns = zeros(n_days, n_stocks)
for day in 1:n_days
    # Tech sector common factor
    tech_factor = randn(rng) * 0.02
    # Finance sector common factor
    finance_factor = randn(rng) * 0.015
    # Healthcare sector common factor
    health_factor = randn(rng) * 0.01

    stock_returns[day, 1:5] .= tech_factor .+ randn(rng, 5) .* 0.015  # Tech stocks
    stock_returns[day, 6:8] .= finance_factor .+ randn(rng, 3) .* 0.012  # Finance
    stock_returns[day, 9:10] .= health_factor .+ randn(rng, 2) .* 0.008  # Healthcare
end

# Create DataFrame
df_stocks = DataFrame(stock_returns, stock_symbols)

# Scenario 1: Short-term returns (daily)
short_vars = Symbol.(stock_symbols)
cors_short = compute_correlations(df_stocks, short_vars)
corr_data_short = prepare_corrplot_data(cors_short.pearson, cors_short.spearman, stock_symbols,
                                        scenario="Short-term Returns (Daily)")

# Scenario 2: Long-term returns (20-day rolling)
df_longterm = DataFrame()
for sym in stock_symbols
    df_longterm[!, Symbol(sym)] = [sum(df_stocks[max(1, i-19):i, Symbol(sym)])
                                    for i in 20:n_days]
end
long_vars = Symbol.(stock_symbols)
cors_long = compute_correlations(df_longterm, long_vars)
corr_data_long = prepare_corrplot_data(cors_long.pearson, cors_long.spearman, stock_symbols,
                                       scenario="Long-term Returns (20-day)")

# Scenario 3: Volatility correlations (rolling std deviation)
df_volatility = DataFrame()
for sym in stock_symbols
    volatilities = [std(df_stocks[max(1, i-19):i, Symbol(sym)])
                   for i in 20:n_days]
    df_volatility[!, Symbol(sym)] = volatilities
end
vol_vars = Symbol.(stock_symbols)
cors_vol = compute_correlations(df_volatility, vol_vars)
corr_data_vol = prepare_corrplot_data(cors_vol.pearson, cors_vol.spearman, stock_symbols,
                                      scenario="Volatility Correlations")

# Combine all scenarios into one DataFrame
# The data has columns: node1, node2, strength, scenario, correlation_method
stock_corr_data = vcat(corr_data_short, corr_data_long, corr_data_vol)

# Add sector information for Graph node coloring
stock_sectors = Dict(
    "AAPL" => "Technology", "MSFT" => "Technology", "GOOGL" => "Technology",
    "AMZN" => "Technology", "TSLA" => "Technology",
    "JPM" => "Finance", "BAC" => "Finance", "GS" => "Finance",
    "JNJ" => "Healthcare", "PFE" => "Healthcare"
)
stock_corr_data[!, :sector] = [stock_sectors[asset] for asset in stock_corr_data.node1]

# Create CorrPlot with multiple scenarios
corrplot5 = CorrPlot(:stock_advanced, stock_corr_data, :stock_corr_data;
    title = "Stock Market Correlation Analysis - Multiple Scenarios",
    notes = "A Correlation Plot with Dendrogram shows relationships between variables using hierarchical clustering. The dendrogram (top) groups similar variables based on their correlation patterns, with clustering performed dynamically in your browser. Note that it will only appear if i) you select order by dendrogram and ii) you select all of the variables. The correlation matrix (bottom) uses two different correlation measures: Pearson correlations (top-right triangle, marked with 'P:') measure linear relationships, while Spearman correlations (bottom-left triangle, marked with 'S:') measure monotonic relationships and are robust to outliers. You can change the clustering linkage method (Ward, Average, Single, Complete) to see different groupings. Variables are automatically reordered by the clustering to reveal correlation blocks. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/corrplot_examples.html\" style=\"color: blue; font-weight: bold;\">See here for CorrPlot examples</a>",
    scenario_col = :scenario,
    default_scenario = "Short-term Returns (Daily)",
    default_variables = ["AAPL", "MSFT", "JPM", "JNJ"],
    allow_manual_order = true
)

# Create Graph using the SAME data as CorrPlot
graph_stock = Graph(:stock_network,
                    stock_corr_data,
                    :stock_corr_data;
    title = "Graph",
    notes = "This Graph allows you to visualise the relationships between variables. The dataformat to make this is a DataFrame with columns: node1, node2, strength, scenario, correlation_method, sector. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/graph_examples.html\" style=\"color: blue; font-weight: bold;\">See here for more Graph examples</a>",
    cutoff = 0.5,
    color_cols = [:sector],
    show_edge_labels = false,
    layout = :cose,
    scenario_col = :scenario,
    default_scenario = "Short-term Returns (Daily)"
)

# TSNEPlot - Interactive t-SNE visualization
# Create stock feature data from the returns
tsne_stock_data = DataFrame(
    stock = stock_symbols,
    sector = [stock_sectors[s] for s in stock_symbols],
    mean_return = [mean(df_stocks[!, Symbol(s)]) for s in stock_symbols],
    volatility = [std(df_stocks[!, Symbol(s)]) for s in stock_symbols],
    max_drawdown = [minimum(df_stocks[!, Symbol(s)]) for s in stock_symbols],
    best_day = [maximum(df_stocks[!, Symbol(s)]) for s in stock_symbols],
    skewness = [begin
        vals = df_stocks[!, Symbol(s)]
        m = mean(vals)
        s_std = std(vals)
        mean(((vals .- m) ./ s_std) .^ 3)
    end for s in stock_symbols],
    kurtosis = [begin
        vals = df_stocks[!, Symbol(s)]
        m = mean(vals)
        s_std = std(vals)
        mean(((vals .- m) ./ s_std) .^ 4) - 3
    end for s in stock_symbols]
)

tsne_chart = TSNEPlot(:stock_tsne, tsne_stock_data, :tsne_stock_data;
    entity_col = :stock,
    feature_cols = [:mean_return, :volatility, :max_drawdown, :best_day, :skewness, :kurtosis],
    color_cols = [:sector],
    tooltip_cols = [:sector, :mean_return, :volatility],
    perplexity = 5.0,
    learning_rate = 200.0,
    title = "Stock Similarity (t-SNE)",
    notes = "TSNEPlot performs t-SNE dimensionality reduction entirely in the browser. This example shows 10 stocks positioned by similarity across 6 statistical features. <strong>Key Features:</strong> Interactive feature selection (Available/Selected lists let you choose which variables define similarity), Rescaling options (None, Z-score, Z-score capped, Quantile), Configurable early exaggeration (iterations and factor), Three step modes: 'Step (small)' for single non-exaggerated steps, 'Exaggerated Step' for large movements, 'Run to Convergence' for automatic optimization. You can drag nodes to manually reposition them and resume iteration. Color by sector to see if similar stocks cluster together. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/tsneplot_examples/tsneplot_examples.html\" style=\"color: blue; font-weight: bold;\">See here for TSNEPlot examples</a>"
)

# ===== Financial Charts =====
financial_section = TextBlock("<h1>Financial Charts</h1>")

# Generate Candlestick data for multiple stocks
using Random
rng_candlestick = Random.MersenneTwister(789)
trading_dates = Date(2024, 1, 1):Day(1):Date(2024, 3, 31)  # Q1 2024
trading_dates = filter(d -> dayofweek(d) < 6, collect(trading_dates))  # Remove weekends

candlestick_symbols = ["AAPL", "MSFT", "GOOGL"]
candlestick_data_parts = []

for symbol in candlestick_symbols
    # Different base prices for each stock
    base_price = Dict("AAPL" => 175.0, "MSFT" => 380.0, "GOOGL" => 140.0)[symbol]
    price = base_price

    for date in trading_dates
        # Simulate daily price movement
        daily_return = randn(rng_candlestick) * 0.02  # 2% daily volatility

        open_price = price
        close_price = price * (1 + daily_return)

        # High and low with some randomness
        high_price = max(open_price, close_price) * (1 + abs(randn(rng_candlestick)) * 0.01)
        low_price = min(open_price, close_price) * (1 - abs(randn(rng_candlestick)) * 0.01)

        # Volume varies with volatility
        volume = round(Int, 50_000_000 * (1 + abs(daily_return) * 2 + rand(rng_candlestick) * 0.5))

        push!(candlestick_data_parts, (
            time_from = date,
            time_to = date,
            symbol = symbol,
            open = open_price,
            high = high_price,
            low = low_price,
            close = close_price,
            volume = volume,
            sector = symbol == "AAPL" ? "Technology" : (symbol == "MSFT" ? "Technology" : "Technology")
        ))

        price = close_price  # Next day starts where previous closed
    end
end

candlestick_df = DataFrame(candlestick_data_parts)

candlestick_chart = CandlestickChart(:financial_candlestick, candlestick_df, :candlestick_data;
    time_from_col=:time_from,
    time_to_col=:time_to,
    symbol_col=:symbol,
    open_col=:open,
    high_col=:high,
    low_col=:low,
    close_col=:close,
    volume_col=:volume,
    filters=Dict{Symbol,Any}(:sector => ["Technology"]),
    display_mode="Overlay",
    show_volume=true,
    title="Stock Price Analysis - Q1 2024",
    notes="An Candlestick (Open-High-Low-Close) chart displays financial market data with candlesticks showing price movements. This example tracks AAPL, MSFT, and GOOGL through Q1 2024. <strong>Key Features:</strong> Time range sliders to zoom into specific date ranges (drag the handles to adjust), Renormalize toggle to compare stocks at different price levels (divides all prices by first bar's open price, setting it to 1.0), Display mode dropdown to switch between Overlay (all symbols on same chart) and Faceted (one subplot per symbol), Volume bars at bottom with Show/Hide toggle and Log scale option (useful when volume varies greatly), Chart type selector to switch between candlestick (filled bars) and Candlestick (line bars) styles, Filter controls to select which stocks and sectors to display. The volume bars use a dodged (grouped) layout and align perfectly with the Candlestick bars above. This visualization is essential for technical analysis, allowing traders to identify patterns, trends, and volume spikes. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/candlestickchart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for CandlestickChart examples</a>")

# ExecutionPlot - Trading Execution Analysis
# Generate simulated execution data for 5 different orders
rng_exec = StableRNG(456)
dims_exec = 5
ticks_exec = 15000  # Need enough ticks for 5 executions with 500 time slots each

# Generate correlated price paths for 5 assets
brownian_corr_exec = Hermitian(0.6 .+ 0.4*I(dims_exec))
ts_exec, true_covar_exec, _, _ = HighFrequencyCovariance.generate_random_path(
    dims_exec, ticks_exec; syncronous=true, brownian_corr_matrix=brownian_corr_exec,
    vol_dist = Distributions.Uniform(0.0008, 0.0015),
    micro_noise_dist = Distributions.Uniform(0, 0.0000001),
)

# Create bid/ask data
bidask_exec = copy(ts_exec.df)
bidask_exec[!, :Value] .= exp.(bidask_exec.Value)
rename!(bidask_exec, Dict(:Time => :time, :Name => :symbol, :Value => :bid_price))
bidask_exec[:, :ask_price] = bidask_exec[:, :bid_price] .* (1.002 .+ (0.001 .* rand(rng_exec, size(bidask_exec,1))))

exec_assets = true_covar_exec.labels
unique_times_exec = sort(unique(bidask_exec.time))

# Generate 5 executions, each for a different asset
exec_fills_parts = DataFrame[]
exec_metadata_parts = DataFrame[]

for exec_idx in 1:5
    asset = exec_assets[exec_idx]
    fills_per_exec = rand(rng_exec, 8:15)

    # Get time window for this execution
    start_tick = 1 + (exec_idx - 1) * 500
    end_tick = min(start_tick + 400, length(unique_times_exec))
    exec_times = unique_times_exec[start_tick:end_tick]

    subframe = bidask_exec[(bidask_exec.symbol .== asset) .& (bidask_exec.time .>= exec_times[1]) .& (bidask_exec.time .<= exec_times[end]), :]

    fill_indices = round.(Int, range(1, nrow(subframe), length=fills_per_exec))
    fill_times = subframe.time[fill_indices]
    fill_prices = [subframe.bid_price[i] + rand(rng_exec) * (subframe.ask_price[i] - subframe.bid_price[i]) for i in fill_indices]
    fill_quantities = rand(rng_exec, 500:2000, fills_per_exec)

    exec_name = "Order_$(exec_idx)_$(asset)"

    # Add categorical columns for coloring and tooltips
    order_types = rand(rng_exec, ["limit", "market", "iceberg"], fills_per_exec)
    exchanges = rand(rng_exec, ["NYSE", "NASDAQ", "BATS", "IEX"], fills_per_exec)
    brokers = rand(rng_exec, ["GoldmanSachs", "MorganStanley", "JPMorgan"], fills_per_exec)

    push!(exec_fills_parts, DataFrame(
        time = fill_times,
        quantity = fill_quantities,
        price = fill_prices,
        execution_name = fill(exec_name, fills_per_exec),
        asset = fill(asset, fills_per_exec),
        order_type = order_types,
        exchange = exchanges,
        broker = brokers
    ))

    arrival_price = (subframe.bid_price[1] + subframe.ask_price[1]) / 2
    side = exec_idx % 2 == 0 ? "buy" : "sell"

    push!(exec_metadata_parts, DataFrame(
        execution_name = [exec_name],
        arrival_price = [arrival_price],
        side = [side],
        desired_quantity = [sum(fill_quantities)]
    ))
end

exec_fills = reduce(vcat, exec_fills_parts)
exec_metadata = reduce(vcat, exec_metadata_parts)

# Create volume data
volume_times_exec = unique(bidask_exec.time[1:30:end])
n_vol_intervals = length(volume_times_exec) - 1
volume_exec_parts = DataFrame[]
for asset in exec_assets
    push!(volume_exec_parts, DataFrame(
        time_from = volume_times_exec[1:end-1],
        time_to = volume_times_exec[2:end],
        symbol = fill(asset, n_vol_intervals),
        volume = rand(rng_exec, 30000:150000, n_vol_intervals)
    ))
end
volume_exec = reduce(vcat, volume_exec_parts)

# Create ExecutionData with peers (refined slippage)
exec_data_tutorial = ExecutionData(exec_fills, exec_metadata, bidask_exec, true_covar_exec; volume=volume_exec)
calculate_slippage!(exec_data_tutorial)

# Create ExecutionPlot with tooltips showing broker and order_type
execution_plot = ExecutionPlot(:execution_analysis, exec_data_tutorial, :exec_data;
    tooltip_cols = [:broker],  # order_type and exchange are auto-included from color_cols
    title = "Trading Execution Analysis",
    notes = "ExecutionPlot provides comprehensive analysis of trading execution quality using the RefinedSlippage methodology. <strong>Key Features:</strong> Dropdown to select individual executions, color fills by order type or exchange, units dropdown to switch between bps/pct/USD, summary table with key metrics (classical slippage, vs VWAP, refined slippage, spread crossing). <strong>Views:</strong> Bid/Ask shows market spread with fills and volume bars, Mid+CF shows counterfactual prices from peer correlations, +Peers overlays correlated asset price paths, Progress shows execution completion %, Spread Pos shows where fills occurred within the bid-ask spread, Slippage shows cumulative slippage metrics over the order. Volume toggle adds market volume bars. Data source documentation appears below the chart. <strong>References:</strong> <a href=\"https://papers.ssrn.com/sol3/papers.cfm?abstract_id=5114581\" style=\"color: blue; font-weight: bold;\">SSRN paper on Refined Slippage</a> | <a href=\"https://github.com/s-baumann/RefinedSlippage.jl\" style=\"color: blue; font-weight: bold;\">RefinedSlippage.jl GitHub repo</a> | <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/executionplot_examples.html\" style=\"color: blue; font-weight: bold;\">See here for ExecutionPlot examples</a>"
)

# Get the prepared data for the page
exec_data_dict = get_execution_data_dict(execution_plot)

# Waterfall
# Create waterfall data showing profit breakdown
waterfall_data = DataFrame(
    item = ["Good Sales", "Renting Spare Office", "Vending Machine Revenue", "COGS", "Staff Expenses", "Marketing", "Depreciation", "Taxes"],
    category = ["Income", "Income", "Income", "Costs", "Costs", "Costs", "Costs", "Taxes"],
    value = [1500, 200, 50, -800, -400, -100, -50, -150]
)

waterfall_chart = Waterfall(:waterfall, waterfall_data, :waterfall_data;
    item_col = :item,
    color_cols = [:category],
    value_col = :value,
    title = "Profit & Loss Waterfall",
    show_table = true,
    show_totals = true,
    notes="A Waterfall chart visualizes how an initial value is affected by a series of positive and negative values. This example shows a profit & loss statement. <strong>Features:</strong> Automatic cumulative calculation, side-by-side table grouped by category, click bars or table rows to exclude items, toggle categories with checkboxes, switch between value-based (green/red) and category-based coloring, black total bar (toggleable). <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/waterfall_examples.html\" style=\"color: blue; font-weight: bold;\">See here for more Waterfall examples</a>")


    # SanKey
# Create Sankey diagram data showing crypto/stock holdings evolution for traders
sankey_data_rows = []

# Define possible holdings
crypto_holdings_by_year = Dict(
    2015 => ["Bitcoin"],
    2018 => ["Bitcoin", "Ethereum", "Dogecoin"],
    2020 => ["Bitcoin", "Ethereum", "Dogecoin", "Cardano", "Solana"],
    2023 => ["Bitcoin", "Ethereum", "Solana", "Cardano", "Polkadot"]
)

stock_holdings_by_year = Dict(
    2015 => ["Tech Stocks", "Index Funds"],
    2018 => ["Tech Stocks", "Index Funds", "Growth Stocks"],
    2020 => ["Tech Stocks", "Index Funds", "Growth Stocks", "Dividend Stocks"],
    2023 => ["Tech Stocks", "Growth Stocks", "Dividend Stocks", "Crypto Stocks"]
)

# Create 50 traders with realistic portfolio evolution
trader_count = 50
for trader_id in 1:trader_count
    # 2015: Everyone holding Bitcoin
    crypto_2015 = "Bitcoin"
    stock_2015 = rand(rng, ["Tech Stocks", "Index Funds"])

    # 2018: Some diversification
    crypto_2018 = if rand(rng) < 0.3
        "Ethereum"
    elseif rand(rng) < 0.2
        "Dogecoin"
    else
        "Bitcoin"
    end
    stock_2018 = if stock_2015 == "Tech Stocks"
        rand(rng, ["Tech Stocks", "Growth Stocks"])
    else
        rand(rng, ["Index Funds", "Tech Stocks"])
    end

    # 2020: More diversification
    crypto_2020 = if crypto_2018 == "Ethereum"
        rand(rng, ["Ethereum", "Cardano", "Solana"])
    elseif crypto_2018 == "Dogecoin"
        rand(rng, ["Dogecoin", "Bitcoin"])
    else
        rand(rng, ["Bitcoin", "Ethereum", "Cardano"])
    end
    stock_2020 = if stock_2018 == "Growth Stocks"
        rand(rng, ["Growth Stocks", "Tech Stocks"])
    else
        rand(rng, ["Index Funds", "Dividend Stocks", "Tech Stocks"])
    end

    # 2023: Current holdings
    crypto_2023 = if crypto_2020 in ["Solana", "Cardano"]
        rand(rng, ["Solana", "Cardano", "Polkadot"])
    elseif crypto_2020 == "Ethereum"
        rand(rng, ["Ethereum", "Solana", "Bitcoin"])
    else
        rand(rng, ["Bitcoin", "Ethereum"])
    end
    stock_2023 = if stock_2020 == "Dividend Stocks"
        rand(rng, ["Dividend Stocks", "Crypto Stocks"])
    else
        rand(rng, ["Tech Stocks", "Growth Stocks", "Crypto Stocks"])
    end

    # Portfolio values (growing over time with some variation)
    value_2015 = Float64(rand(rng, 5000:10000))
    value_2018 = value_2015 * rand(rng, 1.5:0.1:3.0)
    value_2020 = value_2018 * rand(rng, 0.8:0.1:2.5)
    value_2023 = value_2020 * rand(rng, 1.0:0.1:4.0)

    for (year, crypto, stock, value) in [
        (2015, crypto_2015, stock_2015, value_2015),
        (2018, crypto_2018, stock_2018, value_2018),
        (2020, crypto_2020, stock_2020, value_2020),
        (2023, crypto_2023, stock_2023, value_2023)
    ]
        push!(sankey_data_rows, (
            trader_id = trader_id,
            year = year,
            crypto_holding = crypto,
            stock_holding = stock,
            portfolio_value = value
        ))
    end
end

sankey_df = DataFrame(sankey_data_rows)

sankey_chart = SanKey(:ribbon, sankey_df, :sankey_data;
    id_col = :trader_id,
    time_col = :year,
    color_cols = [:crypto_holding, :stock_holding],
    value_cols = [:portfolio_value],
    title = "Trader Portfolio Evolution (2015-2023)",
    notes="A SanKey diagram showing how 50 traders' portfolios evolved from 2015 to 2023. Use the 'Affiliation' dropdown to switch between crypto holdings and stock holdings. The ribbon width represents portfolio value. In 2015, all traders held Bitcoin; by 2023, holdings diversified into various cryptocurrencies and stock categories. Notice migration patterns: early Bitcoin holders moving to Ethereum/Solana, and tech stock investors shifting to growth/crypto stocks. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/sankey_examples.html\" style=\"color: blue; font-weight: bold;\">See here for SanKey examples</a>")

# ===== RadarChart =====
# Create comprehensive product performance data for radar chart
rng_radar = StableRNG(777)
radar_products = [
    "Cloud Platform Pro", "Cloud Platform Starter", "Cloud Platform Enterprise",
    "Analytics Suite Pro", "Analytics Suite Starter", "Analytics Suite Enterprise",
    "Security Shield Pro", "Security Shield Starter", "Security Shield Enterprise",
    "Collaboration Hub Pro", "Collaboration Hub Starter", "Collaboration Hub Enterprise"
]

radar_data_rows = []

# Generate data for two scenarios: Current Version and Next Release
for scenario in ["Current Version", "Next Release"]
    scenario_boost = scenario == "Next Release" ? 8.0 : 0.0  # Next release is better

    for product in radar_products
        # Determine product category and tier
        if occursin("Cloud Platform", product)
            category = "Infrastructure"
            base_tech = 85.0
            base_ui = 70.0
            base_perf = 90.0
        elseif occursin("Analytics", product)
            category = "Data & AI"
            base_tech = 90.0
            base_ui = 85.0
            base_perf = 80.0
        elseif occursin("Security", product)
            category = "Security"
            base_tech = 95.0
            base_ui = 65.0
            base_perf = 85.0
        else  # Collaboration
            category = "Productivity"
            base_tech = 75.0
            base_ui = 95.0
            base_perf = 70.0
        end

        # Determine tier
        if occursin("Enterprise", product)
            tier = "Enterprise"
            tier_mult = 1.2
            price_mult = 3.0
        elseif occursin("Pro", product)
            tier = "Professional"
            tier_mult = 1.0
            price_mult = 1.5
        else
            tier = "Starter"
            tier_mult = 0.8
            price_mult = 1.0
        end

        # Technical Performance metrics (grouped)
        tech_reliability = min(100.0, base_tech * tier_mult + scenario_boost + randn(rng_radar) * 3)
        tech_scalability = min(100.0, (base_tech - 5) * tier_mult + scenario_boost + randn(rng_radar) * 3)
        tech_api_quality = min(100.0, (base_tech + 5) * tier_mult + scenario_boost + randn(rng_radar) * 3)
        tech_integration = min(100.0, base_tech * tier_mult + scenario_boost + randn(rng_radar) * 4)

        # User Experience metrics (grouped) - bigger improvement in next release
        ux_ease_of_use = min(100.0, base_ui * tier_mult + scenario_boost * 1.5 + randn(rng_radar) * 4)
        ux_design = min(100.0, (base_ui + 5) * tier_mult + scenario_boost * 1.5 + randn(rng_radar) * 3)
        ux_customization = min(100.0, (base_ui - 10) * tier_mult + scenario_boost + randn(rng_radar) * 5)
        ux_mobile = min(100.0, base_ui * tier_mult + scenario_boost * 1.5 + randn(rng_radar) * 6)

        # Performance metrics (grouped)
        perf_speed = min(100.0, base_perf * tier_mult + scenario_boost + randn(rng_radar) * 4)
        perf_efficiency = min(100.0, (base_perf + 5) * tier_mult + scenario_boost + randn(rng_radar) * 3)
        perf_uptime = min(100.0, (base_perf + 10) * tier_mult + scenario_boost * 0.5 + randn(rng_radar) * 2)

        # Business Value metrics (grouped)
        biz_roi = min(100.0, 100.0 - (price_mult - 1) * 20 + scenario_boost + randn(rng_radar) * 5)
        biz_support = min(100.0, 60.0 * tier_mult + scenario_boost + randn(rng_radar) * 8)
        biz_documentation = min(100.0, 70.0 * tier_mult + scenario_boost * 1.2 + randn(rng_radar) * 5)
        biz_training = min(100.0, 65.0 * tier_mult + scenario_boost + randn(rng_radar) * 7)

        # Market Position metrics (grouped) - less affected by release
        market_adoption = min(100.0, 50.0 + scenario_boost * 0.3 + randn(rng_radar) * 15)
        market_satisfaction = min(100.0, 75.0 + scenario_boost * 0.5 + randn(rng_radar) * 10)
        market_growth = min(100.0, 60.0 + scenario_boost * 0.7 + randn(rng_radar) * 12)

        push!(radar_data_rows, (
            label = product,
            category = category,
            tier = tier,
            scenario = scenario,
            # Technical Performance
            Reliability = tech_reliability,
            Scalability = tech_scalability,
            API_Quality = tech_api_quality,
            Integration = tech_integration,
            # User Experience
            Ease_of_Use = ux_ease_of_use,
            Design = ux_design,
            Customization = ux_customization,
            Mobile = ux_mobile,
            # Performance
            Speed = perf_speed,
            Efficiency = perf_efficiency,
            Uptime = perf_uptime,
            # Business Value
            ROI = biz_roi,
            Support = biz_support,
            Documentation = biz_documentation,
            Training = biz_training,
            # Market Position
            Adoption = market_adoption,
            Satisfaction = market_satisfaction,
            Growth = market_growth
        ))
    end
end

radar_df = DataFrame(radar_data_rows)

# Define grouping for radar chart axes
radar_group_mapping = Dict{Symbol, String}(
    :Reliability => "Technical Performance",
    :Scalability => "Technical Performance",
    :API_Quality => "Technical Performance",
    :Integration => "Technical Performance",
    :Ease_of_Use => "User Experience",
    :Design => "User Experience",
    :Customization => "User Experience",
    :Mobile => "User Experience",
    :Speed => "Performance",
    :Efficiency => "Performance",
    :Uptime => "Performance",
    :ROI => "Business Value",
    :Support => "Business Value",
    :Documentation => "Business Value",
    :Training => "Business Value",
    :Adoption => "Market Position",
    :Satisfaction => "Market Position",
    :Growth => "Market Position"
)

radar_chart = RadarChart(:product_radar, :radar_data;
    value_cols = [:Reliability, :Scalability, :API_Quality, :Integration,
                  :Ease_of_Use, :Design, :Customization, :Mobile,
                  :Speed, :Efficiency, :Uptime,
                  :ROI, :Support, :Documentation, :Training,
                  :Adoption, :Satisfaction, :Growth],
    label_col = :label,
    group_mapping = radar_group_mapping,
    scenario_col = :scenario,
    color_col = :category,
    variable_selector = true,
    max_variables = 3,
    title = "Product Performance RadarChart",
    notes = "RadarChart (spider chart) displaying many dimensions in a geometric way. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/radarchart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for RadarChart examples</a>",
    max_value = 100.0,
    show_legend = true,
    show_grid_labels = true
)

# BumpChart - Rankings over time
# Aggregate data by quarter and product to show rankings
df_rankings = @linq df |>
    groupby([:quarter, :product, :region, :segment]) |>
    combine(:sales_total = sum(:sales),
            :profit_total = sum(:profit),
            :quantity_total = sum(:quantity),
            :satisfaction_avg = mean(:satisfaction))

bump_chart = BumpChart(:bump_rankings, df_rankings, :rankings_data;
    x_col=:quarter,
    performance_cols=[:sales_total, :profit_total, :quantity_total, :satisfaction_avg],
    entity_col=:product,
    filters=Dict{Symbol,Any}(:region => unique(df_rankings.region), :segment => unique(df_rankings.segment)),
    facet_cols=[:region, :segment],
    default_facet_cols = [:region, :segment],
    y_mode="Ranking",
    line_width=3,
    title="Product Rankings Over Time",
    notes="A BumpChart shows how entities rank over time based on different performance metrics. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/bumpchart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for BumpChart examples</a>")



# ===== Distributional Plots =====
distribution_section = TextBlock("<h1>Distributional Plots</h1>")

# DistPlot
dist_chart = DistPlot(:dist, df, :sales_data,
    value_cols=[:profit, :sales, :cost, :quantity, :customers, :satisfaction],
    color_cols=[:region, :product, :segment],
    filters=[:region, :product, :segment],
    notes="This makes a historgram, box and whiskers and rugplot. So you can see differences in distribution for a variable between different groups of observations. Note at the bottom there is a slider for changing the number of bins in the histogram. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/distplot_examples.html\" style=\"color: blue; font-weight: bold;\">See here for DistPlot examples</a>")

# KernelDensity
kde_chart = KernelDensity(:kde, df, :sales_data,
    value_cols=[:profit, :sales, :cost, :quantity, :customers, :satisfaction],
    color_cols=[:region, :product, :segment],
    filters=[:region, :product, :segment],
    facet_cols=[:region, :product, :segment],
    default_facet_cols=[:segment],
    notes="This shows kernel density estimates for a variable seperated by groups in the observations. It also has faceting available (unlike DistPlot). There is a slider at the bottom for controlling the bandwidth of the kernel density estimate. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/kerneldensity_examples.html\" style=\"color: blue; font-weight: bold;\">See here for KernelDensity examples</a>")

# PieChart
pie_chart = PieChart(:pie, df, :sales_data,
    color_cols=[:region, :product, :segment, :month, :quarter],
    value_cols=[:sales, :profit, :quantity, :cost, :customers, :satisfaction],
    notes="This gives piecharts. Note that piecharts are generally pretty bad (google it to see more on this) but up to you if you like them. There is faceting available, filtering and you can change the grouping variable and the numeric variable being aggregated over to determine pie width. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/piechart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for PieChart examples</a>")

# BoxAndWhiskers
# Create detailed product performance data with multiple grouping levels
ll = DataFrame[]
rng_bw = StableRNG(999)
for region in ["North America", "Europe", "Asia Pacific", "Latin America"]
    for product in ["Premium", "Standard", "Economy"]
        for segment in ["Enterprise", "SMB", "Consumer"]
            # Generate realistic performance metrics
            n_samples = 150
            base_value = (region == "North America" ? 100 :
                         region == "Europe" ? 90 :
                         region == "Asia Pacific" ? 110 :
                         80)
            product_mult = (product == "Premium" ? 1.5 :
                           product == "Standard" ? 1.0 :
                           0.7)
            segment_mult = (segment == "Enterprise" ? 1.4 :
                           segment == "SMB" ? 1.0 :
                           0.8)

            mean_revenue = base_value * product_mult * segment_mult
            std_revenue = mean_revenue * 0.25

            # Create group identifier
            group_name = "$(product)-$(segment)-$(region[1:4])"  # Abbreviated region name

            revenues = abs.(randn(rng_bw, n_samples) .* std_revenue .+ mean_revenue)
            satisfaction = 5.0 .- (randn(rng_bw, n_samples) .* 0.5)  # Out of 5

            temp_df = DataFrame(
                group = fill(group_name, n_samples),
                revenue = revenues,
                satisfaction = satisfaction,
                region = fill(region, n_samples),
                product = fill(product, n_samples),
                segment = fill(segment, n_samples),
                quarter = rand(rng_bw, ["Q1", "Q2", "Q3", "Q4"], n_samples)
            )
            push!(ll, temp_df)
        end
    end
end
boxwhiskers_data = reduce(vcat, ll)


boxwhiskers_chart = BoxAndWhiskers(:boxwhiskers, boxwhiskers_data, :boxwhiskers_data;
    x_cols = [:revenue, :satisfaction],
    color_cols = [:product, :segment, :region],
    grouping_cols = [:region, :product, :segment],
    group_col = :group,
    filters = Dict{Symbol,Any}(
        :quarter => ["Q1", "Q2", "Q3", "Q4"],
        :region => ["North America", "Europe", "Asia Pacific", "Latin America"]
    ),
    title = "BoxAndWhiskers",
    notes="Box and Whiskers plots represent the distribution of various groups of observations in an aligned way. <strong>Key Features:</strong> Each horizontal box shows min, 10% quantile, 25% quantile, median, 75% quantile, 90% quantile, and max values. In addition there is a seperate bar with the mean, mean ± 1 standard deviation and mean ± 2 standard deviations. You can differentiate the various gropus using colour or by rearranging them with 'Color by' or 'Group by'. You can also switch the variable being summarised with the Value dropdown. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/boxandwhiskers_examples.html\" style=\"color: blue; font-weight: bold;\">See here for BoxAndWhiskers examples</a>")

# ===== 3D Plotting =====
plotting_3d_section = TextBlock("<h1>Three-Dimensional Plots</h1>")

# Scatter3D
scatter3d_sample = df[1:200, :]
scatter3d_chart = Scatter3D(:scatter3d, scatter3d_sample, :sales_data,
    [:longitude, :latitude, :sales, :quantity, :profit, :cost, :customers, :satisfaction];
    color_cols = [:region, :product, :segment, :month, :quarter],
    facet_cols = [:region, :product, :segment, :month, :quarter],
    filters = [:region, :product, :segment, :month, :quarter],
    default_facet_cols = nothing,
    title="3D Scatter Plot",
    notes="This is a 3D scatter plot. You can rotate it and zoom in and out. There are options for showing PCA eigenvectors as well. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatter3d_examples.html\" style=\"color: blue; font-weight: bold;\">See here for Scatter3D examples</a>")

# Surface3D

# We are going to make some surfaces that we can plot with Surface3D. We will make a grid of latitudes and longitudes and then for each grouping variable we will compute average sales for nearby points to make a surface.
lat_range = range(minimum(df.latitude), maximum(df.latitude), length=20)
lon_range = range(minimum(df.longitude), maximum(df.longitude), length=20)
long_df = stack(df[:, [:date, :product, :region, :segment, :sales, :latitude, :longitude]],  Not([:date, :sales, :latitude, :longitude]); variable_name=:grouping_category, value_name=:grouping)

surface_data = DataFrame[]
for lat in lat_range
    for lon in lon_range
        for grp in unique(long_df.grouping)
            subframe = long_df[long_df.grouping .== grp, :]
            nearby = subframe[abs.(subframe.latitude .- lat) .< 5 .&& abs.(subframe.longitude .- lon) .< 10, :]
            avg_sales = isempty(nearby) ? 0.0 : mean(nearby.sales)
            push!(surface_data, DataFrame(latitude=lat, longitude=lon, average_sales=avg_sales, grouping=grp))
        end
    end
end
surface_df = vcat(surface_data...)
surface_df = leftjoin(surface_df, unique(long_df[:, [:grouping_category, :grouping]]), on=:grouping)


surface3d_chart = Surface3D(:surface3d, surface_df, :surface_df,
    x_col=:longitude,
    y_col=:latitude,
    z_col=:average_sales,
    group_col=:grouping,
    filters= Dict{Symbol, Any}(:grouping_category => ["product"]),
    notes="This is a 3D surface plot that allows you to display a few surfaces together. You can rotate it and zoom in and out. This example shows average sales over latitude and longitude. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/surface3d_examples.html\" style=\"color: blue; font-weight: bold;\">See here for Surface3D examples</a>")

# ScatterSurface3D
scattersurface_chart = ScatterSurface3D(:scattersurface, df, :sales_data,
    x_col=:longitude,
    y_col=:latitude,
    z_col=:sales,
    group_cols= [:product, :segment],
    facet_cols= [:region, :product, :segment],
    notes="This is a 3D scatter plot with a fitted surface for each group of points. You can train the surface with differing bandwidth parameters and with the L1 or L2 norm (L2 is default). You can rotate it and zoom in and out. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scattersurface3d_examples.html\" style=\"color: blue; font-weight: bold;\">See here for ScatterSurface3D examples</a>")


# ===== Integration Charts =====
integration_section = TextBlock("""
<h1> Pictures and Slides</h1>
<p><strong>Picture</strong> and <strong>Slides</strong> allow you to embed plots from Plots.jl, Makie.jl, and VegaLite.jl. Pictures can also display static images, animated GIFs, and can be filtered to show different charts based on user selections.</p>
""")

# Picture with filtering - create VegaLite charts for different regions and products
println("Creating filtered Picture example...")
picture_charts_dir = mktempdir()

# Generate charts for different combinations
for region in ["North", "South", "East"]
    for product in ["Widget", "Gadget"]
        # Filter business data for this combination
        chart_data = filter(row -> row.Region == region && row.Product == product, df_business_path)
        if nrow(chart_data) > 0
            # Group by month and sum sales
            monthly_data = combine(groupby(chart_data, :Month), :Sales => sum => :Sales)
            sort!(monthly_data, :Month)

            # Create VegaLite chart
            chart = monthly_data |> @vlplot(
                :bar,
                x={:Month, axis={title="Month", labelAngle=-45}},
                y={:Sales, axis={title="Sales (thousands)"}},
                title="$(product) Sales - $(region) Region",
                width=500,
                height=300,
                color={value="#4682B4"}
            )

            # Save with pattern: sales!Region!Product.png
            filename = "sales!$(region)!$(product).png"
            filepath = joinpath(picture_charts_dir, filename)
            VegaLite.save(filepath, chart)
        end
    end
end

# Create filtered Picture viewer
picture_chart = Picture(
    :Picture,
    picture_charts_dir,
    "sales";
    filters = Dict{Symbol,Any}(
        :group_1 => "North",   # Default region
        :group_2 => "Widget"   # Default product
    ),
    title="Regional Sales Analysis",
    notes="<strong>Picture has three main uses:</strong><br>
           <strong>1. Static Images:</strong> Display any image file (PNG, JPEG, SVG, etc.)<br>
           <strong>2. Animated GIFs:</strong> Embed animated visualizations<br>
           <strong>3. Filtered Viewing:</strong> Generate multiple charts and let users switch between them using filters.<br><br>
           This example shows filtered viewing - use the dropdowns above to explore sales data across different regions and products. The charts are generated with VegaLite.
           <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/picture_examples.html\" style=\"color: blue; font-weight: bold;\">See here for more Picture examples</a>"
)

# Prepare aggregated data for slides using the same business metrics as Path examples
# This is the same dataset structure used in the Path chart above
df_slides = df_business_path

# Function to generate a chart for each slide
# This receives: (data, product, region, segment, month)
# Uses the same business metrics dataset as the Path examples
function make_financial_breakdown_chart(data, product, region, segment, month)
    # Filter data for this specific combination
    filtered = filter(row ->
        row.Product == product &&
        row.Region == region &&
        row.Segment == segment &&
        row.Month == month,
        data
    )

    # If no data, create empty values
    if nrow(filtered) == 0
        cost = 0.0
        profit = 0.0
        sales = 0.0
    else
        cost = filtered.Cost[1]
        profit = filtered.Profit[1]
        sales = filtered.Sales[1]
    end

    # Create a bar chart using VegaLite
    chart_df = DataFrame(
        Metric = ["Cost", "Profit", "Sales"],
        Amount = [cost, profit, sales],
        Color = ["#e74c3c", "#27ae60", "#3498db"]
    )

    # Create VegaLite chart
    chart = chart_df |> @vlplot(
        :bar,
        title = {
            text = "Month $(month) - $(product) / $(region) / $(segment)",
            fontSize = 16,
            fontWeight = "bold"
        },
        width = 500,
        height = 350,
        x = {:Metric,
            axis = {title = "", labelAngle = 0, labelFontSize = 14},
            sort = ["Cost", "Profit", "Sales"]
        },
        y = {:Amount,
            axis = {title = "Amount (\$)", format = ",.0f", labelFontSize = 12},
            scale = {domain = [0, maximum(chart_df.Amount) * 1.1]}
        },
        color = {:Color,
            scale = nothing,
            legend = nothing
        },
        config = {
            view = {stroke = nothing},
            axis = {grid = true}
        }
    )

    return chart
end

# Create slides with filters for product, region, and segment
# Month will be the slide progression variable (1-12 months)
# This uses the SAME dataset as the Path examples above - business metrics over 12 months
financial_slides = Slides(
    :Slides,
    df_slides,
    :business_path_data,
    [:Product, :Region, :Segment],  # Filter dimensions
    :Month,                           # Slide progression dimension
    make_financial_breakdown_chart;
    output_format = :svg,
    default_filters = Dict{Symbol,Any}(
        :Product => "Widget",
        :Region => "North",
        :Segment => "Consumer"
    ),
    title = "Monthly Financial Breakdown",
    notes = "Slides display a sequence of charts, one for each month. This uses the same business data (Sales/Cost/Profit by Product/Region/Segment) as the Path examples - where Path shows the entire trajectory, Slides shows individual snapshots for each month. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/slides_examples_embedded.html\" style=\"color: blue; font-weight: bold;\">See here for Slides examples</a>",
    autoplay = false,
    delay = 1.0
)


# =============================================================================
# GeoPlot - Geographic Maps
# =============================================================================
println("Creating GeoPlot examples...")

# GeoPlot section introduction
geoplot_section = TextBlock("""
<h2>Geographic Maps (GeoPlot)</h2>
<p>GeoPlot creates interactive geographic visualizations using Leaflet.js with OpenStreetMap tiles.
It supports two modes:</p>
<ul>
    <li><strong>Points Mode:</strong> Display markers at latitude/longitude coordinates with optional color and size encoding</li>
    <li><strong>Choropleth Mode:</strong> Shade geographic regions (countries, states) by value</li>
</ul>
<p>Built-in region types include <code>:world_countries</code>, <code>:us_states</code>, and <code>:us_counties</code>.
Custom GeoJSON can also be provided via URL.</p>
<p><strong>Note:</strong> Maps require an internet connection to load tiles and boundary data.</p>
<p><a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/geoplot_examples.html" style="color: blue; font-weight: bold;">See here for GeoPlot examples</a></p>
""")

# Create sample city data for points mode
cities_geo_df = DataFrame(
    city = ["New York", "Los Angeles", "Chicago", "Houston", "Phoenix",
            "London", "Paris", "Tokyo", "Sydney", "São Paulo"],
    latitude = [40.7128, 34.0522, 41.8781, 29.7604, 33.4484,
                51.5074, 48.8566, 35.6762, -33.8688, -23.5505],
    longitude = [-74.0060, -118.2437, -87.6298, -95.3698, -112.0740,
                 -0.1278, 2.3522, 139.6503, 151.2093, -46.6333],
    population_millions = [8.34, 3.98, 2.69, 2.32, 1.68,
                          8.98, 2.16, 13.96, 5.31, 12.33],
    continent = ["North America", "North America", "North America", "North America", "North America",
                 "Europe", "Europe", "Asia", "Oceania", "South America"]
)

# Points mode example - Global cities
geoplot_points = GeoPlot(:global_cities_geo, cities_geo_df, :cities_geo_data;
    lat = :latitude,
    lon = :longitude,
    color = :population_millions,
    popup_cols = [:city, :continent],
    filters = [:continent],
    color_scale = :viridis,
    title = "Global Major Cities - Points Mode",
    notes = "Markers colored by population (millions). Click markers for details. Filter by continent."
)

# Create sample country data with multiple metrics for choropleth mode
countries_geo_df = DataFrame(
    country = ["United States", "China", "Germany", "Japan", "India",
               "United Kingdom", "France", "Italy", "Brazil", "Canada",
               "Russia", "Australia", "Spain", "Mexico", "Indonesia"],
    gdp_trillion = [25.46, 17.96, 4.07, 4.23, 3.39,
                    3.07, 2.78, 2.01, 1.92, 2.14,
                    1.78, 1.68, 1.42, 1.32, 1.32],
    population_millions = [331.0, 1412.0, 83.0, 125.0, 1408.0,
                          67.0, 65.0, 59.0, 214.0, 38.0,
                          144.0, 26.0, 47.0, 129.0, 274.0],
    area_million_km2 = [9.83, 9.60, 0.36, 0.38, 3.29,
                        0.24, 0.64, 0.30, 8.52, 9.98,
                        17.10, 7.69, 0.51, 1.96, 1.90]
)

# Choropleth mode example with multiple overlays - switch between GDP, Population, and Area
geoplot_choropleth = GeoPlot(:world_stats_geo, countries_geo_df, :countries_geo_data;
    region = :country,
    value_cols = [:gdp_trillion, :population_millions, :area_million_km2],  # Multiple overlays!
    region_type = :world_countries,
    region_key = "name",
    color_scale = :turbo,
    title = "World Country Statistics - Multiple Overlays",
    notes = "Use the Overlay dropdown to switch between GDP (trillion USD), Population (millions), and Area (million km²). Gray indicates no data."
)


# Collect all data
all_data = Dict{Symbol, Any}(
    :sales_data => df,
    :product_summary => product_summary,
    :daily_product => daily_product,
    :surface_df => surface_df,
    :business_path_data => df_business_path,
    :rankings_data => df_rankings,
    :candlestick_data => candlestick_df,
    :waterfall_data => waterfall_data,
    :sankey_data => sankey_df,
    :radar_data => radar_df,
    :boxwhiskers_data => boxwhiskers_data,
    :stock_corr_data => stock_corr_data,
    :tsne_stock_data => tsne_stock_data,
    :cities_geo_data => cities_geo_df,
    :countries_geo_data => countries_geo_df
)

# Merge execution data into all_data
merge!(all_data, exec_data_dict)

text_plot_page =  JSPlotPage(
    all_data,
    [textblock_example,
        notes_explanation,
        notes_example,
        code_chart,
        linklist_intro,
        linklist_chart],
    tab_title="Text Data",
    page_header = "Text Data",
    notes = "This shows examples of TextBlock, Notes, LinkList, CodeBlock.",
    dataformat = :parquet)

tabular_plot_page =  JSPlotPage(
    all_data,
    [dataset_intro,
        pivot_chart,
        table_chart],
    tab_title="Tabular Data",
    page_header = "Tabular Data",
    notes = "This shows examples of DataTable and PivotTable.",
    dataformat = :parquet
)

two_d_plot_page =  JSPlotPage(
    all_data,
    [plotting_2d_section, line_chart, area_chart, scatter_chart, path_chart],
    tab_title="2D Charts",
    page_header = "2D Charts",
    notes = "This shows examples of LinePlot, AreaChart, ScatterPlot and Path.",
    dataformat = :parquet
)

distributional_plot_page =  JSPlotPage(
    all_data,
    [distribution_section, dist_chart, kde_chart, pie_chart, boxwhiskers_chart],
    tab_title="Distributional Charts",
    page_header = "Distributional Charts",
    notes = "This shows examples of DistPlot, KernelDensity, PieChart and BoxAndWhiskers.",
    dataformat = :parquet
)

three_d_plot_page =  JSPlotPage(
    all_data,
    [plotting_3d_section, scatter3d_chart, surface3d_chart, scattersurface_chart],
    tab_title="3D Charts",
    page_header = "3D Charts",
    notes = "This shows examples of Scatter3D, Surface3D and ScatterSurface3D.",
    dataformat = :parquet
)

images_page =  JSPlotPage(
    all_data,
    [picture_chart, integration_section, financial_slides],
    tab_title="Images and Slides",
    page_header = "Images and Slides",
    notes = "This shows examples of filtered Pictures and Slides. Pictures can display static images, animated GIFs, or provide interactive filtering between multiple charts.",
    dataformat = :parquet
)

variable_relationships_page =  JSPlotPage(
    all_data,
    [corrplot5, graph_stock, tsne_chart],
    tab_title="Variable Relationship Charts",
    page_header = "Variable Relationship Charts",
    notes = "This shows examples of CorrPlot, Graph, and TSNEPlot. CorrPlot displays correlation matrices with hierarchical clustering dendrograms. Graph visualizes correlations as a network. TSNEPlot performs t-SNE dimensionality reduction in the browser, letting you interactively explore which features drive similarity between entities.",
    dataformat = :parquet
)


situational_plot_page =  JSPlotPage(
    all_data,
    [waterfall_chart, sankey_chart, radar_chart, bump_chart],
    tab_title="Situational Charts",
    page_header = "Situational Charts",
    notes = "This shows examples of Waterfall, SanKey, RadarChart, and BumpChart. Waterfall charts display cumulative effects of sequential positive and negative values. SanKey (alluvial) diagrams show how entities flow between categories over time. RadarChart (spider chart) displays multi-dimensional data on axes radiating from a central point, ideal for comparing items across multiple metrics. BumpChart shows rankings over time with dense ranking and cross-facet highlighting.",
    dataformat = :parquet
)

financial_plot_page =  JSPlotPage(
    all_data,
    [financial_section, candlestick_chart, execution_plot],
    tab_title="Financial Charts",
    page_header = "Financial Charts",
    notes = "This shows examples of financial market visualization charts. CandlestickChart displays candlestick patterns for technical analysis. ExecutionPlot provides comprehensive trading execution analysis with refined slippage methodology.",
    dataformat = :parquet
)

gis_plot_page = JSPlotPage(
    all_data,
    [geoplot_section, geoplot_points, geoplot_choropleth],
    tab_title="GIS / Geographic Charts",
    page_header = "GIS / Geographic Charts",
    notes = "This shows examples of GeoPlot for geographic data visualization. GeoPlot supports both points mode (markers at coordinates) and choropleth mode (shaded regions). Maps use Leaflet.js with OpenStreetMap tiles and require an internet connection.",
    dataformat = :parquet
)

subpages = OrderedCollections.OrderedDict{String, Vector{JSPlotPage}}("Coding Practices" => JSPlotPage[coding_practices_theory_page, dataformat_theory_page, pages_theory_page, reportindex_theory_page],
    "Plot Types" => JSPlotPage[text_plot_page, tabular_plot_page, two_d_plot_page, distributional_plot_page, three_d_plot_page, images_page, variable_relationships_page, situational_plot_page, financial_plot_page, gis_plot_page])


# Create final Pages object with all pages including the new theoretical ones
pagess = Pages(
    [intro],
    subpages,
    tab_title="JSPlots.jl",
    page_header = "JSPlots.jl",
    dataformat = :parquet
)

# Generate HTML
# Manifest entry for report index
manifest_entry = ManifestEntry(path=".", html_filename="z_general_example.html",
                               description="JSPlots.jl Documentation", date=today(),
                               extra_columns=Dict(:chart_type => "Documentation", :page_type => "Documentation"))
create_html(pagess, "generated_html_examples/z_general_example.html";
            manifest="generated_html_examples/z_general_example/manifest.csv", manifest_entry=manifest_entry)

println("\n" * "="^70)
println("Comprehensive Tutorial created successfully!")
println("="^70)
println("\nFile: generated_html_examples/z_general_example.html")
println("\nThis tutorial demonstrates all chart types in JSPlots.jl")
println("Open the HTML file in your browser to explore!")
println("="^70)
