using JSPlots, DataFrames, DataFramesMeta, Dates, StableRNGs, Statistics, OrderedCollections, VegaLite

# Introduction
intro = TextBlock("""
<p>JSPlots.jl creates interactive, standalone HTML visualizations that work in any browser. Build line charts, scatter plots, 3D visualizations, pivot tables, and more - all from Julia without any coding in JavaScript needed.

The closest comparison to what I am trying to build is probably Pluto notebooks or jupyter notebooks. The key difference is that the pages that you generate with JSPlots runnable anywhere with interactive plotting - you do not need Julia or anything else installed except for a webbrowser. This means too that the documents that are generated by JSPlots are intended to be immutable documents to present your data rather than something you develop with (as you get with the notebooks).</p>

You can see below an overview of all of the plots that are available. You can also see a discussion on the coding practices, data formats, etc.

All of this documentation was made in JSPlots.jl itself. <a href=\"https://github.com/s-baumann/JSPlots.jl/blob/main/examples/z_general_tutorial.jl\" style=\"color: blue; font-weight: bold;\">See here for the script that generates it</a>.
""")


### Theoretical Pages


# General Coding Patterns
coding_patterns = TextBlock("""
<h2>General Coding Patterns</h2>
<p>The arguments each chart type accepts are slightly different reflecting the nature of each plot.
However, there are some common elements found across many plot types:</p>

<h3>Filters</h3>
<p> Filters allow users to subset the data that is used to display the chart. The logic is that a datapoint is included if it satisfies ALL of the various filter conditions.</p>
<p>Filters can be specified with either a Dict or a Vector:</p>
<ul>
    <li><strong>Vector of Symbols:</strong> <code>filters = [:product_line, :country]</code> creates multi-select dropdown filters
    with all unique values selected by default. So if you have [:product_line, :country] then you will end up with two dropdown boxes allowing you to subset the data by country and by the product_line.</li>
    <li><strong>Dict:</strong> <code>filters = Dict(:country => ["Australia", "United Kingdom"], :product_line => nothing)</code> where each key
    is a column name and each value specifies the default selected values. This is a bit more flexible than the above as you can specify what filters are applied by default. In this case you will end up with the same filters being possible as in the above case but by default when a user first opens a page there will be filters applied for Australia and the UK.
    </li>
</ul>

<h3>Color Columns</h3>
<p><code>color_cols</code> are the options that affect the grouping and color of objects in the chart.
For instance in a KernelDensity plot, different colors can be used to show the distribution of different groups.
In a ScatterPlot, different colors can be used to show points from different groups.</p>

<h3>Facet Columns</h3>
<p><code>facet_cols</code> specify which columns can be used for faceting (creating small aligned multiples of the same plot).</p>
<p>Note that if only one facet_col is specified there will be one dropdown list for applying this faceting or not. If two or more are provided there will be two dropdown lists for the x and y dimensions of the facet_grid.</p>
<ul>
    <li><strong>facet_cols:</strong> Defines which columns are available for faceting. Can be a single Symbol or Vector of Symbols.</li>
    <li><strong>default_facet_cols:</strong> Specifies which facet columns should be used by default:
        <ul>
            <li>If <code>nothing</code>, no faceting will appear initially (but users can enable it if <code>facet_cols</code> is provided)</li>
            <li>If specified, the chart will start with faceting enabled using those columns</li>
        </ul>
    </li>
</ul>

<h3>Value Columns</h3>
<p>Many chart types accept <code>value_cols</code> which specify the columns containing the data to visualize.
For plots that can display multiple value columns (like DistPlot or KernelDensity), you can provide a vector
of column names and use dropdown controls to switch between them.</p>

<h3>x, y, z Columns</h3>
<p>Some chart types allow you to specify several columns that are used for x, y and z. In these cases you can swap them on the fly.</p>

<h3>Interactive Controls</h3>
<p>Several chart types have their own interactive controls that are quite specific to them. Some examples are:</p>
<ul>
    <li>The DistPlot has a button to turn on or off the rugplot;</li>
    <li>The ScatterPlot has buttons to turn on or off the density shading</li>
    <li>The KernelDensity has a slider beneath it to change the kernel bandwidth</li>
    <li>ScatterSurface3D has a button to change the regularisation of the surface from L2 to L1</li>
</ul>
and there are many more. For some details on these see the specific section on the plot in this documentation.
""")

coding_practices_theory_page = JSPlotPage(
    Dict{Symbol, DataFrame}(),
    [coding_patterns],
    tab_title="General Coding Patterns",
    page_header = "General Coding Patterns",
    notes = "This gives an overview of the common coding patterns used across many chart types",
    dataformat = :csv_embedded
)


# Page about data formats
dataformat_theory = TextBlock("""
<h2>Data Storage Formats in JSPlots.jl</h2>

<h3>Overview</h3>
<p>JSPlots.jl supports multiple data storage formats for embedding data in HTML pages.
The format affects file size, loading speed, and browser compatibility.</p>

<h3>Available Formats</h3>

<h4>1. :parquet (Recommended)</h4>
<p><strong>Best for:</strong> Large datasets, multi-page reports, production use</p>
<ul>
    <li><strong>Compressed binary format</strong> - smallest file sizes (typically 5-10x smaller than CSV)</li>
    <li><strong>Fast loading</strong> - efficient decompression in browser</li>
    <li><strong>Modern browsers</strong> - requires JavaScript support</li>
    <li><strong>Column-oriented</strong> - excellent compression for tabular data</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :parquet)</code></pre>

<h4>2. :csv_embedded</h4>
<p><strong>Best for:</strong> Small datasets, maximum compatibility, debugging</p>
<ul>
    <li><strong>Text-based CSV format</strong> - human-readable in HTML source</li>
    <li><strong>Single file</strong> - data embedded directly in HTML</li>
    <li><strong>Compact format</strong> - smaller than JSON for tabular data</li>
    <li><strong>Universal compatibility</strong> - works everywhere</li>
    <li><strong>Easy debugging</strong> - can inspect data in HTML source</li>
    <li><strong>No deduplication</strong> - data embedded separately in each page</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :csv_embedded)</code></pre>

<h4>3. :csv_external</h4>
<p><strong>Best for:</strong> Sharing data files, version control, spreadsheet analysis</p>
<ul>
    <li><strong>Separate CSV files</strong> - one file per dataset in data/ subdirectory</li>
    <li><strong>Multiple files</strong> - HTML + CSV files</li>
    <li><strong>Enables deduplication</strong> - shared datasets only stored once</li>
    <li><strong>Data reusability</strong> - CSV files can be opened in Excel/spreadsheets</li>
    <li><strong>Better for git</strong> - separate data from HTML</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :csv_external)</code></pre>

<h4>4. :json_embedded</h4>
<p><strong>Best for:</strong> Small datasets, web developers, API-like structure</p>
<ul>
    <li><strong>JSON format</strong> - familiar to web developers</li>
    <li><strong>Single file</strong> - data embedded directly in HTML</li>
    <li><strong>Structured data</strong> - preserves data types (numbers, strings, booleans)</li>
    <li><strong>Larger than CSV</strong> - JSON is ~25% larger due to key names in each row</li>
    <li><strong>Fast browser parsing</strong> - native JSON.parse() is highly optimized</li>
    <li><strong>No deduplication</strong> - data embedded separately in each page</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :json_embedded)</code></pre>

<h4>5. :json_external</h4>
<p><strong>Best for:</strong> API consumption, web applications, data interchange</p>
<ul>
    <li><strong>Separate JSON files</strong> - one file per dataset in data/ subdirectory</li>
    <li><strong>Multiple files</strong> - HTML + JSON files</li>
    <li><strong>Enables deduplication</strong> - shared datasets only stored once</li>
    <li><strong>API-ready format</strong> - can be consumed by other web applications</li>
    <li><strong>Type preservation</strong> - maintains data types better than CSV</li>
    <li><strong>Web-friendly</strong> - easy to load from external servers</li>
</ul>
<pre><code>page = JSPlotPage(data_dict, charts, dataformat = :json_external)</code></pre>

<h3>Data Deduplication</h3>
<p><strong>Key Efficiency Feature:</strong> JSPlots.jl automatically detects when the same dataset
is used multiple times and only includes it once.</p>
<p>Note that thisData deduplication only works with external formats
Data deduplication only works with external formats - (<code>:parquet</code>, <code>:csv_external</code>, <code>:json_external</code>).
With embedded formats (<code>:csv_embedded</code>, <code>:json_embedded</code>),
data is embedded separately in each HTML page, so there's no deduplication benefit.</p>

<h4>How It Works</h4>
<p>When you create a multi-page report with <code>Pages</code>, datasets are identified by their
<code>Symbol</code> key in the data dictionary. <strong>The <code>Pages</code>-level dataformat setting
overrides any individual <code>JSPlotPage</code> dataformat settings.</strong></p>

<pre><code># Both pages use :sales_data
page1 = JSPlotPage(
    Dict(:sales_data => df),
    [chart1, chart2],
    dataformat = :csv_embedded  # This is ignored!
)

page2 = JSPlotPage(
    Dict(:sales_data => df),  # Same Symbol = reuses data!
    [chart3, chart4],
    dataformat = :json_embedded  # This is also ignored!
)

# Pages-level dataformat is what actually gets used
report = Pages(
    [intro],
    [page1, page2],
    dataformat = :parquet  # ← This overrides page-level settings!
)
# Result: One parquet file in data/sales_data.parquet shared by both pages</code></pre>

<h4>Benefits of Deduplication (External Formats Only)</h4>
<ul>
    <li><strong>Reduced File Size:</strong> Large datasets only stored once, not duplicated per page</li>
    <li><strong>Faster Loading:</strong> Less data to download and parse</li>
    <li><strong>Memory Efficiency:</strong> Browser loads dataset into memory once</li>
    <li><strong>Consistency:</strong> All pages use the exact same data</li>
</ul>

<h3>Format Comparison Table</h3>
<table border="1" cellpadding="8" style="border-collapse: collapse; margin: 20px 0; width: 100%;">
    <tr style="background-color: #f0f0f0;">
        <th>Feature</th>
        <th>:parquet</th>
        <th>:csv_embedded</th>
        <th>:csv_external</th>
        <th>:json_embedded</th>
        <th>:json_external</th>
    </tr>
    <tr>
        <td><strong>File Size</strong></td>
        <td style="color: green;">Smallest (5-10x smaller)</td>
        <td style="color: orange;">Medium</td>
        <td style="color: orange;">Medium</td>
        <td style="color: red;">Large (~25% bigger than CSV)</td>
        <td style="color: red;">Large (~25% bigger than CSV)</td>
    </tr>
    <tr>
        <td><strong>Loading Speed</strong></td>
        <td style="color: green;">Fast</td>
        <td style="color: orange;">Moderate</td>
        <td style="color: orange;">Moderate</td>
        <td style="color: green;">Fast (native JSON.parse)</td>
        <td style="color: green;">Fast (native JSON.parse)</td>
    </tr>
    <tr>
        <td><strong>Compatibility</strong></td>
        <td style="color: orange;">Modern browsers</td>
        <td style="color: green;">Universal</td>
        <td style="color: green;">Universal</td>
        <td style="color: green;">Universal</td>
        <td style="color: green;">Universal</td>
    </tr>
    <tr>
        <td><strong>Deduplication</strong></td>
        <td style="color: green;">Yes (in Pages)</td>
        <td style="color: red;">No (embedded)</td>
        <td style="color: green;">Yes (in Pages)</td>
        <td style="color: red;">No (embedded)</td>
        <td style="color: green;">Yes (in Pages)</td>
    </tr>
    <tr>
        <td><strong>Type Preservation</strong></td>
        <td style="color: green;">Excellent</td>
        <td style="color: orange;">Limited (strings)</td>
        <td style="color: orange;">Limited (strings)</td>
        <td style="color: green;">Good</td>
        <td style="color: green;">Good</td>
    </tr>
    <tr>
        <td><strong>Human Readable</strong></td>
        <td>No (binary)</td>
        <td>Yes (in HTML)</td>
        <td>Yes (separate files)</td>
        <td>Yes (in HTML)</td>
        <td>Yes (separate files)</td>
    </tr>
    <tr>
        <td><strong>File Structure</strong></td>
        <td>Single HTML + data/</td>
        <td>Single HTML</td>
        <td>HTML + data/ folder</td>
        <td>Single HTML</td>
        <td>HTML + data/ folder</td>
    </tr>
    <tr>
        <td><strong>Best For</strong></td>
        <td>Production, large data</td>
        <td>Small data, debugging</td>
        <td>Spreadsheet analysis</td>
        <td>Web developers</td>
        <td>API/web apps</td>
    </tr>
</table>

<h3>Setting Format Globally vs Per-Page</h3>
<pre><code># Set format for entire report (RECOMMENDED)
report = Pages(
    [intro],
    [page1, page2],
    dataformat = :parquet  # Overrides any page-level settings
)

# Individual pages (only for single-page JSPlotPage, not Pages)
page1 = JSPlotPage(data_dict, charts, dataformat = :parquet)
create_html(page1, "standalone_page.html")</code></pre>

<p><strong>Note:</strong> When using <code>Pages</code>, the Pages-level <code>dataformat</code>
overrides any <code>dataformat</code> settings in individual <code>JSPlotPage</code> objects.</p>

<h3>Launcher Scripts for External Formats</h3>
<p>When using external formats (<code>:parquet</code>, <code>:csv_external</code>, <code>:json_external</code>),
JSPlots.jl automatically generates launcher scripts to help with browser security restrictions:</p>

<ul>
    <li><strong>open.sh</strong> - Shell script for Linux/Mac that launches a local web server</li>
    <li><strong>open.bat</strong> - Batch script for Windows that opens with appropriate permissions</li>
    <li><strong>README.md</strong> - Instructions for opening the HTML files</li>
</ul>

<p><strong>Why launcher scripts?</strong> Modern browsers block loading external files (data/, pictures/, etc.)
from <code>file://</code> URLs for security reasons. The launcher scripts either:</p>
<ul>
    <li>Start a local web server (on Linux/Mac via Python's http.server)</li>
    <li>Launch the browser with flags to allow local file access (on Windows)</li>
</ul>

<p>For embedded formats (<code>:csv_embedded</code>, <code>:json_embedded</code>), you can open
the HTML file directly in a browser since all data is embedded - no launcher scripts needed!</p>
""")

dataformat_theory_page = JSPlotPage(
    Dict{Symbol, DataFrame}(),
    [dataformat_theory],
    tab_title="Data Storage Formats",
    page_header = "Understanding Data Storage Formats",
    notes = "This shows the options for including data with the HTML",
    dataformat = :csv_embedded
)

pages_theory = TextBlock("""
<h2>Creating Multi-Page Reports with JSPlotPage and Pages</h2>

<h3>Overview</h3>
<p>JSPlots.jl makes it easy to create multi-page HTML reports. You create individual pages using <code>JSPlotPage</code>,
then combine them into a multi-page report using <code>Pages</code>.</p>

<h3>Creating Individual Pages with JSPlotPage</h3>
<p>A <code>JSPlotPage</code> represents a single HTML page with charts, tables, and text content:</p>

<pre><code>page = JSPlotPage(
    Dict(:data_name => dataframe),  # Data dictionary
    [chart1, chart2, text_block],   # Content items
    tab_title = "My Page",          # Browser tab title
    page_header = "Analysis Report", # Page header
    dataformat = :parquet           # Data storage format
)</code></pre>

<h3>Combining Pages with the Pages Constructor</h3>
<p>The <code>Pages</code> constructor creates a multi-page report with automatic navigation:</p>

<pre><code># Easy constructor - automatically creates LinkList!
report = Pages(
    [coverpage_content],  # Items for the coverpage
    [page1, page2, page3], # Your JSPlotPage objects
    tab_title = "Report Home",
    page_header = "Business Report",
    dataformat = :parquet
)</code></pre>

<h3>Automatic LinkList Generation</h3>
<p><strong>Key Feature:</strong> The Pages constructor automatically generates a <code>LinkList</code> from your pages
and adds it to the coverpage!</p>

<ul>
    <li>Each page in the <code>[page1, page2, page3]</code> array becomes a link</li>
    <li>Link titles come from each page's <code>tab_title</code></li>
    <li>Link descriptions come from each page's <code>notes</code> field</li>
    <li>The LinkList is automatically appended to your coverpage content</li>
</ul>

<h3>Manual LinkList (Advanced)</h3>
<p>You can also create LinkLists manually for custom navigation:</p>

<pre><code>links = LinkList([
    ("Title 1", "page_1.html", "Description of page 1"),
    ("Title 2", "page_2.html", "Description of page 2")
])</code></pre>

<h3>Complete Example</h3>
<pre><code># Create individual pages
analysis_page = JSPlotPage(
    Dict(:sales => sales_df),
    [scatter_chart, line_chart],
    tab_title = "Sales Analysis",
    notes = "Detailed sales trends and patterns"
)

metrics_page = JSPlotPage(
    Dict(:kpis => kpi_df),
    [kde_chart, dist_chart],
    tab_title = "Key Metrics",
    notes = "Performance indicators and distributions"
)

# Create multi-page report with automatic LinkList
report = Pages(
    [TextBlock("&lt;h1&gt;Q4 Report&lt;/h1&gt;")],
    [analysis_page, metrics_page],
    tab_title = "Q4 2024 Report"
)

# Generate HTML
create_html(report, "my_report")
# Creates: my_report.html (coverpage with links)
#          page_1.html (Sales Analysis)
#          page_2.html (Key Metrics)</code></pre>

<h3>Benefits</h3>
<ul>
    <li><strong>Automatic Navigation:</strong> No need to manually create links between pages</li>
    <li><strong>Consistent Structure:</strong> All pages follow the same format</li>
    <li><strong>Easy Maintenance:</strong> Add/remove pages without updating navigation</li>
    <li><strong>Professional Output:</strong> Clean, navigable HTML reports</li>
</ul>

<h3>Opening Multi-Page Reports</h3>
<p>When you use external data formats (<code>:parquet</code>, <code>:csv_external</code>, <code>:json_external</code>),
JSPlots.jl automatically generates launcher scripts in the project directory:</p>

<ul>
    <li><strong>open.sh</strong> (Linux/Mac) - Starts a local web server and opens in browser</li>
    <li><strong>open.bat</strong> (Windows) - Opens with appropriate browser permissions</li>
    <li><strong>README.md</strong> - Detailed instructions</li>
</ul>

<p><strong>Why?</strong> Browsers block loading external files from <code>file://</code> URLs for security.
The launcher scripts solve this by either running a local web server or launching the browser
with flags to allow local file access.</p>
""")

pages_theory_page = JSPlotPage(
    Dict{Symbol, DataFrame}(),
    [pages_theory],
    tab_title="Creating Multi-Page Reports",
    page_header = "How to Create Multi-Page Reports",
    notes = "Learn how to use JSPlotPage and Pages to create multi-page HTML reports with automatic navigation",
    dataformat = :csv_embedded
)



### Plot Types

# Generate comprehensive dataset
dataset_intro = TextBlock("""
<h2>Dataset Generation</h2>
<p>We'll create a business analytics dataset for use throughout this documentation to show off all of the plottypes. The dataset contains sales data for a company employing door to door salesmen accross a wide area and with a large set of possible products.</p>
<p> The code that generates this dataset is shown below as the example of the CodeBlock type.</p>
""")

function generate_comprehensive_data()
    rng = StableRNG(42)

    # Time period: One year of daily data
    start_date = Date(2024, 1, 1)
    dates = start_date:Day(1):(start_date + Day(700))
    n = length(dates)

    # Product categories
    products = ["Laptop", "Tablet", "Phone"]
    regions = ["North", "South", "West"]
    segments = ["Enterprise", "SMB", "Consumer"]

    # Generate sales data
    records = DataFrame[]

    for (i, date) in enumerate(dates)
        for product in products
            for region in regions
                # Base sales with trends and seasonality
                base = 10000 + 1000 * sin(2π * i / 365)
                trend = i * 10

                # Product-specific multipliers
                product_mult = Dict(
                    "Laptop" => 3.0, "Tablet" => 2.0, "Phone" => 4.0
                )[product]

                # Region-specific multipliers
                region_mult = Dict("North" => 1.2, "South" => 1.0, "West" => 1.1)[region]

                sales = (base + trend) * product_mult * region_mult * (1 + 0.2 * randn(rng))
                quantity = round(Int, sales / (100 + 50 * randn(rng)))
                cost = sales * (0.6 + 0.1 * randn(rng))
                profit = sales - cost

                # Customer metrics
                customers = round(Int, quantity * (0.3 + 0.1 * randn(rng)))
                satisfaction = 3.5 + 1.0 * randn(rng)

                # Geographic coordinates
                lat = 35.0 + Dict("North" => 10, "South" => -10, "West" => 0)[region] + randn(rng)
                lon = -95.0 + Dict("North" => 0, "South" => 0, "West" => -15)[region] + randn(rng)

                # Random segment assignment
                segment = rand(rng, segments)

                push!(records, DataFrame(
                    date = date,
                    product = product,
                    region = region,
                    segment = segment,
                    sales = max(0, sales),
                    quantity = max(0, quantity),
                    cost = max(0, cost),
                    profit = profit,
                    customers = max(0, customers),
                    satisfaction = clamp(satisfaction, 1, 5),
                    latitude = lat,
                    longitude = lon,
                    month = month(date),
                    quarter = (month(date) - 1) ÷ 3 + 1,
                    day_of_year = dayofyear(date)
                ))
            end
        end
    end

    return vcat(records...)
end

dataset_code = CodeBlock(generate_comprehensive_data,
    notes=" We can use a CodeBlock to show code snippets with syntax highlighting. We have correct Syntax highlighting for Julia, Python, R, JavaScript, Java, C, C++, SQL, pl/pgsql, Rust. For anything else it will all be black.")

df = dataset_code()

# PivotTable
pivot_chart = PivotTable(:PivotTable, :sales_data,
    rows=[:product],
    cols=[:region],
    vals=:customers,
    aggregatorName = :Average,
    rendererName = :Heatmap,
    colour_map = Dict{Float64,String}([0.0, 50.0, 100.0, 150.0] .=>
                                      ["#ffffff", "#ccccff", "#99ccff", "#3366ff"]),
    extrapolate_colours = false,
    notes="PivotTables can do quite alot. Indeed many of the charttypes of this package would alternatively be doable just using a PivotTable so you might prefer doing that in some cases.Now we have example data generated (from the above function) we will shoow this in a pivottable (and it will be used throughout the rest of the examples). <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/pivottable_examples.html\" style=\"color: blue; font-weight: bold;\">See here for PivotTable examples</a>")

# Table

product_summary = @linq df |> groupby(:product) |> combine(:total_sales = sum(:sales),
    :total_quantity = sum(:quantity),
    :total_profit = sum(:profit))
sort!(product_summary, :total_sales, rev=true)

table_chart = Table(:Table, product_summary,
    notes="This just displays your DataFrame in a nice way on the html page. There is a download as csv button at the bottom of it. You could also just use a PivotTable but this is lighterweight for cases where a PivotTable is overkill. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/table_examples.html\" style=\"color: blue; font-weight: bold;\">See here for Table examples</a>")

# CodeBlock
code_chart = dataset_code

# LinkList
linklist_intro = TextBlock("""
<h1>LinkList</h1>
""")

od = OrderedCollections.OrderedDict{String, Vector{Tuple{String,String,String}}}()
od["OverView"] = [("GitHub Repository", "https://github.com/s-baumann/JSPlots.jl", "Source code"),
    ("Documentation", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/z_general_example/z_general_example.html", "General tutorial and overview"),
    ("Pages", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/annual_report.html", "Multi-page reports with navigation")]
od["Tabular Data and Text"] = [("PivotTable", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/pivottable_examples.html", "Interactive drag-and-drop pivot tables"),
    ("Table", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/table_examples.html", "Sortable data tables with CSV download"),
    ("TextBlock", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/textblock_examples.html", "Rich text and HTML content"),
    ("CodeBlock", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/codeblock_examples.html", "Syntax-highlighted code blocks"),
    ("LinkList", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linklist_examples.html", "Navigation and link lists")]
od["Multimedia"] = [
    ("Picture", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/picture_examples.html", "Display images, GIFs, and filtered charts from VegaLite, Plots.jl, or Makie"),
    ("Slides", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/slides_examples_embedded.html", "Slideshows and animations")]
od["2D Plots"] = [("LineChart", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linechart_examples.html", "Time series and trend visualization"),
    ("AreaChart", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/areachart_examples.html", "Stacked area charts"),
    ("ScatterPlot", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatterplot_examples.html", "2D scatter plots with marginal distributions"),
    ("Path", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/path_examples.html", "Trajectory visualization with direction arrows")]
od["Distributional Plots"] = [
    ("DistPlot", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/distplot_examples.html", "Histogram, box plot, and rug plot combined"),
    ("KernelDensity", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/kerneldensity_examples.html", "Smooth kernel density estimation"),
    ("PieChart", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/piechart_examples.html", "Pie charts with faceting and filtering")]
od["3D Plots"] = [
    ("Scatter3D", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatter3d_examples.html", "3D scatter plots with PCA eigenvectors"),
    ("Surface3D", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/surface3d_examples.html", "3D surface visualization"),
    ("ScatterSurface3D", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scattersurface3d_example.html", "3D scatter with fitted surfaces")]
od["Situational Charts"] = [
    ("CorrPlot", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/corrplot_examples.html", "Make correlation plots with hierarchical clustering dendrograms showing Pearson and Spearman correlations."),
    ("Waterfall", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/waterfall_examples.html", "Make Waterfall plots showing how positive and negative elements add up to an aggregate."),
    ("SanKey", "https://s-baumann.github.io/JSPlots.jl/dev/examples_html/sankey_examples.html", "Make SanKey plots showing how individuals change affiliation over multiple waves.")]


linklist_chart = LinkList(od, chart_title=:links, notes = "A LinkList shows you a list of links with optional descriptions. These are automatically generated if you make a Pages struct where there is a LinkList on the top page with links to the others. You can also make your own. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linklist_examples.html\" style=\"color: blue; font-weight: bold;\">See here for LinkList examples</a>")

# TextBlock
textblock_example = TextBlock("""
<h1>TextBlock</h1>
You can write whatever HTML you want and put it in a TextBlock which will put it in the resultant HTML.
<div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px;">
    <p><strong>TextBlock</strong> allows you to add rich text, HTML, and annotations to your reports.</p>
    <p>You can include <em>formatting</em>, <strong>styled text</strong>, and even <code>inline code</code>.</p>
    <p> See here for <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/textblock_examples.html" style="color: blue; font-weight: bold;">TextBlock examples</a>.</p>
</div>
""")

# ===== 2D Plotting =====
plotting_2d_section = TextBlock("<h1>Two-Dimensional Plots</h1>")

# LineChart
daily_product = @linq df |> groupby( [:date, :product]) |> combine( :total_sales = sum(:sales))

line_chart = LineChart(:LineChart, df, :sales_data,
    x_cols=[:date, :quarter],
    y_cols=[:sales, :quantity, :profit, :customers, :satisfaction],
    color_cols=[:product, :region, :segment],
    facet_cols=[:region, :segment, :product, :month],
    notes="A linechart. There are optional controls to change the variables on the x and or y axis. It is also possible to change the faceting, the grouping variable, the aggregation variable (if there are multiple y values per x value) as well as filters. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/linechart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for LineChart examples</a>")

# AreaChart
area_chart = AreaChart(:AreaChart, df, :sales_data,
    x_cols=[:date, :quarter],
    y_cols=[:sales, :quantity, :cost, :customers, :satisfaction],
    color_cols=[:product, :segment, :region],
    filters = Dict{Symbol,Any}(:product => unique(df.product), :segment => unique(df.segment), :region => unique(df.region)),
    facet_cols=[:region, :product, :segment],
    notes="Stacked Trends. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/areachart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for AreaChart examples</a>")

# ScatterPlot
scatter_chart = ScatterPlot(:scatter, df, :sales_data, [:profit, :sales, :quantity, :customers, :cost, :satisfaction];
    color_cols=[:product, :region, :segment, :month],
    facet_cols=[:region, :product, :segment],
    default_facet_cols=nothing,
    notes="Scatter plots show x vs y. There is a density colouring that can be applied or not depending on a slider. In addition the marginal distributions appear on the edges of the plot in cases when you do not apply faceting. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatterplot_examples.html\" style=\"color: blue; font-weight: bold;\">See here for ScatterPlot examples</a>")


# Path - Business Performance Trajectories
# Create business metrics dataset (same as used in Slides examples)
rng_path = StableRNG(333)
products_path = ["Widget", "Gadget", "Doohickey"]
regions_path = ["North", "South", "East", "West"]
segments_path = ["Consumer", "Enterprise", "Government"]

business_path_data = []
for product in products_path
    for region in regions_path
        for segment in segments_path
            for month in 1:12
                base_sales = product == "Widget" ? 500 : (product == "Gadget" ? 700 : 400)
                sales = base_sales + month * 20 + rand(rng_path, 50:300)
                cost = sales * (0.60 + rand(rng_path) * 0.10)
                profit = sales - cost

                push!(business_path_data, (
                    Product = product,
                    Region = region,
                    Segment = segment,
                    Month = month,
                    Sales = round(sales),
                    Cost = round(cost),
                    Profit = round(profit)
                ))
            end
        end
    end
end
df_business_path = DataFrame(business_path_data)

path_chart = Path(:path, df_business_path, :business_path_data;
    x_cols=[:Cost, :Profit, :Sales],
    y_cols=[:Profit, :Sales, :Cost],
    order_col=:Month,
    color_cols=[:Product, :Region, :Segment],
    filters = Dict{Symbol,Any}(:Region => "North", :Segment => "Consumer", :Product => unique(df_business_path.Product)),
    show_arrows=true,
    use_alpharange=true,
    notes="A Path chart shows trajectories through metric space over time. This example uses business data (Sales/Cost/Profit by Product/Region/Segment over 12 months) - the same dataset that will be used later in the Slides examples. Each path traces how a product's metrics evolve month-by-month. By default, it shows the North region and Consumer segment, with paths colored by Product. Use the filters to explore different regions and segments. The arrows and alpha gradient show the direction of time progression. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/path_examples.html\" style=\"color: blue; font-weight: bold;\">See here for Path examples</a>")

# More Exotic Plot Types
# Corrplot.
example5_text = TextBlock("""
<h2>Example 5: Advanced CorrPlot - Stock Market Analysis with Multiple Scenarios</h2>
<p>This example demonstrates the advanced CorrPlot features with multiple correlation scenarios:</p>
<ul>
    <li><strong>Multiple scenarios:</strong> Switch between different correlation analyses (Short-term, Long-term, Volatility)</li>
    <li><strong>Variable selection:</strong> Multi-select box to choose which stocks to display</li>
    <li><strong>Manual ordering:</strong> Toggle between dendrogram ordering and drag-drop manual ordering</li>
    <li>Interactive exploration of different time horizons and metrics</li>
</ul>
<p><strong>Try this:</strong></p>
<ol>
    <li>Switch scenarios using the dropdown to compare short-term vs long-term correlations</li>
    <li>Select specific stocks to focus on particular sectors</li>
    <li>Uncheck "Order by Dendrogram" and drag stocks to create your own ordering</li>
</ol>
""")

# Initialize random number generator for reproducibility
using Random
rng = Random.MersenneTwister(12345)

# Generate stock market data for different time horizons
n_days = 250  # Trading days
stock_symbols = ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "JPM", "BAC", "GS", "JNJ", "PFE"]
n_stocks = length(stock_symbols)

# Generate returns for each stock (correlated within sectors)
# Tech: AAPL, MSFT, GOOGL, AMZN, TSLA
# Finance: JPM, BAC, GS
# Healthcare: JNJ, PFE

stock_returns = zeros(n_days, n_stocks)
for day in 1:n_days
    # Tech sector common factor
    tech_factor = randn(rng) * 0.02
    # Finance sector common factor
    finance_factor = randn(rng) * 0.015
    # Healthcare sector common factor
    health_factor = randn(rng) * 0.01

    stock_returns[day, 1:5] .= tech_factor .+ randn(rng, 5) .* 0.015  # Tech stocks
    stock_returns[day, 6:8] .= finance_factor .+ randn(rng, 3) .* 0.012  # Finance
    stock_returns[day, 9:10] .= health_factor .+ randn(rng, 2) .* 0.008  # Healthcare
end

# Create DataFrame
df_stocks = DataFrame(stock_returns, stock_symbols)

# Scenario 1: Short-term returns (daily)
short_vars = Symbol.(stock_symbols)
cors_short = compute_correlations(df_stocks, short_vars)
hc_short = cluster_from_correlation(cors_short.pearson, linkage=:ward)
scenario_short = CorrelationScenario("Short-term Returns (Daily)",
    cors_short.pearson, cors_short.spearman, hc_short, stock_symbols)

# Scenario 2: Long-term returns (20-day rolling)
df_longterm = DataFrame()
for sym in stock_symbols
    df_longterm[!, Symbol(sym)] = [sum(df_stocks[max(1, i-19):i, Symbol(sym)])
                                    for i in 20:n_days]
end
long_vars = Symbol.(stock_symbols)
cors_long = compute_correlations(df_longterm, long_vars)
hc_long = cluster_from_correlation(cors_long.pearson, linkage=:ward)
scenario_long = CorrelationScenario("Long-term Returns (20-day)",
    cors_long.pearson, cors_long.spearman, hc_long, stock_symbols)

# Scenario 3: Volatility correlations (rolling std deviation)
df_volatility = DataFrame()
for sym in stock_symbols
    volatilities = [std(df_stocks[max(1, i-19):i, Symbol(sym)])
                   for i in 20:n_days]
    df_volatility[!, Symbol(sym)] = volatilities
end
vol_vars = Symbol.(stock_symbols)
cors_vol = compute_correlations(df_volatility, vol_vars)
hc_vol = cluster_from_correlation(cors_vol.pearson, linkage=:ward)
scenario_vol = CorrelationScenario("Volatility Correlations",
    cors_vol.pearson, cors_vol.spearman, hc_vol, stock_symbols)

# Create advanced CorrPlot with multiple scenarios
corrplot5 = CorrPlot(:stock_advanced, [scenario_short, scenario_long, scenario_vol];
    title = "Stock Market Correlation Analysis - Multiple Scenarios",
    notes = "A Correlation Plot with Dendrogram shows relationships between variables using hierarchical clustering. The dendrogram (top) groups similar variables based on their correlation patterns. The correlation matrix (bottom) uses two different correlation measures: Pearson correlations (top-right triangle, marked with 'P:') measure linear relationships, while Spearman correlations (bottom-left triangle, marked with 'S:') measure monotonic relationships and are robust to outliers. Variables are automatically reordered by the clustering to reveal correlation blocks. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/corrplot_examples.html\" style=\"color: blue; font-weight: bold;\">See here for CorrPlot examples</a>",
    default_scenario = "Short-term Returns (Daily)",
    default_variables = ["AAPL", "MSFT", "JPM", "JNJ"],
    allow_manual_order = true
)

# Waterfall
# Create waterfall data showing profit breakdown
waterfall_data = DataFrame(
    item = ["Good Sales", "Renting Spare Office", "Vending Machine Revenue", "COGS", "Staff Expenses", "Marketing", "Depreciation", "Taxes"],
    category = ["Income", "Income", "Income", "Costs", "Costs", "Costs", "Costs", "Taxes"],
    value = [1500, 200, 50, -800, -400, -100, -50, -150]
)

waterfall_chart = Waterfall(:waterfall, waterfall_data, :waterfall_data;
    item_col = :item,
    color_cols = [:category],
    value_col = :value,
    title = "Profit & Loss Waterfall",
    show_table = true,
    show_totals = true,
    notes="A Waterfall chart visualizes how an initial value is affected by a series of positive and negative values. This example shows a profit & loss statement. <strong>Features:</strong> Automatic cumulative calculation, side-by-side table grouped by category, click bars or table rows to exclude items, toggle categories with checkboxes, switch between value-based (green/red) and category-based coloring, black total bar (toggleable). <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/waterfall_examples.html\" style=\"color: blue; font-weight: bold;\">See here for more Waterfall examples</a>")


    # SanKey
# Create Sankey diagram data showing crypto/stock holdings evolution for traders
sankey_data_rows = []

# Define possible holdings
crypto_holdings_by_year = Dict(
    2015 => ["Bitcoin"],
    2018 => ["Bitcoin", "Ethereum", "Dogecoin"],
    2020 => ["Bitcoin", "Ethereum", "Dogecoin", "Cardano", "Solana"],
    2023 => ["Bitcoin", "Ethereum", "Solana", "Cardano", "Polkadot"]
)

stock_holdings_by_year = Dict(
    2015 => ["Tech Stocks", "Index Funds"],
    2018 => ["Tech Stocks", "Index Funds", "Growth Stocks"],
    2020 => ["Tech Stocks", "Index Funds", "Growth Stocks", "Dividend Stocks"],
    2023 => ["Tech Stocks", "Growth Stocks", "Dividend Stocks", "Crypto Stocks"]
)

# Create 50 traders with realistic portfolio evolution
trader_count = 50
for trader_id in 1:trader_count
    # 2015: Everyone holding Bitcoin
    crypto_2015 = "Bitcoin"
    stock_2015 = rand(rng, ["Tech Stocks", "Index Funds"])

    # 2018: Some diversification
    crypto_2018 = if rand(rng) < 0.3
        "Ethereum"
    elseif rand(rng) < 0.2
        "Dogecoin"
    else
        "Bitcoin"
    end
    stock_2018 = if stock_2015 == "Tech Stocks"
        rand(rng, ["Tech Stocks", "Growth Stocks"])
    else
        rand(rng, ["Index Funds", "Tech Stocks"])
    end

    # 2020: More diversification
    crypto_2020 = if crypto_2018 == "Ethereum"
        rand(rng, ["Ethereum", "Cardano", "Solana"])
    elseif crypto_2018 == "Dogecoin"
        rand(rng, ["Dogecoin", "Bitcoin"])
    else
        rand(rng, ["Bitcoin", "Ethereum", "Cardano"])
    end
    stock_2020 = if stock_2018 == "Growth Stocks"
        rand(rng, ["Growth Stocks", "Tech Stocks"])
    else
        rand(rng, ["Index Funds", "Dividend Stocks", "Tech Stocks"])
    end

    # 2023: Current holdings
    crypto_2023 = if crypto_2020 in ["Solana", "Cardano"]
        rand(rng, ["Solana", "Cardano", "Polkadot"])
    elseif crypto_2020 == "Ethereum"
        rand(rng, ["Ethereum", "Solana", "Bitcoin"])
    else
        rand(rng, ["Bitcoin", "Ethereum"])
    end
    stock_2023 = if stock_2020 == "Dividend Stocks"
        rand(rng, ["Dividend Stocks", "Crypto Stocks"])
    else
        rand(rng, ["Tech Stocks", "Growth Stocks", "Crypto Stocks"])
    end

    # Portfolio values (growing over time with some variation)
    value_2015 = Float64(rand(rng, 5000:10000))
    value_2018 = value_2015 * rand(rng, 1.5:0.1:3.0)
    value_2020 = value_2018 * rand(rng, 0.8:0.1:2.5)
    value_2023 = value_2020 * rand(rng, 1.0:0.1:4.0)

    for (year, crypto, stock, value) in [
        (2015, crypto_2015, stock_2015, value_2015),
        (2018, crypto_2018, stock_2018, value_2018),
        (2020, crypto_2020, stock_2020, value_2020),
        (2023, crypto_2023, stock_2023, value_2023)
    ]
        push!(sankey_data_rows, (
            trader_id = trader_id,
            year = year,
            crypto_holding = crypto,
            stock_holding = stock,
            portfolio_value = value
        ))
    end
end

sankey_df = DataFrame(sankey_data_rows)

sankey_chart = SanKey(:ribbon, sankey_df, :sankey_data;
    id_col = :trader_id,
    time_col = :year,
    color_cols = [:crypto_holding, :stock_holding],
    value_cols = [:portfolio_value],
    title = "Trader Portfolio Evolution (2015-2023)",
    notes="A SanKey diagram showing how 50 traders' portfolios evolved from 2015 to 2023. Use the 'Affiliation' dropdown to switch between crypto holdings and stock holdings. The ribbon width represents portfolio value. In 2015, all traders held Bitcoin; by 2023, holdings diversified into various cryptocurrencies and stock categories. Notice migration patterns: early Bitcoin holders moving to Ethereum/Solana, and tech stock investors shifting to growth/crypto stocks. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/sankey_examples.html\" style=\"color: blue; font-weight: bold;\">See here for SanKey examples</a>")

# ===== Distributional Plots =====
distribution_section = TextBlock("<h1>Distributional Plots</h1>")

# DistPlot
dist_chart = DistPlot(:dist, df, :sales_data,
    value_cols=[:profit, :sales, :cost, :quantity, :customers, :satisfaction],
    color_cols=[:region, :product, :segment],
    filters=[:region, :product, :segment],
    notes="This makes a historgram, box and whiskers and rugplot. So you can see differences in distribution for a variable between different groups of observations. Note at the bottom there is a slider for changing the number of bins in the histogram. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/distplot_examples.html\" style=\"color: blue; font-weight: bold;\">See here for DistPlot examples</a>")

# KernelDensity
kde_chart = KernelDensity(:kde, df, :sales_data,
    value_cols=[:profit, :sales, :cost, :quantity, :customers, :satisfaction],
    color_cols=[:region, :product, :segment],
    filters=[:region, :product, :segment],
    facet_cols=[:region, :product, :segment],
    default_facet_cols=[:segment],
    notes="This shows kernel density estimates for a variable seperated by groups in the observations. It also has faceting available (unlike DistPlot). There is a slider at the bottom for controlling the bandwidth of the kernel density estimate. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/kerneldensity_examples.html\" style=\"color: blue; font-weight: bold;\">See here for KernelDensity examples</a>")

# PieChart
pie_chart = PieChart(:pie, df, :sales_data,
    color_cols=[:region, :product, :segment, :month, :quarter],
    value_cols=[:sales, :profit, :quantity, :cost, :customers, :satisfaction],
    notes="This gives piecharts. Note that piecharts are generally pretty bad (google it to see more on this) but up to you if you like them. There is faceting available, filtering and you can change the grouping variable and the numeric variable being aggregated over to determine pie width. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/piechart_examples.html\" style=\"color: blue; font-weight: bold;\">See here for PieChart examples</a>")

# ===== 3D Plotting =====
plotting_3d_section = TextBlock("<h1>Three-Dimensional Plots</h1>")

# Scatter3D
scatter3d_sample = df[1:200, :]
scatter3d_chart = Scatter3D(:scatter3d, scatter3d_sample, :sales_data,
    [:longitude, :latitude, :sales, :quantity, :profit, :cost, :customers, :satisfaction];
    color_cols = [:region, :product, :segment, :month, :quarter],
    facet_cols = [:region, :product, :segment, :month, :quarter],
    filters = [:region, :product, :segment, :month, :quarter],
    default_facet_cols = nothing,
    title="3D Scatter Plot",
    notes="This is a 3D scatter plot. You can rotate it and zoom in and out. There are options for showing PCA eigenvectors as well. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scatter3d_examples.html\" style=\"color: blue; font-weight: bold;\">See here for Scatter3D examples</a>")

# Surface3D

# We are going to make some surfaces that we can plot with Surface3D. We will make a grid of latitudes and longitudes and then for each grouping variable we will compute average sales for nearby points to make a surface.
lat_range = range(minimum(df.latitude), maximum(df.latitude), length=20)
lon_range = range(minimum(df.longitude), maximum(df.longitude), length=20)
long_df = stack(df[:, [:date, :product, :region, :segment, :sales, :latitude, :longitude]],  Not([:date, :sales, :latitude, :longitude]); variable_name=:grouping_category, value_name=:grouping)

surface_data = DataFrame[]
for lat in lat_range
    for lon in lon_range
        for grp in unique(long_df.grouping)
            subframe = long_df[long_df.grouping .== grp, :]
            nearby = subframe[abs.(subframe.latitude .- lat) .< 5 .&& abs.(subframe.longitude .- lon) .< 10, :]
            avg_sales = isempty(nearby) ? 0.0 : mean(nearby.sales)
            push!(surface_data, DataFrame(latitude=lat, longitude=lon, average_sales=avg_sales, grouping=grp))
        end
    end
end
surface_df = vcat(surface_data...)
surface_df = leftjoin(surface_df, unique(long_df[:, [:grouping_category, :grouping]]), on=:grouping)


surface3d_chart = Surface3D(:surface3d, surface_df, :surface_df,
    x_col=:longitude,
    y_col=:latitude,
    z_col=:average_sales,
    group_col=:grouping,
    filters= Dict{Symbol, Any}(:grouping_category => ["product"]),
    notes="This is a 3D surface plot that allows you to display a few surfaces together. You can rotate it and zoom in and out. This example shows average sales over latitude and longitude. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/surface3d_examples.html\" style=\"color: blue; font-weight: bold;\">See here for Surface3D examples</a>")

# ScatterSurface3D
scattersurface_chart = ScatterSurface3D(:scattersurface, df, :sales_data,
    x_col=:longitude,
    y_col=:latitude,
    z_col=:sales,
    group_cols= [:product, :segment],
    facet_cols= [:region, :product, :segment],
    notes="This is a 3D scatter plot with a fitted surface for each group of points. You can train the surface with differing bandwidth parameters and with the L1 or L2 norm (L2 is default). You can rotate it and zoom in and out. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/scattersurface3d_examples.html\" style=\"color: blue; font-weight: bold;\">See here for ScatterSurface3D examples</a>")


# ===== Integration Charts =====
integration_section = TextBlock("""
<h1> Pictures and Slides</h1>
<p><strong>Picture</strong> and <strong>Slides</strong> allow you to embed plots from Plots.jl, Makie.jl, and VegaLite.jl. Pictures can also display static images, animated GIFs, and can be filtered to show different charts based on user selections.</p>
""")

# Picture with filtering - create VegaLite charts for different regions and products
println("Creating filtered Picture example...")
picture_charts_dir = mktempdir()

# Generate charts for different combinations
for region in ["North", "South", "East"]
    for product in ["Widget", "Gadget"]
        # Filter business data for this combination
        chart_data = filter(row -> row.Region == region && row.Product == product, df_business_path)
        if nrow(chart_data) > 0
            # Group by month and sum sales
            monthly_data = combine(groupby(chart_data, :Month), :Sales => sum => :Sales)
            sort!(monthly_data, :Month)

            # Create VegaLite chart
            chart = monthly_data |> @vlplot(
                :bar,
                x={:Month, axis={title="Month", labelAngle=-45}},
                y={:Sales, axis={title="Sales (thousands)"}},
                title="$(product) Sales - $(region) Region",
                width=500,
                height=300,
                color={value="#4682B4"}
            )

            # Save with pattern: sales!Region!Product.png
            filename = "sales!$(region)!$(product).png"
            filepath = joinpath(picture_charts_dir, filename)
            VegaLite.save(filepath, chart)
        end
    end
end

# Create filtered Picture viewer
picture_chart = Picture(
    :Picture,
    picture_charts_dir,
    "sales";
    filters = Dict{Symbol,Any}(
        :group_1 => "North",   # Default region
        :group_2 => "Widget"   # Default product
    ),
    title="Regional Sales Analysis",
    notes="<strong>Picture has three main uses:</strong><br>
           <strong>1. Static Images:</strong> Display any image file (PNG, JPEG, SVG, etc.)<br>
           <strong>2. Animated GIFs:</strong> Embed animated visualizations<br>
           <strong>3. Filtered Viewing:</strong> Generate multiple charts and let users switch between them using filters.<br><br>
           This example shows filtered viewing - use the dropdowns above to explore sales data across different regions and products. The charts are generated with VegaLite.
           <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/picture_examples.html\" style=\"color: blue; font-weight: bold;\">See here for more Picture examples</a>"
)

# Prepare aggregated data for slides using the same business metrics as Path examples
# This is the same dataset structure used in the Path chart above
df_slides = df_business_path

# Function to generate a chart for each slide
# This receives: (data, product, region, segment, month)
# Uses the same business metrics dataset as the Path examples
function make_financial_breakdown_chart(data, product, region, segment, month)
    # Filter data for this specific combination
    filtered = filter(row ->
        row.Product == product &&
        row.Region == region &&
        row.Segment == segment &&
        row.Month == month,
        data
    )

    # If no data, create empty values
    if nrow(filtered) == 0
        cost = 0.0
        profit = 0.0
        sales = 0.0
    else
        cost = filtered.Cost[1]
        profit = filtered.Profit[1]
        sales = filtered.Sales[1]
    end

    # Create a bar chart using VegaLite
    chart_df = DataFrame(
        Metric = ["Cost", "Profit", "Sales"],
        Amount = [cost, profit, sales],
        Color = ["#e74c3c", "#27ae60", "#3498db"]
    )

    # Create VegaLite chart
    chart = chart_df |> @vlplot(
        :bar,
        title = {
            text = "Month $(month) - $(product) / $(region) / $(segment)",
            fontSize = 16,
            fontWeight = "bold"
        },
        width = 500,
        height = 350,
        x = {:Metric,
            axis = {title = "", labelAngle = 0, labelFontSize = 14},
            sort = ["Cost", "Profit", "Sales"]
        },
        y = {:Amount,
            axis = {title = "Amount (\$)", format = ",.0f", labelFontSize = 12},
            scale = {domain = [0, maximum(chart_df.Amount) * 1.1]}
        },
        color = {:Color,
            scale = nothing,
            legend = nothing
        },
        config = {
            view = {stroke = nothing},
            axis = {grid = true}
        }
    )

    return chart
end

# Create slides with filters for product, region, and segment
# Month will be the slide progression variable (1-12 months)
# This uses the SAME dataset as the Path examples above - business metrics over 12 months
financial_slides = Slides(
    :Slides,
    df_slides,
    :business_path_data,
    [:Product, :Region, :Segment],  # Filter dimensions
    :Month,                           # Slide progression dimension
    make_financial_breakdown_chart;
    output_format = :svg,
    default_filters = Dict{Symbol,Any}(
        :Product => "Widget",
        :Region => "North",
        :Segment => "Consumer"
    ),
    title = "Monthly Financial Breakdown",
    notes = "Slides display a sequence of charts, one for each month. This uses the same business data (Sales/Cost/Profit by Product/Region/Segment) as the Path examples - where Path shows the entire trajectory, Slides shows individual snapshots for each month. <a href=\"https://s-baumann.github.io/JSPlots.jl/dev/examples_html/slides_examples_embedded.html\" style=\"color: blue; font-weight: bold;\">See here for Slides examples</a>",
    autoplay = false,
    delay = 1.0
)

# Collect all data
all_data = Dict{Symbol, DataFrame}(
    :sales_data => df,
    :product_summary => product_summary,
    :daily_product => daily_product,
    :surface_df => surface_df,
    :business_path_data => df_business_path,
    :waterfall_data => waterfall_data,
    :sankey_data => sankey_df,
)

tabular_plot_page =  JSPlotPage(
    all_data,
    [dataset_intro,
        code_chart,
        pivot_chart,
        table_chart,
        linklist_intro,
        linklist_chart,
        textblock_example],
    tab_title="Tabular and Text Data",
    page_header = "Tabular and Text Data",
    notes = "This shows examples of TextBlock, LinkList, CodeBlock, DataTable and PivotTable.",
    dataformat = :parquet
)

two_d_plot_page =  JSPlotPage(
    all_data,
    [plotting_2d_section, line_chart, area_chart, scatter_chart, path_chart],
    tab_title="2D Charts",
    page_header = "2D Charts",
    notes = "This shows examples of LinePlot, AreaChart, ScatterPlot, and Path.",
    dataformat = :parquet
)

distributional_plot_page =  JSPlotPage(
    all_data,
    [distribution_section, dist_chart, kde_chart, pie_chart],
    tab_title="Distributional Charts",
    page_header = "Distributional Charts",
    notes = "This shows examples of DistPlot, KernelDensity and PieChart.",
    dataformat = :parquet
)

three_d_plot_page =  JSPlotPage(
    all_data,
    [plotting_3d_section, scatter3d_chart, surface3d_chart, scattersurface_chart],
    tab_title="3D Charts",
    page_header = "3D Charts",
    notes = "This shows examples of Scatter3D, Surface3D and ScatterSurface3D.",
    dataformat = :parquet
)

images_page =  JSPlotPage(
    all_data,
    [picture_chart, integration_section, financial_slides],
    tab_title="Images and Slides",
    page_header = "Images and Slides",
    notes = "This shows examples of filtered Pictures and Slides. Pictures can display static images, animated GIFs, or provide interactive filtering between multiple charts.",
    dataformat = :parquet
)

situational_plot_page =  JSPlotPage(
    all_data,
    [corrplot5, waterfall_chart, sankey_chart],
    tab_title="Situational Charts",
    page_header = "Situational Charts",
    notes = "This shows examples of Waterfall, SanKey, and CorrPlot. Waterfall charts display cumulative effects of sequential positive and negative values. SanKey (alluvial) diagrams show how entities flow between categories over time. CorrPlot displays correlation matrices with hierarchical clustering dendrograms. The advanced CorrPlot example demonstrates scenario switching, variable selection, and manual ordering.",
    dataformat = :parquet
)


subpages = OrderedCollections.OrderedDict{String, Vector{JSPlotPage}}("Coding Practices" => JSPlotPage[coding_practices_theory_page, dataformat_theory_page, pages_theory_page],
    "Plot Types" => JSPlotPage[tabular_plot_page, two_d_plot_page, distributional_plot_page, three_d_plot_page, images_page, situational_plot_page])


# Create final Pages object with all pages including the new theoretical ones
pagess = Pages(
    [intro],
    subpages,
    tab_title="JSPlots.jl",
    page_header = "JSPlots.jl",
    dataformat = :parquet
)

# Generate HTML
create_html(pagess, "generated_html_examples/z_general_example.html")

println("\n" * "="^70)
println("Comprehensive Tutorial created successfully!")
println("="^70)
println("\nFile: generated_html_examples/z_general_example.html")
println("\nThis tutorial demonstrates all chart types in JSPlots.jl")
println("Open the HTML file in your browser to explore!")
println("="^70)
