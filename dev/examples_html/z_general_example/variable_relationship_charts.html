<!DOCTYPE html>
<html>
<head>
    <title>Variable Relationship Charts</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
    

    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    const scenarios = [{"name":"Short-term Returns (Daily)","allLabels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"labels":["AMZN","AAPL","MSFT","GOOGL","TSLA","JNJ","PFE","JPM","BAC","GS"],"dendroData":{"maxHeight":2.228532270661073,"leafLabels":["AMZN","AAPL","MSFT","GOOGL","TSLA","JNJ","PFE","JPM","BAC","GS"],"leafPositions":[0,1,2,3,4,5,6,7,8,9],"shapes":[{"line":{"color":"#636efa","width":2},"x1":1.0,"y1":0.4881618719932269,"x0":1.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":2.0,"y1":0.4881618719932269,"x0":1.0,"type":"line","y0":0.4881618719932269},{"line":{"color":"#636efa","width":2},"x1":2.0,"y1":0.0,"x0":2.0,"type":"line","y0":0.4881618719932269},{"line":{"color":"#636efa","width":2},"x1":3.0,"y1":0.5260194892698108,"x0":3.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":4.0,"y1":0.5260194892698108,"x0":3.0,"type":"line","y0":0.5260194892698108},{"line":{"color":"#636efa","width":2},"x1":4.0,"y1":0.0,"x0":4.0,"type":"line","y0":0.5260194892698108},{"line":{"color":"#636efa","width":2},"x1":1.5,"y1":0.5802879048719402,"x0":1.5,"type":"line","y0":0.4881618719932269},{"line":{"color":"#636efa","width":2},"x1":3.5,"y1":0.5802879048719402,"x0":1.5,"type":"line","y0":0.5802879048719402},{"line":{"color":"#636efa","width":2},"x1":3.5,"y1":0.5260194892698108,"x0":3.5,"type":"line","y0":0.5802879048719402},{"line":{"color":"#636efa","width":2},"x1":0.0,"y1":0.5895900645171215,"x0":0.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":2.5,"y1":0.5895900645171215,"x0":0.0,"type":"line","y0":0.5895900645171215},{"line":{"color":"#636efa","width":2},"x1":2.5,"y1":0.5802879048719402,"x0":2.5,"type":"line","y0":0.5895900645171215},{"line":{"color":"#636efa","width":2},"x1":8.0,"y1":0.6058079102886209,"x0":8.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":9.0,"y1":0.6058079102886209,"x0":8.0,"type":"line","y0":0.6058079102886209},{"line":{"color":"#636efa","width":2},"x1":9.0,"y1":0.0,"x0":9.0,"type":"line","y0":0.6058079102886209},{"line":{"color":"#636efa","width":2},"x1":5.0,"y1":0.654281909390823,"x0":5.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":6.0,"y1":0.654281909390823,"x0":5.0,"type":"line","y0":0.654281909390823},{"line":{"color":"#636efa","width":2},"x1":6.0,"y1":0.0,"x0":6.0,"type":"line","y0":0.654281909390823},{"line":{"color":"#636efa","width":2},"x1":7.0,"y1":0.6734157364896151,"x0":7.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":8.5,"y1":0.6734157364896151,"x0":7.0,"type":"line","y0":0.6734157364896151},{"line":{"color":"#636efa","width":2},"x1":8.5,"y1":0.6058079102886209,"x0":8.5,"type":"line","y0":0.6734157364896151},{"line":{"color":"#636efa","width":2},"x1":5.5,"y1":1.55648917358413,"x0":5.5,"type":"line","y0":0.654281909390823},{"line":{"color":"#636efa","width":2},"x1":7.75,"y1":1.55648917358413,"x0":5.5,"type":"line","y0":1.55648917358413},{"line":{"color":"#636efa","width":2},"x1":7.75,"y1":0.6734157364896151,"x0":7.75,"type":"line","y0":1.55648917358413},{"line":{"color":"#636efa","width":2},"x1":1.25,"y1":2.228532270661073,"x0":1.25,"type":"line","y0":0.5895900645171215},{"line":{"color":"#636efa","width":2},"x1":6.625,"y1":2.228532270661073,"x0":1.25,"type":"line","y0":2.228532270661073},{"line":{"color":"#636efa","width":2},"x1":6.625,"y1":1.55648917358413,"x0":6.625,"type":"line","y0":2.228532270661073}]}},{"name":"Long-term Returns (20-day)","allLabels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"labels":["BAC","JPM","GS","JNJ","PFE","GOOGL","AMZN","TSLA","AAPL","MSFT"],"dendroData":{"maxHeight":2.725504205244352,"leafLabels":["BAC","JPM","GS","JNJ","PFE","GOOGL","AMZN","TSLA","AAPL","MSFT"],"leafPositions":[0,1,2,3,4,5,6,7,8,9],"shapes":[{"line":{"color":"#636efa","width":2},"x1":8.0,"y1":0.32312118023631425,"x0":8.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":9.0,"y1":0.32312118023631425,"x0":8.0,"type":"line","y0":0.32312118023631425},{"line":{"color":"#636efa","width":2},"x1":9.0,"y1":0.0,"x0":9.0,"type":"line","y0":0.32312118023631425},{"line":{"color":"#636efa","width":2},"x1":5.0,"y1":0.33940489444645144,"x0":5.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":6.0,"y1":0.33940489444645144,"x0":5.0,"type":"line","y0":0.33940489444645144},{"line":{"color":"#636efa","width":2},"x1":6.0,"y1":0.0,"x0":6.0,"type":"line","y0":0.33940489444645144},{"line":{"color":"#636efa","width":2},"x1":3.0,"y1":0.4679117387253641,"x0":3.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":4.0,"y1":0.4679117387253641,"x0":3.0,"type":"line","y0":0.4679117387253641},{"line":{"color":"#636efa","width":2},"x1":4.0,"y1":0.0,"x0":4.0,"type":"line","y0":0.4679117387253641},{"line":{"color":"#636efa","width":2},"x1":7.0,"y1":0.49751384528203174,"x0":7.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":8.5,"y1":0.49751384528203174,"x0":7.0,"type":"line","y0":0.49751384528203174},{"line":{"color":"#636efa","width":2},"x1":8.5,"y1":0.32312118023631425,"x0":8.5,"type":"line","y0":0.49751384528203174},{"line":{"color":"#636efa","width":2},"x1":1.0,"y1":0.5346653548886294,"x0":1.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":2.0,"y1":0.5346653548886294,"x0":1.0,"type":"line","y0":0.5346653548886294},{"line":{"color":"#636efa","width":2},"x1":2.0,"y1":0.0,"x0":2.0,"type":"line","y0":0.5346653548886294},{"line":{"color":"#636efa","width":2},"x1":5.5,"y1":0.557884185530227,"x0":5.5,"type":"line","y0":0.33940489444645144},{"line":{"color":"#636efa","width":2},"x1":7.75,"y1":0.557884185530227,"x0":5.5,"type":"line","y0":0.557884185530227},{"line":{"color":"#636efa","width":2},"x1":7.75,"y1":0.49751384528203174,"x0":7.75,"type":"line","y0":0.557884185530227},{"line":{"color":"#636efa","width":2},"x1":0.0,"y1":0.7318610966675901,"x0":0.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":1.5,"y1":0.7318610966675901,"x0":0.0,"type":"line","y0":0.7318610966675901},{"line":{"color":"#636efa","width":2},"x1":1.5,"y1":0.5346653548886294,"x0":1.5,"type":"line","y0":0.7318610966675901},{"line":{"color":"#636efa","width":2},"x1":3.5,"y1":1.5497671109059268,"x0":3.5,"type":"line","y0":0.4679117387253641},{"line":{"color":"#636efa","width":2},"x1":6.625,"y1":1.5497671109059268,"x0":3.5,"type":"line","y0":1.5497671109059268},{"line":{"color":"#636efa","width":2},"x1":6.625,"y1":0.557884185530227,"x0":6.625,"type":"line","y0":1.5497671109059268},{"line":{"color":"#636efa","width":2},"x1":0.75,"y1":2.725504205244352,"x0":0.75,"type":"line","y0":0.7318610966675901},{"line":{"color":"#636efa","width":2},"x1":5.0625,"y1":2.725504205244352,"x0":0.75,"type":"line","y0":2.725504205244352},{"line":{"color":"#636efa","width":2},"x1":5.0625,"y1":1.5497671109059268,"x0":5.0625,"type":"line","y0":2.725504205244352}]}},{"name":"Volatility Correlations","allLabels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"labels":["GOOGL","AAPL","AMZN","TSLA","GS","JPM","BAC","PFE","MSFT","JNJ"],"dendroData":{"maxHeight":1.6724791499834804,"leafLabels":["GOOGL","AAPL","AMZN","TSLA","GS","JPM","BAC","PFE","MSFT","JNJ"],"leafPositions":[0,1,2,3,4,5,6,7,8,9],"shapes":[{"line":{"color":"#636efa","width":2},"x1":2.0,"y1":0.5528255403188058,"x0":2.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":3.0,"y1":0.5528255403188058,"x0":2.0,"type":"line","y0":0.5528255403188058},{"line":{"color":"#636efa","width":2},"x1":3.0,"y1":0.0,"x0":3.0,"type":"line","y0":0.5528255403188058},{"line":{"color":"#636efa","width":2},"x1":5.0,"y1":0.6816558345725967,"x0":5.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":6.0,"y1":0.6816558345725967,"x0":5.0,"type":"line","y0":0.6816558345725967},{"line":{"color":"#636efa","width":2},"x1":6.0,"y1":0.0,"x0":6.0,"type":"line","y0":0.6816558345725967},{"line":{"color":"#636efa","width":2},"x1":1.0,"y1":0.7301616298629354,"x0":1.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":2.5,"y1":0.7301616298629354,"x0":1.0,"type":"line","y0":0.7301616298629354},{"line":{"color":"#636efa","width":2},"x1":2.5,"y1":0.5528255403188058,"x0":2.5,"type":"line","y0":0.7301616298629354},{"line":{"color":"#636efa","width":2},"x1":4.0,"y1":0.752259642702112,"x0":4.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":5.5,"y1":0.752259642702112,"x0":4.0,"type":"line","y0":0.752259642702112},{"line":{"color":"#636efa","width":2},"x1":5.5,"y1":0.6816558345725967,"x0":5.5,"type":"line","y0":0.752259642702112},{"line":{"color":"#636efa","width":2},"x1":0.0,"y1":0.776408244039714,"x0":0.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":1.75,"y1":0.776408244039714,"x0":0.0,"type":"line","y0":0.776408244039714},{"line":{"color":"#636efa","width":2},"x1":1.75,"y1":0.7301616298629354,"x0":1.75,"type":"line","y0":0.776408244039714},{"line":{"color":"#636efa","width":2},"x1":8.0,"y1":0.9814232852525075,"x0":8.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":9.0,"y1":0.9814232852525075,"x0":8.0,"type":"line","y0":0.9814232852525075},{"line":{"color":"#636efa","width":2},"x1":9.0,"y1":0.0,"x0":9.0,"type":"line","y0":0.9814232852525075},{"line":{"color":"#636efa","width":2},"x1":7.0,"y1":1.0363834860406589,"x0":7.0,"type":"line","y0":0.0},{"line":{"color":"#636efa","width":2},"x1":8.5,"y1":1.0363834860406589,"x0":7.0,"type":"line","y0":1.0363834860406589},{"line":{"color":"#636efa","width":2},"x1":8.5,"y1":0.9814232852525075,"x0":8.5,"type":"line","y0":1.0363834860406589},{"line":{"color":"#636efa","width":2},"x1":4.75,"y1":1.5421431415574036,"x0":4.75,"type":"line","y0":0.752259642702112},{"line":{"color":"#636efa","width":2},"x1":7.75,"y1":1.5421431415574036,"x0":4.75,"type":"line","y0":1.5421431415574036},{"line":{"color":"#636efa","width":2},"x1":7.75,"y1":1.0363834860406589,"x0":7.75,"type":"line","y0":1.5421431415574036},{"line":{"color":"#636efa","width":2},"x1":0.875,"y1":1.6724791499834804,"x0":0.875,"type":"line","y0":0.776408244039714},{"line":{"color":"#636efa","width":2},"x1":6.25,"y1":1.6724791499834804,"x0":0.875,"type":"line","y0":1.6724791499834804},{"line":{"color":"#636efa","width":2},"x1":6.25,"y1":1.5421431415574036,"x0":6.25,"type":"line","y0":1.6724791499834804}]}}];
    let currentScenario = scenarios[0];
    let selectedVars = ["AAPL","MSFT","JPM","JNJ"];
    let manualOrder = null;
    let corrDataRaw = null;

    // Load correlation data from external dataset
    loadDataset('stock_corr_data').then(function(data) {
        corrDataRaw = data;
        populateVarSelector();
        updateChart_stock_advanced();
    }).catch(function(error) {
        console.error('Failed to load correlation data:', error);
    });

    // Initialize variable selector
    function populateVarSelector() {
        const select = document.getElementById('var_select_stock_advanced');
        select.innerHTML = '';
        currentScenario.allLabels.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    // Initialize sortable list
    function initializeSortable() {
        const container = document.getElementById('sortable_vars_stock_advanced');
        container.innerHTML = '';
        // Show all variables in the manual order list
        const orderToUse = manualOrder || currentScenario.allLabels;
        orderToUse.forEach(v => {
            const div = document.createElement('div');
            div.className = 'sortable-item';
            div.textContent = v;
            div.setAttribute('data-var', v);
            container.appendChild(div);
        });

        if (typeof Sortable !== 'undefined') {
            Sortable.create(container, {
                animation: 150,
                onEnd: function() {
                    manualOrder = Array.from(container.children).map(el => el.getAttribute('data-var'));
                    updateChart_stock_advanced();
                }
            });
        }
    }

    window.updateChart_stock_advanced = function() {
        if (!corrDataRaw) {
            console.warn('Correlation data not loaded yet');
            return;
        }

        // Check if scenario changed
        const scenarioSelect = document.getElementById('scenario_select_stock_advanced');
        let scenarioChanged = false;
        if (scenarioSelect) {
            const scenarioName = scenarioSelect.value;
            const newScenario = scenarios.find(s => s.name === scenarioName);
            if (newScenario !== currentScenario) {
                scenarioChanged = true;
                // Remember currently selected variables
                const varSelect = document.getElementById('var_select_stock_advanced');
                const previouslySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

                // Update to new scenario
                currentScenario = newScenario;

                // Repopulate variable selector with new scenario's variables
                populateVarSelector();

                // Try to keep the same variables selected if they exist in new scenario
                const newVarSelect = document.getElementById('var_select_stock_advanced');
                const availableVars = Array.from(newVarSelect.options).map(opt => opt.value);
                const varsToSelect = previouslySelected.filter(v => availableVars.includes(v));

                // If none of the previous variables exist in new scenario, select all
                if (varsToSelect.length < 2) {
                    selectedVars = currentScenario.allLabels;
                    Array.from(newVarSelect.options).forEach(opt => opt.selected = true);
                } else {
                    selectedVars = varsToSelect;
                    Array.from(newVarSelect.options).forEach(opt => {
                        opt.selected = varsToSelect.includes(opt.value);
                    });
                }
            }
        }

        // Update selected variables (if scenario didn't change)
        if (!scenarioChanged) {
            const varSelect = document.getElementById('var_select_stock_advanced');
            selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);
        }

        if (selectedVars.length < 2) {
            console.warn('Select at least 2 variables');
            return;
        }

        // Check order mode
        const orderModeSelect = document.getElementById('order_mode_stock_advanced');
        const orderMode = orderModeSelect ? orderModeSelect.value : 'dendrogram';

        // Show/hide manual ordering UI
        const manualDiv = document.getElementById('manual_order_stock_advanced');
        if (manualDiv) {
            manualDiv.style.display = (orderMode === 'manual') ? 'block' : 'none';
        }

        if (orderMode === 'manual') {
            initializeSortable();
        }

        // Determine variable order
        let orderedVars;
        if (orderMode === 'manual' && manualOrder) {
            // Use manual order, filtered to selected vars
            orderedVars = manualOrder.filter(v => selectedVars.includes(v));
        } else if (orderMode === 'alphabetical') {
            // Use alphabetical order
            orderedVars = selectedVars.slice().sort();
        } else {
            // Use dendrogram order (default)
            orderedVars = currentScenario.labels.filter(v => selectedVars.includes(v));
        }

        const n = orderedVars.length;

        // Build correlation matrix for selected variables
        const zValues = [];
        const textValues = [];
        const hoverText = [];

        for (let i = 0; i < n; i++) {
            zValues[i] = [];
            textValues[i] = [];
            hoverText[i] = [];
            for (let j = 0; j < n; j++) {
                if (i === j) {
                    // Diagonal
                    zValues[i][j] = 1.0;
                    textValues[i][j] = '1.00';
                    hoverText[i][j] = orderedVars[i];
                } else {
                    // Find correlation values from external data
                    // Data can have either (node1, node2) or (node2, node1) ordering
                    let pearsonCorr = 0;
                    let spearmanCorr = 0;

                    const pearsonItem = corrDataRaw.find(d =>
                        d.scenario === currentScenario.name &&
                        d.correlation_method === 'pearson' &&
                        ((d.node1 === orderedVars[i] && d.node2 === orderedVars[j]) ||
                         (d.node1 === orderedVars[j] && d.node2 === orderedVars[i])));

                    const spearmanItem = corrDataRaw.find(d =>
                        d.scenario === currentScenario.name &&
                        d.correlation_method === 'spearman' &&
                        ((d.node1 === orderedVars[i] && d.node2 === orderedVars[j]) ||
                         (d.node1 === orderedVars[j] && d.node2 === orderedVars[i])));

                    pearsonCorr = pearsonItem ? pearsonItem.strength : 0;
                    spearmanCorr = spearmanItem ? spearmanItem.strength : 0;

                    if (i < j) {
                        // Upper-right triangle: always show Pearson
                        zValues[i][j] = pearsonCorr;
                        textValues[i][j] = 'P: ' + pearsonCorr.toFixed(2);
                        hoverText[i][j] = orderedVars[i] + ' vs ' + orderedVars[j] + '<br>Pearson: ' + pearsonCorr.toFixed(3);
                    } else {
                        // Lower-left triangle: always show Spearman
                        zValues[i][j] = spearmanCorr;
                        textValues[i][j] = 'S: ' + spearmanCorr.toFixed(2);
                        hoverText[i][j] = orderedVars[i] + ' vs ' + orderedVars[j] + '<br>Spearman: ' + spearmanCorr.toFixed(3);
                    }
                }
            }
        }

        // Create heatmap
        const heatmapTrace = {
            z: zValues,
            x: orderedVars,
            y: orderedVars,
            type: 'heatmap',
            colorscale: [
                [0, '#ff0000'],
                [0.5, '#ffffff'],
                [1, '#0000ff']
            ],
            zmin: -1,
            zmax: 1,
            text: hoverText,
            hovertemplate: '%{text}<extra></extra>',
            colorbar: {
                title: 'Correlation',
                titleside: 'right'
            }
        };

        const heatmapLayout = {
            xaxis: { side: 'bottom', tickangle: -45 },
            yaxis: { autorange: 'reversed' },
            annotations: [],
            margin: { l: 150, r: 50, b: 150, t: 50 }
        };

        // Add text annotations
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                heatmapLayout.annotations.push({
                    x: orderedVars[j],
                    y: orderedVars[i],
                    text: textValues[i][j],
                    showarrow: false,
                    font: {
                        size: 10,
                        color: Math.abs(zValues[i][j]) > 0.5 ? 'white' : 'black'
                    }
                });
            }
        }

        Plotly.newPlot('corrmatrix_stock_advanced', [heatmapTrace], heatmapLayout, {responsive: true});

        // Draw dendrogram (only if using dendrogram order and all variables are selected)
        const dendroDiv = document.getElementById('dendrogram_stock_advanced');
        const allVarsSelected = selectedVars.length === currentScenario.allLabels.length;

        if (orderMode === 'dendrogram' && allVarsSelected && currentScenario.dendroData.shapes && currentScenario.dendroData.shapes.length > 0) {
            dendroDiv.style.display = 'block';

            // Show full dendrogram with all variables
            const selectedIndices = orderedVars.map(v => currentScenario.labels.indexOf(v));
            const leafTrace = {
                x: selectedIndices,
                y: Array(n).fill(0),
                mode: 'text',
                type: 'scatter',
                text: orderedVars,
                textposition: 'bottom center',
                textfont: { size: 10 },
                hoverinfo: 'text',
                showlegend: false
            };

            const dendroLayout = {
                title: 'Hierarchical Clustering Dendrogram',
                xaxis: {
                    visible: false,
                    range: [Math.min(...selectedIndices) - 0.5, Math.max(...selectedIndices) + 0.5]
                },
                yaxis: {
                    title: 'Height',
                    range: [0, currentScenario.dendroData.maxHeight * 1.15]
                },
                margin: { l: 80, r: 50, b: 120, t: 50 },
                showlegend: false,
                shapes: currentScenario.dendroData.shapes
            };

            Plotly.newPlot('dendrogram_stock_advanced', [leafTrace], dendroLayout, {responsive: true});
        } else {
            dendroDiv.style.display = 'none';
        }
    };

    // Note: populateVarSelector() and updateChart_stock_advanced() are called
    // after data loads in the loadDataset promise above
})();
(function() {
    const scenarios = [{"name":"Short-term Returns (Daily)","is_correlation":true,"node_labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"]},{"name":"Long-term Returns (20-day)","is_correlation":true,"node_labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"]},{"name":"Volatility Correlations","is_correlation":true,"node_labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"]}];
    let currentScenario = scenarios[0];
    let selectedVars = ["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};  // Store node positions to keep them stable

    // Load graph data
    loadDataset('stock_corr_data').then(function(data) {
        graphData = data;
        populateVarSelector_stock_network();  // Populate selector BEFORE initializing graph
        initializeGraph_stock_network();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_stock_network() {
        const select = document.getElementById('var_select_stock_network');
        select.innerHTML = '';
        currentScenario.node_labels.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_stock_network() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_stock_network'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'cose'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_stock_network();
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_stock_network = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_stock_network').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_stock_network');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_stock_network(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_stock_network = function() {
        if (!cy || !graphData) return;

        // Update scenario
        const scenarioSelect = document.getElementById('scenario_select_stock_network');
        if (scenarioSelect) {
            const scenarioName = scenarioSelect.value;
            const newScenario = scenarios.find(s => s.name === scenarioName);
            if (newScenario !== currentScenario) {
                currentScenario = newScenario;
                populateVarSelector_stock_network();
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_stock_network').value);
        const showEdgeLabels = document.getElementById('show_edges_stock_network').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_stock_network(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_stock_network = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_stock_network');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_stock_network = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_stock_network').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Apply colors based on attribute
            const uniqueValues = new Set();
            cy.nodes().forEach(node => {
                const val = node.data(colorBy);
                if (val) uniqueValues.add(val);
            });

            const colors = generateColors_stock_network(uniqueValues.size);
            const colorMap = {};
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });

            cy.nodes().forEach(node => {
                const val = node.data(colorBy);
                const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                node.style('background-color', color);
            });
        }
    };

    // Update edge labels
    window.updateEdgeLabels_stock_network = function() {
        const showLabels = document.getElementById('show_edges_stock_network').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    function buildGraph_stock_network(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_stock_network').value);
        const showEdgeLabels = document.getElementById('show_edges_stock_network').checked;

        const colorBy = document.getElementById('color_select_stock_network').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_stock_network(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_stock_network(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            cy.nodes().forEach(node => {
                node.style('background-color', node.data('color'));
            });
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_stock_network(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];
        const scenarioData = graphData.filter(row =>
            (!row.scenario || row.scenario === scenario.name) &&
            varsToShow.includes(row.node1) && varsToShow.includes(row.node2)
        );

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            let distance = strength;

            if (scenario.is_correlation) {
                distance = 1 - Math.abs(strength);
            }

            if (distance <= cutoffValue) {
                const edgeWidth = scenario.is_correlation ?
                    Math.abs(strength) * 5 + 1 :
                    (1 - distance) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario.name + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_stock_network(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="boxwhiskers_data" data-format="parquet" data-src="data/boxwhiskers_data.parquet"></script><script type="text/plain" id="sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script><script type="text/plain" id="sankey_data" data-format="parquet" data-src="data/sankey_data.parquet"></script><script type="text/plain" id="stock_corr_data" data-format="parquet" data-src="data/stock_corr_data.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>Variable Relationship Charts</h1>
<p>This shows examples of CorrPlot and Graph using the same underlying correlation data. CorrPlot displays correlation matrices with hierarchical clustering dendrograms. Graph visualizes correlations as a network with nodes and edges. Both charts demonstrate different ways to explore the same correlation structure.</p>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<div class="corrplot-container">
    <h2>Stock Market Correlation Analysis - Multiple Scenarios</h2>
    <p>A Correlation Plot with Dendrogram shows relationships between variables using hierarchical clustering. The dendrogram (top) groups similar variables based on their correlation patterns. Note that it will only appear if i) you select order by dendrogram and ii) you select all of the variables. The correlation matrix (bottom) uses two different correlation measures: Pearson correlations (top-right triangle, marked with 'P:') measure linear relationships, while Spearman correlations (bottom-left triangle, marked with 'S:') measure monotonic relationships and are robust to outliers. Variables are automatically reordered by the clustering to reveal correlation blocks. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/corrplot_examples.html" style="color: blue; font-weight: bold;">See here for CorrPlot examples</a></p>
    <div style="margin-bottom: 15px;">
    <label for="scenario_select_stock_advanced"><strong>Scenario:</strong></label>
    <select id="scenario_select_stock_advanced" onchange="updateChart_stock_advanced()">
        <option value="Short-term Returns (Daily)" selected>Short-term Returns (Daily)</option>
                <option value="Long-term Returns (20-day)" >Long-term Returns (20-day)</option>
                <option value="Volatility Correlations" >Volatility Correlations</option>
    </select>
</div>

    <div style="margin-bottom: 15px;">
        <label for="var_select_stock_advanced"><strong>Select Variables:</strong></label><br>
        <select id="var_select_stock_advanced" multiple size="8" style="width: 300px;" onchange="updateChart_stock_advanced()">
        </select>
    </div>
    <div style="margin-bottom: 15px;">
    <label for="order_mode_stock_advanced"><strong>Variable ordering:</strong></label>
    <select id="order_mode_stock_advanced" onchange="updateChart_stock_advanced()">
        <option value="dendrogram" selected>Order by dendrogram</option>
        <option value="alphabetical">Order alphabetically</option>
        <option value="manual">Order manually</option>
    </select>
</div>

    <div id="manual_order_stock_advanced" style="margin-bottom: 15px; display: none;">
    <label><strong>Drag to Reorder:</strong></label>
    <div id="sortable_vars_stock_advanced" style="padding: 10px; border: 1px solid #ccc; min-height: 50px;">
    </div>
</div>

    <div id="dendrogram_stock_advanced" style="width: 100%; height: 300px;"></div>
    <div id="corrmatrix_stock_advanced" style="width: 100%; height: 600px;"></div>
</div>
<style>
#sortable_vars_stock_advanced .sortable-item {
    padding: 5px 10px;
    margin: 2px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    cursor: move;
    display: inline-block;
}
#sortable_vars_stock_advanced .sortable-item:hover {
    background-color: #e0e0e0;
}
</style>

<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: stock_corr_data.parquet</p><br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<div class="graph-container">
    <h2>Stock Correlation Network - Multiple Scenarios</h2>
    <p>This Graph uses the EXACT SAME data as the CorrPlot above - no duplication! Both charts consume stock_corr_data with columns: node1, node2, strength, scenario, correlation_method, sector. <strong>Scenario switching:</strong> Select different scenarios (Short-term, Long-term, Volatility) and watch how the edges change while nodes stay in the same positions. <strong>Variable selection:</strong> Deselect stocks to make them translucent, then click 'Recalculate Graph' to remove them. Stocks are colored by sector showing how same-sector stocks cluster together. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/graph_examples.html" style="color: blue; font-weight: bold;">See here for more Graph examples</a></p>
    <div style="margin-bottom: 10px;">
    <label for="scenario_select_stock_network"><strong>Scenario:</strong></label>
    <select id="scenario_select_stock_network" onchange="updateEdges_stock_network()">
        <option value="Short-term Returns (Daily)">Short-term Returns (Daily)</option>
                <option value="Long-term Returns (20-day)">Long-term Returns (20-day)</option>
                <option value="Volatility Correlations">Volatility Correlations</option>
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <label for="var_select_stock_network"><strong>Select Variables:</strong></label><br>
    <select id="var_select_stock_network" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_stock_network()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_stock_network" onclick="recalculateGraph_stock_network()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_stock_network"><strong>Color nodes by:</strong></label>
    <select id="color_select_stock_network" onchange="updateColors_stock_network()">
        <option value="none">None</option>
        <option value="sector" selected>sector</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_stock_network"><strong>Layout:</strong></label>
    <select id="layout_select_stock_network" onchange="recalculateGraph_stock_network()">
        <option value="cose" selected>Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_stock_network"
               
               onchange="updateEdgeLabels_stock_network()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_stock_network"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_stock_network">0.6849176421207755</span>
    </label>
    <input type="range" id="cutoff_slider_stock_network"
           min="0" max="1" step="0.05" value="0.6849176421207755"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_stock_network').textContent = this.value; updateEdges_stock_network()">
</div>

    <div id="graph_stock_network" style="width: 100%; height: 600px; border: 1px solid #ccc;"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: stock_corr_data.parquet</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.3.3.</small></p>
</body>
</html>
