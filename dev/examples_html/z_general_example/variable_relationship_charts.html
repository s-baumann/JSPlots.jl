<!DOCTYPE html>
<html>
<head>
    <title>Variable Relationship Charts</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
    

    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->
<script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
<script type="module">
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';
await parquet.default();
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts various date formats to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
// Handles: ISO strings, Date objects (from Arrow/Parquet), timestamps, and day counts
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Timestamp range for reasonable dates (2000-01-01 to 2100-01-01 in milliseconds)
    // Using year 2000 as minimum to avoid false positives with regular numeric values
    var MIN_TIMESTAMP_MS = 946684800000;  // 2000-01-01
    var MAX_TIMESTAMP_MS = 4102444800000;  // 2100-01-01

    // Day count range (for dates stored as days since epoch, e.g., from some Parquet files)
    // Reasonable range: 0 (1970-01-01) to ~47500 (~2100-01-01)
    var MIN_DAYS = 0;
    var MAX_DAYS = 50000;
    var MS_PER_DAY = 86400000;

    // Scan multiple rows to better detect column types (some rows might have missing values)
    var rowsToCheck = Math.min(10, data.length);
    var dateColumns = [];
    var timeColumns = [];
    var timestampColumns = [];
    var dayCountColumns = [];
    var alreadyDateColumns = [];

    // Helper to check if a numeric value looks like a timestamp (milliseconds since epoch)
    function looksLikeTimestamp(value) {
        return typeof value === 'number' && value >= MIN_TIMESTAMP_MS && value <= MAX_TIMESTAMP_MS && value > MAX_DAYS;
    }

    // Helper to check if a numeric value looks like a day count since epoch
    // DISABLED: This was too aggressive and incorrectly converted normal numeric values
    // (like Month=1, Year=2022, Sales=120) to dates. Only enable for columns with
    // explicit date-like names if needed in the future.
    function looksLikeDayCount(value) {
        return false;  // Disabled - too many false positives
    }

    // Build list of keys from first row
    var keys = Object.keys(data[0]);

    // Check each column across multiple rows
    keys.forEach(function(key) {
        var stringDateCount = 0;
        var timeCount = 0;
        var timestampCount = 0;
        var dayCountCount = 0;
        var alreadyDateCount = 0;
        var nonNullCount = 0;

        for (var i = 0; i < rowsToCheck; i++) {
            var value = data[i][key];
            if (value === null || value === undefined) continue;
            nonNullCount++;

            if (value instanceof Date) {
                alreadyDateCount++;
            } else if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    stringDateCount++;
                } else if (timePattern.test(value)) {
                    timeCount++;
                }
            } else if (typeof value === 'number') {
                if (looksLikeTimestamp(value)) {
                    timestampCount++;
                } else if (looksLikeDayCount(value)) {
                    dayCountCount++;
                }
            }
        }

        // Classify column if majority of non-null values match a pattern
        var threshold = nonNullCount * 0.5;
        if (alreadyDateCount > threshold) {
            alreadyDateColumns.push(key);
        } else if (stringDateCount > threshold) {
            dateColumns.push(key);
        } else if (timeCount > threshold) {
            timeColumns.push(key);
        } else if (timestampCount > threshold) {
            timestampColumns.push(key);
        } else if (dayCountCount > threshold && dayCountCount >= 3) {
            // Be more conservative with day counts - require at least 3 matches
            dayCountColumns.push(key);
        }
    });

    // If no date/time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0 &&
        timestampColumns.length === 0 && dayCountColumns.length === 0 &&
        alreadyDateColumns.length === 0) {
        return data;
    }

    // Convert values in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                var value = row[key];

                if (alreadyDateColumns.indexOf(key) !== -1) {
                    // Already a Date object - keep as is
                    newRow[key] = value;
                } else if (dateColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // ISO date string - convert to Date
                    newRow[key] = new Date(value);
                } else if (timeColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = value.split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else if (timestampColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Timestamp in milliseconds - convert to Date
                    newRow[key] = new Date(value);
                } else if (dayCountColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Day count since epoch - convert to Date
                    newRow[key] = new Date(value * MS_PER_DAY);
                } else {
                    newRow[key] = value;
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
// Now supports optional choice filters (single-select) in addition to categorical filters (multi-select)
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters, choiceFilters, choices) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply choice filters first (single-select, exact match)
    if (choiceFilters && choices) {
        choiceFilters.forEach(function(col) {
            if (choices[col] !== undefined && choices[col] !== null && choices[col] !== '') {
                currentData = currentData.filter(function(row) {
                    var rowValueStr = temporalValueToString(row[col]);
                    return rowValueStr === choices[col];
                });
            }
        });
    }

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Read all filter values from the DOM for a given chart
// Returns { filters, rangeFilters, choices } ready for applyFiltersWithCounting
function readFilterValues(chartTitle, categoricalFilters, continuousFilters, choiceFilters) {
    const choices = {};
    choiceFilters.forEach(function(col) {
        const select = document.getElementById(col + '_choice_' + chartTitle);
        if (select) {
            choices[col] = select.value;
        }
    });

    const filters = {};
    categoricalFilters.forEach(function(col) {
        const select = document.getElementById(col + '_select_' + chartTitle);
        if (select) {
            filters[col] = Array.from(select.selectedOptions).map(function(opt) { return opt.value; });
        }
    });

    const rangeFilters = {};
    continuousFilters.forEach(function(col) {
        const slider = $('#' + col + '_range_' + chartTitle + '_slider');
        if (slider.length > 0 && slider.hasClass('ui-slider')) {
            rangeFilters[col] = {
                min: slider.slider("values", 0),
                max: slider.slider("values", 1)
            };
        }
    });

    return { filters: filters, rangeFilters: rangeFilters, choices: choices };
}

// Read facet selections from the DOM for a given chart
// Returns { facet1, facet2, facetCols } where facet1/facet2 are column names or null
function readFacetSelections(chartTitle) {
    const facet1Select = document.getElementById('facet1_select_' + chartTitle);
    const facet2Select = document.getElementById('facet2_select_' + chartTitle);
    const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
    const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;
    const facetCols = [];
    if (facet1) facetCols.push(facet1);
    if (facet2) facetCols.push(facet2);
    return { facet1: facet1, facet2: facet2, facetCols: facetCols };
}

// Robust sort comparator that handles dates, numbers, strings, and optional custom ordering
// xOrder is an optional array of values defining custom sort order (pass [] to skip)
function robustSortComparator(aVal, bVal, xOrder) {
    // Custom ordering
    if (xOrder && xOrder.length > 0) {
        const aIdx = xOrder.indexOf(String(aVal));
        const bIdx = xOrder.indexOf(String(bVal));
        if (aIdx >= 0 && bIdx >= 0) return aIdx - bIdx;
        if (aIdx >= 0) return -1;
        if (bIdx >= 0) return 1;
    }

    // Date objects
    if (aVal instanceof Date && bVal instanceof Date) {
        return aVal - bVal;
    }

    const aStr = String(aVal);
    const bStr = String(bVal);

    // Try numeric comparison
    const aNum = parseFloat(aVal);
    const bNum = parseFloat(bVal);
    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
        return aNum - bNum;
    }

    // Fall back to string comparison
    return aStr.localeCompare(bStr);
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        case 'cumulative':
        case 'cumprod':
            // These are handled specially in chart code (computed per group)
            // Here they act as identity
            return values;

        default:
            return values;
    }
}

// Compute cumulative sum of values
// Returns array of same length: [y[0], y[0]+y[1], y[0]+y[1]+y[2], ...]
function computeCumulativeSum(values) {
    if (!values || values.length === 0) return [];
    var result = [];
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);  // Explicitly convert to number
        if (!isNaN(v) && isFinite(v)) {
            sum += v;
        }
        result.push(sum);
    }
    return result;
}

// Compute cumulative product of values for returns data
// For returns r_i, computes: cumprod(1 + r_i) - 1
// This converts returns to growth factors, compounds them, then converts back to cumulative return
// Example: returns [0.1, 0.2, -0.1] -> (1+r): [1.1, 1.2, 0.9] -> cumprod: [1.1, 1.32, 1.188] -> result: [0.1, 0.32, 0.188]
function computeCumulativeProduct(values) {
    if (!values || values.length === 0) return [];
    var result = [];
    var product = 1;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);  // Explicitly convert to number
        if (!isNaN(v) && isFinite(v)) {
            product *= (1 + v);  // Convert return to growth factor and multiply
        }
        result.push(product - 1);  // Convert back to cumulative return
    }
    return result;
}

// Compute Exponentially Weighted Moving Average
// weight: weight on newest observation, with warmup max(1/(i+1), weight)
function computeEWMA(values, weight) {
    var result = [];
    var ewma = NaN;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);
        var wt = Math.max(1 / (i + 1), weight);
        if (isNaN(v) || !isFinite(v)) {
            result.push(ewma);
        } else if (isNaN(ewma)) {
            ewma = v;
            result.push(ewma);
        } else {
            ewma = v * wt + ewma * (1 - wt);
            result.push(ewma);
        }
    }
    return result;
}

// Compute Exponentially Weighted Moving Standard Deviation
// Tracks EWMA of value and EWMA of value squared, std = sqrt(E[X^2] - E[X]^2)
// weight: weight on newest observation, with warmup max(1/(i+1), weight)
function computeEWMSTD(values, weight) {
    var result = [];
    var ewmaMean = NaN;
    var ewmaSq = NaN;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);
        var wt = Math.max(1 / (i + 1), weight);
        if (isNaN(v) || !isFinite(v)) {
            result.push(isNaN(ewmaMean) ? NaN : Math.sqrt(Math.max(0, ewmaSq - ewmaMean * ewmaMean)));
        } else if (isNaN(ewmaMean)) {
            ewmaMean = v;
            ewmaSq = v * v;
            result.push(0);
        } else {
            ewmaMean = v * wt + ewmaMean * (1 - wt);
            ewmaSq = (v * v) * wt + ewmaSq * (1 - wt);
            result.push(Math.sqrt(Math.max(0, ewmaSq - ewmaMean * ewmaMean)));
        }
    }
    return result;
}

// Compute Simple Moving Average over last windowSize periods
function computeSMA(values, windowSize) {
    var result = [];
    for (var i = 0; i < values.length; i++) {
        var start = Math.max(0, i - windowSize + 1);
        var sum = 0, count = 0;
        for (var j = start; j <= i; j++) {
            var v = parseFloat(values[j]);
            if (!isNaN(v) && isFinite(v)) { sum += v; count++; }
        }
        result.push(count > 0 ? sum / count : NaN);
    }
    return result;
}

// Compute a moving statistic on an array of values
// windowType: "fixed_interval" | "fixed_interval_around" | "exponential_decay"
// aggregation: "mean" | "std" | "skewness" | "kurtosis"
// parameter: window size (for fixed_interval/fixed_interval_around) or decay weight (for exponential_decay)
function computeMovingStatistic(values, windowType, aggregation, parameter) {
    if (!values || values.length === 0) return [];

    if (windowType === 'exponential_decay') {
        return computeEWMStatistic(values, aggregation, parameter);
    }

    var result = [];
    var windowSize = Math.max(1, Math.round(parameter));

    for (var i = 0; i < values.length; i++) {
        var start, end;
        if (windowType === 'fixed_interval') {
            // Backward-looking: [i - windowSize + 1, i]
            start = Math.max(0, i - windowSize + 1);
            end = i + 1;
        } else {
            // Centered: [i - half, i + half]
            var half = Math.floor(windowSize / 2);
            start = Math.max(0, i - half);
            end = Math.min(values.length, i + half + 1);
        }

        var windowValues = [];
        for (var j = start; j < end; j++) {
            var v = parseFloat(values[j]);
            if (!isNaN(v) && isFinite(v)) {
                windowValues.push(v);
            }
        }

        result.push(computeWindowAggregation(windowValues, aggregation));
    }
    return result;
}

// Compute aggregation over a window of values
function computeWindowAggregation(windowValues, aggregation) {
    var n = windowValues.length;
    if (n === 0) return NaN;

    var sum = 0;
    for (var i = 0; i < n; i++) sum += windowValues[i];
    var mean = sum / n;

    if (aggregation === 'mean') return mean;

    // For std, skewness, kurtosis we need central moments
    var m2 = 0, m3 = 0, m4 = 0;
    for (var i = 0; i < n; i++) {
        var d = windowValues[i] - mean;
        m2 += d * d;
        m3 += d * d * d;
        m4 += d * d * d * d;
    }

    var variance = n > 1 ? m2 / (n - 1) : 0;
    var stddev = Math.sqrt(variance);

    if (aggregation === 'std') return stddev;

    // Population moments for skewness/kurtosis
    var popM2 = m2 / n;
    var popM3 = m3 / n;
    var popM4 = m4 / n;

    if (popM2 === 0) return 0;

    if (aggregation === 'skewness') {
        return popM3 / Math.pow(popM2, 1.5);
    }

    if (aggregation === 'kurtosis') {
        // Excess kurtosis (normal = 0)
        return (popM4 / (popM2 * popM2)) - 3;
    }

    return NaN;
}

// Exponentially weighted moving statistic
// alpha is weight on the LATEST value: EWMA_t = alpha * x_t + (1 - alpha) * EWMA_{t-1}
function computeEWMStatistic(values, aggregation, alpha) {
    if (!values || values.length === 0) return [];
    var result = [];

    if (aggregation === 'mean') {
        var ewma = parseFloat(values[0]);
        result.push(isNaN(ewma) ? NaN : ewma);
        for (var i = 1; i < values.length; i++) {
            var v = parseFloat(values[i]);
            if (!isNaN(v) && isFinite(v)) {
                ewma = alpha * v + (1 - alpha) * ewma;
            }
            result.push(ewma);
        }
        return result;
    }

    // For std, skewness, kurtosis: track exponentially weighted moments
    var ewmMean = parseFloat(values[0]);
    var ewmVar = 0;
    var ewmM3 = 0;
    var ewmM4 = 0;

    result.push(0);  // First value: no variance/skew/kurtosis yet

    for (var i = 1; i < values.length; i++) {
        var v = parseFloat(values[i]);
        if (isNaN(v) || !isFinite(v)) {
            result.push(result[result.length - 1]);
            continue;
        }
        var delta = v - ewmMean;
        ewmMean = alpha * v + (1 - alpha) * ewmMean;
        var delta2 = v - ewmMean;
        ewmVar = (1 - alpha) * (ewmVar + alpha * delta * delta2);

        if (aggregation === 'std') {
            result.push(Math.sqrt(Math.max(0, ewmVar)));
        } else {
            var ewmStd = Math.sqrt(Math.max(0, ewmVar));
            ewmM3 = (1 - alpha) * (ewmM3 + alpha * delta * delta * delta);
            ewmM4 = (1 - alpha) * (ewmM4 + alpha * delta * delta * delta * delta);

            if (ewmStd > 0 && ewmVar > 0) {
                if (aggregation === 'skewness') {
                    result.push(ewmM3 / (ewmStd * ewmStd * ewmStd));
                } else {
                    // Excess kurtosis
                    result.push((ewmM4 / (ewmVar * ewmVar)) - 3);
                }
            } else {
                result.push(0);
            }
        }
    }
    return result;
}

// Compute quantile transformation of values (rank-based, maps to [0, 1])
function computeQuantileTransform(values) {
    if (!values || values.length === 0) return [];

    var indexedValues = values.map(function(v, i) {
        return { value: parseFloat(v), index: i };  // Explicitly convert to number
    });

    var validValues = indexedValues.filter(function(item) {
        return !isNaN(item.value) && isFinite(item.value);
    }).sort(function(a, b) {
        return a.value - b.value;
    });

    if (validValues.length === 0) return values;

    var ranks = new Array(values.length).fill(NaN);
    validValues.forEach(function(item, rank) {
        ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
    });

    return ranks;
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        case 'cumulative':
            return 'cumulative(' + originalLabel + ')';
        case 'cumprod':
            return 'cumprod(' + originalLabel + ')';
        case 'ewma':
            return 'ewma(' + originalLabel + ')';
        case 'ewmstd':
            return 'ewmstd(' + originalLabel + ')';
        case 'sma':
            return 'sma(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// =============================================================================
// Expression Parser for ScatterTwo
// Supports: +, -, *, /, variable references (:var or var), and functions:
//   z(expr, [groups]) - z-score within groups
//   q(expr, [groups]) - quantile within groups
//   PCA1(var1, var2) - projection on first principal component
//   PCA2(var1, var2) - projection on second principal component
// =============================================================================

// Tokenizer for expression parsing
function tokenizeExpression(expr) {
    var tokens = [];
    var i = 0;
    while (i < expr.length) {
        var ch = expr[i];

        // Skip whitespace
        if (/\s/.test(ch)) { i++; continue; }

        // Operators and punctuation
        if ('+-*/(),[]'.indexOf(ch) !== -1) {
            tokens.push({ type: 'punct', value: ch });
            i++;
            continue;
        }

        // Numbers
        if (/[0-9.]/.test(ch)) {
            var num = '';
            while (i < expr.length && /[0-9.]/.test(expr[i])) {
                num += expr[i++];
            }
            tokens.push({ type: 'number', value: parseFloat(num) });
            continue;
        }

        // Variable with colon prefix :varname
        if (ch === ':') {
            i++; // skip colon
            var name = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) {
                name += expr[i++];
            }
            tokens.push({ type: 'variable', value: name });
            continue;
        }

        // Identifiers (function names or variable names without colon)
        if (/[a-zA-Z_]/.test(ch)) {
            var ident = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) {
                ident += expr[i++];
            }
            // Check if it's a function (followed by open paren)
            var j = i;
            while (j < expr.length && /\s/.test(expr[j])) j++;
            if (j < expr.length && expr[j] === '(') {
                tokens.push({ type: 'function', value: ident });
            } else {
                tokens.push({ type: 'variable', value: ident });
            }
            continue;
        }

        // Unknown character - skip
        i++;
    }
    return tokens;
}

// Simple recursive descent parser
function parseExpression(tokens, pos) {
    return parseAddSub(tokens, pos);
}

function parseAddSub(tokens, pos) {
    var result = parseMulDiv(tokens, pos);
    var node = result.node;
    pos = result.pos;

    while (pos < tokens.length && tokens[pos].type === 'punct' &&
           (tokens[pos].value === '+' || tokens[pos].value === '-')) {
        var op = tokens[pos].value;
        pos++;
        var right = parseMulDiv(tokens, pos);
        node = { type: 'binary', op: op, left: node, right: right.node };
        pos = right.pos;
    }
    return { node: node, pos: pos };
}

function parseMulDiv(tokens, pos) {
    var result = parseUnary(tokens, pos);
    var node = result.node;
    pos = result.pos;

    while (pos < tokens.length && tokens[pos].type === 'punct' &&
           (tokens[pos].value === '*' || tokens[pos].value === '/')) {
        var op = tokens[pos].value;
        pos++;
        var right = parseUnary(tokens, pos);
        node = { type: 'binary', op: op, left: node, right: right.node };
        pos = right.pos;
    }
    return { node: node, pos: pos };
}

function parseUnary(tokens, pos) {
    if (pos < tokens.length && tokens[pos].type === 'punct' && tokens[pos].value === '-') {
        pos++;
        var result = parseUnary(tokens, pos);
        return { node: { type: 'unary', op: '-', arg: result.node }, pos: result.pos };
    }
    return parsePrimary(tokens, pos);
}

function parsePrimary(tokens, pos) {
    if (pos >= tokens.length) {
        return { node: { type: 'number', value: 0 }, pos: pos };
    }

    var token = tokens[pos];

    // Number literal
    if (token.type === 'number') {
        return { node: { type: 'number', value: token.value }, pos: pos + 1 };
    }

    // Variable reference
    if (token.type === 'variable') {
        return { node: { type: 'variable', name: token.value }, pos: pos + 1 };
    }

    // Function call
    if (token.type === 'function') {
        var funcName = token.value;
        pos++; // skip function name
        if (pos < tokens.length && tokens[pos].value === '(') {
            pos++; // skip (
            var args = [];
            while (pos < tokens.length && tokens[pos].value !== ')') {
                // Check for array literal [...]
                if (tokens[pos].value === '[') {
                    pos++; // skip [
                    var arrayItems = [];
                    while (pos < tokens.length && tokens[pos].value !== ']') {
                        if (tokens[pos].type === 'variable') {
                            arrayItems.push(tokens[pos].value);
                        }
                        pos++;
                        if (pos < tokens.length && tokens[pos].value === ',') pos++;
                    }
                    if (pos < tokens.length && tokens[pos].value === ']') pos++;
                    args.push({ type: 'array', items: arrayItems });
                } else {
                    var argResult = parseExpression(tokens, pos);
                    args.push(argResult.node);
                    pos = argResult.pos;
                }
                if (pos < tokens.length && tokens[pos].value === ',') pos++;
            }
            if (pos < tokens.length && tokens[pos].value === ')') pos++;
            return { node: { type: 'function', name: funcName, args: args }, pos: pos };
        }
    }

    // Parenthesized expression
    if (token.type === 'punct' && token.value === '(') {
        pos++; // skip (
        var result = parseExpression(tokens, pos);
        pos = result.pos;
        if (pos < tokens.length && tokens[pos].value === ')') pos++;
        return { node: result.node, pos: pos };
    }

    // Default: return 0
    return { node: { type: 'number', value: 0 }, pos: pos + 1 };
}

// Evaluate parsed expression against data
// Returns an array of values, one per data row
function evaluateExpression(node, data) {
    if (!node) return data.map(function() { return 0; });

    switch (node.type) {
        case 'number':
            return data.map(function() { return node.value; });

        case 'variable':
            return data.map(function(row) {
                var val = row[node.name];
                return (typeof val === 'number') ? val : parseFloat(val) || 0;
            });

        case 'binary':
            var left = evaluateExpression(node.left, data);
            var right = evaluateExpression(node.right, data);
            return left.map(function(l, i) {
                var r = right[i];
                switch (node.op) {
                    case '+': return l + r;
                    case '-': return l - r;
                    case '*': return l * r;
                    case '/': return r !== 0 ? l / r : NaN;
                    default: return 0;
                }
            });

        case 'unary':
            var arg = evaluateExpression(node.arg, data);
            if (node.op === '-') {
                return arg.map(function(v) { return -v; });
            }
            return arg;

        case 'function':
            return evaluateFunction(node.name, node.args, data);

        default:
            return data.map(function() { return 0; });
    }
}

// Evaluate function calls
function evaluateFunction(name, args, data) {
    var lowerName = name.toLowerCase();

    // z(expr, [groups]) - z-score within groups
    if (lowerName === 'z') {
        var values = evaluateExpression(args[0], data);
        var groupCols = (args.length > 1 && args[1].type === 'array') ? args[1].items : [];
        return computeGroupedZScore(values, data, groupCols);
    }

    // q(expr, [groups]) - quantile within groups
    if (lowerName === 'q') {
        var values = evaluateExpression(args[0], data);
        var groupCols = (args.length > 1 && args[1].type === 'array') ? args[1].items : [];
        return computeGroupedQuantile(values, data, groupCols);
    }

    // PCA1(var1, var2) - first principal component
    if (lowerName === 'pca1') {
        if (args.length >= 2) {
            var v1 = evaluateExpression(args[0], data);
            var v2 = evaluateExpression(args[1], data);
            return computePCA(v1, v2, 1);
        }
        return data.map(function() { return 0; });
    }

    // PCA2(var1, var2) - second principal component
    if (lowerName === 'pca2') {
        if (args.length >= 2) {
            var v1 = evaluateExpression(args[0], data);
            var v2 = evaluateExpression(args[1], data);
            return computePCA(v1, v2, 2);
        }
        return data.map(function() { return 0; });
    }

    // r(y, x) - OLS residual (y - fitted)
    if (lowerName === 'r') {
        if (args.length >= 2) {
            var y = evaluateExpression(args[0], data);
            var x = evaluateExpression(args[1], data);
            return computeOLSResidual(y, x);
        }
        return data.map(function() { return 0; });
    }

    // f(y, x) - OLS fitted value
    if (lowerName === 'f') {
        if (args.length >= 2) {
            var y = evaluateExpression(args[0], data);
            var x = evaluateExpression(args[1], data);
            return computeOLSFitted(y, x);
        }
        return data.map(function() { return 0; });
    }

    // c(expr, min, max) - clamp values between min and max
    // Use Infinity or -Infinity to only set one bound
    if (lowerName === 'c') {
        if (args.length >= 3) {
            var values = evaluateExpression(args[0], data);
            var minVal = evaluateExpression(args[1], data);
            var maxVal = evaluateExpression(args[2], data);

            // Get min/max bounds (they're arrays from evaluateExpression, but should be constant)
            var lo = minVal[0];
            var hi = maxVal[0];

            return values.map(function(v) {
                if (isNaN(v)) return v;
                if (v < lo) return lo;
                if (v > hi) return hi;
                return v;
            });
        }
        return data.map(function() { return 0; });
    }

    // Unknown function - return zeros
    return data.map(function() { return 0; });
}

// Compute z-score within groups
function computeGroupedZScore(values, data, groupCols) {
    if (groupCols.length === 0) {
        // No grouping - compute global z-score
        var validVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
        if (validVals.length === 0) return values;
        var mean = validVals.reduce(function(a, b) { return a + b; }, 0) / validVals.length;
        var variance = validVals.reduce(function(a, b) { return a + (b - mean) * (b - mean); }, 0) / validVals.length;
        var std = Math.sqrt(variance);
        if (std === 0) return values.map(function() { return 0; });
        return values.map(function(v) { return (v - mean) / std; });
    }

    // Group by specified columns
    var groups = {};
    data.forEach(function(row, i) {
        var key = groupCols.map(function(col) { return row[col]; }).join('|');
        if (!groups[key]) groups[key] = { indices: [], values: [] };
        groups[key].indices.push(i);
        groups[key].values.push(values[i]);
    });

    // Compute z-score within each group
    var result = new Array(values.length);
    Object.keys(groups).forEach(function(key) {
        var g = groups[key];
        var validVals = g.values.filter(function(v) { return !isNaN(v) && isFinite(v); });
        if (validVals.length === 0) {
            g.indices.forEach(function(i) { result[i] = NaN; });
            return;
        }
        var mean = validVals.reduce(function(a, b) { return a + b; }, 0) / validVals.length;
        var variance = validVals.reduce(function(a, b) { return a + (b - mean) * (b - mean); }, 0) / validVals.length;
        var std = Math.sqrt(variance);
        g.indices.forEach(function(idx, j) {
            result[idx] = std === 0 ? 0 : (g.values[j] - mean) / std;
        });
    });
    return result;
}

// Compute quantile within groups
function computeGroupedQuantile(values, data, groupCols) {
    if (groupCols.length === 0) {
        // No grouping - compute global quantile
        return computeQuantileTransform(values);
    }

    // Group by specified columns
    var groups = {};
    data.forEach(function(row, i) {
        var key = groupCols.map(function(col) { return row[col]; }).join('|');
        if (!groups[key]) groups[key] = { indices: [], values: [] };
        groups[key].indices.push(i);
        groups[key].values.push(values[i]);
    });

    // Compute quantile within each group
    var result = new Array(values.length);
    Object.keys(groups).forEach(function(key) {
        var g = groups[key];
        var quantiles = computeQuantileTransform(g.values);
        g.indices.forEach(function(idx, j) {
            result[idx] = quantiles[j];
        });
    });
    return result;
}

// Compute PCA projection
// component: 1 for first PC, 2 for second PC
function computePCA(v1, v2, component) {
    var n = v1.length;
    if (n === 0) return [];

    // Filter valid pairs
    var validIndices = [];
    for (var i = 0; i < n; i++) {
        if (!isNaN(v1[i]) && isFinite(v1[i]) && !isNaN(v2[i]) && isFinite(v2[i])) {
            validIndices.push(i);
        }
    }

    if (validIndices.length < 2) {
        return v1.map(function() { return 0; });
    }

    // Compute means
    var mean1 = 0, mean2 = 0;
    validIndices.forEach(function(i) {
        mean1 += v1[i];
        mean2 += v2[i];
    });
    mean1 /= validIndices.length;
    mean2 /= validIndices.length;

    // Compute covariance matrix elements
    var cov11 = 0, cov12 = 0, cov22 = 0;
    validIndices.forEach(function(i) {
        var d1 = v1[i] - mean1;
        var d2 = v2[i] - mean2;
        cov11 += d1 * d1;
        cov12 += d1 * d2;
        cov22 += d2 * d2;
    });
    cov11 /= validIndices.length;
    cov12 /= validIndices.length;
    cov22 /= validIndices.length;

    // Compute eigenvalues and eigenvectors of 2x2 covariance matrix
    // Using closed-form solution for 2x2 symmetric matrix
    var trace = cov11 + cov22;
    var det = cov11 * cov22 - cov12 * cov12;
    var discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
    var lambda1 = trace / 2 + discriminant; // larger eigenvalue
    var lambda2 = trace / 2 - discriminant; // smaller eigenvalue

    // Eigenvector for lambda1 (first PC)
    var ev1_x, ev1_y;
    if (Math.abs(cov12) > 1e-10) {
        ev1_x = lambda1 - cov22;
        ev1_y = cov12;
    } else {
        ev1_x = 1;
        ev1_y = 0;
    }
    var norm1 = Math.sqrt(ev1_x * ev1_x + ev1_y * ev1_y);
    if (norm1 > 0) { ev1_x /= norm1; ev1_y /= norm1; }

    // Eigenvector for lambda2 (second PC) - perpendicular to first
    var ev2_x = -ev1_y;
    var ev2_y = ev1_x;

    // Choose eigenvector based on component
    var ev_x = component === 1 ? ev1_x : ev2_x;
    var ev_y = component === 1 ? ev1_y : ev2_y;

    // Project all points onto the principal component
    var result = new Array(n);
    for (var i = 0; i < n; i++) {
        if (!isNaN(v1[i]) && isFinite(v1[i]) && !isNaN(v2[i]) && isFinite(v2[i])) {
            result[i] = (v1[i] - mean1) * ev_x + (v2[i] - mean2) * ev_y;
        } else {
            result[i] = NaN;
        }
    }
    return result;
}

// Compute OLS regression coefficients (y = alpha + beta * x)
// Returns {alpha, beta} or null if regression fails
function computeOLSCoefficients(y, x) {
    var n = y.length;
    if (n === 0 || n !== x.length) return null;

    // Filter to valid pairs only
    var validPairs = [];
    for (var i = 0; i < n; i++) {
        if (!isNaN(y[i]) && isFinite(y[i]) && !isNaN(x[i]) && isFinite(x[i])) {
            validPairs.push({ y: y[i], x: x[i] });
        }
    }

    if (validPairs.length < 2) return null;

    // Compute means
    var sumX = 0, sumY = 0;
    validPairs.forEach(function(p) {
        sumX += p.x;
        sumY += p.y;
    });
    var meanX = sumX / validPairs.length;
    var meanY = sumY / validPairs.length;

    // Compute beta = Cov(x,y) / Var(x)
    var covXY = 0, varX = 0;
    validPairs.forEach(function(p) {
        var dx = p.x - meanX;
        var dy = p.y - meanY;
        covXY += dx * dy;
        varX += dx * dx;
    });

    if (varX === 0) return null; // x has no variance

    var beta = covXY / varX;
    var alpha = meanY - beta * meanX;

    return { alpha: alpha, beta: beta };
}

// Compute OLS residuals: r(y, x) = y - fitted = y - (alpha + beta * x)
function computeOLSResidual(y, x) {
    var coef = computeOLSCoefficients(y, x);
    if (!coef) {
        return y.map(function() { return NaN; });
    }

    return y.map(function(yi, i) {
        if (isNaN(yi) || !isFinite(yi) || isNaN(x[i]) || !isFinite(x[i])) {
            return NaN;
        }
        var fitted = coef.alpha + coef.beta * x[i];
        return yi - fitted;
    });
}

// Compute OLS fitted values: f(y, x) = alpha + beta * x
function computeOLSFitted(y, x) {
    var coef = computeOLSCoefficients(y, x);
    if (!coef) {
        return y.map(function() { return NaN; });
    }

    return x.map(function(xi, i) {
        if (isNaN(y[i]) || !isFinite(y[i]) || isNaN(xi) || !isFinite(xi)) {
            return NaN;
        }
        return coef.alpha + coef.beta * xi;
    });
}

// Main function to evaluate an expression string against data
function evaluateExpressionString(exprString, data) {
    if (!exprString || exprString.trim() === '') {
        return data.map(function() { return 0; });
    }
    try {
        var tokens = tokenizeExpression(exprString);
        var parseResult = parseExpression(tokens, 0);
        return evaluateExpression(parseResult.node, data);
    } catch (e) {
        console.error('Expression parsing error:', e);
        return data.map(function() { return 0; });
    }
}

// =============================================================================
// End Expression Parser
// =============================================================================

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
// Note: Data elements have IDs prefixed with "data_" to avoid collisions with chart container IDs
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        // Sanitize the label: replace spaces and special chars with underscores
        var sanitizedLabel = dataLabel.replace(/[\s\-\.:/\\]/g, '_');
        var dataElementId = 'data_' + sanitizedLabel;
        var dataElement = document.getElementById(dataElementId);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataElementId + ' (from label: ' + dataLabel + ')'));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

// Global fix for PivotTable.js filter box positioning issue
// See: https://github.com/nicolaskruchten/pivottable/issues/865
// The library calculates position incorrectly - we fix it by repositioning after creation
(function() {
    if (window._pvtFilterBoxFixApplied) return; // Only apply once
    window._pvtFilterBoxFixApplied = true;

    var lastClickedTriangle = null;

    // Helper function to reposition the filter box
    function repositionFilterBox($box, triangle) {
        if (!triangle || !$box.length) return;

        // Get triangle position relative to viewport
        var triangleRect = triangle.getBoundingClientRect();

        // Get box dimensions (use defaults if not yet rendered)
        var boxWidth = $box.outerWidth() || 300;
        var boxHeight = $box.outerHeight() || 400;

        // Calculate position relative to viewport (for position:fixed)
        var newLeft = triangleRect.left;
        var newTop = triangleRect.bottom + 5;

        // Adjust if it would go off the right edge
        if (newLeft + boxWidth > window.innerWidth - 20) {
            newLeft = triangleRect.right - boxWidth;
        }

        // Adjust if it would go off the bottom edge
        if (newTop + boxHeight > window.innerHeight - 20) {
            newTop = triangleRect.top - boxHeight - 5;
        }

        // Ensure minimum positions
        if (newLeft < 10) newLeft = 10;
        if (newTop < 10) newTop = 10;

        // Use position:fixed for viewport-relative positioning
        $box.css({
            'position': 'fixed',
            'left': newLeft + 'px',
            'top': newTop + 'px'
        });
    }

    // Capture which triangle was clicked
    $(document).on('click', '.pvtTriangle', function(e) {
        lastClickedTriangle = this;
    });

    // Watch for filter box creation and fix position
    var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1 && $(node).hasClass('pvtFilterBox')) {
                    var $box = $(node);
                    var triangle = lastClickedTriangle;

                    // Apply the fix multiple times to ensure it sticks after PivotTable.js finishes
                    // The library may set position after initial render
                    var timings = [0, 10, 50, 100, 200];
                    timings.forEach(function(delay) {
                        setTimeout(function() {
                            repositionFilterBox($box, triangle);
                        }, delay);
                    });

                    // Also reposition on any style changes to the box (in case library updates position)
                    var styleObserver = new MutationObserver(function(styleMutations) {
                        repositionFilterBox($box, triangle);
                    });
                    styleObserver.observe(node, { attributes: true, attributeFilter: ['style'] });

                    // Disconnect the style observer when the filter box is removed
                    var removalObserver = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            mutation.removedNodes.forEach(function(removedNode) {
                                if (removedNode === node) {
                                    styleObserver.disconnect();
                                    removalObserver.disconnect();
                                    lastClickedTriangle = null;
                                }
                            });
                        });
                    });
                    removalObserver.observe(document.body, { childList: true, subtree: true });
                }
            });
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
})();

(function() {
    const scenarios = ["Short-term Returns (Daily)","Long-term Returns (20-day)","Volatility Correlations"];
    const hasScenarios = true;
    let currentScenario = "Short-term Returns (Daily)";
    let selectedVars = ["AAPL","MSFT","JPM","JNJ"];
    let manualOrder = [];
    let corrDataRaw = null;
    let allVars = [];
    const dendroOrderings = {"Volatility Correlations":{"spearman":{"single":{"tree":{"merges":[[-5,-4],[-3,1],[2,-1],[-8,-6],[4,-7],[5,-9],[3,6],[-10,7],[8,-2]],"heights":[0.3866712954262247,0.44253985954748065,0.46041696410629174,0.47132064372846905,0.4900288894209637,0.5198834692776324,0.5725168646178138,0.5989669156724866,0.6103193665298466],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,3,5,4,1,8,6,7,9,2]},"ordering":["PFE","GOOGL","TSLA","AMZN","AAPL","GS","JPM","BAC","JNJ","MSFT"]},"average":{"tree":{"merges":[[-5,-4],[-1,1],[2,-3],[-8,-6],[-10,3],[4,-7],[6,-9],[5,7],[8,-2]],"heights":[0.3866712954262247,0.46670490369319617,0.4876683239092146,0.47132064372846905,0.6268830118126881,0.5143392496973284,0.6190277253606759,0.6499379666093554,0.6643616437374921],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,1,5,4,3,8,6,7,9,2]},"ordering":["PFE","AAPL","TSLA","AMZN","GOOGL","GS","JPM","BAC","JNJ","MSFT"]},"complete":{"tree":{"merges":[[-4,-5],[1,-1],[-3,2],[-6,-8],[-9,-7],[5,-2],[-10,4],[7,6],[3,8]],"heights":[0.3866712954262247,0.4729928432801006,0.5229171418809313,0.47132064372846905,0.5198834692776324,0.6607256194552479,0.6417079343408257,0.6961234810396554,0.7016865719465509],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[3,4,5,1,10,6,8,9,7,2]},"ordering":["GOOGL","AMZN","TSLA","AAPL","PFE","JPM","GS","JNJ","BAC","MSFT"]},"ward":{"tree":{"merges":[[-5,-4],[-1,1],[2,-3],[-8,-6],[-7,-9],[-2,-10],[4,5],[6,7],[3,8]],"heights":[0.3866712954262247,0.4905430088366366,0.5107662284242976,0.47132064372846905,0.5198834692776324,0.6708145881585795,0.6828890452767838,0.7392403363247896,0.9177238634290787],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[1,5,4,3,2,10,8,6,7,9]},"ordering":["AAPL","TSLA","AMZN","GOOGL","MSFT","PFE","GS","JPM","BAC","JNJ"]}},"pearson":{"single":{"tree":{"merges":[[-5,-4],[-3,1],[-6,-7],[2,-1],[-8,3],[5,-9],[4,6],[-10,7],[8,-2]],"heights":[0.3824571014072994,0.45707984949000025,0.462188008173849,0.46649750128445816,0.4787580725105466,0.5032831483762644,0.5755365891128742,0.5793058486820118,0.6059974598671367],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,3,5,4,1,8,6,7,9,2]},"ordering":["PFE","GOOGL","TSLA","AMZN","AAPL","GS","JPM","BAC","JNJ","MSFT"]},"average":{"tree":{"merges":[[-4,-5],[1,-1],[-3,2],[-6,-7],[3,-10],[-8,4],[6,-9],[-2,5],[8,7]],"heights":[0.3824571014072994,0.4702232178575639,0.49448647167006277,0.462188008173849,0.6229880324993509,0.5031024688117811,0.5942190481528642,0.6543577712049944,0.660228419962486],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[2,3,4,5,1,10,8,6,7,9]},"ordering":["MSFT","GOOGL","AMZN","TSLA","AAPL","PFE","GS","JPM","BAC","JNJ"]},"complete":{"tree":{"merges":[[-5,-4],[-1,1],[2,-3],[-6,-7],[-8,4],[-10,3],[-9,-2],[6,5],[8,7]],"heights":[0.3824571014072994,0.4739489344306696,0.514305956266783,0.462188008173849,0.5274468651130156,0.65517826819661,0.6535264536585684,0.6835420685598781,0.7047664475216749],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,1,5,4,3,8,6,7,9,2]},"ordering":["PFE","AAPL","TSLA","AMZN","GOOGL","GS","JPM","BAC","JNJ","MSFT"]},"ward":{"tree":{"merges":[[-5,-4],[-1,1],[2,-3],[-7,-6],[4,-8],[-9,5],[-2,-10],[7,3],[8,6]],"heights":[0.3824571014072994,0.4960583258342199,0.5193641969908686,0.462188008173849,0.5167853261988685,0.6453091670720156,0.6896170212235384,0.7332551145857229,0.942233663138558],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[2,10,1,5,4,3,9,7,6,8]},"ordering":["MSFT","PFE","AAPL","TSLA","AMZN","GOOGL","JNJ","BAC","JPM","GS"]}}},"Short-term Returns (Daily)":{"spearman":{"single":{"tree":{"merges":[[-2,-1],[1,-3],[-4,2],[3,-5],[-8,-7],[-9,-10],[-6,5],[7,4],[8,6]],"heights":[0.3421409548226103,0.3700151977688826,0.37525792342886716,0.39511343413507644,0.457360377444568,0.45894366764194616,0.4590193843191406,0.6572387324283486,0.6601123267842706],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[6,8,7,4,2,1,3,5,9,10]},"ordering":["JPM","GS","BAC","AMZN","MSFT","AAPL","GOOGL","TSLA","JNJ","PFE"]},"average":{"tree":{"merges":[[-1,-2],[-3,1],[2,-4],[-5,3],[-10,-9],[-7,-8],[5,4],[6,-6],[7,8]],"heights":[0.3421409548226103,0.3703089247979441,0.3958948543779884,0.4101353689666005,0.45894366764194616,0.457360377444568,0.6850948042234086,0.46219379189619675,0.6875549109461149],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,9,5,3,1,2,4,7,8,6]},"ordering":["PFE","JNJ","TSLA","GOOGL","AAPL","MSFT","AMZN","BAC","GS","JPM"]},"complete":{"tree":{"merges":[[-2,-1],[1,-3],[-4,2],[3,-5],[-8,-7],[-9,-10],[-6,5],[7,4],[8,6]],"heights":[0.3421409548226103,0.3706026518270055,0.40896777877273555,0.4304910186755057,0.457360377444568,0.45894366764194616,0.4653681994732529,0.7036611814111473,0.7064106343025621],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[6,8,7,4,2,1,3,5,9,10]},"ordering":["JPM","GS","BAC","AMZN","MSFT","AAPL","GOOGL","TSLA","JNJ","PFE"]},"ward":{"tree":{"merges":[[-1,-2],[-3,1],[2,-4],[-5,3],[-9,-10],[-7,-8],[6,-6],[7,5],[4,8]],"heights":[0.3421409548226103,0.3792337499376783,0.4125608261856242,0.4280402227535594,0.45894366764194616,0.457360377444568,0.4638082210235759,0.9181553106892062,1.14448038749719],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[5,3,1,2,4,7,8,6,9,10]},"ordering":["TSLA","GOOGL","AAPL","MSFT","AMZN","BAC","GS","JPM","JNJ","PFE"]}},"pearson":{"single":{"tree":{"merges":[[-1,-2],[-3,1],[-5,2],[3,-4],[-8,-7],[-9,-10],[5,-6],[6,7],[4,8]],"heights":[0.3441471973533646,0.36408029685242765,0.368019966357301,0.3801343881931233,0.4280240997706328,0.45592858727991037,0.4599483362525539,0.6501217558587401,0.6640638129582613],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[5,3,1,2,4,9,10,8,7,6]},"ordering":["TSLA","GOOGL","AAPL","MSFT","AMZN","JNJ","PFE","GS","BAC","JPM"]},"average":{"tree":{"merges":[[-1,-2],[-3,1],[-5,2],[3,-4],[-9,-10],[-8,-7],[6,-6],[5,7],[4,8]],"heights":[0.3441471973533646,0.366322898755881,0.38572042733606987,0.39876945312488543,0.45592858727991037,0.4280240997706328,0.4623038301398733,0.6842922181224398,0.6892246408852971],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[5,3,1,2,4,9,10,8,7,6]},"ordering":["TSLA","GOOGL","AAPL","MSFT","AMZN","JNJ","PFE","GS","BAC","JPM"]},"complete":{"tree":{"merges":[[-1,-2],[-5,-3],[2,1],[3,-4],[-9,-10],[-8,-7],[6,-6],[5,7],[4,8]],"heights":[0.3441471973533646,0.368019966357301,0.39691457385640583,0.40917895299973217,0.45592858727991037,0.4280240997706328,0.46465932402719273,0.7041945448085875,0.7060365980013122],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[5,3,1,2,4,9,10,8,7,6]},"ordering":["TSLA","GOOGL","AAPL","MSFT","AMZN","JNJ","PFE","GS","BAC","JPM"]},"ward":{"tree":{"merges":[[-1,-2],[-5,-3],[2,1],[3,-4],[-9,-10],[-8,-7],[6,-6],[5,7],[4,8]],"heights":[0.3441471973533646,0.368019966357301,0.40367189502550005,0.4138558917949446,0.45592858727991037,0.4280240997706328,0.4731866752383389,0.9150068514868309,1.1644377694923305],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[5,3,1,2,4,9,10,8,7,6]},"ordering":["TSLA","GOOGL","AAPL","MSFT","AMZN","JNJ","PFE","GS","BAC","JPM"]}}},"Long-term Returns (20-day)":{"spearman":{"single":{"tree":{"merges":[[-3,-4],[-1,-2],[1,2],[3,-5],[-9,-10],[-6,-8],[6,-7],[4,5],[8,7]],"heights":[0.2536019458179345,0.25683665901375,0.2988828932185983,0.3235395738966969,0.32618870794476834,0.35087710288736906,0.47909581352355507,0.49076540073320724,0.5927370041572197],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[3,4,1,2,5,9,10,6,8,7]},"ordering":["GOOGL","AMZN","AAPL","MSFT","TSLA","JNJ","PFE","JPM","GS","BAC"]},"average":{"tree":{"merges":[[-2,-1],[-4,-3],[1,2],[-5,3],[-10,-9],[5,4],[-6,-8],[7,-7],[6,8]],"heights":[0.25683665901375,0.2536019458179345,0.32441509192745566,0.32957734360999846,0.32618870794476834,0.5534151795661906,0.35087710288736906,0.4829233071331962,0.6555900243659997],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,9,5,2,1,4,3,6,8,7]},"ordering":["PFE","JNJ","TSLA","MSFT","AAPL","AMZN","GOOGL","JPM","GS","BAC"]},"complete":{"tree":{"merges":[[-1,-2],[-4,-3],[-5,2],[1,3],[-9,-10],[5,4],[-6,-8],[7,-7],[6,8]],"heights":[0.25683665901375,0.2536019458179345,0.3349872485733026,0.3445939793606054,0.32618870794476834,0.636061071896703,0.35087710288736906,0.48675080074283733,0.698898199118839],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[9,10,1,2,5,4,3,6,8,7]},"ordering":["JNJ","PFE","AAPL","MSFT","TSLA","AMZN","GOOGL","JPM","GS","BAC"]},"ward":{"tree":{"merges":[[-2,-1],[-4,-3],[-5,1],[3,2],[-10,-9],[-6,-8],[6,-7],[5,4],[8,7]],"heights":[0.25683665901375,0.2536019458179345,0.35035323965606124,0.37650808969850375,0.32618870794476834,0.35087710288736906,0.5195522238070482,0.8321340064545025,1.0847921168497174],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,9,5,2,1,4,3,6,8,7]},"ordering":["PFE","JNJ","TSLA","MSFT","AAPL","AMZN","GOOGL","JPM","GS","BAC"]}},"pearson":{"single":{"tree":{"merges":[[-1,-2],[-3,-4],[2,1],[-5,3],[-10,-9],[-6,-8],[6,-7],[5,4],[8,7]],"heights":[0.22590163889782938,0.23200506231314463,0.29394118370565747,0.30471183605659247,0.32218254975178473,0.36071970620881294,0.45671711725985714,0.49613886755049624,0.5645932851984347],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,9,5,3,4,1,2,6,8,7]},"ordering":["PFE","JNJ","TSLA","GOOGL","AMZN","AAPL","MSFT","JPM","GS","BAC"]},"average":{"tree":{"merges":[[-1,-2],[-3,-4],[2,1],[-5,3],[-10,-9],[5,4],[-6,-8],[7,-7],[6,8]],"heights":[0.22590163889782938,0.23200506231314463,0.3045671655429867,0.3100653608910023,0.32218254975178473,0.5525790919063535,0.36071970620881294,0.4662206865540357,0.6430867391631007],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,9,5,3,4,1,2,6,8,7]},"ordering":["PFE","JNJ","TSLA","GOOGL","AMZN","AAPL","MSFT","JPM","GS","BAC"]},"complete":{"tree":{"merges":[[-1,-2],[-4,-3],[-5,2],[3,1],[-10,-9],[5,4],[-6,-8],[7,-7],[6,8]],"heights":[0.22590163889782938,0.23200506231314463,0.3083299569617625,0.31613987461360166,0.32218254975178473,0.633908851039548,0.36071970620881294,0.4757242558482142,0.7044354494315903],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,9,5,4,3,1,2,6,8,7]},"ordering":["PFE","JNJ","TSLA","AMZN","GOOGL","AAPL","MSFT","JPM","GS","BAC"]},"ward":{"tree":{"merges":[[-1,-2],[-4,-3],[-5,2],[3,1],[-10,-9],[-6,-8],[6,-7],[5,4],[8,7]],"heights":[0.22590163889782938,0.23200506231314463,0.3276212151489979,0.36347617964291423,0.32218254975178473,0.36071970620881294,0.4965512659513316,0.8395984036985801,1.0653352373241234],"labels":["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"],"order":[10,9,5,4,3,1,2,6,8,7]},"ordering":["PFE","JNJ","TSLA","AMZN","GOOGL","AAPL","MSFT","JPM","GS","BAC"]}}}};

    // Load correlation data
    loadDataset('stock_corr_data').then(function(data) {
        corrDataRaw = data;
        allVars = [...new Set(corrDataRaw.map(d => d.node1).concat(corrDataRaw.map(d => d.node2)))].sort();
        populateVarSelector_stock_advanced();
        updateChart_stock_advanced();
    }).catch(function(error) {
        console.error('Failed to load correlation data:', error);
        document.getElementById('corrmatrix_stock_advanced').innerHTML =
            '<p style="color: red;">Error loading correlation data: ' + error.message + '</p>';
    });

    function populateVarSelector_stock_advanced() {
        const select = document.getElementById('var_select_stock_advanced');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeSortable_stock_advanced() {
        const container = document.getElementById('sortable_vars_stock_advanced');
        if (!container) return;

        container.innerHTML = '';

        // Only show currently selected variables in manual order
        const varsToShow = manualOrder.length > 0 ?
            manualOrder.filter(v => selectedVars.includes(v)) :
            selectedVars;

        varsToShow.forEach(v => {
            const div = document.createElement('div');
            div.className = 'sortable-item';
            div.textContent = v;
            div.setAttribute('data-var', v);
            container.appendChild(div);
        });

        if (typeof Sortable !== 'undefined') {
            Sortable.create(container, {
                animation: 150,
                onEnd: function() {
                    manualOrder = Array.from(container.children).map(el => el.getAttribute('data-var'));
                    updateChart_stock_advanced();
                }
            });
        }
    }

    window.updateChart_stock_advanced = function() {
        if (!corrDataRaw || corrDataRaw.length === 0) {
            console.warn('Correlation data not loaded yet');
            return;
        }

        // Update scenario (if applicable)
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_stock_advanced');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Update selected variables
        const varSelect = document.getElementById('var_select_stock_advanced');
        const newSelectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Check if new variables were added
        const addedVars = newSelectedVars.filter(v => !selectedVars.includes(v));
        if (addedVars.length > 0 && manualOrder.length > 0) {
            // Add new variables to end of manual order
            addedVars.forEach(v => {
                if (!manualOrder.includes(v)) {
                    manualOrder.push(v);
                }
            });
        }

        selectedVars = newSelectedVars;

        if (selectedVars.length < 2) {
            console.warn('Select at least 2 variables');
            return;
        }

        // Get correlation method
        const corrMethod = document.getElementById('corr_method_select_stock_advanced').value;

        // Get order mode
        const orderModeSelect = document.getElementById('order_mode_stock_advanced');
        const orderMode = orderModeSelect ? orderModeSelect.value : 'dendrogram';

        // Show/hide linkage selector
        const linkageContainer = document.getElementById('linkage_container_stock_advanced');
        if (linkageContainer) {
            linkageContainer.style.display = (orderMode === 'dendrogram') ? 'block' : 'none';
        }

        // Show/hide manual ordering UI
        const manualDiv = document.getElementById('manual_order_stock_advanced');
        if (manualDiv) {
            manualDiv.style.display = (orderMode === 'manual') ? 'block' : 'none';
        }

        if (orderMode === 'manual') {
            initializeSortable_stock_advanced();
        }

        // Get linkage method
        const linkageMethod = document.getElementById('linkage_select_stock_advanced').value;

        // Build correlation matrix for selected variables
        const n = selectedVars.length;
        const corrMatrix = [];
        for (let i = 0; i < n; i++) {
            corrMatrix[i] = [];
            for (let j = 0; j < n; j++) {
                if (i === j) {
                    corrMatrix[i][j] = 1.0;
                } else {
                    // Find correlation from data
                    const item = corrDataRaw.find(d =>
                        ((d.node1 === selectedVars[i] && d.node2 === selectedVars[j]) ||
                         (d.node1 === selectedVars[j] && d.node2 === selectedVars[i])) &&
                        d.correlation_method === corrMethod &&
                        (!hasScenarios || d.scenario === currentScenario));
                    corrMatrix[i][j] = item ? item.strength : 0;
                }
            }
        }

        // Determine variable order
        let orderedVars;
        if (orderMode === 'manual' && manualOrder.length > 0) {
            // Use manual order, filtered to selected vars
            orderedVars = manualOrder.filter(v => selectedVars.includes(v));
            // Add any selected vars not in manual order to the end
            selectedVars.forEach(v => {
                if (!orderedVars.includes(v)) {
                    orderedVars.push(v);
                }
            });
        } else if (orderMode === 'alphabetical') {
            orderedVars = selectedVars.slice().sort();
        } else {
            // Use precomputed hierarchical clustering from Julia
            orderedVars = performClustering_stock_advanced(selectedVars, corrMatrix, linkageMethod, corrMethod);
        }

        // Reorder correlation matrix according to ordering
        const orderedIndices = orderedVars.map(v => selectedVars.indexOf(v));
        const reorderedMatrix = [];
        for (let i = 0; i < n; i++) {
            reorderedMatrix[i] = [];
            for (let j = 0; j < n; j++) {
                reorderedMatrix[i][j] = corrMatrix[orderedIndices[i]][orderedIndices[j]];
            }
        }

        // Draw heatmap
        drawHeatmap_stock_advanced(orderedVars, reorderedMatrix, corrMethod);

        // Draw dendrogram (only if using dendrogram order)
        if (orderMode === 'dendrogram') {
            drawDendrogram_stock_advanced(orderedVars, linkageMethod, corrMethod);
        } else {
            document.getElementById('dendrogram_stock_advanced').style.display = 'none';
        }
    };

    function performClustering_stock_advanced(vars, corrMatrix, linkageMethod, corrMethod) {
        if (vars.length < 2) return vars;

        // Get precomputed dendrogram ordering from Julia
        const scenario = hasScenarios ? currentScenario : "default";

        if (!dendroOrderings[scenario] || !dendroOrderings[scenario][corrMethod] ||
            !dendroOrderings[scenario][corrMethod][linkageMethod]) {
            console.warn('No precomputed ordering for', scenario, corrMethod, linkageMethod);
            return vars;
        }

        // Get the full dendrogram data
        const dendroData = dendroOrderings[scenario][corrMethod][linkageMethod];
        if (!dendroData || !dendroData.ordering) {
            console.warn('Invalid dendrogram data structure');
            return vars;
        }

        const fullOrdering = dendroData.ordering;

        // Filter to only the selected variables, preserving the ordering
        const orderedVars = fullOrdering.filter(v => vars.includes(v));

        return orderedVars;
    }

    function drawHeatmap_stock_advanced(vars, corrMatrix, corrMethod) {
        const n = vars.length;

        // Build z-values and text
        const zValues = [];
        const textValues = [];
        const hoverText = [];

        for (let i = 0; i < n; i++) {
            zValues[i] = [];
            textValues[i] = [];
            hoverText[i] = [];
            for (let j = 0; j < n; j++) {
                const corr = corrMatrix[i][j];
                zValues[i][j] = corr;

                if (i === j) {
                    textValues[i][j] = '1.00';
                    hoverText[i][j] = vars[i];
                } else if (i < j) {
                    // Upper triangle: Pearson
                    textValues[i][j] = 'P: ' + corr.toFixed(2);
                    hoverText[i][j] = vars[i] + ' vs ' + vars[j] + '<br>Pearson: ' + corr.toFixed(3);
                } else {
                    // Lower triangle: Spearman
                    textValues[i][j] = 'S: ' + corr.toFixed(2);
                    hoverText[i][j] = vars[i] + ' vs ' + vars[j] + '<br>Spearman: ' + corr.toFixed(3);
                }
            }
        }

        // Create heatmap
        const heatmapTrace = {
            z: zValues,
            x: vars,
            y: vars,
            type: 'heatmap',
            colorscale: [
                [0, '#ff0000'],    // -1: red
                [0.5, '#ffffff'],  //  0: white
                [1, '#0000ff']     //  1: blue
            ],
            zmin: -1,
            zmax: 1,
            text: hoverText,
            hovertemplate: '%{text}<extra></extra>',
            colorbar: {
                title: 'Correlation',
                titleside: 'right'
            }
        };

        const heatmapLayout = {
            xaxis: { side: 'bottom', tickangle: -45 },
            yaxis: { autorange: 'reversed' },
            annotations: [],
            margin: { l: 150, r: 50, b: 150, t: 50 }
        };

        // Add text annotations
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                heatmapLayout.annotations.push({
                    x: vars[j],
                    y: vars[i],
                    text: textValues[i][j],
                    showarrow: false,
                    font: {
                        size: 10,
                        color: Math.abs(zValues[i][j]) > 0.5 ? 'white' : 'black'
                    }
                });
            }
        }

        Plotly.newPlot('corrmatrix_stock_advanced', [heatmapTrace], heatmapLayout, {responsive: true});
    }

    function drawDendrogram_stock_advanced(vars, linkageMethod, corrMethod) {
        const dendroDiv = document.getElementById('dendrogram_stock_advanced');
        dendroDiv.style.display = 'block';

        if (vars.length < 2) {
            dendroDiv.innerHTML = '<p style="color: #666;">Select at least 2 variables to see dendrogram</p>';
            return;
        }

        // Get precomputed tree structure from Julia
        const scenario = hasScenarios ? currentScenario : "default";
        const dendroData = dendroOrderings[scenario] && dendroOrderings[scenario][corrMethod] &&
                          dendroOrderings[scenario][corrMethod][linkageMethod];

        if (!dendroData || !dendroData.tree) {
            dendroDiv.innerHTML = '<p style="color: #666;">Dendrogram unavailable for this selection</p>';
            return;
        }

        const tree = dendroData.tree;

        // Filter tree to show only selected variables
        const selectedSet = new Set(vars);
        const varIndexMap = {};
        tree.labels.forEach((label, idx) => {
            varIndexMap[idx + 1] = label;  // 1-indexed
        });

        try {
            // Build dendrogram structure from tree merges
            const shapes = [];
            const positions = {};
            const heights = {};
            let nextPos = 0;
            let maxHeight = 0;

            // First pass: assign positions to leaves in the order they appear
            tree.order.forEach((leafIdx) => {
                const label = tree.labels[leafIdx - 1];  // Convert to 0-indexed
                if (selectedSet.has(label)) {
                    positions[-leafIdx] = nextPos;  // Leaves are negative
                    heights[-leafIdx] = 0;
                    nextPos++;
                }
            });

            const n = nextPos;
            if (n === 0) {
                dendroDiv.innerHTML = '<p style="color: #666;">No selected variables in dendrogram</p>';
                return;
            }

            // Second pass: process merges
            for (let i = 0; i < tree.merges.length; i++) {
                const [left, right] = tree.merges[i];
                const height = tree.heights[i];
                maxHeight = Math.max(maxHeight, height);

                const clusterId = i + 1;  // Clusters are 1-indexed positive

                // Check if either child involves selected variables
                const leftInSelection = positions[left] !== undefined;
                const rightInSelection = positions[right] !== undefined;

                if (!leftInSelection && !rightInSelection) continue;

                if (leftInSelection && rightInSelection) {
                    const leftPos = positions[left];
                    const rightPos = positions[right];
                    const leftHeight = heights[left];
                    const rightHeight = heights[right];
                    const mergePos = (leftPos + rightPos) / 2;

                    positions[clusterId] = mergePos;
                    heights[clusterId] = height;

                    // Draw U-shaped connection (xref/yref must be 'x'/'y' for data coordinates)
                    shapes.push(
                        {type: 'line', xref: 'x', yref: 'y', x0: leftPos, y0: leftHeight, x1: leftPos, y1: height, line: {color: '#636efa', width: 2}},
                        {type: 'line', xref: 'x', yref: 'y', x0: leftPos, y0: height, x1: rightPos, y1: height, line: {color: '#636efa', width: 2}},
                        {type: 'line', xref: 'x', yref: 'y', x0: rightPos, y0: rightHeight, x1: rightPos, y1: height, line: {color: '#636efa', width: 2}}
                    );
                } else if (leftInSelection) {
                    positions[clusterId] = positions[left];
                    heights[clusterId] = height;
                } else {
                    positions[clusterId] = positions[right];
                    heights[clusterId] = height;
                }
            }

            // Get leaf labels in display order
            const leafLabels = [];
            const leafPositions = [];
            for (let i = 0; i < n; i++) {
                leafPositions.push(i);
                // Find which leaf is at this position
                for (const [key, pos] of Object.entries(positions)) {
                    if (pos === i && parseInt(key) < 0) {
                        const leafIdx = -parseInt(key);
                        leafLabels.push(tree.labels[leafIdx - 1]);
                        break;
                    }
                }
            }

            // Draw dendrogram
            const leafTrace = {
                x: leafPositions,
                y: Array(n).fill(0),
                mode: 'text',
                type: 'scatter',
                text: leafLabels,
                textposition: 'bottom center',
                textfont: {size: 10},
                hoverinfo: 'text',
                showlegend: false
            };

            // Ensure minimum y-axis range to prevent dendrogram from being crushed
            const minYRange = 0.1;  // Minimum height range

            // If maxHeight is too small, scale the shapes so dendrogram is visible
            // This happens when all variables are highly correlated
            let scaledShapes = shapes;
            let displayMaxHeight = maxHeight;

            if (maxHeight < minYRange && maxHeight > 0) {
                // Scale factor to make dendrogram fill the visible area
                const scaleFactor = (minYRange * 0.9) / maxHeight;  // 0.9 to leave some margin
                displayMaxHeight = minYRange;

                // Scale all y coordinates in shapes
                scaledShapes = shapes.map(function(shape) {
                    return {
                        type: shape.type,
                        xref: shape.xref,
                        yref: shape.yref,
                        x0: shape.x0,
                        y0: shape.y0 * scaleFactor,
                        x1: shape.x1,
                        y1: shape.y1 * scaleFactor,
                        line: shape.line
                    };
                });

                console.info('Dendrogram heights scaled for visibility (original maxHeight=' + maxHeight.toFixed(6) + ', scale=' + scaleFactor.toFixed(2) + ')');
            } else if (maxHeight === 0 && shapes.length > 0) {
                // All heights are exactly zero - assign arbitrary heights for visibility
                displayMaxHeight = minYRange;
                console.warn('All dendrogram heights are zero. Variables may be perfectly correlated or identical.');
            }

            const yAxisMax = Math.max(displayMaxHeight * 1.15, minYRange);
            const wasScaled = (maxHeight < minYRange && maxHeight > 0);

            // Log warning if original heights were very small
            if (maxHeight < 0.01 && maxHeight > 0) {
                console.warn('Dendrogram heights are very small (maxHeight=' + maxHeight.toFixed(6) + '). This indicates highly correlated variables. Heights have been scaled for visibility.');
            }

            const yAxisTitle = wasScaled ? 'Height (scaled for visibility)' : 'Height';
            const chartTitle = wasScaled
                ? 'Hierarchical Clustering Dendrogram (' + linkageMethod + ' linkage) - Note: Heights scaled due to high correlation'
                : 'Hierarchical Clustering Dendrogram (' + linkageMethod + ' linkage)';

            const dendroLayout = {
                title: chartTitle,
                xaxis: {visible: false, range: [-0.5, n - 0.5]},
                yaxis: {title: yAxisTitle, range: [0, yAxisMax]},
                margin: {l: 80, r: 50, b: 120, t: 50},
                showlegend: false,
                shapes: scaledShapes,
                height: 400
            };

            Plotly.newPlot('dendrogram_stock_advanced', [leafTrace], dendroLayout, {responsive: true});
        } catch (error) {
            console.error('Failed to draw dendrogram:', error);
            dendroDiv.innerHTML = '<p style="color: red;">Error drawing dendrogram</p>';
        }
    }

})();
(function() {
    const scenarios = ["Short-term Returns (Daily)","Long-term Returns (20-day)","Volatility Correlations"];
    const hasScenarios = true;
    let currentScenario = "Short-term Returns (Daily)";
    let selectedVars = ["AAPL","MSFT","GOOGL","AMZN","TSLA","JPM","BAC","GS","JNJ","PFE"];
    let graphData = null;
    let cy = null;
    let nodePositions = {};
    let allVars = [];

    // Color configuration
    const continuousCols = [];
    const discreteCols = ["sector"];
    const colourMap = null;
    const extrapolateColors = false;

    // Tooltip configuration
    const tooltipCols = ["sector"];
    const tooltipDiv = document.getElementById('tooltip_stock_network');

    // Load graph data
    loadDataset('stock_corr_data').then(function(data) {
        graphData = data;
        allVars = [...new Set(data.map(d => d.node1).concat(data.map(d => d.node2)))].sort();

        // Check if data has correlation_method column and populate selector dynamically
        if (data.length > 0) {
            const firstRow = data[0];
            const hasCorrelationMethod = 'correlation_method' in firstRow || firstRow.hasOwnProperty('correlation_method');
            if (hasCorrelationMethod) {
                // Get unique correlation methods from data
                const corrMethods = [...new Set(data.map(row => row.correlation_method).filter(m => m))];

                if (corrMethods.length > 0) {
                    const select = document.getElementById('corr_method_select_stock_network');
                    const container = document.getElementById('corr_method_container_stock_network');

                    if (select && container) {
                        // Clear existing options
                        select.innerHTML = '';

                        // Add options for each correlation method (first one is default)
                        corrMethods.forEach((method, idx) => {
                            const option = document.createElement('option');
                            option.value = method;
                            option.text = method.charAt(0).toUpperCase() + method.slice(1);
                            if (idx === 0) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        // Show the selector
                        container.style.display = 'block';
                    }
                }
            }
        }

        populateVarSelector_stock_network();
        initializeGraph_stock_network();
    }).catch(function(error) {
        console.error('Failed to load graph data:', error);
    });

    function populateVarSelector_stock_network() {
        const select = document.getElementById('var_select_stock_network');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeGraph_stock_network() {
        if (!graphData || graphData.length === 0) {
            console.warn('No graph data loaded');
            return;
        }

        // Initialize Cytoscape
        cy = cytoscape({
            container: document.getElementById('graph_stock_network'),

            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': '#3498db',
                        'label': 'data(label)',
                        'color': '#000',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '10px',
                        'width': '30px',
                        'height': '30px',
                        'opacity': 1.0
                    }
                },
                {
                    selector: 'node.deselected',
                    style: {
                        'opacity': 0.15
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 'data(displayWidth)',
                        'line-color': '#95a5a6',
                        'opacity': 0.6,
                        'curve-style': 'bezier'
                    }
                },
                {
                    selector: 'edge[label]',
                    style: {
                        'label': 'data(label)',
                        'font-size': '8px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555'
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'background-color': '#e74c3c',
                        'line-color': '#e74c3c',
                        'width': '40px',
                        'height': '40px'
                    }
                }
            ],

            layout: {
                name: 'cose'
            }
        });

        // Store initial positions after layout
        cy.on('layoutstop', function() {
            cy.nodes().forEach(node => {
                const pos = node.position();
                nodePositions[node.id()] = {x: pos.x, y: pos.y};
            });
        });

        recalculateGraph_stock_network();

        // Setup aspect ratio control for Cytoscape
        setupGraphAspectRatio_stock_network();

        // Setup tooltips
        setupTooltips_stock_network();
    }

    function setupTooltips_stock_network() {
        if (!cy || !tooltipDiv || tooltipCols.length === 0) return;

        // Show tooltip on mouseover
        cy.on('mouseover', 'node', function(event) {
            const node = event.target;
            const nodeData = node.data();

            // Build tooltip content
            let content = nodeData.label || nodeData.id;

            // Add all tooltip columns
            tooltipCols.forEach(col => {
                if (nodeData[col] !== undefined && nodeData[col] !== null) {
                    const value = nodeData[col];
                    // Format the column name (capitalize first letter, replace underscores)
                    const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');

                    // Format value (handle numbers with reasonable precision)
                    let formattedValue;
                    if (typeof value === 'number') {
                        // If it's a small number (likely a percentage or ratio), show more decimals
                        if (Math.abs(value) < 10) {
                            formattedValue = value.toFixed(2);
                        } else {
                            formattedValue = value.toFixed(1);
                        }
                    } else {
                        formattedValue = value;
                    }

                    content += '\n' + colName + ': ' + formattedValue;
                }
            });

            tooltipDiv.innerHTML = content;
            tooltipDiv.style.display = 'block';
        });

        // Update tooltip position on mousemove
        cy.on('mousemove', 'node', function(event) {
            const container = document.getElementById('graph_stock_network');
            const containerRect = container.getBoundingClientRect();

            tooltipDiv.style.left = (event.originalEvent.pageX - containerRect.left + 15) + 'px';
            tooltipDiv.style.top = (event.originalEvent.pageY - containerRect.top + 15) + 'px';
        });

        // Hide tooltip on mouseout
        cy.on('mouseout', 'node', function(event) {
            tooltipDiv.style.display = 'none';
        });
    }

    function setupGraphAspectRatio_stock_network() {
        const slider = document.getElementById('aspect_ratio_slider_stock_network');
        const label = document.getElementById('aspect_ratio_label_stock_network');
        const graphDiv = document.getElementById('graph_stock_network');

        if (!slider || !label || !graphDiv) return;

        slider.addEventListener('input', function() {
            // Convert from log space to linear space
            const logValue = parseFloat(this.value);
            const aspectRatio = Math.exp(logValue);
            label.textContent = aspectRatio.toFixed(2);

            // Get current width of graph div
            const width = graphDiv.offsetWidth;
            const height = width * aspectRatio;

            // Update graph div height
            graphDiv.style.height = height + 'px';

            // Resize Cytoscape container (without refitting/zooming)
            // This gives more vertical space while keeping current zoom level
            if (cy) {
                cy.resize();
            }
        });

        // Trigger initial sizing
        const initialLogValue = parseFloat(slider.value);
        const initialAspectRatio = Math.exp(initialLogValue);
        label.textContent = initialAspectRatio.toFixed(2);

        const width = graphDiv.offsetWidth;
        const height = width * initialAspectRatio;
        graphDiv.style.height = height + 'px';

        if (cy) {
            cy.resize();
        }
    }

    // Recalculate graph - full rebuild with selected variables
    window.recalculateGraph_stock_network = function() {
        if (!cy || !graphData) return;

        const layoutType = document.getElementById('layout_select_stock_network').value;

        // Update selected variables from selector
        const varSelect = document.getElementById('var_select_stock_network');
        selectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        if (selectedVars.length === 0) {
            console.warn('Select at least one variable');
            return;
        }

        // Clear existing graph
        cy.elements().remove();
        nodePositions = {};  // Clear stored positions for full recalculation

        // Build new graph with only selected variables
        buildGraph_stock_network(selectedVars, layoutType);
    };

    // Update edges when scenario or cutoff changes (keep node positions)
    window.updateEdges_stock_network = function() {
        if (!cy || !graphData) return;

        // Update scenario
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_stock_network');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Remove and rebuild edges (keep nodes)
        cy.edges().remove();
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_stock_network').value);
        const showEdgeLabels = document.getElementById('show_edges_stock_network').checked;

        // Add edges based on current scenario and cutoff
        const edges = getEdgesForScenario_stock_network(currentScenario, selectedVars, cutoffValue, showEdgeLabels);
        cy.add(edges);
    };

    // Update node opacity when variable selection changes
    window.updateNodeOpacity_stock_network = function() {
        if (!cy) return;

        const varSelect = document.getElementById('var_select_stock_network');
        const currentlySelected = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Make deselected nodes translucent
        cy.nodes().forEach(node => {
            if (currentlySelected.includes(node.id())) {
                node.removeClass('deselected');
            } else {
                node.addClass('deselected');
            }
        });
    };

    // Update colors
    window.updateColors_stock_network = function() {
        if (!cy) return;

        const colorBy = document.getElementById('color_select_stock_network').value;

        if (colorBy === 'none') {
            cy.nodes().style('background-color', '#3498db');
        } else {
            // Check if this is a continuous or discrete column
            const isContinuous = continuousCols.includes(colorBy);

            if (isContinuous) {
                // Continuous coloring with gradient interpolation
                applyContinuousColoring_stock_network(colorBy);
            } else {
                // Discrete coloring (existing behavior)
                const uniqueValues = new Set();
                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    if (val) uniqueValues.add(val);
                });

                const colors = generateColors_stock_network(uniqueValues.size);
                const colorMap = {};
                Array.from(uniqueValues).forEach((val, idx) => {
                    colorMap[val] = colors[idx];
                });

                cy.nodes().forEach(node => {
                    const val = node.data(colorBy);
                    const color = val ? (colorMap[val] || '#3498db') : '#3498db';
                    node.style('background-color', color);
                });
            }
        }
    };

    // Update edge labels
    window.updateEdgeLabels_stock_network = function() {
        const showLabels = document.getElementById('show_edges_stock_network').checked;
        cy.edges().forEach(edge => {
            if (showLabels) {
                edge.data('label', edge.data('strength').toFixed(2));
            } else {
                edge.removeData('label');
            }
        });
    };

    // Apply continuous coloring with gradient interpolation
    function applyContinuousColoring_stock_network(colorBy) {
        // Get gradient for this variable
        let gradient = null;
        if (colourMap) {
            // Check if we have per-variable or global gradient
            if (typeof colourMap === 'object' && !Array.isArray(colourMap)) {
                // Check if keys are numbers (global gradient) or strings (per-variable)
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    // Try to parse first key as number
                    if (!isNaN(parseFloat(keys[0]))) {
                        // Global gradient: {-2.5: "#FF9999", ...}
                        gradient = colourMap;
                    } else {
                        // Per-variable: {sharpe_ratio: {-2.5: "#FF9999", ...}, ...}
                        gradient = colourMap[colorBy];
                    }
                }
            }
        }

        if (!gradient) {
            // Default gradient if none specified
            gradient = {
                "-2": "#FF0000",
                "0": "#FFFFFF",
                "2": "#0000FF"
            };
        }

        // Convert gradient object to sorted array of stops
        // Create array of {stop, color} pairs to avoid string conversion issues
        const stopPairs = Object.keys(gradient)
            .map(k => ({stop: parseFloat(k), color: gradient[k]}))
            .sort((a, b) => a.stop - b.stop);
        const stops = stopPairs.map(p => p.stop);
        const stopColors = stopPairs.map(p => p.color);

        // Get all values to determine range
        const values = [];
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                values.push(val);
            }
        });

        if (values.length === 0) {
            console.warn('No numeric values found for column:', colorBy);
            return;
        }

        // Log gradient info for debugging
        console.log('Applying continuous coloring for:', colorBy);
        console.log('Gradient stops:', stops);
        console.log('Gradient colors:', stopColors);
        console.log('Extrapolate colors:', extrapolateColors);
        console.log('Value range:', Math.min(...values), 'to', Math.max(...values));

        // Apply colors
        cy.nodes().forEach(node => {
            const val = node.data(colorBy);
            if (typeof val === 'number' && !isNaN(val)) {
                const color = interpolateColor_stock_network(val, stops, stopColors);
                node.style('background-color', color);
            } else {
                node.style('background-color', '#CCCCCC');  // Gray for missing values
            }
        });
    }

    // Interpolate color based on value and gradient stops
    function interpolateColor_stock_network(value, stops, colors) {
        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                // Clamp to minimum color (default behavior)
                console.log('Clamping value', value, 'to min stop', stops[0], '=> color', colors[0]);
                return colors[0];
            } else {
                // Extrapolate below minimum using first gradient segment
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_stock_network(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                // Clamp to maximum color (default behavior)
                console.log('Clamping value', value, 'to max stop', stops[stops.length - 1], '=> color', colors[colors.length - 1]);
                return colors[colors.length - 1];
            } else {
                // Extrapolate above maximum using last gradient segment
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_stock_network(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_stock_network(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_stock_network(color1, color2, t) {
        // Parse hex colors
        const c1 = parseHexColor_stock_network(color1);
        const c2 = parseHexColor_stock_network(color2);

        // Interpolate each channel
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        // Convert back to hex
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_stock_network(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }

    function buildGraph_stock_network(varsToShow, layoutType) {
        const cutoffValue = parseFloat(document.getElementById('cutoff_slider_stock_network').value);
        const showEdgeLabels = document.getElementById('show_edges_stock_network').checked;

        const colorBy = document.getElementById('color_select_stock_network').value;

        // Collect all nodes and their attributes
        const nodeSet = new Set();
        const nodeAttributes = {};

        graphData.forEach(row => {
            if (!row.node1 || !row.node2) return;
            if (!varsToShow.includes(row.node1) || !varsToShow.includes(row.node2)) return;

            nodeSet.add(row.node1);
            nodeSet.add(row.node2);

            if (!nodeAttributes[row.node1]) nodeAttributes[row.node1] = {};
            if (!nodeAttributes[row.node2]) nodeAttributes[row.node2] = {};

            Object.keys(row).forEach(key => {
                if (key !== 'node1' && key !== 'node2' && key !== 'strength' && key !== 'scenario') {
                    nodeAttributes[row.node1][key] = row[key];
                    nodeAttributes[row.node2][key] = row[key];
                }
            });
        });

        // Create color mapping
        let colorMap = {};
        if (colorBy !== 'none') {
            const uniqueValues = new Set();
            Object.values(nodeAttributes).forEach(attrs => {
                if (attrs[colorBy]) uniqueValues.add(attrs[colorBy]);
            });
            const colors = generateColors_stock_network(uniqueValues.size);
            Array.from(uniqueValues).forEach((val, idx) => {
                colorMap[val] = colors[idx];
            });
        }

        // Add nodes
        Array.from(nodeSet).forEach(nodeName => {
            const attrs = nodeAttributes[nodeName] || {};
            const colorValue = (colorBy !== 'none' && attrs[colorBy]) ? attrs[colorBy] : null;
            const nodeColor = colorValue ? (colorMap[colorValue] || '#3498db') : '#3498db';

            const nodeData = {
                id: nodeName,
                label: nodeName,
                color: nodeColor,
                ...attrs
            };

            // Use stored position if available
            if (nodePositions[nodeName]) {
                cy.add({
                    data: nodeData,
                    position: nodePositions[nodeName]
                });
            } else {
                cy.add({data: nodeData});
            }
        });

        // Add edges
        const edges = getEdgesForScenario_stock_network(currentScenario, varsToShow, cutoffValue, showEdgeLabels);
        cy.add(edges);

        // Apply colors
        if (colorBy !== 'none') {
            const isContinuous = continuousCols.includes(colorBy);
            if (isContinuous) {
                // Use continuous coloring
                applyContinuousColoring_stock_network(colorBy);
            } else {
                // Use discrete coloring
                cy.nodes().forEach(node => {
                    node.style('background-color', node.data('color'));
                });
            }
        }

        // Apply layout only if no positions stored
        const hasStoredPositions = Array.from(nodeSet).every(n => nodePositions[n]);
        if (!hasStoredPositions) {
            cy.layout({
                name: layoutType,
                animate: true,
                animationDuration: 500,
                fit: true,
                padding: 30
            }).run();
        }
    }

    function getEdgesForScenario_stock_network(scenario, varsToShow, cutoffValue, showEdgeLabels) {
        const edges = [];

        // Get selected correlation method (if selector exists)
        const corrMethodSelect = document.getElementById('corr_method_select_stock_network');
        const selectedCorrMethod = corrMethodSelect ? corrMethodSelect.value : null;

        const scenarioData = graphData.filter(row => {
            // Basic filters
            const scenarioMatch = !hasScenarios || !row.scenario || row.scenario === scenario;
            const nodeMatch = varsToShow.includes(row.node1) && varsToShow.includes(row.node2);

            // Correlation method filter (only if data has this column AND selector exists)
            const corrMethodMatch = !selectedCorrMethod || !row.correlation_method || row.correlation_method === selectedCorrMethod;

            return scenarioMatch && nodeMatch && corrMethodMatch;
        });

        scenarioData.forEach((row, idx) => {
            let strength = row.strength;
            // For correlation data, convert to distance
            let distance = 1 - Math.abs(strength);

            if (distance <= cutoffValue) {
                const edgeWidth = Math.abs(strength) * 5 + 1;

                const edgeData = {
                    id: 'edge_' + scenario + '_' + idx,
                    source: row.node1,
                    target: row.node2,
                    strength: strength,
                    displayWidth: edgeWidth
                };

                if (showEdgeLabels) {
                    edgeData.label = strength.toFixed(2);
                }

                edges.push({data: edgeData});
            }
        });

        return edges;
    }

    function generateColors_stock_network(n) {
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400',
            '#c0392b', '#2980b9', '#27ae60', '#8e44ad', '#16a085'
        ];

        if (n <= colors.length) return colors.slice(0, n);

        const result = [...colors];
        for (let i = colors.length; i < n; i++) {
            const hue = (i * 137.508) % 360;
            result.push(`hsl(${hue}, 70%, 50%)`);
        }
        return result;
    }
})();
(function() {
    // Configuration
    const ENTITY_COL = 'stock';
    const LABEL_COL = 'stock';
    const ALL_NUMERIC_COLS = ["mean_return","volatility","max_drawdown","best_day","skewness","kurtosis"];
    const INITIAL_FEATURE_COLS = ["mean_return","volatility","max_drawdown","best_day","skewness","kurtosis"];
    const IS_DISTANCE_MATRIX = false;
    const COLOR_COLS = ["sector"];
    const TOOLTIP_COLS = ["sector","mean_return","volatility"];
    const INITIAL_PERPLEXITY = 5.0;
    const INITIAL_LEARNING_RATE = 200.0;

    // Color configuration for continuous support
    const continuousCols = [];
    const discreteCols = ["sector"];
    const colourMap = null;
    const extrapolateColors = false;

    // State
    let rawData = null;
    let entities = [];
    let entityMap = {};
    let distanceMatrix = null;
    let selectedFeatures = [...INITIAL_FEATURE_COLS];
    let positions = [];
    let velocities = [];
    let gains = [];  // For adaptive learning rate
    let iteration = 0;
    let isRunning = false;
    let animationFrameId = null;
    let lastTotalMovement = 0;
    let cachedP = null;
    let lastPerplexity = null;

    // Current transform state (for drag coordinate conversion)
    let currentTransform = { scale: 1, centerX: 0, centerY: 0 };

    // Pan offset (in embedding coordinates)
    let panOffsetX = 0;
    let panOffsetY = 0;

    // Zoom factor (for manual zoom control)
    let zoomFactor = 1.0;

    // SVG elements
    let svg = null;
    let width = 800;
    let height = 600;
    const margin = { top: 20, right: 20, bottom: 20, left: 20 };
    const nodeRadius = 8;

    // Tooltip - get dynamically to ensure DOM is ready
    function getTooltipDiv() {
        return document.getElementById('tooltip_stock_tsne');
    }

    // Load data
    loadDataset('tsne_stock_data').then(function(data) {
        rawData = data;
        initializeVisualization();
    }).catch(function(error) {
        console.error('Failed to load t-SNE data:', error);
    });

    function initializeVisualization() {
        // Extract entities
        if (IS_DISTANCE_MATRIX) {
            const entitySet = new Set();
            rawData.forEach(function(row) {
                entitySet.add(row.node1);
                entitySet.add(row.node2);
            });
            entities = Array.from(entitySet).sort();
        } else {
            entities = [];
            const seen = new Set();
            rawData.forEach(function(row) {
                const e = row[ENTITY_COL];
                if (!seen.has(e)) {
                    seen.add(e);
                    entities.push(e);
                }
            });
        }

        // Build entity to index map
        entities.forEach(function(e, i) {
            entityMap[e] = i;
        });

        // Initialize feature selection UI
        if (!IS_DISTANCE_MATRIX) {
            populateFeatureSelectors();
        }

        // Build distance matrix
        buildDistanceMatrix();

        // Initialize random positions
        randomizePositions_stock_tsne();

        // Create SVG
        createSVG();

        // Setup aspect ratio control
        setupAspectRatio();

        // Initial render
        render();
    }

    function populateFeatureSelectors() {
        const availableSelect = document.getElementById('available_features_stock_tsne');
        const selectedSelect = document.getElementById('selected_features_stock_tsne');

        if (!availableSelect || !selectedSelect) return;

        availableSelect.innerHTML = '';
        selectedSelect.innerHTML = '';

        ALL_NUMERIC_COLS.forEach(function(col) {
            const option = document.createElement('option');
            option.value = col;
            option.text = col;
            if (selectedFeatures.includes(col)) {
                selectedSelect.appendChild(option);
            } else {
                availableSelect.appendChild(option);
            }
        });
    }

    window.addFeature_stock_tsne = function() {
        const availableSelect = document.getElementById('available_features_stock_tsne');
        const selectedSelect = document.getElementById('selected_features_stock_tsne');
        const selected = Array.from(availableSelect.selectedOptions);
        selected.forEach(function(opt) {
            selectedSelect.appendChild(opt);
            if (!selectedFeatures.includes(opt.value)) {
                selectedFeatures.push(opt.value);
            }
        });
    };

    window.removeFeature_stock_tsne = function() {
        const availableSelect = document.getElementById('available_features_stock_tsne');
        const selectedSelect = document.getElementById('selected_features_stock_tsne');
        const selected = Array.from(selectedSelect.selectedOptions);
        selected.forEach(function(opt) {
            availableSelect.appendChild(opt);
            const idx = selectedFeatures.indexOf(opt.value);
            if (idx > -1) selectedFeatures.splice(idx, 1);
        });
    };

    window.recalculateDistances_stock_tsne = function() {
        if (selectedFeatures.length === 0) {
            alert('Please select at least one feature');
            return;
        }
        // Stop any running optimization
        if (isRunning) {
            toggleRun_stock_tsne();
        }
        // Rebuild distance matrix with new features
        buildDistanceMatrix();
        // Reset positions and state
        cachedP = null;
        randomizePositions_stock_tsne();
        render();
        updateStatus('Distances recalculated - ready');
    };

    function buildDistanceMatrix() {
        const n = entities.length;
        distanceMatrix = [];
        for (let i = 0; i < n; i++) {
            distanceMatrix[i] = [];
            for (let j = 0; j < n; j++) {
                distanceMatrix[i][j] = 0;
            }
        }

        if (IS_DISTANCE_MATRIX) {
            rawData.forEach(function(row) {
                const i = entityMap[row.node1];
                const j = entityMap[row.node2];
                if (i !== undefined && j !== undefined) {
                    distanceMatrix[i][j] = row.distance;
                    distanceMatrix[j][i] = row.distance;
                }
            });
        } else {
            // Get rescaling method
            const rescalingSelect = document.getElementById('rescaling_stock_tsne');
            const rescaling = rescalingSelect ? rescalingSelect.value : 'zscore';

            // Build feature vectors
            const featureVectors = {};
            rawData.forEach(function(row) {
                const entity = row[ENTITY_COL];
                if (!featureVectors[entity]) {
                    const vec = selectedFeatures.map(function(col) {
                        const val = row[col];
                        return typeof val === 'number' && !isNaN(val) ? val : 0;
                    });
                    featureVectors[entity] = vec;
                }
            });

            // Apply rescaling per feature
            if (selectedFeatures.length > 0 && rescaling !== 'none') {
                selectedFeatures.forEach(function(col, colIdx) {
                    const values = entities.map(function(e) {
                        return featureVectors[e] ? featureVectors[e][colIdx] : 0;
                    });

                    if (rescaling === 'zscore' || rescaling === 'zscore_capped') {
                        // Z-score normalization
                        const mean = values.reduce(function(a, b) { return a + b; }, 0) / values.length;
                        const variance = values.reduce(function(a, b) { return a + (b - mean) * (b - mean); }, 0) / values.length;
                        const std = Math.sqrt(variance) || 1;

                        entities.forEach(function(entity) {
                            if (featureVectors[entity]) {
                                let zval = (featureVectors[entity][colIdx] - mean) / std;
                                if (rescaling === 'zscore_capped') {
                                    zval = Math.max(-2, Math.min(2, zval));
                                }
                                featureVectors[entity][colIdx] = zval;
                            }
                        });
                    } else if (rescaling === 'quantile') {
                        // Quantile scaling: min=0, median=0.5, max=1
                        const sorted = values.slice().sort(function(a, b) { return a - b; });
                        const rankMap = {};
                        sorted.forEach(function(val, rank) {
                            if (!(val in rankMap)) {
                                rankMap[val] = rank;
                            }
                        });
                        const maxRank = sorted.length - 1;

                        entities.forEach(function(entity) {
                            if (featureVectors[entity]) {
                                const val = featureVectors[entity][colIdx];
                                const rank = rankMap[val] || 0;
                                featureVectors[entity][colIdx] = maxRank > 0 ? rank / maxRank : 0.5;
                            }
                        });
                    }
                });
            }

            // Calculate Euclidean distances
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const v1 = featureVectors[entities[i]] || [];
                    const v2 = featureVectors[entities[j]] || [];
                    let dist = 0;
                    const len = Math.max(v1.length, v2.length);
                    for (let k = 0; k < len; k++) {
                        const a = v1[k] || 0;
                        const b = v2[k] || 0;
                        dist += (a - b) * (a - b);
                    }
                    dist = Math.sqrt(dist);
                    distanceMatrix[i][j] = dist;
                    distanceMatrix[j][i] = dist;
                }
            }
        }
    }

    function createSVG() {
        const container = document.getElementById('tsne_canvas_stock_tsne');
        width = container.offsetWidth || 800;
        height = width * 0.6;
        container.style.height = height + 'px';
        container.innerHTML = '';

        svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height);

        // Add background rect for pan events
        svg.append('rect')
            .attr('class', 'tsne-background-stock_tsne')
            .attr('width', width)
            .attr('height', height)
            .attr('fill', 'transparent')
            .style('cursor', 'move')
            .call(d3.behavior.drag()
                .on('dragstart', panStarted)
                .on('drag', panning)
                .on('dragend', panEnded));

        // D3 v3 drag behavior for nodes
        const drag = d3.behavior.drag()
            .origin(function(d) { return d; })
            .on('dragstart', dragStarted)
            .on('drag', dragged)
            .on('dragend', dragEnded);

        window.tsneDrag_stock_tsne = drag;
    }

    // Pan handlers
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;

    function panStarted() {
        isPanning = true;
        panStartX = d3.event.x;
        panStartY = d3.event.y;
        d3.event.sourceEvent.stopPropagation();
    }

    function panning() {
        if (!isPanning) return;
        const dx = d3.event.x - panStartX;
        const dy = d3.event.y - panStartY;
        // Convert screen delta to embedding delta
        panOffsetX -= dx / currentTransform.scale;
        panOffsetY -= dy / currentTransform.scale;
        panStartX = d3.event.x;
        panStartY = d3.event.y;
        render();
    }

    function panEnded() {
        isPanning = false;
    }

    function dragStarted(d) {
        if (isRunning) {
            toggleRun_stock_tsne();
        }
        d3.select(this).classed('dragging', true);
    }

    function dragged(d) {
        const idx = entityMap[d.entity];
        // Convert screen coordinates back to embedding coordinates
        const screenX = d3.event.x;
        const screenY = d3.event.y;
        const embeddingX = currentTransform.centerX + (screenX - width / 2) / currentTransform.scale;
        const embeddingY = currentTransform.centerY + (screenY - height / 2) / currentTransform.scale;

        positions[idx].x = embeddingX;
        positions[idx].y = embeddingY;
        // Reset velocity when manually moved
        velocities[idx].x = 0;
        velocities[idx].y = 0;

        render();
    }

    function dragEnded(d) {
        d3.select(this).classed('dragging', false);
    }

    function setupAspectRatio() {
        const aspectSlider = document.getElementById('aspect_ratio_slider_stock_tsne');
        const aspectLabel = document.getElementById('aspect_ratio_label_stock_tsne');
        const zoomSlider = document.getElementById('zoom_slider_stock_tsne');
        const zoomLabel = document.getElementById('zoom_label_stock_tsne');
        const container = document.getElementById('tsne_canvas_stock_tsne');

        if (!aspectSlider || !aspectLabel || !container) return;

        // Aspect ratio slider - changes viewport height/width ratio
        aspectSlider.addEventListener('input', function() {
            const aspectRatio = parseFloat(this.value);
            aspectLabel.textContent = aspectRatio.toFixed(2);

            width = container.offsetWidth;
            height = width * aspectRatio;
            container.style.height = height + 'px';

            if (svg) {
                svg.attr('width', width).attr('height', height);
                // Update background rect size
                svg.select('.tsne-background-stock_tsne')
                    .attr('width', width)
                    .attr('height', height);
                render();
            }
        });

        // Zoom slider - changes how much of the embedding is visible
        if (zoomSlider && zoomLabel) {
            zoomSlider.addEventListener('input', function() {
                zoomFactor = parseFloat(this.value);
                zoomLabel.textContent = zoomFactor.toFixed(1);
                render();
            });
        }

        // Initialize aspect ratio
        const initialAspectRatio = parseFloat(aspectSlider.value);
        aspectLabel.textContent = initialAspectRatio.toFixed(2);
        height = width * initialAspectRatio;
        container.style.height = height + 'px';
    }

    // t-SNE algorithm with proper scaling
    function computeGaussianPerplexity(distances, targetPerplexity) {
        const n = distances.length;
        const P = [];
        for (let i = 0; i < n; i++) {
            P[i] = [];
            for (let j = 0; j < n; j++) {
                P[i][j] = 0;
            }
        }
        const logPerp = Math.log(targetPerplexity);

        for (let i = 0; i < n; i++) {
            let betaMin = -Infinity;
            let betaMax = Infinity;
            let beta = 1.0;

            for (let iter = 0; iter < 50; iter++) {
                let sum = 0;
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        P[i][j] = Math.exp(-distances[i][j] * distances[i][j] * beta);
                        sum += P[i][j];
                    }
                }

                if (sum > 0) {
                    for (let j = 0; j < n; j++) {
                        P[i][j] /= sum;
                    }
                }

                let H = 0;
                for (let j = 0; j < n; j++) {
                    if (P[i][j] > 1e-7) {
                        H -= P[i][j] * Math.log(P[i][j]);
                    }
                }

                const diff = H - logPerp;
                if (Math.abs(diff) < 1e-5) break;

                if (diff > 0) {
                    betaMin = beta;
                    beta = betaMax === Infinity ? beta * 2 : (beta + betaMax) / 2;
                } else {
                    betaMax = beta;
                    beta = betaMin === -Infinity ? beta / 2 : (beta + betaMin) / 2;
                }
            }
        }

        // Symmetrize
        const P_sym = [];
        for (let i = 0; i < n; i++) {
            P_sym[i] = [];
            for (let j = 0; j < n; j++) {
                P_sym[i][j] = (P[i][j] + P[j][i]) / (2 * n);
            }
        }

        return P_sym;
    }

    function getExaggerationFactor() {
        const input = document.getElementById('exag_factor_stock_tsne');
        return input ? parseFloat(input.value) || 4.0 : 4.0;
    }

    function getExaggerationIters() {
        const input = document.getElementById('exag_iters_stock_tsne');
        return input ? parseInt(input.value) || 100 : 100;
    }

    function tsneStep(P, learningRate, useExaggeration) {
        const n = positions.length;
        const exaggeration = useExaggeration ? getExaggerationFactor() : 1.0;

        // Compute Q matrix (Student-t distribution)
        let Qsum = 0;
        const Qnum = [];
        for (let i = 0; i < n; i++) {
            Qnum[i] = [];
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    const dx = positions[i].x - positions[j].x;
                    const dy = positions[i].y - positions[j].y;
                    const dist2 = dx * dx + dy * dy;
                    Qnum[i][j] = 1 / (1 + dist2);
                    Qsum += Qnum[i][j];
                } else {
                    Qnum[i][j] = 0;
                }
            }
        }

        // Compute gradients
        const gradients = [];
        for (let i = 0; i < n; i++) {
            gradients[i] = { x: 0, y: 0 };
        }

        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    const Q_ij = Qnum[i][j] / Qsum;
                    const P_ij = P[i][j] * exaggeration;
                    const dx = positions[i].x - positions[j].x;
                    const dy = positions[i].y - positions[j].y;
                    const mult = (P_ij - Q_ij) * Qnum[i][j];
                    gradients[i].x += 4 * mult * dx;
                    gradients[i].y += 4 * mult * dy;
                }
            }
        }

        // Update with momentum and adaptive gains
        const momentum = iteration < 250 ? 0.5 : 0.8;
        let totalMovement = 0;

        for (let i = 0; i < n; i++) {
            // Update gains (for adaptive learning rate)
            const gx = gradients[i].x;
            const gy = gradients[i].y;
            gains[i].x = (Math.sign(gx) === Math.sign(velocities[i].x)) ? gains[i].x * 0.8 : gains[i].x + 0.2;
            gains[i].y = (Math.sign(gy) === Math.sign(velocities[i].y)) ? gains[i].y * 0.8 : gains[i].y + 0.2;
            gains[i].x = Math.max(gains[i].x, 0.01);
            gains[i].y = Math.max(gains[i].y, 0.01);

            // Velocity update
            velocities[i].x = momentum * velocities[i].x - learningRate * gains[i].x * gx;
            velocities[i].y = momentum * velocities[i].y - learningRate * gains[i].y * gy;

            // Position update
            positions[i].x += velocities[i].x;
            positions[i].y += velocities[i].y;

            totalMovement += Math.sqrt(velocities[i].x * velocities[i].x + velocities[i].y * velocities[i].y);
        }

        return totalMovement;
    }

    // Global functions
    window.randomizePositions_stock_tsne = function() {
        const n = entities.length;
        positions = [];
        velocities = [];
        gains = [];

        // Initialize in a small region centered at origin
        const scale = 0.0001;
        for (let i = 0; i < n; i++) {
            positions.push({
                x: (Math.random() - 0.5) * scale,
                y: (Math.random() - 0.5) * scale
            });
            velocities.push({ x: 0, y: 0 });
            gains.push({ x: 1, y: 1 });
        }

        iteration = 0;
        lastTotalMovement = 0;
        cachedP = null;
        // Reset pan offset
        panOffsetX = 0;
        panOffsetY = 0;
        updateStatus('Ready');
        updateIterationDisplay();

        if (svg) render();
    };

    window.stepIteration_stock_tsne = function(forceExaggeration) {
        if (!distanceMatrix) return;

        const perplexity = parseFloat(document.getElementById('perplexity_slider_stock_tsne').value);
        const learningRate = parseFloat(document.getElementById('lr_slider_stock_tsne').value);

        // Cache P matrix if perplexity hasn't changed
        if (!cachedP || lastPerplexity !== perplexity) {
            cachedP = computeGaussianPerplexity(distanceMatrix, perplexity);
            lastPerplexity = perplexity;
        }

        // forceExaggeration: true = always exaggerate, false = never exaggerate
        const useExaggeration = forceExaggeration === true;
        lastTotalMovement = tsneStep(cachedP, learningRate, useExaggeration);
        iteration++;

        updateIterationDisplay();
        render();
    };

    window.toggleRun_stock_tsne = function() {
        if (isRunning) {
            isRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            document.getElementById('run_btn_stock_tsne').textContent = 'Run to Convergence';
            updateStatus('Stopped');
        } else {
            isRunning = true;
            document.getElementById('run_btn_stock_tsne').textContent = 'Stop';
            updateStatus('Running...');
            runLoop();
        }
    };

    function runLoop() {
        if (!isRunning) return;

        const perplexity = parseFloat(document.getElementById('perplexity_slider_stock_tsne').value);
        const learningRate = parseFloat(document.getElementById('lr_slider_stock_tsne').value);
        const convergenceThreshold = parseFloat(document.getElementById('convergence_stock_tsne').value);
        const maxIter = parseInt(document.getElementById('max_iter_stock_tsne').value);
        const exagIters = getExaggerationIters();

        if (!cachedP || lastPerplexity !== perplexity) {
            cachedP = computeGaussianPerplexity(distanceMatrix, perplexity);
            lastPerplexity = perplexity;
        }

        const useExaggeration = iteration < exagIters;
        lastTotalMovement = tsneStep(cachedP, learningRate, useExaggeration);
        iteration++;

        updateIterationDisplay();
        render();

        if (iteration > exagIters && lastTotalMovement < convergenceThreshold) {
            isRunning = false;
            document.getElementById('run_btn_stock_tsne').textContent = 'Run to Convergence';
            updateStatus('Converged!');
            return;
        }

        if (iteration >= maxIter) {
            isRunning = false;
            document.getElementById('run_btn_stock_tsne').textContent = 'Run to Convergence';
            updateStatus('Max iterations reached');
            return;
        }

        animationFrameId = requestAnimationFrame(runLoop);
    }

    window.updateColors_stock_tsne = function() {
        render();
    };

    function updateIterationDisplay() {
        document.getElementById('iteration_stock_tsne').textContent = iteration;
        document.getElementById('distance_stock_tsne').textContent = lastTotalMovement.toFixed(4);

        const exaggerationStatus = document.getElementById('exaggeration_status_stock_tsne');
        const exagIters = getExaggerationIters();
        if (exaggerationStatus) {
            if (iteration < exagIters) {
                exaggerationStatus.textContent = '(Early Exaggeration: ' + (exagIters - iteration) + ' iters remaining)';
            } else {
                exaggerationStatus.textContent = '';
            }
        }
    }

    function updateStatus(status) {
        document.getElementById('status_stock_tsne').textContent = status;
    }

    function render() {
        if (!svg || !positions || positions.length === 0) return;
        if (width <= 0 || height <= 0) return;

        // Find bounds and scale to fit canvas
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        positions.forEach(function(p) {
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
        });

        // Handle case where all points are at the same location
        let rangeX = maxX - minX;
        let rangeY = maxY - minY;
        if (rangeX < 1e-10) rangeX = 1;
        if (rangeY < 1e-10) rangeY = 1;

        const innerWidth = Math.max(1, width - margin.left - margin.right - 2 * nodeRadius);
        const innerHeight = Math.max(1, height - margin.top - margin.bottom - 2 * nodeRadius);

        // Base scale fits all points, zoom factor adjusts how much is visible
        const baseScale = Math.min(innerWidth / rangeX, innerHeight / rangeY) * 0.9;
        const currentZoom = zoomFactor || 1.0;
        const scale = isFinite(baseScale) ? baseScale * currentZoom : 1;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // Apply pan offset to center (ensure panOffset is valid)
        const validPanX = isFinite(panOffsetX) ? panOffsetX : 0;
        const validPanY = isFinite(panOffsetY) ? panOffsetY : 0;
        const viewCenterX = centerX + validPanX;
        const viewCenterY = centerY + validPanY;

        // Save transform for drag coordinate conversion
        currentTransform.scale = scale;
        currentTransform.centerX = viewCenterX;
        currentTransform.centerY = viewCenterY;

        function toScreenX(x) {
            return width / 2 + (x - viewCenterX) * scale;
        }
        function toScreenY(y) {
            return height / 2 + (y - viewCenterY) * scale;
        }

        // Get current color column
        const colorSelect = document.getElementById('color_select_stock_tsne');
        const colorBy = colorSelect ? colorSelect.value : 'none';

        // Check if this is a continuous or discrete column
        const isContinuous = continuousCols.includes(colorBy);

        // Build color map for discrete coloring
        const colorPalette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                              '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
        let colorMap = {};
        if (colorBy !== 'none' && !IS_DISTANCE_MATRIX && !isContinuous) {
            const uniqueValues = [];
            const seen = new Set();
            rawData.forEach(function(row) {
                const v = row[colorBy];
                if (!seen.has(v)) {
                    seen.add(v);
                    uniqueValues.push(v);
                }
            });
            uniqueValues.forEach(function(val, idx) {
                colorMap[val] = colorPalette[idx % colorPalette.length];
            });
        }

        // Build continuous color scale if needed
        let continuousColorScale = null;
        if (colorBy !== 'none' && isContinuous && !IS_DISTANCE_MATRIX) {
            // Get gradient for this variable
            let gradient = null;
            if (colourMap) {
                const keys = Object.keys(colourMap);
                if (keys.length > 0) {
                    if (!isNaN(parseFloat(keys[0]))) {
                        gradient = colourMap;
                    } else {
                        gradient = colourMap[colorBy];
                    }
                }
            }
            if (!gradient) {
                gradient = { "-2": "#FF0000", "0": "#FFFFFF", "2": "#0000FF" };
            }
            continuousColorScale = { gradient: gradient };
        }

        // Get entity data
        const entityData = {};
        if (!IS_DISTANCE_MATRIX) {
            rawData.forEach(function(row) {
                const entity = row[ENTITY_COL];
                if (!entityData[entity]) {
                    entityData[entity] = row;
                }
            });
        }

        // Prepare node data
        const nodeData = entities.map(function(entity, idx) {
            let nodeColor = '#3498db';
            if (colorBy !== 'none' && entityData[entity]) {
                const colorValue = entityData[entity][colorBy];
                if (isContinuous && continuousColorScale) {
                    // Use continuous color interpolation
                    if (typeof colorValue === 'number' && !isNaN(colorValue)) {
                        nodeColor = interpolateColor_stock_tsne(colorValue, continuousColorScale.gradient);
                    } else {
                        nodeColor = '#CCCCCC';  // Gray for missing values
                    }
                } else {
                    // Use discrete color map
                    nodeColor = colorMap[colorValue] || '#3498db';
                }
            }
            return {
                entity: entity,
                label: IS_DISTANCE_MATRIX ? entity : (entityData[entity] ? entityData[entity][LABEL_COL] : entity) || entity,
                x: toScreenX(positions[idx].x),
                y: toScreenY(positions[idx].y),
                color: nodeColor,
                data: entityData[entity] || {}
            };
        });

        // Update nodes (D3 v3 pattern)
        const nodes = svg.selectAll('.tsne-node-stock_tsne')
            .data(nodeData, function(d) { return d.entity; });

        nodes.exit().remove();

        nodes.enter()
            .append('circle')
            .attr('class', 'tsne-node-stock_tsne')
            .attr('r', nodeRadius)
            .call(window.tsneDrag_stock_tsne)
            .on('mouseover', function(d) { showTooltip(d); })
            .on('mousemove', function(d) { moveTooltip(); })
            .on('mouseout', function() { hideTooltip(); });

        svg.selectAll('.tsne-node-stock_tsne')
            .attr('cx', function(d) { return d.x; })
            .attr('cy', function(d) { return d.y; })
            .attr('fill', function(d) { return d.color; });

        // Update labels
        const labels = svg.selectAll('.tsne-label-stock_tsne')
            .data(nodeData, function(d) { return d.entity; });

        labels.exit().remove();

        labels.enter()
            .append('text')
            .attr('class', 'tsne-label-stock_tsne');

        svg.selectAll('.tsne-label-stock_tsne')
            .attr('x', function(d) { return d.x + nodeRadius + 3; })
            .attr('y', function(d) { return d.y + 3; })
            .text(function(d) { return d.label; });
    }

    function showTooltip(d) {
        const tooltipDiv = getTooltipDiv();
        if (!tooltipDiv) return;

        let content = '<strong>' + d.label + '</strong>';

        TOOLTIP_COLS.forEach(function(col) {
            const val = d.data[col];
            if (val !== undefined && val !== null) {
                const colName = col.charAt(0).toUpperCase() + col.slice(1).replace(/_/g, ' ');
                let formattedValue;
                if (typeof val === 'number') {
                    formattedValue = Math.abs(val) < 10 ? val.toFixed(2) : val.toFixed(1);
                } else {
                    formattedValue = val;
                }
                content += '<br>' + colName + ': ' + formattedValue;
            }
        });

        tooltipDiv.innerHTML = content;
        tooltipDiv.style.display = 'block';
        moveTooltip();
    }

    function moveTooltip() {
        const tooltipDiv = getTooltipDiv();
        if (!tooltipDiv) return;

        const event = d3.event;
        if (!event) return;

        // Use clientX/clientY with position:fixed for accurate positioning
        tooltipDiv.style.left = (event.clientX + 15) + 'px';
        tooltipDiv.style.top = (event.clientY + 15) + 'px';
    }

    function hideTooltip() {
        const tooltipDiv = getTooltipDiv();
        if (tooltipDiv) {
            tooltipDiv.style.display = 'none';
        }
    }

    // Color interpolation functions for continuous coloring
    function interpolateColor_stock_tsne(value, gradient) {
        // Convert gradient object to sorted array of stops
        const stopPairs = Object.keys(gradient)
            .map(function(k) { return { stop: parseFloat(k), color: gradient[k] }; })
            .sort(function(a, b) { return a.stop - b.stop; });
        const stops = stopPairs.map(function(p) { return p.stop; });
        const colors = stopPairs.map(function(p) { return p.color; });

        // Handle values below minimum stop
        if (value < stops[0]) {
            if (!extrapolateColors) {
                return colors[0];
            } else {
                if (stops.length > 1) {
                    const t = (value - stops[0]) / (stops[1] - stops[0]);
                    return interpolateBetweenColors_stock_tsne(colors[0], colors[1], t);
                }
                return colors[0];
            }
        }

        // Handle values above maximum stop
        if (value > stops[stops.length - 1]) {
            if (!extrapolateColors) {
                return colors[colors.length - 1];
            } else {
                if (stops.length > 1) {
                    const n = stops.length - 1;
                    const t = (value - stops[n]) / (stops[n] - stops[n - 1]);
                    return interpolateBetweenColors_stock_tsne(colors[n], colors[n - 1], -t);
                }
                return colors[colors.length - 1];
            }
        }

        // Find surrounding stops for values within range
        for (let i = 0; i < stops.length - 1; i++) {
            if (value >= stops[i] && value <= stops[i + 1]) {
                const t = (value - stops[i]) / (stops[i + 1] - stops[i]);
                return interpolateBetweenColors_stock_tsne(colors[i], colors[i + 1], t);
            }
        }

        return colors[0];  // Fallback
    }

    // Linear interpolation between two hex colors
    function interpolateBetweenColors_stock_tsne(color1, color2, t) {
        const c1 = parseHexColor_stock_tsne(color1);
        const c2 = parseHexColor_stock_tsne(color2);

        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);

        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Parse hex color to RGB
    function parseHexColor_stock_tsne(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }
})();
(function() {
// Filter configuration
const CATEGORICAL_FILTERS = ['market_regime'];
const CONTINUOUS_FILTERS = [];
const CHOICE_FILTERS = [];

// Settings
const GRID_SIZE = 25;
const MIN_WEIGHT = 0.05;
const COLORSCALE = 'RdBu';
const BOOTSTRAP_ITERATIONS = 200;
const DEFAULT_BANDWIDTH = 0.015;

// Cache for bootstrap results (keyed by data hash)
let bootstrapCache_stock_lgc = null;
let lastDataHash_stock_lgc = null;

const getCol = (id, def) => { const el = document.getElementById(id); return el ? el.value : def; };

// Simple hash for data to detect changes
function hashData(xData, yData, bandwidth) {
    const sample = xData.slice(0, 10).concat(yData.slice(0, 10));
    return sample.join(',') + ':' + xData.length + ':' + (bandwidth || 'auto');
}

// Kernel density function (Gaussian kernel)
function gaussianKernel(dist, bandwidth) {
    return Math.exp(-0.5 * (dist / bandwidth) ** 2) / (bandwidth * Math.sqrt(2 * Math.PI));
}

// 2D Gaussian kernel weight
function kernel2D(dx, dy, hx, hy) {
    return Math.exp(-0.5 * ((dx / hx) ** 2 + (dy / hy) ** 2));
}

// Compute local Gaussian correlation at a grid point
function localCorrelation(xGrid, yGrid, xData, yData, hx, hy) {
    let sumW = 0, sumWX = 0, sumWY = 0;
    let sumWXX = 0, sumWYY = 0, sumWXY = 0;

    for (let i = 0; i < xData.length; i++) {
        const w = kernel2D(xData[i] - xGrid, yData[i] - yGrid, hx, hy);
        sumW += w;
        sumWX += w * xData[i];
        sumWY += w * yData[i];
    }

    if (sumW < MIN_WEIGHT) return null;

    const meanX = sumWX / sumW;
    const meanY = sumWY / sumW;

    for (let i = 0; i < xData.length; i++) {
        const w = kernel2D(xData[i] - xGrid, yData[i] - yGrid, hx, hy);
        const dx = xData[i] - meanX;
        const dy = yData[i] - meanY;
        sumWXX += w * dx * dx;
        sumWYY += w * dy * dy;
        sumWXY += w * dx * dy;
    }

    const varX = sumWXX / sumW;
    const varY = sumWYY / sumW;
    const covXY = sumWXY / sumW;

    if (varX <= 0 || varY <= 0) return null;

    const corr = covXY / Math.sqrt(varX * varY);
    return Math.max(-1, Math.min(1, corr));  // Clamp to [-1, 1]
}

// Compute kernel density at a point
function kernelDensity1D(x, data, h) {
    let sum = 0;
    for (let i = 0; i < data.length; i++) {
        sum += gaussianKernel(x - data[i], h);
    }
    return sum / data.length;
}

// Silverman's rule for bandwidth
function silvermanBandwidth(data) {
    const n = data.length;
    const mean = data.reduce((a, b) => a + b, 0) / n;
    const std = Math.sqrt(data.reduce((sum, x) => sum + (x - mean) ** 2, 0) / n);
    return 1.06 * std * Math.pow(n, -0.2);
}

// Bootstrap resampling - returns indices for a bootstrap sample
function bootstrapIndices(n) {
    const indices = [];
    for (let i = 0; i < n; i++) {
        indices.push(Math.floor(Math.random() * n));
    }
    return indices;
}

// Compute local correlation on a grid for given data (used for bootstrap)
function computeGridCorrelations(xData, yData, xGrid, yGrid, hx, hy) {
    const gridSize = xGrid.length;
    const zGrid = [];
    for (let j = 0; j < gridSize; j++) {
        const zRow = [];
        for (let i = 0; i < gridSize; i++) {
            const corr = localCorrelation(xGrid[i], yGrid[j], xData, yData, hx, hy);
            zRow.push(corr);
        }
        zGrid.push(zRow);
    }
    return zGrid;
}

// Compute bootstrap t-statistics
function computeBootstrapTStats(xData, yData, xGrid, yGrid, hx, hy, originalZGrid, nBootstrap, progressCallback) {
    const gridSize = xGrid.length;
    const n = xData.length;

    // Store all bootstrap correlations for each grid point
    const bootstrapCorrs = [];
    for (let j = 0; j < gridSize; j++) {
        bootstrapCorrs.push([]);
        for (let i = 0; i < gridSize; i++) {
            bootstrapCorrs[j].push([]);
        }
    }

    // Run bootstrap iterations
    for (let b = 0; b < nBootstrap; b++) {
        // Resample with replacement
        const indices = bootstrapIndices(n);
        const xBoot = indices.map(i => xData[i]);
        const yBoot = indices.map(i => yData[i]);

        // Compute correlations for this bootstrap sample
        const zBoot = computeGridCorrelations(xBoot, yBoot, xGrid, yGrid, hx, hy);

        // Store correlations
        for (let j = 0; j < gridSize; j++) {
            for (let i = 0; i < gridSize; i++) {
                if (zBoot[j][i] !== null) {
                    bootstrapCorrs[j][i].push(zBoot[j][i]);
                }
            }
        }

        // Progress callback
        if (progressCallback && b % 20 === 0) {
            progressCallback(b / nBootstrap);
        }
    }

    // Compute t-statistics: t = corr / SE(corr)
    const tGrid = [];
    const seGrid = [];
    for (let j = 0; j < gridSize; j++) {
        const tRow = [];
        const seRow = [];
        for (let i = 0; i < gridSize; i++) {
            const corrs = bootstrapCorrs[j][i];
            const origCorr = originalZGrid[j][i];

            if (origCorr === null || corrs.length < 10) {
                tRow.push(null);
                seRow.push(null);
            } else {
                // Compute standard error from bootstrap distribution
                const mean = corrs.reduce((a, b) => a + b, 0) / corrs.length;
                const variance = corrs.reduce((sum, c) => sum + (c - mean) ** 2, 0) / (corrs.length - 1);
                const se = Math.sqrt(variance);

                seRow.push(se);

                if (se > 0.001) {
                    // t-statistic: original correlation / bootstrap SE
                    const t = origCorr / se;
                    tRow.push(t);
                } else {
                    // SE too small, correlation is very stable
                    tRow.push(origCorr > 0 ? 10 : (origCorr < 0 ? -10 : 0));
                }
            }
        }
        tGrid.push(tRow);
        seGrid.push(seRow);
    }

    return { tGrid, seGrid };
}

// Main computation function
function computeLocalCorrelation(xData, yData, gridSize, bandwidth) {
    const xMin = Math.min(...xData);
    const xMax = Math.max(...xData);
    const yMin = Math.min(...yData);
    const yMax = Math.max(...yData);

    // Extend grid slightly beyond data range
    const xPad = (xMax - xMin) * 0.05;
    const yPad = (yMax - yMin) * 0.05;
    const xRange = [xMin - xPad, xMax + xPad];
    const yRange = [yMin - yPad, yMax + yPad];

    // Compute bandwidth using Silverman's rule if not specified
    const hx = bandwidth || silvermanBandwidth(xData);
    const hy = bandwidth || silvermanBandwidth(yData);

    // Create grid
    const xStep = (xRange[1] - xRange[0]) / (gridSize - 1);
    const yStep = (yRange[1] - yRange[0]) / (gridSize - 1);

    const xGrid = [];
    const yGrid = [];
    const zGrid = [];  // Local correlation values
    const densityGrid = [];  // Kernel density values

    for (let i = 0; i < gridSize; i++) {
        xGrid.push(xRange[0] + i * xStep);
    }
    for (let j = 0; j < gridSize; j++) {
        yGrid.push(yRange[0] + j * yStep);
    }

    // Compute local correlation and density at each grid point
    for (let j = 0; j < gridSize; j++) {
        const zRow = [];
        const densityRow = [];
        for (let i = 0; i < gridSize; i++) {
            const corr = localCorrelation(xGrid[i], yGrid[j], xData, yData, hx, hy);
            zRow.push(corr);

            // Compute 2D kernel density at this point
            let density = 0;
            for (let k = 0; k < xData.length; k++) {
                density += kernel2D(xData[k] - xGrid[i], yData[k] - yGrid[j], hx, hy);
            }
            densityRow.push(density / xData.length);
        }
        zGrid.push(zRow);
        densityGrid.push(densityRow);
    }

    // Compute marginal integrations (kernel-density weighted)
    // For each y value, average correlation over all x values, weighted by density
    const marginalY = [];  // Average correlation for each y
    const marginalYDensity = [];  // Density at each y for weighting
    for (let j = 0; j < gridSize; j++) {
        let sumCorr = 0, sumDensity = 0;
        for (let i = 0; i < gridSize; i++) {
            if (zGrid[j][i] !== null) {
                sumCorr += zGrid[j][i] * densityGrid[j][i];
                sumDensity += densityGrid[j][i];
            }
        }
        marginalY.push(sumDensity > 0 ? sumCorr / sumDensity : null);
        marginalYDensity.push(kernelDensity1D(yGrid[j], yData, hy));
    }

    // For each x value, average correlation over all y values, weighted by density
    const marginalX = [];  // Average correlation for each x
    const marginalXDensity = [];  // Density at each x for weighting
    for (let i = 0; i < gridSize; i++) {
        let sumCorr = 0, sumDensity = 0;
        for (let j = 0; j < gridSize; j++) {
            if (zGrid[j][i] !== null) {
                sumCorr += zGrid[j][i] * densityGrid[j][i];
                sumDensity += densityGrid[j][i];
            }
        }
        marginalX.push(sumDensity > 0 ? sumCorr / sumDensity : null);
        marginalXDensity.push(kernelDensity1D(xGrid[i], xData, hx));
    }

    return {
        xGrid, yGrid, zGrid, densityGrid,
        marginalX, marginalY, marginalXDensity, marginalYDensity,
        bandwidth: { x: hx, y: hy },
        xData, yData  // Store for bootstrap
    };
}

// Compute marginals for t-statistics
function computeTStatMarginals(tGrid, densityGrid, gridSize) {
    const marginalY = [];
    for (let j = 0; j < gridSize; j++) {
        let sumT = 0, sumDensity = 0;
        for (let i = 0; i < gridSize; i++) {
            if (tGrid[j][i] !== null) {
                sumT += tGrid[j][i] * densityGrid[j][i];
                sumDensity += densityGrid[j][i];
            }
        }
        marginalY.push(sumDensity > 0 ? sumT / sumDensity : null);
    }

    const marginalX = [];
    for (let i = 0; i < gridSize; i++) {
        let sumT = 0, sumDensity = 0;
        for (let j = 0; j < gridSize; j++) {
            if (tGrid[j][i] !== null) {
                sumT += tGrid[j][i] * densityGrid[j][i];
                sumDensity += densityGrid[j][i];
            }
        }
        marginalX.push(sumDensity > 0 ? sumT / sumDensity : null);
    }

    return { marginalX, marginalY };
}

function renderPlot(result, xData, yData, X_COL, Y_COL, X_TRANSFORM, Y_TRANSFORM, displayMode) {
    const isTStat = displayMode === 'tstat';

    // Determine which z values and marginals to display
    let zValues, marginalX, marginalY, colorbarTitle, zmin, zmax, hoverLabel;

    if (isTStat && result.tGrid) {
        zValues = result.tGrid;
        const tMarginals = computeTStatMarginals(result.tGrid, result.densityGrid, GRID_SIZE);
        marginalX = tMarginals.marginalX;
        marginalY = tMarginals.marginalY;
        colorbarTitle = 't-statistic';
        // Use symmetric range centered at 0, cap at Â±5 for better visualization
        const maxAbsT = Math.min(5, Math.max(...zValues.flat().filter(v => v !== null).map(Math.abs)));
        zmin = -maxAbsT;
        zmax = maxAbsT;
        hoverLabel = 't';
    } else {
        zValues = result.zGrid;
        marginalX = result.marginalX;
        marginalY = result.marginalY;
        colorbarTitle = 'Local Correlation';
        zmin = -1;
        zmax = 1;
        hoverLabel = 'Ï';
    }

    // Create heatmap trace
    const heatmapTrace = {
        x: result.xGrid,
        y: result.yGrid,
        z: zValues,
        type: 'heatmap',
        colorscale: COLORSCALE,
        reversescale: true,  // Reversed: red=negative, blue=positive
        zmin: zmin,
        zmax: zmax,
        colorbar: {
            title: colorbarTitle,
            orientation: 'h',
            x: 0.4,
            y: 1.12,
            xanchor: 'center',
            len: 0.6,
            thickness: 15
        },
        xaxis: 'x',
        yaxis: 'y',
        hovertemplate: 'X: %{x:.3f}<br>Y: %{y:.3f}<br>' + hoverLabel + ': %{z:.3f}<extra></extra>'
    };

    // Create scatter plot of actual data points
    const scatterTrace = {
        x: xData,
        y: yData,
        mode: 'markers',
        type: 'scatter',
        marker: {
            size: 3,
            color: 'rgba(0, 0, 0, 0.3)'
        },
        xaxis: 'x',
        yaxis: 'y',
        showlegend: false,
        hoverinfo: 'skip'
    };

    // Create marginal Y line (right side)
    const marginalYTrace = {
        x: marginalY.map(v => v !== null ? v : NaN),
        y: result.yGrid,
        type: 'scatter',
        mode: 'lines',
        line: { color: '#2ca02c', width: 2 },
        xaxis: 'x2',
        yaxis: 'y',
        showlegend: false,
        name: 'Avg ' + hoverLabel + ' (over X)',
        hovertemplate: 'Y: %{y:.3f}<br>Avg ' + hoverLabel + ': %{x:.3f}<extra></extra>'
    };

    // Create marginal X line (bottom)
    const marginalXTrace = {
        x: result.xGrid,
        y: marginalX.map(v => v !== null ? v : NaN),
        type: 'scatter',
        mode: 'lines',
        line: { color: '#d62728', width: 2 },
        xaxis: 'x',
        yaxis: 'y2',
        showlegend: false,
        name: 'Avg ' + hoverLabel + ' (over Y)',
        hovertemplate: 'X: %{x:.3f}<br>Avg ' + hoverLabel + ': %{y:.3f}<extra></extra>'
    };

    // Reference lines at 0
    const zeroLineY = {
        x: [0, 0],
        y: [result.yGrid[0], result.yGrid[result.yGrid.length - 1]],
        type: 'scatter',
        mode: 'lines',
        line: { color: '#999', width: 1, dash: 'dash' },
        xaxis: 'x2',
        yaxis: 'y',
        showlegend: false,
        hoverinfo: 'skip'
    };

    const zeroLineX = {
        x: [result.xGrid[0], result.xGrid[result.xGrid.length - 1]],
        y: [0, 0],
        type: 'scatter',
        mode: 'lines',
        line: { color: '#999', width: 1, dash: 'dash' },
        xaxis: 'x',
        yaxis: 'y2',
        showlegend: false,
        hoverinfo: 'skip'
    };

    // Add significance threshold lines for t-stat mode
    const extraTraces = [];
    if (isTStat) {
        // Lines at t = Â±1.96 (95% significance)
        extraTraces.push({
            x: [1.96, 1.96],
            y: [result.yGrid[0], result.yGrid[result.yGrid.length - 1]],
            type: 'scatter',
            mode: 'lines',
            line: { color: '#ff7f0e', width: 1, dash: 'dot' },
            xaxis: 'x2',
            yaxis: 'y',
            showlegend: false,
            hoverinfo: 'skip'
        });
        extraTraces.push({
            x: [-1.96, -1.96],
            y: [result.yGrid[0], result.yGrid[result.yGrid.length - 1]],
            type: 'scatter',
            mode: 'lines',
            line: { color: '#ff7f0e', width: 1, dash: 'dot' },
            xaxis: 'x2',
            yaxis: 'y',
            showlegend: false,
            hoverinfo: 'skip'
        });
        extraTraces.push({
            x: [result.xGrid[0], result.xGrid[result.xGrid.length - 1]],
            y: [1.96, 1.96],
            type: 'scatter',
            mode: 'lines',
            line: { color: '#ff7f0e', width: 1, dash: 'dot' },
            xaxis: 'x',
            yaxis: 'y2',
            showlegend: false,
            hoverinfo: 'skip'
        });
        extraTraces.push({
            x: [result.xGrid[0], result.xGrid[result.xGrid.length - 1]],
            y: [-1.96, -1.96],
            type: 'scatter',
            mode: 'lines',
            line: { color: '#ff7f0e', width: 1, dash: 'dot' },
            xaxis: 'x',
            yaxis: 'y2',
            showlegend: false,
            hoverinfo: 'skip'
        });
    }

    const xLabel = X_TRANSFORM === 'identity' ? X_COL : X_TRANSFORM + '(' + X_COL + ')';
    const yLabel = Y_TRANSFORM === 'identity' ? Y_COL : Y_TRANSFORM + '(' + Y_COL + ')';

    const marginalRange = isTStat ? [-5, 5] : [-1, 1];
    const marginalTitle = isTStat ? 'Avg t' : 'Avg Ï';

    const layout = {
        title: 'Local Gaussian Correlation Between Stock Returns' + (isTStat ? ' (t-statistic)' : ''),
        showlegend: false,
        autosize: true,
        margin: { t: 120, r: 120, b: 120, l: 80 },
        xaxis: {
            title: xLabel,
            domain: [0, 0.8],
            showgrid: true,
            zeroline: false
        },
        yaxis: {
            title: yLabel,
            domain: [0.2, 1],
            showgrid: true,
            zeroline: false
        },
        xaxis2: {
            title: marginalTitle,
            domain: [0.85, 1],
            range: marginalRange,
            showgrid: true,
            zeroline: true
        },
        yaxis2: {
            title: marginalTitle,
            domain: [0, 0.15],
            range: marginalRange,
            showgrid: true,
            zeroline: true
        },
        annotations: [
            {
                text: 'Integrated over X',
                x: 0.925,
                y: 1.05,
                xref: 'paper',
                yref: 'paper',
                showarrow: false,
                font: { size: 10, color: '#2ca02c' }
            },
            {
                text: 'Integrated over Y',
                x: 0.4,
                y: -0.15,
                xref: 'paper',
                yref: 'paper',
                showarrow: false,
                font: { size: 10, color: '#d62728' }
            }
        ]
    };

    // Add significance note for t-stat mode
    if (isTStat) {
        layout.annotations.push({
            text: 'Orange dashed lines: |t| = 1.96 (p < 0.05)',
            x: 0.5,
            y: -0.22,
            xref: 'paper',
            yref: 'paper',
            showarrow: false,
            font: { size: 10, color: '#ff7f0e' }
        });
    }

    Plotly.newPlot('stock_lgc',
        [heatmapTrace, scatterTrace, marginalYTrace, zeroLineY, marginalXTrace, zeroLineX, ...extraTraces],
        layout,
        { responsive: true }
    );
}

// Async function to compute bootstrap and update plot
async function computeAndDisplayBootstrap(result, xData, yData, X_COL, Y_COL, X_TRANSFORM, Y_TRANSFORM) {
    const statusEl = document.getElementById('stock_lgc_bootstrap_status');
    const progressEl = document.getElementById('stock_lgc_bootstrap_progress');

    if (statusEl) statusEl.textContent = 'Computing bootstrap...';
    if (progressEl) progressEl.style.width = '0%';

    // Use setTimeout to allow UI to update
    await new Promise(resolve => setTimeout(resolve, 50));

    const progressCallback = (progress) => {
        if (progressEl) progressEl.style.width = (progress * 100) + '%';
    };

    // Compute bootstrap t-statistics
    const { tGrid, seGrid } = computeBootstrapTStats(
        xData, yData,
        result.xGrid, result.yGrid,
        result.bandwidth.x, result.bandwidth.y,
        result.zGrid,
        BOOTSTRAP_ITERATIONS,
        progressCallback
    );

    // Store in result and cache
    result.tGrid = tGrid;
    result.seGrid = seGrid;
    bootstrapCache_stock_lgc = result;

    if (statusEl) statusEl.textContent = 'Bootstrap complete (' + BOOTSTRAP_ITERATIONS + ' iterations)';
    if (progressEl) progressEl.style.width = '100%';

    // Render with t-stat
    renderPlot(result, xData, yData, X_COL, Y_COL, X_TRANSFORM, Y_TRANSFORM, 'tstat');
}

function updatePlot_stock_lgc(data) {
    const X_COL = getCol('x_col_select_stock_lgc', 'AAPL_return');
    const Y_COL = getCol('y_col_select_stock_lgc', 'MSFT_return');
    const X_TRANSFORM = getCol('x_transform_select_stock_lgc', 'identity');
    const Y_TRANSFORM = getCol('y_transform_select_stock_lgc', 'identity');
    const displayMode = getCol('stock_lgc_display_mode', 'correlation');

    // Extract and transform data
    const validPairs = [];
    for (let i = 0; i < data.length; i++) {
        const x = parseFloat(data[i][X_COL]);
        const y = parseFloat(data[i][Y_COL]);
        if (!isNaN(x) && !isNaN(y)) {
            validPairs.push({ x, y });
        }
    }

    if (validPairs.length < 10) {
        document.getElementById('stock_lgc').innerHTML =
            '<p style="color: red; padding: 20px;">Need at least 10 valid data points for local correlation analysis.</p>';
        return;
    }

    let xData = validPairs.map(p => p.x);
    let yData = validPairs.map(p => p.y);

    // Apply transforms
    let xTransformed = applyAxisTransform(xData, X_TRANSFORM);
    let yTransformed = applyAxisTransform(yData, Y_TRANSFORM);

    // Filter out NaN pairs after transformation
    const transformedPairs = [];
    for (let i = 0; i < xTransformed.length; i++) {
        if (!isNaN(xTransformed[i]) && isFinite(xTransformed[i]) &&
            !isNaN(yTransformed[i]) && isFinite(yTransformed[i])) {
            transformedPairs.push({ x: xTransformed[i], y: yTransformed[i] });
        }
    }

    if (transformedPairs.length < 10) {
        document.getElementById('stock_lgc').innerHTML =
            '<p style="color: red; padding: 20px;">Need at least 10 valid data points after transformation. Try a different transform.</p>';
        return;
    }

    xData = transformedPairs.map(p => p.x);
    yData = transformedPairs.map(p => p.y);

    // Get bandwidth from slider (0 means auto)
    const bwSlider = document.getElementById('stock_lgc_bandwidth_slider');
    const bw = bwSlider ? parseFloat(bwSlider.value) : 0;
    const actualBandwidth = bw > 0 ? bw : null;

    // Check if we need to recompute or can use cache
    const dataHash = hashData(xData, yData, actualBandwidth);
    let result;

    if (dataHash === lastDataHash_stock_lgc && bootstrapCache_stock_lgc) {
        // Use cached result
        result = bootstrapCache_stock_lgc;
    } else {
        // Compute fresh local correlation
        result = computeLocalCorrelation(xData, yData, GRID_SIZE, actualBandwidth);
        lastDataHash_stock_lgc = dataHash;
        bootstrapCache_stock_lgc = null;  // Invalidate bootstrap cache
    }

    // Update bandwidth display
    const bwLabel = document.getElementById('stock_lgc_bandwidth_label');
    if (bwLabel) {
        bwLabel.textContent = result.bandwidth.x.toFixed(3);
    }

    // Reset bootstrap status if cache was invalidated
    const statusEl = document.getElementById('stock_lgc_bootstrap_status');
    const progressEl = document.getElementById('stock_lgc_bootstrap_progress');
    if (!bootstrapCache_stock_lgc || !bootstrapCache_stock_lgc.tGrid) {
        if (statusEl) statusEl.textContent = 'Not computed';
        if (progressEl) progressEl.style.width = '0%';
    }

    // If t-stat mode requested and not cached, compute bootstrap
    if (displayMode === 'tstat') {
        if (result.tGrid) {
            // Already have bootstrap results
            renderPlot(result, xData, yData, X_COL, Y_COL, X_TRANSFORM, Y_TRANSFORM, 'tstat');
        } else {
            // Need to compute bootstrap - show correlation first, then compute
            renderPlot(result, xData, yData, X_COL, Y_COL, X_TRANSFORM, Y_TRANSFORM, 'correlation');
            computeAndDisplayBootstrap(result, xData, yData, X_COL, Y_COL, X_TRANSFORM, Y_TRANSFORM);
        }
    } else {
        // Correlation mode
        renderPlot(result, xData, yData, X_COL, Y_COL, X_TRANSFORM, Y_TRANSFORM, 'correlation');
    }
}

window.updateChart_stock_lgc = () => updatePlotWithFilters_stock_lgc();

// Filter and update function
window.updatePlotWithFilters_stock_lgc = function() {
    // Get current filter values
    const { filters, rangeFilters, choices } = readFilterValues('stock_lgc', CATEGORICAL_FILTERS, CONTINUOUS_FILTERS, CHOICE_FILTERS);

    // Apply filters with observation counting
    const filteredData = applyFiltersWithCounting(
        window.allData_stock_lgc,
        'stock_lgc',
        CATEGORICAL_FILTERS,
        CONTINUOUS_FILTERS,
        filters,
        rangeFilters,
        CHOICE_FILTERS,
        choices
    );

    // Update plot with filtered data
    updatePlot_stock_lgc(filteredData);
};

loadDataset('lgc_stock_data').then(data => {
    window.allData_stock_lgc = data;
    $(function() {
        // Setup bandwidth slider
        document.getElementById('stock_lgc_bandwidth_slider').addEventListener('input', function() {
            var bw = parseFloat(this.value);
            document.getElementById('stock_lgc_bandwidth_label').textContent = bw === 0 ? 'auto' : bw.toFixed(3);
            // Invalidate cache when bandwidth changes
            bootstrapCache_stock_lgc = null;
            lastDataHash_stock_lgc = null;
            updateChart_stock_lgc();
        });

        // Setup display mode selector
        document.getElementById('stock_lgc_display_mode').addEventListener('change', function() {
            updateChart_stock_lgc();
        });

        updatePlotWithFilters_stock_lgc();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('stock_lgc');
    });
}).catch(error => console.error('Error loading data for chart stock_lgc:', error));
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="data_countries_geo_data" data-format="parquet" data-src="data/countries_geo_data.parquet"></script><script type="text/plain" id="data_strategy_data" data-format="parquet" data-src="data/strategy_data.parquet"></script><script type="text/plain" id="data_product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="data_sankey_data" data-format="parquet" data-src="data/sankey_data.parquet"></script><script type="text/plain" id="data_stock_corr_data" data-format="parquet" data-src="data/stock_corr_data.parquet"></script><script type="text/plain" id="data_exec_data_tob" data-format="parquet" data-src="data/exec_data/tob.parquet"></script><script type="text/plain" id="data_exec_data_summary_usd" data-format="parquet" data-src="data/exec_data/summary_usd.parquet"></script><script type="text/plain" id="data_exec_data_fill_returns" data-format="parquet" data-src="data/exec_data/fill_returns.parquet"></script><script type="text/plain" id="data_lgc_stock_data" data-format="parquet" data-src="data/lgc_stock_data.parquet"></script><script type="text/plain" id="data_surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script><script type="text/plain" id="data_exec_data_summary_bps" data-format="parquet" data-src="data/exec_data/summary_bps.parquet"></script><script type="text/plain" id="data_radar_data" data-format="parquet" data-src="data/radar_data.parquet"></script><script type="text/plain" id="data_cities_geo_data" data-format="parquet" data-src="data/cities_geo_data.parquet"></script><script type="text/plain" id="data_rankings_data" data-format="parquet" data-src="data/rankings_data.parquet"></script><script type="text/plain" id="data_exec_data_summary_pct" data-format="parquet" data-src="data/exec_data/summary_pct.parquet"></script><script type="text/plain" id="data_exec_data_fills" data-format="parquet" data-src="data/exec_data/fills.parquet"></script><script type="text/plain" id="data_sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="data_exec_data_volume" data-format="parquet" data-src="data/exec_data/volume.parquet"></script><script type="text/plain" id="data_drawdown_data" data-format="parquet" data-src="data/drawdown_data.parquet"></script><script type="text/plain" id="data_tsne_stock_data" data-format="parquet" data-src="data/tsne_stock_data.parquet"></script><script type="text/plain" id="data_daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="data_business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="data_boxwhiskers_data" data-format="parquet" data-src="data/boxwhiskers_data.parquet"></script><script type="text/plain" id="data_waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="data_candlestick_data" data-format="parquet" data-src="data/candlestick_data.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>Variable Relationship Charts</h1>
<p>This shows examples of CorrPlot, Graph, TSNEPlot, and LocalGaussianCorrelationPlot. CorrPlot displays correlation matrices with hierarchical clustering dendrograms. Graph visualizes correlations as a network. TSNEPlot performs t-SNE dimensionality reduction in the browser. LocalGaussianCorrelationPlot shows how correlation varies across the joint distribution of two variables.</p>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<div class="corrplot-container">
    <h2>Stock Market Correlation Analysis - Multiple Scenarios</h2>
    <p>A Correlation Plot with Dendrogram shows relationships between variables using hierarchical clustering. The dendrogram (top) groups similar variables based on their correlation patterns, with clustering performed dynamically in your browser. Note that it will only appear if i) you select order by dendrogram and ii) you select all of the variables. The correlation matrix (bottom) uses two different correlation measures: Pearson correlations (top-right triangle, marked with 'P:') measure linear relationships, while Spearman correlations (bottom-left triangle, marked with 'S:') measure monotonic relationships and are robust to outliers. You can change the clustering linkage method (Ward, Average, Single, Complete) to see different groupings. Variables are automatically reordered by the clustering to reveal correlation blocks. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/corrplot_examples.html" style="color: blue; font-weight: bold;">See here for CorrPlot examples</a></p>
    <div style="margin-bottom: 15px;">
    <label for="scenario_select_stock_advanced"><strong>Scenario:</strong></label>
    <select id="scenario_select_stock_advanced" onchange="updateChart_stock_advanced()">
        <option value="Short-term Returns (Daily)" selected>Short-term Returns (Daily)</option>
                <option value="Long-term Returns (20-day)" >Long-term Returns (20-day)</option>
                <option value="Volatility Correlations" >Volatility Correlations</option>
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <label for="var_select_stock_advanced"><strong>Select Variables:</strong></label><br>
    <select id="var_select_stock_advanced" multiple size="8" style="width: 300px;" onchange="updateChart_stock_advanced()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <label for="corr_method_select_stock_advanced"><strong>Correlation method for dendrogram:</strong></label>
    <select id="corr_method_select_stock_advanced" onchange="updateChart_stock_advanced()">
        <option value="pearson" selected>Pearson</option>
        <option value="spearman">Spearman</option>
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <label for="order_mode_stock_advanced"><strong>Variable ordering:</strong></label>
    <select id="order_mode_stock_advanced" onchange="updateChart_stock_advanced()">
        <option value="dendrogram" selected>Order by dendrogram</option>
        <option value="alphabetical">Order alphabetically</option>
        <option value="manual">Order manually</option>
    </select>
</div>

    <div id="linkage_container_stock_advanced" style="margin-bottom: 15px; display: none;">
    <label for="linkage_select_stock_advanced"><strong>Clustering linkage:</strong></label>
    <select id="linkage_select_stock_advanced" onchange="updateChart_stock_advanced()">
        <option value="ward" selected>Ward</option>
        <option value="average">Average</option>
        <option value="single">Single</option>
        <option value="complete">Complete</option>
    </select>
</div>

    <div id="manual_order_stock_advanced" style="margin-bottom: 15px; display: none;">
    <label><strong>Drag to Reorder:</strong></label>
    <div id="sortable_vars_stock_advanced" style="padding: 10px; border: 1px solid #ccc; min-height: 50px;">
    </div>
</div>

    <div id="dendrogram_stock_advanced" style="width: 100%; height: 400px;"></div>
    <div id="corrmatrix_stock_advanced" style="width: 100%; height: 600px;"></div>
</div>
<style>
#sortable_vars_stock_advanced .sortable-item {
    padding: 5px 10px;
    margin: 2px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    cursor: move;
    display: inline-block;
}
#sortable_vars_stock_advanced .sortable-item:hover {
    background-color: #e0e0e0;
}
</style>

<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: stock_corr_data.parquet</p><br>
<hr>
<br>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
<style>
    .graph-tooltip-stock_network {
        position: absolute;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
</style>
<div class="graph-container">
    <h2>Graph</h2>
    <p>This Graph allows you to visualise the relationships between variables. The dataformat to make this is a DataFrame with columns: node1, node2, strength, scenario, correlation_method, sector. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/graph_examples.html" style="color: blue; font-weight: bold;">See here for more Graph examples</a></p>
    <div style="margin-bottom: 10px;">
    <label for="scenario_select_stock_network"><strong>Scenario:</strong></label>
    <select id="scenario_select_stock_network" onchange="updateEdges_stock_network()">
        <option value="Short-term Returns (Daily)">Short-term Returns (Daily)</option>
                <option value="Long-term Returns (20-day)">Long-term Returns (20-day)</option>
                <option value="Volatility Correlations">Volatility Correlations</option>
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <label for="var_select_stock_network"><strong>Select Variables:</strong></label><br>
    <select id="var_select_stock_network" multiple size="6" style="width: 300px;" onchange="updateNodeOpacity_stock_network()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <button id="recalc_btn_stock_network" onclick="recalculateGraph_stock_network()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
        Recalculate Graph
    </button>
    <span style="margin-left: 10px; font-size: 12px; color: #666;">
        (Apply variable selection & reorganize layout)
    </span>
</div>

    <div id="corr_method_container_stock_network" style="margin-bottom: 10px; display: none;">
    <label for="corr_method_select_stock_network"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_stock_network" onchange="updateEdges_stock_network()">
        <!-- Options will be populated dynamically from data -->
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_stock_network"><strong>Color nodes by:</strong></label>
    <select id="color_select_stock_network" onchange="updateColors_stock_network()">
        <option value="none">None</option>
        <option value="sector" selected>sector (discrete)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="layout_select_stock_network"><strong>Layout:</strong></label>
    <select id="layout_select_stock_network" onchange="recalculateGraph_stock_network()">
        <option value="cose" selected>Cose</option>
                <option value="circle" >Circle</option>
                <option value="grid" >Grid</option>
                <option value="concentric" >Concentric</option>
                <option value="breadthfirst" >Breadthfirst</option>
                <option value="random" >Random</option>
    </select>
    <span style="margin-left: 5px; font-size: 11px; color: #666;">(Changing layout recalculates)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label>
        <input type="checkbox" id="show_edges_stock_network"
               
               onchange="updateEdgeLabels_stock_network()">
        <strong>Show edge strengths</strong>
    </label>
</div>

    <div style="margin-bottom: 15px;">
    <label for="cutoff_slider_stock_network"><strong>Connection cutoff:</strong>
           <span id="cutoff_value_stock_network">0.5</span>
    </label>
    <input type="range" id="cutoff_slider_stock_network"
           min="0" max="1" step="0.05" value="0.5"
           style="width: 75%; margin-left: 10px;"
           oninput="document.getElementById('cutoff_value_stock_network').textContent = this.value; updateEdges_stock_network()">
</div>

    <div style="margin-bottom: 15px;">
    <label for="aspect_ratio_slider_stock_network"><strong>Aspect Ratio:</strong>
           <span id="aspect_ratio_label_stock_network">0.6</span>
    </label>
    <input type="range" id="aspect_ratio_slider_stock_network"
           min="-1.61" max="0.69" step="0.01" value="-0.5108256237659907"
           style="width: 75%; margin-left: 10px;">
</div>

    <div id="graph_stock_network" style="width: 100%; border: 1px solid #ccc;"></div>
    <div id="tooltip_stock_network" class="graph-tooltip-stock_network"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Deselected variables become translucent. Click "Recalculate Graph" to remove them and reorganize.
        Switching scenarios updates edges but keeps node positions.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: stock_corr_data.parquet</p><br>
<hr>
<br>
<style>
    .tsne-container-stock_tsne {
        position: relative;
    }
    .tsne-tooltip-stock_tsne {
        position: fixed;
        display: none;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
        max-width: 300px;
        white-space: pre-line;
        line-height: 1.4;
    }
    .tsne-node-stock_tsne {
        cursor: grab;
    }
    .tsne-node-stock_tsne:active {
        cursor: grabbing;
    }
    .tsne-label-stock_tsne {
        font-size: 10px;
        pointer-events: none;
        user-select: none;
    }
</style>
<div class="tsne-container-stock_tsne">
    <h2>Stock Similarity (t-SNE)</h2>
    <p>TSNEPlot performs t-SNE dimensionality reduction entirely in the browser. This example shows 10 stocks positioned by similarity across 6 statistical features. <strong>Key Features:</strong> Interactive feature selection (Available/Selected lists let you choose which variables define similarity), Rescaling options (None, Z-score, Z-score capped, Quantile), Configurable early exaggeration (iterations and factor), Three step modes: 'Step (small)' for single non-exaggerated steps, 'Exaggerated Step' for large movements, 'Run to Convergence' for automatic optimization. You can drag nodes to manually reposition them and resume iteration. Color by sector to see if similar stocks cluster together. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/tsneplot_examples/tsneplot_examples.html" style="color: blue; font-weight: bold;">See here for TSNEPlot examples</a></p>
    <div style="margin-bottom: 15px; padding: 10px; background-color: #f0f0f0; border-radius: 4px;">
    <strong>Feature Selection for Distance Calculation:</strong>
    <div style="display: flex; gap: 20px; margin-top: 10px;">
        <div style="flex: 1;">
            <label><strong>Available Features:</strong></label>
            <select id="available_features_stock_tsne" multiple size="6" style="width: 100%; margin-top: 5px;">
            </select>
        </div>
        <div style="display: flex; flex-direction: column; justify-content: center; gap: 5px;">
            <button onclick="addFeature_stock_tsne()" style="padding: 5px 15px;">&rarr; Add</button>
            <button onclick="removeFeature_stock_tsne()" style="padding: 5px 15px;">&larr; Remove</button>
        </div>
        <div style="flex: 1;">
            <label><strong>Selected Features:</strong></label>
            <select id="selected_features_stock_tsne" multiple size="6" style="width: 100%; margin-top: 5px;">
            </select>
        </div>
    </div>
    <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <label><strong>Rescaling:</strong></label>
        <select id="rescaling_stock_tsne" style="padding: 4px 8px;">
            <option value="none">No rescaling</option>
            <option value="zscore" selected>Z-score</option>
            <option value="zscore_capped">Z-score (capped at Â±2)</option>
            <option value="quantile">Quantile (0 to 1)</option>
        </select>
        <button onclick="recalculateDistances_stock_tsne()" style="padding: 8px 16px; background-color: #9b59b6; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Recalculate Distances & Reset
        </button>
        <span style="font-size: 11px; color: #666;">(Changes which variables determine similarity)</span>
    </div>
</div>

    <div style="margin-bottom: 10px;">
    <label for="color_select_stock_tsne"><strong>Color nodes by:</strong></label>
    <select id="color_select_stock_tsne" onchange="updateColors_stock_tsne()">
        <option value="none">None (uniform color)</option>
        <option value="sector">sector (discrete)</option>
    </select>
</div>

    <div style="margin-bottom: 10px;">
    <label for="perplexity_slider_stock_tsne"><strong>Perplexity:</strong>
           <span id="perplexity_value_stock_tsne">5.0</span>
    </label>
    <input type="range" id="perplexity_slider_stock_tsne"
           min="5" max="100" step="1" value="5.0"
           style="width: 50%; margin-left: 10px;"
           oninput="document.getElementById('perplexity_value_stock_tsne').textContent = this.value;">
    <span style="font-size: 11px; color: #666; margin-left: 5px;">(5-100, typically 15-50)</span>
</div>

    <div style="margin-bottom: 10px;">
    <label for="lr_slider_stock_tsne"><strong>Learning Rate:</strong>
           <span id="lr_value_stock_tsne">200.0</span>
    </label>
    <input type="range" id="lr_slider_stock_tsne"
           min="10" max="1000" step="10" value="200.0"
           style="width: 50%; margin-left: 10px;"
           oninput="document.getElementById('lr_value_stock_tsne').textContent = this.value;">
    <span style="font-size: 11px; color: #666; margin-left: 5px;">(10-1000, typically 100-500)</span>
</div>

    <div style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
    <button id="randomize_btn_stock_tsne" onclick="randomizePositions_stock_tsne()"
            style="padding: 8px 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">
        Randomize Positions
    </button>
    <button id="step_btn_stock_tsne" onclick="stepIteration_stock_tsne(false)"
            style="padding: 8px 16px; background-color: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">
        Step (small)
    </button>
    <button id="exag_step_btn_stock_tsne" onclick="stepIteration_stock_tsne(true)"
            style="padding: 8px 16px; background-color: #f39c12; color: white; border: none; border-radius: 4px; cursor: pointer;">
        Exaggerated Step
    </button>
    <button id="run_btn_stock_tsne" onclick="toggleRun_stock_tsne()"
            style="padding: 8px 16px; background-color: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer;">
        Run to Convergence
    </button>
</div>

    <div style="margin-bottom: 15px; display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
    <div>
        <label for="convergence_stock_tsne"><strong>Convergence threshold:</strong></label>
        <input type="number" id="convergence_stock_tsne" value="0.1" min="0.001" max="10" step="0.01"
               style="width: 80px; margin-left: 5px;">
    </div>
    <div>
        <label for="max_iter_stock_tsne"><strong>Max iterations:</strong></label>
        <input type="number" id="max_iter_stock_tsne" value="5000" min="100" max="10000" step="100"
               style="width: 80px; margin-left: 5px;">
    </div>
    <div>
        <label for="exag_iters_stock_tsne"><strong>Early exaggeration iters:</strong></label>
        <input type="number" id="exag_iters_stock_tsne" value="100" min="0" max="500" step="10"
               style="width: 70px; margin-left: 5px;">
    </div>
    <div>
        <label for="exag_factor_stock_tsne"><strong>Exaggeration factor:</strong></label>
        <input type="number" id="exag_factor_stock_tsne" value="4.0" min="1.0" max="20.0" step="0.5"
               style="width: 60px; margin-left: 5px;">
    </div>
</div>

    <div style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; font-family: monospace;">
    <div><strong>Iteration:</strong> <span id="iteration_stock_tsne">0</span>
         <span id="exaggeration_status_stock_tsne" style="color: #e74c3c; margin-left: 10px;"></span></div>
    <div><strong>Movement (last iteration):</strong> <span id="distance_stock_tsne">0.000</span></div>
    <div><strong>Status:</strong> <span id="status_stock_tsne">Ready</span></div>
</div>

    <div style="margin-bottom: 10px; display: flex; gap: 30px; flex-wrap: wrap;">
    <div style="flex: 1; min-width: 200px;">
        <label for="aspect_ratio_slider_stock_tsne"><strong>Aspect Ratio:</strong>
               <span id="aspect_ratio_label_stock_tsne">0.6</span>
        </label>
        <input type="range" id="aspect_ratio_slider_stock_tsne"
               min="0.3" max="1.2" step="0.05" value="0.6"
               style="width: 70%; margin-left: 10px;">
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="zoom_slider_stock_tsne"><strong>Zoom:</strong>
               <span id="zoom_label_stock_tsne">1.0</span>x
        </label>
        <input type="range" id="zoom_slider_stock_tsne"
               min="0.2" max="5.0" step="0.1" value="1.0"
               style="width: 70%; margin-left: 10px;">
    </div>
</div>

    <div id="tsne_canvas_stock_tsne" style="width: 100%; border: 1px solid #ccc; position: relative; overflow: hidden;"></div>
    <div id="tooltip_stock_tsne" class="tsne-tooltip-stock_tsne"></div>
    <div style="margin-top: 10px; font-size: 12px; color: #666;">
        <strong>Tip:</strong> Drag nodes to manually reposition. "Run to Convergence" uses early exaggeration for the configured number of iterations; "Step (small)" never uses exaggeration; "Exaggerated Step" always uses it.
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: tsne_stock_data.parquet</p><br>
<hr>
<br>
<h2>Local Gaussian Correlation Between Stock Returns</h2>
<p>LocalGaussianCorrelationPlot visualizes how correlation between two variables changes across their joint distribution. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/localgaussiancorrelationplot_examples/localgaussiancorrelationplot_examples.html" style="color: blue; font-weight: bold;">See here for LocalGaussianCorrelationPlot examples</a></p>

<!-- Filters (for data filtering) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="stock_lgc_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="market_regime_select_stock_lgc">market_regime: </label>
                <select id="market_regime_select_stock_lgc" multiple onchange="updatePlotWithFilters_stock_lgc()">
                <option value="High Volatility" selected>High Volatility</option>
                <option value="Normal" selected>Normal</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="market_regime_select_stock_lgc_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<!-- Plot Attributes -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Display Mode</h4>
<div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
    <div>
        <label for="stock_lgc_display_mode">Show: </label>
        <select id="stock_lgc_display_mode" style="padding: 5px 10px;">
            <option value="correlation" selected>Local Correlation</option>
            <option value="tstat">Bootstrap t-statistic</option>
        </select>
    </div>
    <div style="display: flex; align-items: center; gap: 8px;">
        <span style="color: #666; font-size: 0.85em;">Bootstrap: </span>
        <span id="stock_lgc_bootstrap_status" style="font-size: 0.85em; color: #666;">Not computed</span>
        <div style="width: 100px; height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden;">
            <div id="stock_lgc_bootstrap_progress" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.2s;"></div>
        </div>
    </div>
</div>

<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
    <div>
        <label for="x_col_select_stock_lgc">X: </label>
        <select id="x_col_select_stock_lgc" style="padding: 5px 10px;" onchange="updateChart_stock_lgc()">
            <option value="AAPL_return" selected>AAPL_return</option>
<option value="MSFT_return">MSFT_return</option>
<option value="JPM_return">JPM_return</option>
<option value="JNJ_return">JNJ_return</option>
        </select>
    </div>
    <div>
        <label for="x_transform_select_stock_lgc">X Transform: </label>
        <select id="x_transform_select_stock_lgc" style="padding: 5px 10px;" onchange="updateChart_stock_lgc()">
            <option value="identity">identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_stock_lgc">Y: </label>
        <select id="y_col_select_stock_lgc" style="padding: 5px 10px;" onchange="updateChart_stock_lgc()">
            <option value="AAPL_return">AAPL_return</option>
<option value="MSFT_return" selected>MSFT_return</option>
<option value="JPM_return">JPM_return</option>
<option value="JNJ_return">JNJ_return</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_stock_lgc">Y Transform: </label>
        <select id="y_transform_select_stock_lgc" style="padding: 5px 10px;" onchange="updateChart_stock_lgc()">
            <option value="identity">identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>

<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Bandwidth</h4>
<div style="display: flex; gap: 10px; align-items: center;">
    <label for="stock_lgc_bandwidth_slider">Kernel Bandwidth: </label>
    <span id="stock_lgc_bandwidth_label">auto</span>
    <input type="range" id="stock_lgc_bandwidth_slider"
           min="0" max="3" step="0.01" value="0"
           style="width: 50%;">
    <span style="color: #666; font-size: 0.9em;">(0 = auto)</span>
</div>

<div style="margin-top: 15px; padding: 12px; background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 5px; font-size: 0.9em;">
    <h5 style="margin: 0 0 10px 0; color: #495057;">About Local Gaussian Correlation</h5>
    <p style="margin: 5px 0;">
        Local Gaussian Correlation shows how the correlation between two variables varies across their joint distribution.
        The <strong>heatmap</strong> displays the local correlation at each (x, y) point, computed using a Gaussian kernel
        to weight nearby observations.
    </p>
    <p style="margin: 5px 0;">
        The <strong style="color: #2ca02c;">green line</strong> on the right shows the average correlation at each Y value
        (integrated over X), weighted by the kernel density.
        The <strong style="color: #d62728;">red line</strong> at the bottom shows the average correlation at each X value
        (integrated over Y).
    </p>
    <p style="margin: 5px 0;">
        <strong>Blue</strong> = positive, <strong>Red</strong> = negative, <strong>White</strong> = zero.
    </p>
    <p style="margin: 5px 0;">
        <strong>Bootstrap t-statistic</strong>: Resamples the data 200 times to estimate the standard error of the local correlation.
        The t-statistic (correlation / SE) indicates statistical significance. Values beyond Â±1.96 are significant at p &lt; 0.05.
    </p>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="stock_lgc_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="stock_lgc_aspect_ratio_label">1.0</span>
    <input type="range" id="stock_lgc_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="0.0"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="stock_lgc"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: lgc_stock_data.parquet</p>

<hr><div style="display: flex; justify-content: space-between; align-items: center;">
<small><a href="z_general_example.html">JSPlots.jl</a></small>
<small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.6.3.</small>
</div>
</body>
</html>
