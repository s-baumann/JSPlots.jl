<!DOCTYPE html>
<html>
<head>
    <title>Situational Charts</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
    

    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->
<script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
<script type="module">
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';
await parquet.default();
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts various date formats to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
// Handles: ISO strings, Date objects (from Arrow/Parquet), timestamps, and day counts
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Timestamp range for reasonable dates (1970-01-01 to 2100-01-01 in milliseconds)
    var MIN_TIMESTAMP_MS = 0;
    var MAX_TIMESTAMP_MS = 4102444800000;  // 2100-01-01

    // Day count range (for dates stored as days since epoch, e.g., from some Parquet files)
    // Reasonable range: 0 (1970-01-01) to ~47500 (~2100-01-01)
    var MIN_DAYS = 0;
    var MAX_DAYS = 50000;
    var MS_PER_DAY = 86400000;

    // Scan multiple rows to better detect column types (some rows might have missing values)
    var rowsToCheck = Math.min(10, data.length);
    var dateColumns = [];
    var timeColumns = [];
    var timestampColumns = [];
    var dayCountColumns = [];
    var alreadyDateColumns = [];

    // Helper to check if a numeric value looks like a timestamp (milliseconds since epoch)
    function looksLikeTimestamp(value) {
        return typeof value === 'number' && value >= MIN_TIMESTAMP_MS && value <= MAX_TIMESTAMP_MS && value > MAX_DAYS;
    }

    // Helper to check if a numeric value looks like a day count since epoch
    function looksLikeDayCount(value) {
        return typeof value === 'number' && value >= MIN_DAYS && value <= MAX_DAYS && Number.isInteger(value);
    }

    // Build list of keys from first row
    var keys = Object.keys(data[0]);

    // Check each column across multiple rows
    keys.forEach(function(key) {
        var stringDateCount = 0;
        var timeCount = 0;
        var timestampCount = 0;
        var dayCountCount = 0;
        var alreadyDateCount = 0;
        var nonNullCount = 0;

        for (var i = 0; i < rowsToCheck; i++) {
            var value = data[i][key];
            if (value === null || value === undefined) continue;
            nonNullCount++;

            if (value instanceof Date) {
                alreadyDateCount++;
            } else if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    stringDateCount++;
                } else if (timePattern.test(value)) {
                    timeCount++;
                }
            } else if (typeof value === 'number') {
                if (looksLikeTimestamp(value)) {
                    timestampCount++;
                } else if (looksLikeDayCount(value)) {
                    dayCountCount++;
                }
            }
        }

        // Classify column if majority of non-null values match a pattern
        var threshold = nonNullCount * 0.5;
        if (alreadyDateCount > threshold) {
            alreadyDateColumns.push(key);
        } else if (stringDateCount > threshold) {
            dateColumns.push(key);
        } else if (timeCount > threshold) {
            timeColumns.push(key);
        } else if (timestampCount > threshold) {
            timestampColumns.push(key);
        } else if (dayCountCount > threshold && dayCountCount >= 3) {
            // Be more conservative with day counts - require at least 3 matches
            dayCountColumns.push(key);
        }
    });

    // If no date/time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0 &&
        timestampColumns.length === 0 && dayCountColumns.length === 0 &&
        alreadyDateColumns.length === 0) {
        return data;
    }

    // Convert values in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                var value = row[key];

                if (alreadyDateColumns.indexOf(key) !== -1) {
                    // Already a Date object - keep as is
                    newRow[key] = value;
                } else if (dateColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // ISO date string - convert to Date
                    newRow[key] = new Date(value);
                } else if (timeColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = value.split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else if (timestampColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Timestamp in milliseconds - convert to Date
                    newRow[key] = new Date(value);
                } else if (dayCountColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Day count since epoch - convert to Date
                    newRow[key] = new Date(value * MS_PER_DAY);
                } else {
                    newRow[key] = value;
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Φ(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

// Global fix for PivotTable.js filter box positioning issue
// See: https://github.com/nicolaskruchten/pivottable/issues/865
// The library calculates position incorrectly - we fix it by repositioning after creation
(function() {
    if (window._pvtFilterBoxFixApplied) return; // Only apply once
    window._pvtFilterBoxFixApplied = true;

    var lastClickedTriangle = null;

    // Helper function to reposition the filter box
    function repositionFilterBox($box, triangle) {
        if (!triangle || !$box.length) return;

        // Get triangle position relative to viewport
        var triangleRect = triangle.getBoundingClientRect();

        // Get box dimensions (use defaults if not yet rendered)
        var boxWidth = $box.outerWidth() || 300;
        var boxHeight = $box.outerHeight() || 400;

        // Calculate position relative to viewport (for position:fixed)
        var newLeft = triangleRect.left;
        var newTop = triangleRect.bottom + 5;

        // Adjust if it would go off the right edge
        if (newLeft + boxWidth > window.innerWidth - 20) {
            newLeft = triangleRect.right - boxWidth;
        }

        // Adjust if it would go off the bottom edge
        if (newTop + boxHeight > window.innerHeight - 20) {
            newTop = triangleRect.top - boxHeight - 5;
        }

        // Ensure minimum positions
        if (newLeft < 10) newLeft = 10;
        if (newTop < 10) newTop = 10;

        // Use position:fixed for viewport-relative positioning
        $box.css({
            'position': 'fixed',
            'left': newLeft + 'px',
            'top': newTop + 'px'
        });
    }

    // Capture which triangle was clicked
    $(document).on('click', '.pvtTriangle', function(e) {
        lastClickedTriangle = this;
    });

    // Watch for filter box creation and fix position
    var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1 && $(node).hasClass('pvtFilterBox')) {
                    var $box = $(node);
                    var triangle = lastClickedTriangle;

                    // Apply the fix multiple times to ensure it sticks after PivotTable.js finishes
                    // The library may set position after initial render
                    var timings = [0, 10, 50, 100, 200];
                    timings.forEach(function(delay) {
                        setTimeout(function() {
                            repositionFilterBox($box, triangle);
                        }, delay);
                    });

                    // Also reposition on any style changes to the box (in case library updates position)
                    var styleObserver = new MutationObserver(function(styleMutations) {
                        repositionFilterBox($box, triangle);
                    });
                    styleObserver.observe(node, { attributes: true, attributeFilter: ['style'] });

                    // Disconnect the style observer when the filter box is removed
                    var removalObserver = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            mutation.removedNodes.forEach(function(removedNode) {
                                if (removedNode === node) {
                                    styleObserver.disconnect();
                                    removalObserver.disconnect();
                                    lastClickedTriangle = null;
                                }
                            });
                        });
                    });
                    removalObserver.observe(document.body, { childList: true, subtree: true });
                }
            });
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
})();

(function() {
    // Configuration
    const FILTER_COLS = [];
    const COLOR_COLS = ['category'];
    const ITEM_COL = 'item';
    let CATEGORY_COL = 'category';
    const VALUE_COL = 'value';
    const SHOW_TABLE = true;
    const SHOW_TOTALS = true;
    const COLOR_MAPS = {"category":{"Income":"#636efa","Costs":"#EF553B","Taxes":"#00cc96"}};

    // Store data globally
    let allData = [];
    let removedItems = new Set();  // Set of removed item names
    let removedCategories = new Set();  // Set of removed category names

    function calculateWaterfall_waterfall(data) {
        const activeData = data.filter(row => {
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            return !removedItems.has(item) && !removedCategories.has(category);
        });

        let runningTotal = 0;
        const processed = [];

        for (let i = 0; i < activeData.length; i++) {
            const row = activeData[i];
            const item = String(row[ITEM_COL]);
            const category = String(row[CATEGORY_COL]);
            const value = Number(row[VALUE_COL]) || 0;
            const start = runningTotal;
            const end = runningTotal + value;

            // All items are 'relative' (floating bars showing individual changes)
            // First item starts from 0 but still uses relative measure
            processed.push({
                item: item,
                category: category,
                value: value,
                start: start,
                end: end,
                type: value >= 0 ? 'increasing' : 'decreasing',
                isFirst: i === 0
            });

            runningTotal = end;
        }

        // Add total if enabled
        if (SHOW_TOTALS && processed.length > 0) {
            processed.push({
                item: 'Total',
                category: 'Total',
                value: runningTotal,
                start: 0,
                end: runningTotal,
                type: 'total',
                isFirst: false
            });
        }

        return processed;
    }

    function updateTable_waterfall(processedData, allItemsData) {
        if (!SHOW_TABLE) return;

        const container = document.getElementById('waterfall_table_container_waterfall');
        if (!container) return;

        // Build a map for quick lookup by item name
        const dataMap = {};
        for (const item of processedData) {
            dataMap[item.item] = item;
        }

        // Group items by category
        const categoryGroups = {};
        for (const row of allItemsData) {
            const cat = String(row[CATEGORY_COL]);
            const item = String(row[ITEM_COL]);
            if (!categoryGroups[cat]) {
                categoryGroups[cat] = [];
            }
            categoryGroups[cat].push(item);
        }

        // Build table HTML
        let html = '<table class="waterfall-table-waterfall">';
        html += '<thead><tr><th>Item</th><th>Change</th><th>Running Total</th></tr></thead>';
        html += '<tbody>';

        // Iterate through categories
        for (const [category, items] of Object.entries(categoryGroups)) {
            const catRemoved = removedCategories.has(category);

            // Category header row
            html += `<tr class="category-header" style="background-color: #e0e0e0; font-weight: bold; cursor: pointer;"
                     onclick="toggleCategoryGroup_waterfall('${category}')">`;
            html += `<td colspan="3">`;
            html += `<input type="checkbox" ${!catRemoved ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleCategoryGroup_waterfall('${category}')"
                     style="margin-right: 8px;">`;
            html += `${category}</td></tr>`;

            // Item rows within category
            for (const item of items) {
                const itemRemoved = removedItems.has(item) || catRemoved;
                const data = dataMap[item];

                let rowClass = '';
                if (itemRemoved) {
                    rowClass = 'removed';
                } else if (data) {
                    if (data.type === 'absolute' || data.type === 'increasing') {
                        rowClass = 'positive';
                    } else if (data.type === 'decreasing') {
                        rowClass = 'negative';
                    } else if (data.type === 'total') {
                        rowClass = 'total';
                    }
                }

                html += `<tr class="${rowClass}" style="cursor: pointer; padding-left: 20px;"
                         onclick="toggleItem_waterfall('${item}')">`;
                html += `<td style="padding-left: 20px;">${item}</td>`;

                if (data && !itemRemoved) {
                    html += `<td style="text-align: right;">${data.value.toFixed(2)}</td>`;
                    html += `<td style="text-align: right;">${data.end.toFixed(2)}</td>`;
                } else {
                    html += `<td style="text-align: right;">-</td>`;
                    html += `<td style="text-align: right;">-</td>`;
                }
                html += '</tr>';
            }
        }

        // Add Total row if it exists in processed data
        const totalData = processedData.find(d => d.type === 'total');
        if (totalData) {
            const totalRemoved = removedItems.has('Total');
            const rowClass = totalRemoved ? 'removed' : 'total';

            html += `<tr class="${rowClass}" style="background-color: #f5f5f5; font-weight: bold; cursor: pointer;"
                     onclick="toggleItem_waterfall('Total')">`;
            html += `<td style="padding-left: 20px;">Total</td>`;

            if (!totalRemoved) {
                html += `<td style="text-align: right;">${totalData.value.toFixed(2)}</td>`;
                html += `<td style="text-align: right;">${totalData.end.toFixed(2)}</td>`;
            } else {
                html += `<td style="text-align: right;">-</td>`;
                html += `<td style="text-align: right;">-</td>`;
            }
            html += '</tr>';
        }

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    window.toggleItem_waterfall = function(item) {
        // Allow toggling of all items including Total
        if (removedItems.has(item)) {
            removedItems.delete(item);
        } else {
            removedItems.add(item);
        }
        window.updateChart_waterfall();
    };

    window.toggleCategoryGroup_waterfall = function(category) {
        if (removedCategories.has(category)) {
            removedCategories.delete(category);
        } else {
            removedCategories.add(category);
        }
        window.updateChart_waterfall();
    };

    window.resetWaterfall_waterfall = function() {
        removedItems = new Set();
        removedCategories = new Set();
        window.updateChart_waterfall();
    };

    // Make it global so inline onchange can see it
    window.updateChart_waterfall = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Update category column if dropdown exists
        const colorColSelect = document.getElementById('color_col_waterfall');
        if (colorColSelect) {
            CATEGORY_COL = colorColSelect.value;
        }

        // Get color mode
        const colorModeSelect = document.getElementById('color_mode_waterfall');
        const colorMode = colorModeSelect ? colorModeSelect.value : 'Value (Positive/Negative)';
        console.log('Color mode:', colorMode);
        console.log('CATEGORY_COL:', CATEGORY_COL);
        console.log('COLOR_MAPS:', COLOR_MAPS);

        // Get current filter values (single selection)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_waterfall');
            if (select) {
                filters[col] = select.value;
            }
        });

        // Filter data (single selection per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                if (String(row[col]) !== filters[col]) {
                    return false;
                }
            }
            return true;
        });

        // Calculate waterfall (includes all items)
        const processed = calculateWaterfall_waterfall(filteredData);

        // Filter processed data for chart display (remove toggled items like Total)
        const processedForChart = processed.filter(d => !removedItems.has(d.item));

        const items = processedForChart.map(d => d.item);
        const values = processedForChart.map(d => d.value);
        const bases = processedForChart.map(d => d.type === 'total' ? 0 : d.start);

        // Determine colors based on mode
        let markerColors;
        if (colorMode === 'Category' && COLOR_MAPS[CATEGORY_COL]) {
            // Category-based coloring
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                const categoryColor = COLOR_MAPS[CATEGORY_COL][d.category];
                return categoryColor || '#4285F4';
            });
            console.log('Using category-based colors:', markerColors);
        } else {
            // Value-based coloring (positive/negative)
            markerColors = processedForChart.map(d => {
                if (d.type === 'total') return '#000000';  // Total is always black
                return d.value >= 0 ? '#4CAF50' : '#F44336';  // Green for positive, Red for negative
            });
            console.log('Using value-based colors (positive/negative):', markerColors);
        }

        // Build waterfall using bar chart with base values
        // This gives us full control over colors
        const trace = {
            type: 'bar',
            orientation: 'v',
            x: items,
            y: values,
            base: bases,
            text: values.map(v => v.toFixed(2)),
            textposition: 'outside',
            hovertemplate: '%{x}<br>Change: %{y:.2f}<br>Running Total: %{base:+y:.2f}<extra></extra>',
            marker: {
                color: markerColors,
                line: { width: 1, color: '#333' }
            }
        };

        // Add connector lines as shapes
        const shapes = [];
        for (let i = 0; i < processedForChart.length - 1; i++) {
            if (processedForChart[i].type !== 'total' && processedForChart[i + 1].type !== 'total') {
                const endY = processedForChart[i].end;
                shapes.push({
                    type: 'line',
                    x0: i + 0.4,
                    x1: i + 1 - 0.4,
                    y0: endY,
                    y1: endY,
                    line: {
                        color: 'rgb(63, 63, 63)',
                        width: 2,
                        dash: 'dot'
                    }
                });
            }
        }

        const layout = {
            showlegend: false,
            xaxis: { title: ITEM_COL },
            yaxis: { title: VALUE_COL },
            height: 500,
            margin: {l: 80, r: 50, t: 50, b: 100},
            shapes: shapes
        };

        // Use newPlot to ensure colors update properly
        // (react sometimes doesn't update all trace properties)
        Plotly.newPlot('waterfall', [trace], layout, {responsive: true}).then(function() {
            // Initialize click handler after first plot is created
            initClickHandler_waterfall();
        });

        // Update table
        updateTable_waterfall(processed, filteredData);
    };

    // Track if click handler has been initialized
    let clickHandlerInitialized = false;

    // Initialize click handler after first plot is created
    function initClickHandler_waterfall() {
        if (clickHandlerInitialized) return;
        const chartDiv = document.getElementById('waterfall');
        chartDiv.on('plotly_click', function(data) {
            const clickedItem = data.points[0].x;
            window.toggleItem_waterfall(clickedItem);
        });
        clickHandlerInitialized = true;
    }

    // Load and parse data
    loadDataset('waterfall_data').then(function(data) {
        allData = data;
        window.updateChart_waterfall();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('waterfall');
    }).catch(function(error) {
        console.error('Error loading data for chart waterfall:', error);
    });
})();
(function() {
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const COLOR_COLS = ['crypto_holding', 'stock_holding'];
    const VALUE_COLS = ['portfolio_value'];
    const ID_COL = 'trader_id';
    const TIME_COL = 'year';
    let COLOR_COL = 'crypto_holding';
    let VALUE_COL = 'portfolio_value';
    const USE_COUNT = false;

    let allData = [];

    function processSankeyData_ribbon(data) {
        // Update columns from dropdowns if they exist
        const colorColSelect = document.getElementById('color_col_ribbon');
        if (colorColSelect) {
            COLOR_COL = colorColSelect.value;
        }

        const valueColSelect = document.getElementById('value_col_ribbon');
        if (valueColSelect) {
            VALUE_COL = valueColSelect.value;
        }

        // Get unique time values preserving order of first appearance
        // This respects categorical ordering from the data
        const uniqueTimes = [];
        const seen = new Set();
        for (const row of data) {
            const time = row[TIME_COL];
            if (!seen.has(time)) {
                seen.add(time);
                uniqueTimes.push(time);
            }
        }

        // Only sort if values are dates or numbers (not categorical strings)
        const firstTime = uniqueTimes[0];
        if (firstTime instanceof Date || typeof firstTime === 'number') {
            uniqueTimes.sort((a, b) => {
                if (a instanceof Date && b instanceof Date) {
                    return a - b;
                } else {
                    return a - b;
                }
            });
        }
        // For strings (categorical), keep first-occurrence order

        if (uniqueTimes.length < 2) {
            console.error('Need at least 2 time periods for Sankey diagram');
            return { nodes: [], links: [] };
        }

        // Build nodes and links for Sankey diagram
        const nodeMap = new Map();  // name -> index
        const nodes = [];
        const links = [];

        // Create nodes for each (time, affiliation) pair
        uniqueTimes.forEach((time, timeIdx) => {
            const timeData = data.filter(row => row[TIME_COL] === time);
            const uniqueAffiliations = [...new Set(timeData.map(row => String(row[COLOR_COL])))];

            uniqueAffiliations.forEach(affiliation => {
                const nodeName = `${time}__${affiliation}`;
                if (!nodeMap.has(nodeName)) {
                    nodeMap.set(nodeName, nodes.length);
                    nodes.push({
                        name: affiliation,
                        fullName: nodeName,
                        time: time,
                        timeIdx: timeIdx
                    });
                }
            });
        });

        // Build links between consecutive time periods
        for (let i = 0; i < uniqueTimes.length - 1; i++) {
            const time1 = uniqueTimes[i];
            const time2 = uniqueTimes[i + 1];

            // Get data for both time periods
            const time1Data = data.filter(row => row[TIME_COL] === time1);
            const time2Data = data.filter(row => row[TIME_COL] === time2);

            // Build lookup by ID for time2
            const time2Lookup = new Map();
            time2Data.forEach(row => {
                time2Lookup.set(row[ID_COL], row);
            });

            // Track flows: (affiliation1, affiliation2) -> total value
            const flowMap = new Map();

            time1Data.forEach(row1 => {
                const id = row1[ID_COL];
                const affiliation1 = String(row1[COLOR_COL]);

                // Find matching record at time2
                const row2 = time2Lookup.get(id);
                if (row2) {
                    const affiliation2 = String(row2[COLOR_COL]);
                    const flowKey = `${affiliation1}→${affiliation2}`;

                    const value = USE_COUNT ? 1 : (Number(row1[VALUE_COL]) || 0);

                    if (flowMap.has(flowKey)) {
                        flowMap.set(flowKey, flowMap.get(flowKey) + value);
                    } else {
                        flowMap.set(flowKey, value);
                    }
                }
            });

            // Create links from flow map
            flowMap.forEach((value, flowKey) => {
                const [affiliation1, affiliation2] = flowKey.split('→');
                const sourceName = `${time1}__${affiliation1}`;
                const targetName = `${time2}__${affiliation2}`;

                const sourceIdx = nodeMap.get(sourceName);
                const targetIdx = nodeMap.get(targetName);

                if (sourceIdx !== undefined && targetIdx !== undefined && value > 0) {
                    links.push({
                        source: sourceIdx,
                        target: targetIdx,
                        value: value
                    });
                }
            });
        }

        return { nodes, links, uniqueTimes };
    }

    window.updateChart_ribbon = function() {
        if (!allData || allData.length === 0) {
            return;
        }

        // Get categorical filter values
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_ribbon');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_ribbon' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'ribbon',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (filteredData.length === 0) {
            console.warn('No data after filtering');
            return;
        }

        // Process data into Sankey format
        const { nodes, links, uniqueTimes } = processSankeyData_ribbon(filteredData);

        // Create Sankey diagram
        const data = [{
            type: "sankey",
            orientation: "h",
            node: {
                pad: 15,
                thickness: 20,
                line: {
                    color: "black",
                    width: 0.5
                },
                label: nodes.map(n => n.name),
                color: nodes.map((n, i) => {
                    // Color by time stage
                    const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
                    return colors[n.timeIdx % colors.length];
                }),
                // Add x positions based on time
                x: nodes.map(n => n.timeIdx / (Math.max(...nodes.map(node => node.timeIdx)) || 1)),
                y: Array(nodes.length).fill(null)  // Let Plotly auto-position vertically
            },
            link: {
                source: links.map(l => l.source),
                target: links.map(l => l.target),
                value: links.map(l => l.value),
                color: links.map(l => {
                    // Semi-transparent based on source color
                    const sourceNode = nodes[l.source];
                    const colors = ['rgba(31,119,180,0.3)', 'rgba(255,127,14,0.3)', 'rgba(44,160,44,0.3)',
                                  'rgba(214,39,40,0.3)', 'rgba(148,103,189,0.3)', 'rgba(140,86,75,0.3)',
                                  'rgba(227,119,194,0.3)', 'rgba(127,127,127,0.3)', 'rgba(188,189,34,0.3)', 'rgba(23,190,207,0.3)'];
                    return colors[sourceNode.timeIdx % colors.length];
                })
            }
        }];

        // Create time labels annotations
        const timeAnnotations = uniqueTimes.map((time, idx) => {
            const xPos = idx / (uniqueTimes.length - 1 || 1);
            return {
                x: xPos,
                y: 1.05,
                xref: 'paper',
                yref: 'paper',
                text: String(time),
                showarrow: false,
                font: {
                    size: 14,
                    color: '#333'
                },
                xanchor: 'center'
            };
        });

        const layout = {
            font: {
                size: 12
            },
            height: 600,
            margin: { l: 50, r: 50, t: 70, b: 50 },
            annotations: timeAnnotations
        };

        Plotly.newPlot('ribbon', data, layout, {responsive: true});
    };

    // Load data
    loadDataset('sankey_data').then(function(data) {
        allData = data;
        window.updateChart_ribbon();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('ribbon');
    }).catch(function(error) {
        console.error('Error loading data for chart ribbon:', error);
    });
})();
(function() {
    let radarData_product_radar = null;
    let selectedVariables_product_radar = ["Reliability","Scalability","API_Quality","Integration","Ease_of_Use","Design","Customization","Mobile","Speed","Efficiency","Uptime","ROI","Support","Documentation","Training","Adoption","Satisfaction","Growth"];
    let selectedLabels_product_radar = [];
    let selectedScenario_product_radar = null;

    const VALUE_COLS = ["Reliability","Scalability","API_Quality","Integration","Ease_of_Use","Design","Customization","Mobile","Speed","Efficiency","Uptime","ROI","Support","Documentation","Training","Adoption","Satisfaction","Growth"];
    const LABEL_COL = "label";
    const GROUP_MAPPING = {"Scalability":"Technical Performance","Adoption":"Market Position","ROI":"Business Value","Uptime":"Performance","Reliability":"Technical Performance","Support":"Business Value","API_Quality":"Technical Performance","Design":"User Experience","Documentation":"Business Value","Mobile":"User Experience","Growth":"Market Position","Integration":"Technical Performance","Training":"Business Value","Satisfaction":"Market Position","Customization":"User Experience","Ease_of_Use":"User Experience","Speed":"Performance","Efficiency":"Performance"};
    const VARIABLE_LIMITS = {};
    const SCENARIO_COL = "scenario";
    const COLOR_COL = "category";
    const DEFAULT_COLOR = "#1f77b4";
    const MAX_VALUE = 100.0;
    const MAX_VARIABLES = 3;
    const SHOW_LEGEND = true;
    const SHOW_GRID_LABELS = true;
    const VARIABLE_SELECTOR = true;

    // Load data
    loadDataset('radar_data').then(function(data) {
        radarData_product_radar = data;
        initializeRadarChart_product_radar();
    }).catch(function(error) {
        console.error('Error loading data:', error);
        document.getElementById('radar_product_radar').innerHTML =
            '<p style="color: red;">Error loading data: ' + error.message + '</p>';
    });

    function initializeRadarChart_product_radar() {
        const data = radarData_product_radar;
        if (!data || data.length === 0) {
            document.getElementById('radar_product_radar').innerHTML = '<p>No data available</p>';
            return;
        }

        // Populate scenario selector
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_product_radar');
            if (scenarioSelect) {
                const uniqueScenarios = [...new Set(data.map(d => d[SCENARIO_COL]))].filter(s => s);
                scenarioSelect.innerHTML = '';
                uniqueScenarios.forEach(function(scenario, idx) {
                    const option = document.createElement('option');
                    option.value = scenario;
                    option.text = scenario;
                    if (idx === 0) {
                        option.selected = true;
                        selectedScenario_product_radar = scenario;
                    }
                    scenarioSelect.appendChild(option);
                });
            }
        }

        // Populate variable selector
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_product_radar');
            if (varSelect) {
                varSelect.innerHTML = '';
                VALUE_COLS.forEach(function(col) {
                    const option = document.createElement('option');
                    option.value = col;
                    option.text = col.replace(/_/g, ' ');
                    option.selected = selectedVariables_product_radar.includes(col);
                    varSelect.appendChild(option);
                });
            }
        } else {
            selectedVariables_product_radar = VALUE_COLS;
        }

        // Populate label selector
        const labelSelect = document.getElementById('label_select_product_radar');
        if (labelSelect) {
            // Filter by scenario if applicable
            let scenarioData = data;
            if (SCENARIO_COL && selectedScenario_product_radar) {
                scenarioData = data.filter(d => d[SCENARIO_COL] === selectedScenario_product_radar);
            }

            const uniqueLabels = [...new Set(scenarioData.map(d => d[LABEL_COL]))].filter(l => l);
            labelSelect.innerHTML = '';
            uniqueLabels.forEach(function(label) {
                const option = document.createElement('option');
                option.value = label;
                option.text = label;
                option.selected = true;
                labelSelect.appendChild(option);
            });
            const maxToSelect = MAX_VARIABLES || uniqueLabels.length;
            selectedLabels_product_radar = uniqueLabels.slice(0, maxToSelect);

            // Set selected options
            Array.from(labelSelect.options).forEach(function(opt) {
                opt.selected = selectedLabels_product_radar.includes(opt.value);
            });
        }

        updateRadarChart_product_radar();
    }

    window.updateRadarChart_product_radar = function() {
        // Get selected scenario
        if (SCENARIO_COL) {
            const scenarioSelect = document.getElementById('scenario_select_product_radar');
            if (scenarioSelect) {
                selectedScenario_product_radar = scenarioSelect.value;
            }
        }

        // Get selected variables
        if (VARIABLE_SELECTOR) {
            const varSelect = document.getElementById('var_select_product_radar');
            if (varSelect) {
                selectedVariables_product_radar = Array.from(varSelect.selectedOptions).map(opt => opt.value);

                if (selectedVariables_product_radar.length < 3) {
                    document.getElementById('radar_product_radar').innerHTML =
                        '<p style="color: orange;">Please select at least 3 variables to display a radar chart.</p>';
                    return;
                }
            }
        }

        // Get selected labels
        const labelSelect = document.getElementById('label_select_product_radar');
        if (labelSelect) {
            selectedLabels_product_radar = Array.from(labelSelect.selectedOptions).map(opt => opt.value);

            if (selectedLabels_product_radar.length === 0) {
                document.getElementById('radar_product_radar').innerHTML =
                    '<p style="color: orange;">Please select at least one item to display.</p>';
                return;
            }
        }

        renderRadarChart_product_radar(selectedVariables_product_radar, selectedLabels_product_radar, selectedScenario_product_radar);
    }

    function renderRadarChart_product_radar(variables, labels, scenario) {
        const data = radarData_product_radar;
        const container = document.getElementById('radar_product_radar');
        if (!container) return;

        container.innerHTML = '';

        // Filter data by labels and scenario
        let filteredData = data.filter(d => labels.includes(d[LABEL_COL]));

        if (SCENARIO_COL && scenario) {
            filteredData = filteredData.filter(d => d[SCENARIO_COL] === scenario);
        }

        if (filteredData.length === 0) {
            container.innerHTML = '<p>No data matches the selected filters.</p>';
            return;
        }

        // Calculate max value per variable (respecting variable_limits)
        const maxValues = {};
        variables.forEach(function(v) {
            if (VARIABLE_LIMITS.hasOwnProperty(v)) {
                maxValues[v] = VARIABLE_LIMITS[v];
            } else if (MAX_VALUE) {
                maxValues[v] = MAX_VALUE;
            } else {
                // Auto-calculate from data
                let maxVal = 0;
                filteredData.forEach(function(d) {
                    const val = parseFloat(d[v]);
                    if (!isNaN(val) && val > maxVal) {
                        maxVal = val;
                    }
                });
                maxValues[v] = Math.ceil(maxVal * 1.1);
            }
        });

        // Group variables by group_mapping
        const groupedVars = {};
        const ungroupedVars = [];

        variables.forEach(function(v) {
            if (GROUP_MAPPING.hasOwnProperty(v)) {
                const group = GROUP_MAPPING[v];
                if (!groupedVars[group]) {
                    groupedVars[group] = [];
                }
                groupedVars[group].push(v);
            } else {
                ungroupedVars.push(v);
            }
        });

        // Create ordered list of axes with groups
        const axes = [];
        const groupBoundaries = [];  // Track where each group starts and ends
        let currentIndex = 0;

        // Sort groups for consistent ordering
        const sortedGroups = Object.keys(groupedVars).sort();

        sortedGroups.forEach(function(group) {
            const startIdx = currentIndex;
            groupedVars[group].forEach(function(v) {
                axes.push({ name: v, group: group, maxValue: maxValues[v] });
                currentIndex++;
            });
            const endIdx = currentIndex - 1;
            groupBoundaries.push({ group: group, startIdx: startIdx, endIdx: endIdx });
        });

        ungroupedVars.forEach(function(v) {
            axes.push({ name: v, group: null, maxValue: maxValues[v] });
            currentIndex++;
        });

        // Create color mapping
        const colorMap = {};
        if (COLOR_COL) {
            const uniqueColors = [...new Set(filteredData.map(d => d[COLOR_COL]))];
            // D3 v3 API: use d3.scale.category10()
            const colorScale = d3.scale.category10();
            uniqueColors.forEach(function(c, i) {
                colorMap[c] = colorScale(i);
            });
        }

        // Calculate layout
        const numCharts = filteredData.length;
        const chartsPerRow = Math.ceil(Math.sqrt(numCharts));
        const chartSize = Math.min(450, Math.max(350, Math.floor((container.offsetWidth || 800) / chartsPerRow)));

        // Create SVG container
        const svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', Math.ceil(numCharts / chartsPerRow) * chartSize);

        // Draw each radar chart
        filteredData.forEach(function(d, idx) {
            const row = Math.floor(idx / chartsPerRow);
            const col = idx % chartsPerRow;
            const x = col * chartSize;
            const y = row * chartSize;

            const color = COLOR_COL ? (colorMap[d[COLOR_COL]] || DEFAULT_COLOR) : DEFAULT_COLOR;

            drawSingleRadar_product_radar(svg, d, axes, groupBoundaries, x, y, chartSize, color);
        });

        // Add legend
        if (SHOW_LEGEND && COLOR_COL) {
            addLegend_product_radar(container, colorMap);
        }
    }

    function drawSingleRadar_product_radar(svg, dataPoint, axes, groupBoundaries, offsetX, offsetY, size, color) {
        const margin = 60;
        const radius = (size - 2 * margin) / 2;
        const centerX = offsetX + size / 2;
        const centerY = offsetY + size / 2;

        const g = svg.append('g')
            .attr('transform', 'translate(' + centerX + ',' + centerY + ')');

        // Determine overall max for grid (use the max of all variable maxes for consistent grid)
        let gridMax = 0;
        axes.forEach(function(axis) {
            if (axis.maxValue > gridMax) gridMax = axis.maxValue;
        });

        // Draw grid circles
        const levels = 5;
        for (let i = 1; i <= levels; i++) {
            const r = radius * i / levels;
            g.append('circle')
                .attr('r', r)
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);

            if (SHOW_GRID_LABELS && i === levels) {
                g.append('text')
                    .attr('x', 5)
                    .attr('y', -r)
                    .attr('font-size', '10px')
                    .attr('fill', '#666')
                    .text(gridMax.toFixed(1));
            }
        }

        // Draw axes
        const angleSlice = Math.PI * 2 / axes.length;

        axes.forEach(function(axis, i) {
            const angle = angleSlice * i - Math.PI / 2;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            // Draw axis line
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', x)
                .attr('y2', y)
                .attr('stroke', '#999')
                .attr('stroke-width', 1);

            // Draw axis label
            const labelRadius = radius + 15;
            const labelX = labelRadius * Math.cos(angle);
            const labelY = labelRadius * Math.sin(angle);

            g.append('text')
                .attr('x', labelX)
                .attr('y', labelY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '10px')
                .attr('fill', '#333')
                .text(axis.name.replace(/_/g, ' '));
        });

        // Draw group labels using boundaries
        groupBoundaries.forEach(function(boundary) {
            const startAngle = angleSlice * boundary.startIdx - Math.PI / 2;
            const endAngle = angleSlice * (boundary.endIdx + 1) - Math.PI / 2;
            const midAngle = (startAngle + endAngle) / 2;
            const labelRadius = radius + 40;
            const x = labelRadius * Math.cos(midAngle);
            const y = labelRadius * Math.sin(midAngle);

            g.append('text')
                .attr('x', x)
                .attr('y', y)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', '#0066cc')
                .text(boundary.group);
        });

        // Draw data polygon
        const points = [];
        axes.forEach(function(axis, i) {
            const value = parseFloat(dataPoint[axis.name]) || 0;
            // Clamp value to axis max, then normalize by grid max for consistent display
            const clampedValue = Math.min(value, axis.maxValue);
            const normalizedValue = Math.min(Math.max(clampedValue / gridMax, 0), 1);
            const angle = angleSlice * i - Math.PI / 2;
            const r = radius * normalizedValue;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            points.push([x, y]);
        });

        // Close the polygon
        if (points.length > 0) {
            const pathData = 'M' + points.map(p => p.join(',')).join('L') + 'Z';

            g.append('path')
                .attr('d', pathData)
                .attr('fill', color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', color)
                .attr('stroke-width', 2);

            // Draw points
            points.forEach(function(p) {
                g.append('circle')
                    .attr('cx', p[0])
                    .attr('cy', p[1])
                    .attr('r', 3)
                    .attr('fill', color);
            });
        }

        // Add title
        g.append('text')
            .attr('x', 0)
            .attr('y', -radius - 45)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .text(dataPoint[LABEL_COL]);
    }

    function addLegend_product_radar(container, colorMap) {
        const legendDiv = document.createElement('div');
        legendDiv.style.marginTop = '20px';
        legendDiv.innerHTML = '<strong>Legend:</strong>';

        const legendItems = document.createElement('div');
        legendItems.style.display = 'flex';
        legendItems.style.flexWrap = 'wrap';
        legendItems.style.gap = '15px';
        legendItems.style.marginTop = '10px';

        Object.keys(colorMap).forEach(function(key) {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '5px';

            const colorBox = document.createElement('div');
            colorBox.style.width = '20px';
            colorBox.style.height = '20px';
            colorBox.style.backgroundColor = colorMap[key];
            colorBox.style.border = '1px solid #ccc';

            const label = document.createElement('span');
            label.textContent = key;

            item.appendChild(colorBox);
            item.appendChild(label);
            legendItems.appendChild(item);
        });

        legendDiv.appendChild(legendItems);
        container.appendChild(legendDiv);
    }
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = ['segment', 'region'];
    const CONTINUOUS_FILTERS = [];
    const X_COL = 'quarter';
    const PERFORMANCE_COLS = ['sales_total', 'profit_total', 'quantity_total', 'satisfaction_avg'];
    const ENTITY_COL = 'product';
    const COLOR_MAP = {'Phone': '#00cc96', 'Laptop': '#636efa', 'Tablet': '#EF553B'};
    const COLOR_PALETTE = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A',
                           '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];
    const DEFAULT_PERF_COL = 'sales_total';

    let allData = [];
    let entityColors = {};  // Store entity color assignments

    // Calculate dense ranks for data
    function calculateDenseRanks(data, xCol, perfCol) {
        const xGroups = {};
        data.forEach(row => {
            const xVal = row[xCol];
            const xKey = String(xVal);
            if (!xGroups[xKey]) {
                xGroups[xKey] = [];
            }
            xGroups[xKey].push(row);
        });

        const rankedData = [];
        for (let xKey in xGroups) {
            const group = xGroups[xKey];

            // Sort by performance descending (best first)
            const sorted = group.sort((a, b) => b[perfCol] - a[perfCol]);

            // Get unique performance values
            const uniqueValues = [...new Set(sorted.map(r => r[perfCol]))].sort((a, b) => b - a);

            // Assign dense ranks (ties get same rank, next rank = current + 1)
            const valueToRank = {};
            uniqueValues.forEach((val, idx) => {
                valueToRank[val] = idx + 1;  // Dense rank: 1, 2, 3, ... (no gaps)
            });

            sorted.forEach(row => {
                rankedData.push({
                    ...row,
                    y_value: valueToRank[row[perfCol]],
                    original_value: row[perfCol]
                });
            });
        }

        return rankedData;
    }

    // Assign colors to entities from filtered data
    function assignEntityColors(data) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        entityColors = {};
        entities.forEach((entity, idx) => {
            entityColors[entity] = COLOR_MAP[entity] || COLOR_PALETTE[idx % COLOR_PALETTE.length];
        });
    }

    // Make it global so inline onchange can see it
    window.updateChart_bump_rankings = function() {
        // Get current performance column
        const perfColSelect = document.getElementById('perf_col_select_bump_rankings');
        const PERF_COL = perfColSelect ? perfColSelect.value : DEFAULT_PERF_COL;

        // Get Y-axis mode
        const yModeSelect = document.getElementById('y_mode_select_bump_rankings');
        const Y_MODE = yModeSelect ? yModeSelect.value : 'Ranking';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_bump_rankings');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_bump_rankings' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_bump_rankings');
        const facet2Select = document.getElementById('facet2_select_bump_rankings');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Apply filters with observation counting
        const filteredData = applyFiltersWithCounting(
            allData,
            'bump_rankings',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Assign colors to entities in filtered data
        assignEntityColors(filteredData);

        // Route to appropriate rendering function
        // For facets, rankings will be calculated within each facet
        if (FACET_COLS.length === 0) {
            // No facets: calculate rankings globally
            let processedData;
            if (Y_MODE === 'Ranking') {
                processedData = calculateDenseRanks(filteredData, X_COL, PERF_COL);
            } else {
                processedData = filteredData.map(row => ({
                    ...row,
                    y_value: row[PERF_COL],
                    original_value: row[PERF_COL]
                }));
            }
            renderNoFacets(processedData, X_COL, Y_MODE);
        } else if (FACET_COLS.length === 1) {
            // One facet: pass raw data and PERF_COL, rankings calculated per facet
            renderOneFacet(filteredData, X_COL, Y_MODE, FACET_COLS[0], PERF_COL);
        } else {
            // Two facets: pass raw data and PERF_COL, rankings calculated per facet
            renderTwoFacets(filteredData, X_COL, Y_MODE, FACET_COLS[0], FACET_COLS[1], PERF_COL);
        }
    };

    // Render without facets
    function renderNoFacets(data, xCol, yMode) {
        const entities = [...new Set(data.map(row => String(row[ENTITY_COL])))].sort();
        const traces = [];

        entities.forEach(entity => {
            const entityData = data.filter(row => String(row[ENTITY_COL]) === entity);
            entityData.sort((a, b) => {
                const aVal = a[xCol];
                const bVal = b[xCol];
                if (aVal instanceof Date && bVal instanceof Date) {
                    return aVal - bVal;
                }
                return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
            });

            const xValues = entityData.map(row => row[xCol]);
            const yValues = entityData.map(row => row.y_value);
            const origValues = entityData.map(row => row.original_value);

            traces.push({
                x: xValues,
                y: yValues,
                type: 'scatter',
                mode: 'lines+markers',
                name: entity,
                line: {
                    color: entityColors[entity],
                    width: 3
                },
                marker: {size: 6},
                customdata: origValues,
                hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                              (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                              '<extra></extra>'
            });
        });

        const layout = {
            xaxis: {title: xCol},
            yaxis: {
                title: yMode === 'Ranking' ? 'Rank' : 'Performance',
                autorange: yMode === 'Ranking' ? 'reversed' : true  // Rank 1 at top
            },
            hovermode: 'closest',
            showlegend: true
        };

        Plotly.newPlot('bump_rankings', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('bump_rankings', traces);
        });
    }

    // Render with one facet
    function renderOneFacet(data, xCol, yMode, facetCol, perfCol) {
        const facetValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nFacets = facetValues.length;

        // Calculate grid dimensions (prefer wider grids)
        const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
        const nRows = Math.ceil(nFacets / nCols);

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        facetValues.forEach((facetVal, idx) => {
            const rawFacetData = data.filter(row => row[facetCol] === facetVal);

            // Calculate rankings within this facet
            let facetData;
            if (yMode === 'Ranking') {
                facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
            } else {
                facetData = rawFacetData.map(row => ({
                    ...row,
                    y_value: row[perfCol],
                    original_value: row[perfCol]
                }));
            }

            const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

            const row = Math.floor(idx / nCols) + 1;
            const col = (idx % nCols) + 1;
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

            entities.forEach(entity => {
                const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                entityData.sort((a, b) => {
                    const aVal = a[xCol];
                    const bVal = b[xCol];
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }
                    return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                });

                const xValues = entityData.map(row => row[xCol]);
                const yValues = entityData.map(row => row.y_value);
                const origValues = entityData.map(row => row.original_value);

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: entity,
                    legendgroup: entity,
                    showlegend: idx === 0,
                    xaxis: xaxis,
                    yaxis: yaxis,
                    line: {
                        color: entityColors[entity],
                        width: 3
                    },
                    marker: {size: 6},
                    customdata: origValues,
                    hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                  (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                  '<extra></extra>'
                });
            });

            // Add axis configuration
            layout[xaxis] = {
                title: row === nRows ? xCol : '',
                anchor: yaxis
            };

            if (yMode === 'Ranking') {
                layout[yaxis] = {
                    title: col === 1 ? 'Rank' : '',
                    anchor: xaxis,
                    autorange: 'reversed'
                };
            } else {
                layout[yaxis] = {
                    title: col === 1 ? 'Performance' : '',
                    anchor: xaxis,
                    autorange: true
                };
            }

            // Add annotation for facet label
            if (!layout.annotations) layout.annotations = [];
            layout.annotations.push({
                text: facetCol + ': ' + facetVal,
                showarrow: false,
                xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                x: 0.5,
                y: 1.05,
                xanchor: 'center',
                yanchor: 'bottom',
                font: {size: 10}
            });
        });

        Plotly.newPlot('bump_rankings', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('bump_rankings', traces);
        });
    }

    // Render with two facets
    function renderTwoFacets(data, xCol, yMode, facetRow, facetCol, perfCol) {
        const rowValues = [...new Set(data.map(row => row[facetRow]))].sort();
        const colValues = [...new Set(data.map(row => row[facetCol]))].sort();
        const nRows = rowValues.length;
        const nCols = colValues.length;

        const traces = [];
        const layout = {
            hovermode: 'closest',
            showlegend: true,
            grid: {rows: nRows, columns: nCols, pattern: 'independent'}
        };

        rowValues.forEach((rowVal, rowIdx) => {
            colValues.forEach((colVal, colIdx) => {
                const rawFacetData = data.filter(row =>
                    row[facetRow] === rowVal && row[facetCol] === colVal
                );

                // Calculate rankings within this facet combination
                let facetData;
                if (yMode === 'Ranking') {
                    facetData = calculateDenseRanks(rawFacetData, xCol, perfCol);
                } else {
                    facetData = rawFacetData.map(row => ({
                        ...row,
                        y_value: row[perfCol],
                        original_value: row[perfCol]
                    }));
                }

                const entities = [...new Set(facetData.map(row => String(row[ENTITY_COL])))].sort();

                const idx = rowIdx * nCols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                entities.forEach(entity => {
                    const entityData = facetData.filter(row => String(row[ENTITY_COL]) === entity);
                    entityData.sort((a, b) => {
                        const aVal = a[xCol];
                        const bVal = b[xCol];
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }
                        return aVal < bVal ? -1 : (aVal > bVal ? 1 : 0);
                    });

                    const xValues = entityData.map(row => row[xCol]);
                    const yValues = entityData.map(row => row.y_value);
                    const origValues = entityData.map(row => row.original_value);

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: entity,
                        legendgroup: entity,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: entityColors[entity],
                            width: 3
                        },
                        marker: {size: 6},
                        customdata: origValues,
                        hovertemplate: entity + '<br>' + xCol + ': %{x}<br>' +
                                      (yMode === 'Ranking' ? 'Rank: %{y}<br>Value: %{customdata}' : 'Value: %{y}') +
                                      '<extra></extra>'
                    });
                });

                // Add axis configuration
                layout[xaxis] = {
                    title: rowIdx === nRows - 1 ? xCol : '',
                    anchor: yaxis
                };

                if (yMode === 'Ranking') {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Rank' : '',
                        anchor: xaxis,
                        autorange: 'reversed'
                    };
                } else {
                    layout[yaxis] = {
                        title: colIdx === 0 ? 'Performance' : '',
                        anchor: xaxis,
                        autorange: true
                    };
                }

                // Add annotations for facet labels
                if (!layout.annotations) layout.annotations = [];

                // Column header
                if (rowIdx === 0) {
                    layout.annotations.push({
                        text: facetCol + ': ' + colVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 0.5,
                        y: 1.1,
                        xanchor: 'center',
                        yanchor: 'bottom',
                        font: {size: 10}
                    });
                }

                // Row label
                if (colIdx === nCols - 1) {
                    layout.annotations.push({
                        text: facetRow + ': ' + rowVal,
                        showarrow: false,
                        xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                        yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                        x: 1.05,
                        y: 0.5,
                        xanchor: 'left',
                        yanchor: 'middle',
                        textangle: -90,
                        font: {size: 10}
                    });
                }
            });
        });

        Plotly.newPlot('bump_rankings', traces, layout, {responsive: true}).then(() => {
            setupCrossFacetHighlighting('bump_rankings', traces);
        });
    }

    // Setup cross-facet highlighting (hover over one line greys out all others)
    function setupCrossFacetHighlighting(chartId, allTraces) {
        const chartDiv = document.getElementById(chartId);
        const originalColors = allTraces.map(t => t.line.color);

        chartDiv.on('plotly_hover', function(data) {
            if (!data.points || data.points.length === 0) return;

            const hoveredEntity = data.points[0].data.name;

            // Update all traces: hovered stays colored, others turn grey
            const updates = allTraces.map((trace, idx) => {
                if (trace.name === hoveredEntity) {
                    return originalColors[idx];  // Keep original color
                } else {
                    return 'rgba(200, 200, 200, 0.3)';  // Grey out
                }
            });

            Plotly.restyle(chartId, {'line.color': updates});
        });

        chartDiv.on('plotly_unhover', function() {
            // Restore all original colors
            Plotly.restyle(chartId, {'line.color': originalColors});
        });
    }

    // Load and parse CSV data using centralized parser
    loadDataset('rankings_data').then(function(data) {
        allData = data;
        window.updateChart_bump_rankings();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('bump_rankings');
    }).catch(function(error) {
        console.error('Error loading data for chart bump_rankings:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="countries_geo_data" data-format="parquet" data-src="data/countries_geo_data.parquet"></script><script type="text/plain" id="product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="sankey_data" data-format="parquet" data-src="data/sankey_data.parquet"></script><script type="text/plain" id="stock_corr_data" data-format="parquet" data-src="data/stock_corr_data.parquet"></script><script type="text/plain" id="exec_data.tob" data-format="parquet" data-src="data/exec_data/tob.parquet"></script><script type="text/plain" id="exec_data.summary_usd" data-format="parquet" data-src="data/exec_data/summary_usd.parquet"></script><script type="text/plain" id="exec_data.fill_returns" data-format="parquet" data-src="data/exec_data/fill_returns.parquet"></script><script type="text/plain" id="surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script><script type="text/plain" id="exec_data.summary_bps" data-format="parquet" data-src="data/exec_data/summary_bps.parquet"></script><script type="text/plain" id="radar_data" data-format="parquet" data-src="data/radar_data.parquet"></script><script type="text/plain" id="cities_geo_data" data-format="parquet" data-src="data/cities_geo_data.parquet"></script><script type="text/plain" id="rankings_data" data-format="parquet" data-src="data/rankings_data.parquet"></script><script type="text/plain" id="exec_data.summary_pct" data-format="parquet" data-src="data/exec_data/summary_pct.parquet"></script><script type="text/plain" id="exec_data.fills" data-format="parquet" data-src="data/exec_data/fills.parquet"></script><script type="text/plain" id="sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="exec_data.volume" data-format="parquet" data-src="data/exec_data/volume.parquet"></script><script type="text/plain" id="tsne_stock_data" data-format="parquet" data-src="data/tsne_stock_data.parquet"></script><script type="text/plain" id="daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="boxwhiskers_data" data-format="parquet" data-src="data/boxwhiskers_data.parquet"></script><script type="text/plain" id="waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="candlestick_data" data-format="parquet" data-src="data/candlestick_data.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>Situational Charts</h1>
<p>This shows examples of Waterfall, SanKey, RadarChart, and BumpChart. Waterfall charts display cumulative effects of sequential positive and negative values. SanKey (alluvial) diagrams show how entities flow between categories over time. RadarChart (spider chart) displays multi-dimensional data on axes radiating from a central point, ideal for comparing items across multiple metrics. BumpChart shows rankings over time with dense ranking and cross-facet highlighting.</p>

<h2>Profit & Loss Waterfall</h2>
<p>A Waterfall chart visualizes how an initial value is affected by a series of positive and negative values. This example shows a profit & loss statement. <strong>Features:</strong> Automatic cumulative calculation, side-by-side table grouped by category, click bars or table rows to exclude items, toggle categories with checkboxes, switch between value-based (green/red) and category-based coloring, black total bar (toggleable). <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/waterfall_examples.html" style="color: blue; font-weight: bold;">See here for more Waterfall examples</a></p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_mode_waterfall">Color By: </label>
                <select id="color_mode_waterfall" onchange="updateChart_waterfall()">
                <option value="Value (Positive/Negative)" selected>Value (Positive/Negative)</option>
                <option value="Category">Category</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_mode_waterfall_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="waterfall_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="waterfall_aspect_ratio_label">0.4</span>
    <input type="range" id="waterfall_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="waterfall"></div>
<style>
    .waterfall-layout-waterfall {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .waterfall-chart-section-waterfall {
        width: 100%;
        max-width: 1200px;
    }

    .waterfall-table-section-waterfall {
        background-color: #f9f9f9;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow-x: auto;
        max-width: 800px;
    }

    .waterfall-table-waterfall {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    .waterfall-table-waterfall th,
    .waterfall-table-waterfall td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .waterfall-table-waterfall th {
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
    }

    .waterfall-table-waterfall tr.removed {
        opacity: 0.3;
        text-decoration: line-through;
        background-color: #e0e0e0 !important;
    }

    .waterfall-table-waterfall tr.positive {
        background-color: #d5f4e6;
    }

    .waterfall-table-waterfall tr.negative {
        background-color: #fadbd8;
    }

    .waterfall-table-waterfall tr.total {
        background-color: #d6eaf8;
        font-weight: bold;
        border-top: 2px solid #333;
    }

    .waterfall-table-waterfall tr:hover:not(.removed) {
        background-color: #fffacd !important;
        cursor: pointer;
    }

    .waterfall-reset-btn-waterfall {
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #ff5722;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .waterfall-reset-btn-waterfall:hover {
        background-color: #e64a19;
    }
</style>
<div class="waterfall-layout-waterfall">
    <div class="waterfall-chart-section-waterfall">
        <!-- Chart will be rendered here -->
    </div>
    <div class="waterfall-table-section-waterfall">
                <h4>Calculation Table</h4>
                <p style="font-size: 0.85em; color: #666; margin-top: 0;">Click on category headers to toggle groups, or individual rows to exclude items</p>
                <div id="waterfall_table_container_waterfall">
                    <!-- Table will be generated by JavaScript -->
                </div>
                <button class="waterfall-reset-btn-waterfall" onclick="resetWaterfall_waterfall()">🔄 Reset All</button>
            </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: waterfall_data.parquet</p><br>
<hr>
<br>
<h2>Trader Portfolio Evolution (2015-2023)</h2>
<p>A SanKey diagram showing how 50 traders' portfolios evolved from 2015 to 2023. Use the 'Affiliation' dropdown to switch between crypto holdings and stock holdings. The ribbon width represents portfolio value. In 2015, all traders held Bitcoin; by 2023, holdings diversified into various cryptocurrencies and stock categories. Notice migration patterns: early Bitcoin holders moving to Ethereum/Solana, and tech stock investors shifting to growth/crypto stocks. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/sankey_examples.html" style="color: blue; font-weight: bold;">See here for SanKey examples</a></p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="color_col_ribbon">Affiliation: </label>
                <select id="color_col_ribbon" onchange="updateChart_ribbon()">
                <option value="crypto_holding" selected>crypto_holding</option>
                <option value="stock_holding">stock_holding</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="color_col_ribbon_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="ribbon_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="ribbon_aspect_ratio_label">0.4</span>
    <input type="range" id="ribbon_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="ribbon"></div>
<style>
    .sankey-container-ribbon {
        width: 100%;
        max-width: 1200px;
        margin: 20px auto;
    }
</style>
<div class="sankey-container-ribbon">
    <div id="ribbon"></div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sankey_data.parquet</p><br>
<hr>
<br>
<div class="chart-container" id="container_product_radar">
    <h3>Product Performance RadarChart</h3>
    <p>RadarChart (spider chart) displaying many dimensions in a geometric way. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/radarchart_examples.html" style="color: blue; font-weight: bold;">See here for RadarChart examples</a></p>
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        <div style="flex: 0 0 auto; min-width: 200px;">

<div style="margin-bottom: 15px;">
    <label for="scenario_select_product_radar"><strong>Scenario:</strong></label>
    <select id="scenario_select_product_radar" onchange="updateRadarChart_product_radar()">
        <!-- Options will be populated dynamically -->
    </select>
</div>

<div style="margin-bottom: 15px;">
    <label for="var_select_product_radar"><strong>Select variables:</strong></label>
    <select id="var_select_product_radar" multiple size="8" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_product_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

<div style="margin-bottom: 15px;">
    <label for="label_select_product_radar"><strong>Select items to display:</strong></label>
    <select id="label_select_product_radar" multiple size="6" style="width: 100%; max-width: 300px;" onchange="updateRadarChart_product_radar()">
        <!-- Options will be populated dynamically -->
    </select>
    <div style="margin-top: 5px; font-size: 0.9em; color: #666;">
        Hold Ctrl (Cmd on Mac) to select multiple
    </div>
</div>

        </div>
        <div style="flex: 1 1 auto; min-width: 400px;">
            <div id="radar_product_radar" style="width: 100%;"></div>
        </div>
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: radar_data.parquet</p><br>
<hr>
<br>
<h2>Product Rankings Over Time</h2>
<p>A BumpChart shows how entities rank over time based on different performance metrics. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/bumpchart_examples.html" style="color: blue; font-weight: bold;">See here for BumpChart examples</a></p>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0; display: flex; justify-content: space-between; align-items: center;">
        <span>Filters</span>
        <span id="bump_rankings_total_obs" style="font-weight: normal; font-size: 0.9em; color: #666;"></span>
    </h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="segment_select_bump_rankings">segment: </label>
                <select id="segment_select_bump_rankings" multiple onchange="updateChart_bump_rankings()">
                <option value="Consumer" selected>Consumer</option>
                <option value="Enterprise" selected>Enterprise</option>
                <option value="SMB" selected>SMB</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="segment_select_bump_rankings_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
                <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="region_select_bump_rankings">region: </label>
                <select id="region_select_bump_rankings" multiple onchange="updateChart_bump_rankings()">
                <option value="North" selected>North</option>
                <option value="South" selected>South</option>
                <option value="West" selected>West</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="region_select_bump_rankings_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        
</div>

<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="y_mode_select_bump_rankings">Y-axis Mode: </label>
                <select id="y_mode_select_bump_rankings" onchange="updateChart_bump_rankings()">
                <option value="Ranking" selected>Ranking</option>
                <option value="Absolute">Absolute</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="y_mode_select_bump_rankings_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
            <div style="background-color: #f0f8ff; padding: 10px; margin: 10px 0; border-radius: 5px;">
        <h4 style="margin: 0 0 10px 0;">Performance Metric</h4>
        <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="perf_col_select_bump_rankings">Metric: </label>
                <select id="perf_col_select_bump_rankings" onchange="updateChart_bump_rankings()">
                    <option value="sales_total" selected>sales_total</option>
                    <option value="profit_total">profit_total</option>
                    <option value="quantity_total">quantity_total</option>
                    <option value="satisfaction_avg">satisfaction_avg</option>
                </select>
            </div>
        </div>
    </div>
<h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Facets</h4>
<div style="margin: 10px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label for="facet1_select_bump_rankings">Facet 1: </label>
        <select id="facet1_select_bump_rankings" style="padding: 5px 10px;" onchange="updateChart_bump_rankings()">
            <option value="None">None</option>
<option value="region" selected>region</option>
<option value="segment">segment</option>
        </select>
    </div>
    <div>
        <label for="facet2_select_bump_rankings">Facet 2: </label>
        <select id="facet2_select_bump_rankings" style="padding: 5px 10px;" onchange="updateChart_bump_rankings()">
            <option value="None">None</option>
<option value="region">region</option>
<option value="segment" selected>segment</option>
        </select>
    </div>
</div>

<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="bump_rankings_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="bump_rankings_aspect_ratio_label">0.3</span>
    <input type="range" id="bump_rankings_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-1.2039728043259361"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="bump_rankings"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: rankings_data.parquet</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.5.2.</small></p>
</body>
</html>
