<!DOCTYPE html>
<html>
<head>
    <title>Distributional Charts</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\\d{4}-\\d{2}-\\d{2}\$/;  // YYYY-MM-DD
    var datetimePattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;  // YYYY-MM-DDTHH:MM:SS

    // Check first row to identify date columns
    var firstRow = data[0];
    var dateColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                }
            }
        }
    }

    // If no date columns found, return data unchanged
    if (dateColumns.length === 0) return data;

    // Convert date strings to Date objects in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

    // Plotly default colors
    var plotlyColors = [
        'rgb(31, 119, 180)', 'rgb(255, 127, 14)', 'rgb(44, 160, 44)',
        'rgb(214, 39, 40)', 'rgb(148, 103, 189)', 'rgb(140, 86, 75)',
        'rgb(227, 119, 194)', 'rgb(127, 127, 127)', 'rgb(188, 189, 34)',
        'rgb(23, 190, 207)'
    ];
    
    // Initialize toggle states
    window.showHistogram_dist = true;
    window.showBox_dist = true;
    window.showRug_dist = true;
    
    // Load and parse CSV data using centralized parser
    loadDataset('sales_data').then(function(data) {
        window.allData_dist = data;

        // Initialize buttons and sliders after data is loaded
        $(function() {
                

                    document.getElementById('dist_value_selector').addEventListener('change', function() {
        updatePlotWithFilters_dist();
    });


                    document.getElementById('dist_group_selector').addEventListener('change', function() {
        updatePlotWithFilters_dist();
    });


                    document.getElementById('dist_bins_slider').addEventListener('input', function() {
        var bins = parseInt(this.value);
        document.getElementById('dist_bins_label').textContent = bins;
        updatePlotWithFilters_dist();
    });


            // Initial plot
            updatePlotWithFilters_dist();
        });
    }).catch(function(error) {
        console.error('Error loading data for chart dist:', error);
    });

    function updatePlot_dist(data) {
        var traces = [];

        // Get current selections from dropdowns
var currentValueCol = document.getElementById('dist_value_selector').value;
var currentGroupCol = document.getElementById('dist_group_selector').value;

// Handle "None" option for group selector
if (currentGroupCol === '_none_') {
    currentGroupCol = null;
}

// Get current bins from slider
var binsSlider = document.getElementById('dist_bins_slider');
var currentBins = binsSlider ? parseInt(binsSlider.value) : 30;

if (currentGroupCol) {
    // Group data by group column
    var groups = {};
    data.forEach(function(row) {
        var key = row[currentGroupCol];
        if (!groups[key]) groups[key] = [];
        groups[key].push(row);
    });

    var groupKeys = Object.keys(groups);
    var numGroups = groupKeys.length;

    // Create traces for each group
    groupKeys.forEach(function(key, idx) {
        var groupData = groups[key];
        var values = groupData.map(d => d[currentValueCol]);

        // Box plot (top portion)
        if (window.showBox_dist) {
            traces.push({
                x: values,
                name: key,
                type: 'box',
                xaxis: 'x2',
                yaxis: 'y2',
                orientation: 'h',
                marker: {
                    color: plotlyColors[idx % plotlyColors.length]
                },
                boxmean: 'sd',
                opacity: 0.7,
                showlegend: false
            });
        }

        // Histogram (bottom portion)
        if (window.showHistogram_dist) {
            traces.push({
                x: values,
                name: key,
                type: 'histogram',
                xaxis: 'x',
                yaxis: 'y',
                marker: {
                    color: plotlyColors[idx % plotlyColors.length]
                },
                opacity: 0.7,
                nbinsx: currentBins
            });
        }

        // Rug plot (tick marks at bottom)
        if (window.showRug_dist) {
            traces.push({
                x: values,
                name: key + ' rug',
                type: 'scatter',
                mode: 'markers',
                xaxis: 'x',
                yaxis: 'y3',
                marker: {
                    symbol: 'line-ns-open',
                    color: plotlyColors[idx % plotlyColors.length],
                    size: 8,
                    line: {
                        width: 1
                    }
                },
                showlegend: false,
                hoverinfo: 'x'
            });
        }
    });
} else {
    // No grouping
    var values = data.map(d => d[currentValueCol]);

    // Box plot (top portion)
    if (window.showBox_dist) {
        traces.push({
            x: values,
            name: 'distribution',
            type: 'box',
            xaxis: 'x2',
            yaxis: 'y2',
            orientation: 'h',
            marker: {
                color: 'rgb(31, 119, 180)'
            },
            boxmean: 'sd',
            opacity: 0.7,
            showlegend: false
        });
    }

    // Histogram (bottom portion)
    if (window.showHistogram_dist) {
        traces.push({
            x: values,
            name: 'frequency',
            type: 'histogram',
            xaxis: 'x',
            yaxis: 'y',
            marker: {
                color: 'rgb(31, 119, 180)'
            },
            opacity: 0.7,
            nbinsx: currentBins,
            showlegend: false
        });
    }

    // Rug plot (tick marks at bottom)
    if (window.showRug_dist) {
        traces.push({
            x: values,
            name: 'rug',
            type: 'scatter',
            mode: 'markers',
            xaxis: 'x',
            yaxis: 'y3',
            marker: {
                symbol: 'line-ns-open',
                color: 'rgb(31, 119, 180)',
                size: 8,
                line: {
                    width: 1
                }
            },
            showlegend: false,
            hoverinfo: 'x'
        });
    }
}


            var layout = {
        title: 'Distribution Plot',
        showlegend: currentGroupCol !== null,
        autosize: true,
        grid: {
            rows: 3,
            columns: 1,
            pattern: 'independent',
            roworder: 'top to bottom'
        },
        xaxis: {
            title: currentValueCol,
            domain: [0, 1],
            showgrid: true,
            zeroline: true
        },
        yaxis: {
            title: 'Frequency',
            domain: [0.07, 0.69],
            showgrid: true,
            zeroline: true
        },
        xaxis2: {
            domain: [0, 1],
            showgrid: false,
            showticklabels: false
        },
        yaxis2: {
            domain: [0.7, 1],
            showgrid: false,
            showticklabels: false
        },
        xaxis3: {
            domain: [0, 1],
            showgrid: false,
            showticklabels: false
        },
        yaxis3: {
            domain: [0, 0.05],
            showgrid: false,
            showticklabels: false
        },
        margin: {t: 100, r: 50, b: 100, l: 80}
    };


        Plotly.newPlot('dist', traces, layout, {responsive: true});
    }

    // Filter and update function
    window.updatePlotWithFilters_dist = function() {
        const FILTER_COLS = ['segment', 'region', 'product'];

        // Get filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_dist');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = window.allData_dist.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Render with filtered data
        updatePlot_dist(filteredData);
    };
    (function() {
    // Plotly default colors
    const plotlyColors = [
        'rgb(31, 119, 180)', 'rgb(255, 127, 14)', 'rgb(44, 160, 44)',
        'rgb(214, 39, 40)', 'rgb(148, 103, 189)', 'rgb(140, 86, 75)',
        'rgb(227, 119, 194)', 'rgb(127, 127, 127)', 'rgb(188, 189, 34)',
        'rgb(23, 190, 207)'
    ];

    const BANDWIDTH = null; // Auto-calculate

    // Kernel density estimation function
    function kernelDensity(values, bandwidth) {
        // Use Silverman's rule of thumb if bandwidth not specified
        if (!bandwidth) {
            const n = values.length;
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const std = Math.sqrt(values.reduce((sum, x) => {
                return sum + Math.pow(x - mean, 2);
            }, 0) / n);
            bandwidth = 1.06 * std * Math.pow(n, -0.2);
        }

        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min;
        const points = 200;
        const step = range / points;

        const x = [];
        const y = [];

        for (let i = 0; i <= points; i++) {
            const xi = min - range * 0.1 + (range * 1.2) * i / points;
            x.push(xi);

            let density = 0;
            for (let j = 0; j < values.length; j++) {
                const u = (xi - values[j]) / bandwidth;
                // Gaussian kernel
                density += Math.exp(-0.5 * u * u) / Math.sqrt(2 * Math.PI);
            }
            y.push(density / (values.length * bandwidth));
        }

        return {x: x, y: y};
    }

    const getCol = (id, def) => { const el = document.getElementById(id); return el ? el.value : def; };

    function createDensityTraces(data, VALUE_COL, GROUP_COL, BANDWIDTH, xaxis='x', yaxis='y', showlegend=true) {
        const traces = [];

        if (GROUP_COL) {
            // Group data by group column
            const groups = {};
            data.forEach(function(row) {
                const key = row[GROUP_COL];
                if (!groups[key]) groups[key] = [];
                groups[key].push(row);
            });

            const groupKeys = Object.keys(groups);

            groupKeys.forEach(function(key, idx) {
                const groupData = groups[key];
                const values = groupData.map(d => parseFloat(d[VALUE_COL])).filter(v => !isNaN(v));

                if (values.length > 0) {
                    const kde = kernelDensity(values, BANDWIDTH);

                    traces.push({
                        x: kde.x,
                        y: kde.y,
                        name: key,
                        type: 'scatter',
                        mode: 'lines',
                        fill: 'tozeroy',
                        line: {
                            color: plotlyColors[idx % plotlyColors.length],
                            width: 2
                        },
                        fillcolor: plotlyColors[idx % plotlyColors.length].replace('rgb', 'rgba').replace(')', ', 0.6)'),
                        xaxis: xaxis,
                        yaxis: yaxis,
                        showlegend: showlegend,
                        legendgroup: key
                    });
                }
            });
        } else {
            // Single group
            const values = data.map(d => parseFloat(d[VALUE_COL])).filter(v => !isNaN(v));

            if (values.length > 0) {
                const kde = kernelDensity(values, BANDWIDTH);

                traces.push({
                    x: kde.x,
                    y: kde.y,
                    name: 'Density',
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tozeroy',
                    line: {
                        color: 'rgb(31, 119, 180)',
                        width: 2
                    },
                    fillcolor: 'rgba(31, 119, 180, 0.6)',
                    xaxis: xaxis,
                    yaxis: yaxis,
                    showlegend: false
                });
            }
        }

        return traces;
    }

    function renderNoFacets(data, VALUE_COL, GROUP_COL, BANDWIDTH) {
        const traces = createDensityTraces(data, VALUE_COL, GROUP_COL, BANDWIDTH);

        Plotly.newPlot('kde', traces, {
            title: 'Kernel Density Plot',
            showlegend: GROUP_COL !== null,
            autosize: true,
            hovermode: 'closest',
            xaxis: {
                title: VALUE_COL,
                showgrid: true,
                zeroline: true
            },
            yaxis: {
                title: 'Density',
                showgrid: true,
                zeroline: true
            },
            margin: {t: 100, r: 50, b: 100, l: 80}
        }, {responsive: true});
    }

    function renderFacetWrap(data, VALUE_COL, GROUP_COL, FACET_COL, BANDWIDTH) {
        const facetValues = [...new Set(data.map(row => row[FACET_COL]))].sort();
        const nFacets = facetValues.length;
        const cols = Math.ceil(Math.sqrt(nFacets));
        const rows = Math.ceil(nFacets / cols);
        const traces = [];

        facetValues.forEach((facetVal, idx) => {
            const facetData = data.filter(row => row[FACET_COL] === facetVal);
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);
            traces.push(...createDensityTraces(facetData, VALUE_COL, GROUP_COL, BANDWIDTH, xaxis, yaxis, idx === 0));
        });

        const layout = {
            title: 'Kernel Density Plot',
            showlegend: GROUP_COL !== null,
            grid: {rows: rows, columns: cols, pattern: 'independent'},
            annotations: facetValues.map((val, idx) => ({
                text: FACET_COL + ': ' + val,
                showarrow: false,
                xref: (idx === 0 ? 'x' : 'x' + (idx + 1)) + ' domain',
                yref: (idx === 0 ? 'y' : 'y' + (idx + 1)) + ' domain',
                x: 0.5,
                y: 1.1,
                xanchor: 'center',
                yanchor: 'bottom'
            })),
            margin: {t: 100, r: 50, b: 50, l: 50}
        };

        facetValues.forEach((val, idx) => {
            const ax = idx === 0 ? '' : (idx + 1);
            layout['xaxis' + ax] = {title: VALUE_COL};
            layout['yaxis' + ax] = {title: 'Density'};
        });

        Plotly.newPlot('kde', traces, layout, {responsive: true});
    }

    function renderFacetGrid(data, VALUE_COL, GROUP_COL, FACET1_COL, FACET2_COL, BANDWIDTH) {
        const facet1Values = [...new Set(data.map(row => row[FACET1_COL]))].sort();
        const facet2Values = [...new Set(data.map(row => row[FACET2_COL]))].sort();
        const rows = facet1Values.length;
        const cols = facet2Values.length;
        const traces = [];

        facet1Values.forEach((facet1Val, rowIdx) => {
            facet2Values.forEach((facet2Val, colIdx) => {
                const facetData = data.filter(row =>
                    row[FACET1_COL] === facet1Val && row[FACET2_COL] === facet2Val
                );

                if (facetData.length === 0) return;

                const idx = rowIdx * cols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);
                traces.push(...createDensityTraces(facetData, VALUE_COL, GROUP_COL, BANDWIDTH, xaxis, yaxis, idx === 0));
            });
        });

        const layout = {
            title: 'Kernel Density Plot',
            showlegend: GROUP_COL !== null,
            grid: {rows: rows, columns: cols, pattern: 'independent'},
            annotations: [
                ...facet2Values.map((val, colIdx) => ({
                    text: FACET2_COL + ': ' + val,
                    showarrow: false,
                    xref: (colIdx === 0 ? 'x' : 'x' + (colIdx + 1)) + ' domain',
                    yref: (colIdx === 0 ? 'y' : 'y' + (colIdx + 1)) + ' domain',
                    x: 0.5,
                    y: 1.1,
                    xanchor: 'center',
                    yanchor: 'bottom'
                })),
                ...facet1Values.map((val, rowIdx) => ({
                    text: FACET1_COL + ': ' + val,
                    showarrow: false,
                    xref: (rowIdx * cols === 0 ? 'x' : 'x' + (rowIdx * cols + 1)) + ' domain',
                    yref: (rowIdx * cols === 0 ? 'y' : 'y' + (rowIdx * cols + 1)) + ' domain',
                    x: -0.15,
                    y: 0.5,
                    xanchor: 'center',
                    yanchor: 'middle',
                    textangle: -90
                }))
            ],
            margin: {t: 100, r: 50, b: 50, l: 50}
        };

        facet1Values.forEach((v1, rowIdx) => {
            facet2Values.forEach((v2, colIdx) => {
                const idx = rowIdx * cols + colIdx;
                const ax = idx === 0 ? '' : (idx + 1);
                layout['xaxis' + ax] = {title: VALUE_COL};
                layout['yaxis' + ax] = {title: 'Density'};
            });
        });

        Plotly.newPlot('kde', traces, layout, {responsive: true});
    }

    function updatePlot_kde(data) {
        // Get current value column from dropdown or use default
        const VALUE_COL = document.getElementById('kde_value_selector').value;

        // Get current group column from dropdown or use default
        let GROUP_COL = document.getElementById('kde_group_selector').value;

        // Handle "None" option for group selector
        if (GROUP_COL === '_none_') {
            GROUP_COL = null;
        }

        // Get bandwidth from slider (0 means auto)
        const bandwidthSlider = document.getElementById('kde_bandwidth_slider');
        const BANDWIDTH = bandwidthSlider ? parseFloat(bandwidthSlider.value) : 0.0;

        let FACET1 = getCol('facet1_select_kde', null);
        let FACET2 = getCol('facet2_select_kde', null);
        if (FACET1 === 'None') FACET1 = null;
        if (FACET2 === 'None') FACET2 = null;

        if (FACET1 && FACET2) {
            renderFacetGrid(data, VALUE_COL, GROUP_COL, FACET1, FACET2, BANDWIDTH);
        } else if (FACET1) {
            renderFacetWrap(data, VALUE_COL, GROUP_COL, FACET1, BANDWIDTH);
        } else {
            renderNoFacets(data, VALUE_COL, GROUP_COL, BANDWIDTH);
        }
    }

    // Wrapper function
    window.updateChart_kde = () => updatePlotWithFilters_kde();

    // Filter and update function
    window.updatePlotWithFilters_kde = function() {
        const FILTER_COLS = ['segment', 'region', 'product'];

        // Get filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_kde');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = window.allData_kde.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Render with filtered data
        updatePlot_kde(filteredData);
    };

    // Load and parse CSV data using centralized parser
    loadDataset('sales_data').then(function(data) {
        window.allData_kde = data;

        // Initialize controls after data is loaded
        $(function() {
                document.getElementById('kde_value_selector').addEventListener('change', function() {
        updateChart_kde();
    });


                document.getElementById('kde_group_selector').addEventListener('change', function() {
        updateChart_kde();
    });


                document.getElementById('kde_bandwidth_slider').addEventListener('input', function() {
        var bw = parseFloat(this.value);
        document.getElementById('kde_bandwidth_label').textContent = bw === 0 ? 'auto' : bw.toFixed(2);
        updateChart_kde();
    });


            // Initial plot
            updatePlotWithFilters_kde();
        });
    }).catch(function(error) {
        console.error('Error loading data for chart kde:', error);
    });
    })();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const VALUE_COLS = ['sales', 'profit', 'quantity', 'cost', 'customers', 'satisfaction'];
    const COLOR_COLS = ['region', 'product', 'segment', 'month', 'quarter'];
    const COLOR_MAPS = {'month': {'4': '#ab63fa', '1': '#636efa', '12': '#EF553B', '2': '#EF553B', '6': '#19d3f3', '7': '#FF6692', '11': '#636efa', '8': '#B6E880', '5': '#FFA15A', '10': '#FECB52', '9': '#FF97FF', '3': '#00cc96'}, 'segment': {'SMB': '#636efa', 'Enterprise': '#00cc96', 'Consumer': '#EF553B'}, 'quarter': {'4': '#ab63fa', '1': '#636efa', '2': '#EF553B', '3': '#00cc96'}, 'region': {'West': '#00cc96', 'North': '#636efa', 'South': '#EF553B'}, 'product': {'Phone': '#00cc96', 'Laptop': '#636efa', 'Tablet': '#EF553B'}};
    const DEFAULT_VALUE_COL = 'sales';
    const DEFAULT_COLOR_COL = 'region';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_pie = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_pie');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_pie');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_pie');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_pie');
        const facet2Select = document.getElementById('facet2_select_pie');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('pie', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('pie', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('pie', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('sales_data').then(function(data) {
        allData = data;
        window.updateChart_pie();
    }).catch(function(error) {
        console.error('Error loading data for chart pie:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="daily_product" data-format="parquet" data-src="data/daily_product.parquet"></script><script type="text/plain" id="business_path_data" data-format="parquet" data-src="data/business_path_data.parquet"></script><script type="text/plain" id="sales_data" data-format="parquet" data-src="data/sales_data.parquet"></script><script type="text/plain" id="product_summary" data-format="parquet" data-src="data/product_summary.parquet"></script><script type="text/plain" id="waterfall_data" data-format="parquet" data-src="data/waterfall_data.parquet"></script><script type="text/plain" id="surface_df" data-format="parquet" data-src="data/surface_df.parquet"></script><script type="text/plain" id="sankey_data" data-format="parquet" data-src="data/sankey_data.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>Distributional Charts</h1>
<p>This shows examples of DistPlot, KernelDensity and PieChart.</p>

    <div class="textblock-content">
        <h1>Distributional Plots</h1>
    </div>
<br>
<hr>
<br>
<h2>Distribution Plot</h2>
<p>This makes a historgram, box and whiskers and rugplot. So you can see differences in distribution for a variable between different groups of observations. Note at the bottom there is a slider for changing the number of bins in the histogram. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/distplot_examples.html" style="color: blue; font-weight: bold;">See here for DistPlot examples</a></p>

<!-- Filters (for data filtering) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0;">Filters</h4>
            <div style="margin: 10px;">
            <label for="segment_select_dist">segment: </label>
            <select id="segment_select_dist" multiple onchange="updatePlotWithFilters_dist()">
                <option value="Consumer" selected>Consumer</option>
                <option value="Enterprise" selected>Enterprise</option>
                <option value="SMB" selected>SMB</option>
            </select>
        </div>
        
        <div style="margin: 10px;">
            <label for="region_select_dist">region: </label>
            <select id="region_select_dist" multiple onchange="updatePlotWithFilters_dist()">
                <option value="North" selected>North</option>
                <option value="South" selected>South</option>
                <option value="West" selected>West</option>
            </select>
        </div>
        
        <div style="margin: 10px;">
            <label for="product_select_dist">product: </label>
            <select id="product_select_dist" multiple onchange="updatePlotWithFilters_dist()">
                <option value="Laptop" selected>Laptop</option>
                <option value="Phone" selected>Phone</option>
                <option value="Tablet" selected>Tablet</option>
            </select>
        </div>
        
</div>

<!-- Plot Attributes -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <div style="margin: 20px 0;">
        <label for="dist_value_selector">Select variable: </label>
    <select id="dist_value_selector" style="padding: 5px 10px;">
        <option value="profit" selected>profit</option>
<option value="sales">sales</option>
<option value="cost">cost</option>
<option value="quantity">quantity</option>
<option value="customers">customers</option>
<option value="satisfaction">satisfaction</option>
    </select>

        <label for="dist_group_selector" style="margin-left: 20px;">Group by: </label>
    <select id="dist_group_selector" style="padding: 5px 10px;">
        <option value="_none_">None</option>
<option value="region" selected>region</option>
<option value="product">product</option>
<option value="segment">segment</option>
    </select>

</div>

</div>

<!-- Faceting -->

<!-- Chart -->
<div id="dist"></div>

        <!-- Bins slider below chart -->
        <div style="margin: 20px 0;">
    <label for="dist_bins_slider">Number of bins: </label>
    <span id="dist_bins_label">30</span>
    <input type="range" id="dist_bins_slider"
           min="5"
           max="100"
           step="1"
           value="30"
           style="width: 300px; margin-left: 10px;">
</div>

<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p><br>
<hr>
<br>
<h2>Kernel Density Plot</h2>
<p>This shows kernel density estimates for a variable seperated by groups in the observations. It also has faceting available (unlike DistPlot). There is a slider at the bottom for controlling the bandwidth of the kernel density estimate. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/kerneldensity_examples.html" style="color: blue; font-weight: bold;">See here for KernelDensity examples</a></p>

<!-- Filters (for data filtering) -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #fff5f5;">
    <h4 style="margin-top: 0;">Filters</h4>
            <div style="margin: 10px;">
            <label for="segment_select_kde">segment: </label>
            <select id="segment_select_kde" multiple onchange="updatePlotWithFilters_kde()">
                <option value="Consumer" selected>Consumer</option>
                <option value="Enterprise" selected>Enterprise</option>
                <option value="SMB" selected>SMB</option>
            </select>
        </div>
        
        <div style="margin: 10px;">
            <label for="region_select_kde">region: </label>
            <select id="region_select_kde" multiple onchange="updatePlotWithFilters_kde()">
                <option value="North" selected>North</option>
                <option value="South" selected>South</option>
                <option value="West" selected>West</option>
            </select>
        </div>
        
        <div style="margin: 10px;">
            <label for="product_select_kde">product: </label>
            <select id="product_select_kde" multiple onchange="updatePlotWithFilters_kde()">
                <option value="Laptop" selected>Laptop</option>
                <option value="Phone" selected>Phone</option>
                <option value="Tablet" selected>Tablet</option>
            </select>
        </div>
        
</div>

<!-- Plot Attributes -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <div style="margin: 20px 0;">
        <label for="kde_value_selector">Select variable: </label>
    <select id="kde_value_selector" style="padding: 5px 10px;">
        <option value="profit" selected>profit</option>
<option value="sales">sales</option>
<option value="cost">cost</option>
<option value="quantity">quantity</option>
<option value="customers">customers</option>
<option value="satisfaction">satisfaction</option>
    </select>

        <label for="kde_group_selector" style="margin-left: 20px;">Group by: </label>
    <select id="kde_group_selector" style="padding: 5px 10px;">
        <option value="_none_">None</option>
<option value="region" selected>region</option>
<option value="product">product</option>
<option value="segment">segment</option>
    </select>

</div>

</div>

<!-- Faceting -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0f8ff;">
    <h4 style="margin-top: 0;">Faceting</h4>
                <div style="margin: 10px 0; display: flex; gap: 20px; align-items: center;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="facet1_select_kde">Facet 1:</label>
                    <select id="facet1_select_kde" onchange="updateChart_kde()">
                <option value="None">None</option>
                <option value="region">region</option>
                <option value="product">product</option>
                <option value="segment" selected>segment</option>                </select>
                </div>
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="facet2_select_kde">Facet 2:</label>
                    <select id="facet2_select_kde" onchange="updateChart_kde()">
                <option value="None" selected>None</option>
                <option value="region">region</option>
                <option value="product">product</option>
                <option value="segment">segment</option>                </select>
                </div>
            </div>
            
</div>

<!-- Chart -->
<div id="kde"></div>

        <!-- Bandwidth slider below chart -->
        <div style="margin: 20px 0;">
    <label for="kde_bandwidth_slider">Bandwidth: </label>
    <span id="kde_bandwidth_label">auto</span>
    <input type="range" id="kde_bandwidth_slider"
           min="0"
           max="7438.09"
           step="148.7618"
           value="0.0"
           style="width: 300px; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0 = auto, max  7438.1)</span>
</div>

<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p><br>
<hr>
<br>
<h2>Pie Chart</h2>
<p>This gives piecharts. Note that piecharts are generally pretty bad (google it to see more on this) but up to you if you like them. There is faceting available, filtering and you can change the grouping variable and the numeric variable being aggregated over to determine pie width. <a href="https://s-baumann.github.io/JSPlots.jl/dev/examples_html/piechart_examples.html" style="color: blue; font-weight: bold;">See here for PieChart examples</a></p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="value_col_select_pie">Slice size: </label>
            <select id="value_col_select_pie" onchange="updateChart_pie()">
                <option value="sales" selected>sales</option>
                <option value="profit">profit</option>
                <option value="quantity">quantity</option>
                <option value="cost">cost</option>
                <option value="customers">customers</option>
                <option value="satisfaction">satisfaction</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="color_col_select_pie">Slice grouping: </label>
            <select id="color_col_select_pie" onchange="updateChart_pie()">
                <option value="region" selected>region</option>
                <option value="product">product</option>
                <option value="segment">segment</option>
                <option value="month">month</option>
                <option value="quarter">quarter</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="pie"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: sales_data.parquet</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
