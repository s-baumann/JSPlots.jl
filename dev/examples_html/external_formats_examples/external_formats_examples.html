<!DOCTYPE html>
<html>
<head>
    <title>External Format Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    
</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                resolve(results.data);
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                resolve(data);
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        resolve(results.data);
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['date'];
    const Y_COLS = ['value'];
    const COLOR_COLS = ['category'];
    const COLOR_MAPS = {'category': {'B': '#636efa', 'A': '#00cc96', 'C': '#EF553B'}};
    const DEFAULT_X_COL = 'date';
    const DEFAULT_Y_COL = 'value';
    const DEFAULT_COLOR_COL = 'category';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_timeseries = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_timeseries');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_timeseries');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_timeseries');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_timeseries');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_timeseries');
        const facet2Select = document.getElementById('facet2_select_timeseries');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        if (!xGroups[xVal]) xGroups[xVal] = [];
                        xGroups[xVal].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];
                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xVal => {
                        const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // Keep original value type (don't force to float for strings)
                            const numVal = parseFloat(xVal);
                            xValues.push(isNaN(numVal) ? xVal : numVal);
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('timeseries', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            if (!xGroups[xVal]) xGroups[xVal] = [];
                            xGroups[xVal].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];
                        // Sort keys - try numeric sort first, fall back to string sort
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xVal => {
                            const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                // Keep original value type (don't force to float for strings)
                                const numVal = parseFloat(xVal);
                                xValues.push(isNaN(numVal) ? xVal : numVal);
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('timeseries', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                if (!xGroups[xVal]) xGroups[xVal] = [];
                                xGroups[xVal].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];
                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xVal => {
                                const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    const numVal = parseFloat(xVal);
                                    xValues.push(isNaN(numVal) ? xVal : numVal);
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('timeseries', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('df').then(function(data) {
        allData = data;
        window.updateChart_timeseries();
    }).catch(function(error) {
        console.error('Error loading data for chart timeseries:', error);
    });
})();
    (function() {
    const FILTER_COLS = [];
    window.showDensity_stock_scatter = true;
    const POINT_SYMBOLS = ["circle","square","diamond","cross","x","triangle-up","triangle-down","triangle-left","triangle-right","pentagon","hexagon","star"];
    const DEFAULT_X_COL = 'volume';
    const DEFAULT_Y_COL = 'price';
    const DEFAULT_COLOR_COL = 'symbol';

    const getCol = (id, def) => { const el = document.getElementById(id); return el ? el.value : def; };
    const buildSymbolMap = (data, col) => {
        const uniqueVals = [...new Set(data.map(row => row[col]))].sort();
        return Object.fromEntries(uniqueVals.map((val, i) => [val, POINT_SYMBOLS[i % POINT_SYMBOLS.length]]));
    };

    function createTraces(data, X_COL, Y_COL, COLOR_COL, xaxis='x', yaxis='y', showlegend=true) {
        const symbolMap = buildSymbolMap(data, COLOR_COL);
        const groups = {};
        data.forEach(row => {
            const key = row[COLOR_COL];
            if (!groups[key]) groups[key] = [];
            groups[key].push(row);
        });

        return Object.entries(groups).map(([key, groupData]) => ({
            x: groupData.map(d => d[X_COL]),
            y: groupData.map(d => d[Y_COL]),
            mode: 'markers',
            name: key,
            legendgroup: key,
            showlegend: showlegend,
            xaxis: xaxis,
            yaxis: yaxis,
            marker: {
                size: 4,
                opacity: 0.6,
                symbol: groupData.map(d => symbolMap[d[COLOR_COL]])
            },
            type: 'scatter'
        }));
    }

    function renderNoFacets(data, X_COL, Y_COL, COLOR_COL) {
        const traces = createTraces(data, X_COL, Y_COL, COLOR_COL);

        if (window.showDensity_stock_scatter) {
            traces.push({
                x: data.map(d => d[X_COL]), y: data.map(d => d[Y_COL]),
                name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                showscale: false, type: 'histogram2dcontour', showlegend: false
            });
        }

        traces.push(
            { x: data.map(d => d[X_COL]), name: 'x density', marker: {color: 'rgba(128, 128, 128, 0.5)'}, yaxis: 'y2', type: 'histogram', showlegend: false },
            { y: data.map(d => d[Y_COL]), name: 'y density', marker: {color: 'rgba(128, 128, 128, 0.5)'}, xaxis: 'x2', type: 'histogram', showlegend: false }
        );

        Plotly.newPlot('stock_scatter', traces, {
            title: 'Stock Price vs Volume', showlegend: true, autosize: true, hovermode: 'closest',
            xaxis: { title: X_COL, domain: [0, 0.85], showgrid: true, zeroline: true },
            yaxis: { title: Y_COL, domain: [0, 0.85], showgrid: true, zeroline: true },
            xaxis2: { domain: [0.85, 1], showgrid: false, zeroline: false },
            yaxis2: { domain: [0.85, 1], showgrid: false, zeroline: false },
            margin: {t: 100, r: 100, b: 100, l: 100}
        }, {responsive: true});
    }

    function renderFacetWrap(data, X_COL, Y_COL, COLOR_COL, FACET_COL) {
        const facetValues = [...new Set(data.map(row => row[FACET_COL]))].sort();
        const nFacets = facetValues.length, cols = Math.ceil(Math.sqrt(nFacets)), rows = Math.ceil(nFacets / cols);
        const traces = [];

        facetValues.forEach((facetVal, idx) => {
            const facetData = data.filter(row => row[FACET_COL] === facetVal);
            const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
            const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);
            traces.push(...createTraces(facetData, X_COL, Y_COL, COLOR_COL, xaxis, yaxis, idx === 0));

            if (window.showDensity_stock_scatter) {
                traces.push({
                    x: facetData.map(d => d[X_COL]), y: facetData.map(d => d[Y_COL]),
                    name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                    showscale: false, type: 'histogram2dcontour', showlegend: false, xaxis: xaxis, yaxis: yaxis
                });
            }
        });

        const layout = {
            title: 'Stock Price vs Volume', showlegend: true, grid: {rows: rows, columns: cols, pattern: 'independent'},
            annotations: facetValues.map((val, idx) => ({
                text: FACET_COL + ': ' + val, showarrow: false,
                xref: (idx === 0 ? 'x' : 'x' + (idx + 1)) + ' domain',
                yref: (idx === 0 ? 'y' : 'y' + (idx + 1)) + ' domain',
                x: 0.5, y: 1.1, xanchor: 'center', yanchor: 'bottom'
            })),
            margin: {t: 100, r: 50, b: 50, l: 50}
        };
        facetValues.forEach((val, idx) => {
            const ax = idx === 0 ? '' : (idx + 1);
            layout['xaxis' + ax] = {title: X_COL};
            layout['yaxis' + ax] = {title: Y_COL};
        });
        Plotly.newPlot('stock_scatter', traces, layout, {responsive: true});
    }

    function renderFacetGrid(data, X_COL, Y_COL, COLOR_COL, FACET1_COL, FACET2_COL) {
        const facet1Values = [...new Set(data.map(row => row[FACET1_COL]))].sort();
        const facet2Values = [...new Set(data.map(row => row[FACET2_COL]))].sort();
        const rows = facet1Values.length, cols = facet2Values.length;
        const traces = [];

        facet1Values.forEach((facet1Val, rowIdx) => {
            facet2Values.forEach((facet2Val, colIdx) => {
                const facetData = data.filter(row => row[FACET1_COL] === facet1Val && row[FACET2_COL] === facet2Val);
                if (facetData.length === 0) return;

                const idx = rowIdx * cols + colIdx;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);
                traces.push(...createTraces(facetData, X_COL, Y_COL, COLOR_COL, xaxis, yaxis, idx === 0));

                if (window.showDensity_stock_scatter) {
                    traces.push({
                        x: facetData.map(d => d[X_COL]), y: facetData.map(d => d[Y_COL]),
                        name: 'density', ncontours: 20, colorscale: 'Hot', reversescale: true,
                        showscale: false, type: 'histogram2dcontour', showlegend: false, xaxis: xaxis, yaxis: yaxis
                    });
                }
            });
        });

        const layout = {
            title: 'Stock Price vs Volume', showlegend: true, grid: {rows: rows, columns: cols, pattern: 'independent'},
            annotations: [
                ...facet2Values.map((val, colIdx) => ({
                    text: FACET2_COL + ': ' + val, showarrow: false,
                    xref: (colIdx === 0 ? 'x' : 'x' + (colIdx + 1)) + ' domain',
                    yref: (colIdx === 0 ? 'y' : 'y' + (colIdx + 1)) + ' domain',
                    x: 0.5, y: 1.1, xanchor: 'center', yanchor: 'bottom'
                })),
                ...facet1Values.map((val, rowIdx) => ({
                    text: FACET1_COL + ': ' + val, showarrow: false,
                    xref: (rowIdx * cols === 0 ? 'x' : 'x' + (rowIdx * cols + 1)) + ' domain',
                    yref: (rowIdx * cols === 0 ? 'y' : 'y' + (rowIdx * cols + 1)) + ' domain',
                    x: -0.15, y: 0.5, xanchor: 'center', yanchor: 'middle', textangle: -90
                }))
            ],
            margin: {t: 100, r: 50, b: 50, l: 50}
        };
        facet1Values.forEach((v1, rowIdx) => {
            facet2Values.forEach((v2, colIdx) => {
                const idx = rowIdx * cols + colIdx, ax = idx === 0 ? '' : (idx + 1);
                layout['xaxis' + ax] = {title: X_COL};
                layout['yaxis' + ax] = {title: Y_COL};
            });
        });
        Plotly.newPlot('stock_scatter', traces, layout, {responsive: true});
    }

    function updatePlot_stock_scatter(data) {
        const X_COL = getCol('x_col_select_stock_scatter', DEFAULT_X_COL);
        const Y_COL = getCol('y_col_select_stock_scatter', DEFAULT_Y_COL);
        const COLOR_COL = getCol('color_col_select_stock_scatter', DEFAULT_COLOR_COL);

        let FACET1 = getCol('facet1_select_stock_scatter', null);
        let FACET2 = getCol('facet2_select_stock_scatter', null);
        if (FACET1 === 'None') FACET1 = null;
        if (FACET2 === 'None') FACET2 = null;

        if (FACET1 && FACET2) {
            renderFacetGrid(data, X_COL, Y_COL, COLOR_COL, FACET1, FACET2);
        } else if (FACET1) {
            renderFacetWrap(data, X_COL, Y_COL, COLOR_COL, FACET1);
        } else {
            renderNoFacets(data, X_COL, Y_COL, COLOR_COL);
        }
    }

    window.updateChart_stock_scatter = () => updatePlotWithFilters_stock_scatter();

    // Filter and update function
    window.updatePlotWithFilters_stock_scatter = function() {
        // Get filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_stock_scatter');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = window.allData_stock_scatter.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Update plot with filtered data
        updatePlot_stock_scatter(filteredData);
    };

    loadDataset('stock_data').then(data => {
        window.allData_stock_scatter = data;
        $(function() {
            const densityBtn = document.getElementById('stock_scatter_density_toggle');
            if (densityBtn) {
                densityBtn.addEventListener('click', function() {
                    window.showDensity_stock_scatter = !window.showDensity_stock_scatter;
                    this.textContent = window.showDensity_stock_scatter ? 'Hide Density Contours' : 'Show Density Contours';
                    updatePlotWithFilters_stock_scatter();
                });
            }
            updatePlotWithFilters_stock_scatter();
        });
    }).catch(error => console.error('Error loading data for chart stock_scatter:', error));
    })();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="df" data-format="parquet" data-src="data/df.parquet"></script><script type="text/plain" id="stock_data" data-format="parquet" data-src="data/stock_data.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <h1>External Data Format Examples</h1>
<p>This page demonstrates different data storage formats available in JSPlots.</p>
<p>By default, data is embedded directly in the HTML file. For larger datasets, external formats can be more efficient.</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Available Data Formats</h2>
<h3>JSON External (:json_external)</h3>
<p>Data is stored as .json files in a data/ subdirectory.</p>
<ul>
    <li><strong>Pros:</strong> Human-readable, widely compatible</li>
    <li><strong>Cons:</strong> Larger file size than Parquet</li>
</ul>

<h3>Parquet (:parquet)</h3>
<p>Data is stored as .parquet files in a data/ subdirectory.</p>
<ul>
    <li><strong>Pros:</strong> Binary format, smallest size, fastest loading</li>
    <li><strong>Cons:</strong> Not human-readable</li>
    <li><strong>Recommended:</strong> Best choice for production use</li>
</ul>

<h3>CSV External (:csv_external)</h3>
<p>Data is stored as .csv files in a data/ subdirectory.</p>
<ul>
    <li><strong>Pros:</strong> Human-readable, can be opened in spreadsheet applications</li>
    <li><strong>Cons:</strong> Moderate file size</li>
</ul>

    </div>
<br>
<hr>
<br>
<h2>Time Series Data</h2>
<p></p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="aggregator_select_timeseries">Aggregator: </label>
            <select id="aggregator_select_timeseries" onchange="updateChart_timeseries()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="timeseries"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: df.parquet</p><br>
<hr>
<br>
<h2>Stock Price vs Volume</h2>
<p></p>

<!-- Filters (for data filtering) -->

<!-- Plot Attributes -->
<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
    <div style="margin: 10px 0;">
    <button id="stock_scatter_density_toggle" style="padding: 5px 15px; cursor: pointer;">
        Hide Density Contours
    </button>
</div>
<div style="margin: 10px 0; display: flex; gap: 20px; align-items: center;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="x_col_select_stock_scatter">X:</label>
                    <select id="x_col_select_stock_scatter" onchange="updateChart_stock_scatter()">
                    <option value="volume" selected>volume</option>
                    <option value="price">price</option>                </select>
                </div>
                            <div style="display: flex; gap: 5px; align-items: center;">
                    <label for="y_col_select_stock_scatter">Y:</label>
                    <select id="y_col_select_stock_scatter" onchange="updateChart_stock_scatter()">
                    <option value="volume">volume</option>
                    <option value="price" selected>price</option>                </select>
                </div>
                    </div>

</div>

<!-- Faceting -->

<!-- Chart -->
<div id="stock_scatter"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: stock_data.parquet</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Usage Notes</h2>
<p>This example uses Parquet format (the recommended format for production use).</p>
<p>To use external formats, simply set the <code>dataformat</code> parameter when creating a JSPlotPage:</p>
<pre><code>page = JSPlotPage(
    data_dict,
    plot_elements,
    dataformat = :parquet  # or :json_external, :csv_external
)</code></pre>
<p><strong>Important:</strong> When using external formats, you must use the provided launcher scripts (open.sh or open.bat) to avoid CORS errors when viewing files locally.</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary</h2>
<p>This page demonstrated external data formats:</p>
<ul>
    <li><strong>JSON External:</strong> Human-readable, widely compatible</li>
    <li><strong>Parquet:</strong> Binary format, smallest size, fastest loading (recommended)</li>
    <li><strong>CSV External:</strong> Human-readable, spreadsheet-compatible</li>
</ul>
<p><strong>File size comparison:</strong> Parquet is typically the smallest, followed by JSON, then CSV.</p>
<p><strong>Recommendation:</strong> Use Parquet format for production applications with larger datasets.</p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
