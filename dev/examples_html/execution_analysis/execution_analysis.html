<!DOCTYPE html>
<html>
<head>
    <title>Execution Analysis</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
    

    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->
<script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
<script type="module">
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';
await parquet.default();
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts various date formats to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
// Handles: ISO strings, Date objects (from Arrow/Parquet), timestamps, and day counts
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Timestamp range for reasonable dates (2000-01-01 to 2100-01-01 in milliseconds)
    // Using year 2000 as minimum to avoid false positives with regular numeric values
    var MIN_TIMESTAMP_MS = 946684800000;  // 2000-01-01
    var MAX_TIMESTAMP_MS = 4102444800000;  // 2100-01-01

    // Day count range (for dates stored as days since epoch, e.g., from some Parquet files)
    // Reasonable range: 0 (1970-01-01) to ~47500 (~2100-01-01)
    var MIN_DAYS = 0;
    var MAX_DAYS = 50000;
    var MS_PER_DAY = 86400000;

    // Scan multiple rows to better detect column types (some rows might have missing values)
    var rowsToCheck = Math.min(10, data.length);
    var dateColumns = [];
    var timeColumns = [];
    var timestampColumns = [];
    var dayCountColumns = [];
    var alreadyDateColumns = [];

    // Helper to check if a numeric value looks like a timestamp (milliseconds since epoch)
    function looksLikeTimestamp(value) {
        return typeof value === 'number' && value >= MIN_TIMESTAMP_MS && value <= MAX_TIMESTAMP_MS && value > MAX_DAYS;
    }

    // Helper to check if a numeric value looks like a day count since epoch
    // DISABLED: This was too aggressive and incorrectly converted normal numeric values
    // (like Month=1, Year=2022, Sales=120) to dates. Only enable for columns with
    // explicit date-like names if needed in the future.
    function looksLikeDayCount(value) {
        return false;  // Disabled - too many false positives
    }

    // Build list of keys from first row
    var keys = Object.keys(data[0]);

    // Check each column across multiple rows
    keys.forEach(function(key) {
        var stringDateCount = 0;
        var timeCount = 0;
        var timestampCount = 0;
        var dayCountCount = 0;
        var alreadyDateCount = 0;
        var nonNullCount = 0;

        for (var i = 0; i < rowsToCheck; i++) {
            var value = data[i][key];
            if (value === null || value === undefined) continue;
            nonNullCount++;

            if (value instanceof Date) {
                alreadyDateCount++;
            } else if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    stringDateCount++;
                } else if (timePattern.test(value)) {
                    timeCount++;
                }
            } else if (typeof value === 'number') {
                if (looksLikeTimestamp(value)) {
                    timestampCount++;
                } else if (looksLikeDayCount(value)) {
                    dayCountCount++;
                }
            }
        }

        // Classify column if majority of non-null values match a pattern
        var threshold = nonNullCount * 0.5;
        if (alreadyDateCount > threshold) {
            alreadyDateColumns.push(key);
        } else if (stringDateCount > threshold) {
            dateColumns.push(key);
        } else if (timeCount > threshold) {
            timeColumns.push(key);
        } else if (timestampCount > threshold) {
            timestampColumns.push(key);
        } else if (dayCountCount > threshold && dayCountCount >= 3) {
            // Be more conservative with day counts - require at least 3 matches
            dayCountColumns.push(key);
        }
    });

    // If no date/time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0 &&
        timestampColumns.length === 0 && dayCountColumns.length === 0 &&
        alreadyDateColumns.length === 0) {
        return data;
    }

    // Convert values in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                var value = row[key];

                if (alreadyDateColumns.indexOf(key) !== -1) {
                    // Already a Date object - keep as is
                    newRow[key] = value;
                } else if (dateColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // ISO date string - convert to Date
                    newRow[key] = new Date(value);
                } else if (timeColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = value.split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else if (timestampColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Timestamp in milliseconds - convert to Date
                    newRow[key] = new Date(value);
                } else if (dayCountColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Day count since epoch - convert to Date
                    newRow[key] = new Date(value * MS_PER_DAY);
                } else {
                    newRow[key] = value;
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
// Now supports optional choice filters (single-select) in addition to categorical filters (multi-select)
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters, choiceFilters, choices) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply choice filters first (single-select, exact match)
    if (choiceFilters && choices) {
        choiceFilters.forEach(function(col) {
            if (choices[col] !== undefined && choices[col] !== null && choices[col] !== '') {
                currentData = currentData.filter(function(row) {
                    var rowValueStr = temporalValueToString(row[col]);
                    return rowValueStr === choices[col];
                });
            }
        });
    }

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        case 'cumulative':
        case 'cumprod':
            // These are handled specially in chart code (computed per group)
            // Here they act as identity
            return values;

        default:
            return values;
    }
}

// Compute cumulative sum of values
// Returns array of same length: [y[0], y[0]+y[1], y[0]+y[1]+y[2], ...]
function computeCumulativeSum(values) {
    if (!values || values.length === 0) return [];
    var result = [];
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);  // Explicitly convert to number
        if (!isNaN(v) && isFinite(v)) {
            sum += v;
        }
        result.push(sum);
    }
    return result;
}

// Compute cumulative product of values for returns data
// For returns r_i, computes: cumprod(1 + r_i) - 1
// This converts returns to growth factors, compounds them, then converts back to cumulative return
// Example: returns [0.1, 0.2, -0.1] -> (1+r): [1.1, 1.2, 0.9] -> cumprod: [1.1, 1.32, 1.188] -> result: [0.1, 0.32, 0.188]
function computeCumulativeProduct(values) {
    if (!values || values.length === 0) return [];
    var result = [];
    var product = 1;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);  // Explicitly convert to number
        if (!isNaN(v) && isFinite(v)) {
            product *= (1 + v);  // Convert return to growth factor and multiply
        }
        result.push(product - 1);  // Convert back to cumulative return
    }
    return result;
}

// Compute quantile transformation of values (rank-based, maps to [0, 1])
function computeQuantileTransform(values) {
    if (!values || values.length === 0) return [];

    var indexedValues = values.map(function(v, i) {
        return { value: parseFloat(v), index: i };  // Explicitly convert to number
    });

    var validValues = indexedValues.filter(function(item) {
        return !isNaN(item.value) && isFinite(item.value);
    }).sort(function(a, b) {
        return a.value - b.value;
    });

    if (validValues.length === 0) return values;

    var ranks = new Array(values.length).fill(NaN);
    validValues.forEach(function(item, rank) {
        ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
    });

    return ranks;
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        case 'cumulative':
            return 'cumulative(' + originalLabel + ')';
        case 'cumprod':
            return 'cumprod(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// =============================================================================
// Expression Parser for ScatterTwo
// Supports: +, -, *, /, variable references (:var or var), and functions:
//   z(expr, [groups]) - z-score within groups
//   q(expr, [groups]) - quantile within groups
//   PCA1(var1, var2) - projection on first principal component
//   PCA2(var1, var2) - projection on second principal component
// =============================================================================

// Tokenizer for expression parsing
function tokenizeExpression(expr) {
    var tokens = [];
    var i = 0;
    while (i < expr.length) {
        var ch = expr[i];

        // Skip whitespace
        if (/\s/.test(ch)) { i++; continue; }

        // Operators and punctuation
        if ('+-*/(),[]'.indexOf(ch) !== -1) {
            tokens.push({ type: 'punct', value: ch });
            i++;
            continue;
        }

        // Numbers
        if (/[0-9.]/.test(ch)) {
            var num = '';
            while (i < expr.length && /[0-9.]/.test(expr[i])) {
                num += expr[i++];
            }
            tokens.push({ type: 'number', value: parseFloat(num) });
            continue;
        }

        // Variable with colon prefix :varname
        if (ch === ':') {
            i++; // skip colon
            var name = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) {
                name += expr[i++];
            }
            tokens.push({ type: 'variable', value: name });
            continue;
        }

        // Identifiers (function names or variable names without colon)
        if (/[a-zA-Z_]/.test(ch)) {
            var ident = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) {
                ident += expr[i++];
            }
            // Check if it's a function (followed by open paren)
            var j = i;
            while (j < expr.length && /\s/.test(expr[j])) j++;
            if (j < expr.length && expr[j] === '(') {
                tokens.push({ type: 'function', value: ident });
            } else {
                tokens.push({ type: 'variable', value: ident });
            }
            continue;
        }

        // Unknown character - skip
        i++;
    }
    return tokens;
}

// Simple recursive descent parser
function parseExpression(tokens, pos) {
    return parseAddSub(tokens, pos);
}

function parseAddSub(tokens, pos) {
    var result = parseMulDiv(tokens, pos);
    var node = result.node;
    pos = result.pos;

    while (pos < tokens.length && tokens[pos].type === 'punct' &&
           (tokens[pos].value === '+' || tokens[pos].value === '-')) {
        var op = tokens[pos].value;
        pos++;
        var right = parseMulDiv(tokens, pos);
        node = { type: 'binary', op: op, left: node, right: right.node };
        pos = right.pos;
    }
    return { node: node, pos: pos };
}

function parseMulDiv(tokens, pos) {
    var result = parseUnary(tokens, pos);
    var node = result.node;
    pos = result.pos;

    while (pos < tokens.length && tokens[pos].type === 'punct' &&
           (tokens[pos].value === '*' || tokens[pos].value === '/')) {
        var op = tokens[pos].value;
        pos++;
        var right = parseUnary(tokens, pos);
        node = { type: 'binary', op: op, left: node, right: right.node };
        pos = right.pos;
    }
    return { node: node, pos: pos };
}

function parseUnary(tokens, pos) {
    if (pos < tokens.length && tokens[pos].type === 'punct' && tokens[pos].value === '-') {
        pos++;
        var result = parseUnary(tokens, pos);
        return { node: { type: 'unary', op: '-', arg: result.node }, pos: result.pos };
    }
    return parsePrimary(tokens, pos);
}

function parsePrimary(tokens, pos) {
    if (pos >= tokens.length) {
        return { node: { type: 'number', value: 0 }, pos: pos };
    }

    var token = tokens[pos];

    // Number literal
    if (token.type === 'number') {
        return { node: { type: 'number', value: token.value }, pos: pos + 1 };
    }

    // Variable reference
    if (token.type === 'variable') {
        return { node: { type: 'variable', name: token.value }, pos: pos + 1 };
    }

    // Function call
    if (token.type === 'function') {
        var funcName = token.value;
        pos++; // skip function name
        if (pos < tokens.length && tokens[pos].value === '(') {
            pos++; // skip (
            var args = [];
            while (pos < tokens.length && tokens[pos].value !== ')') {
                // Check for array literal [...]
                if (tokens[pos].value === '[') {
                    pos++; // skip [
                    var arrayItems = [];
                    while (pos < tokens.length && tokens[pos].value !== ']') {
                        if (tokens[pos].type === 'variable') {
                            arrayItems.push(tokens[pos].value);
                        }
                        pos++;
                        if (pos < tokens.length && tokens[pos].value === ',') pos++;
                    }
                    if (pos < tokens.length && tokens[pos].value === ']') pos++;
                    args.push({ type: 'array', items: arrayItems });
                } else {
                    var argResult = parseExpression(tokens, pos);
                    args.push(argResult.node);
                    pos = argResult.pos;
                }
                if (pos < tokens.length && tokens[pos].value === ',') pos++;
            }
            if (pos < tokens.length && tokens[pos].value === ')') pos++;
            return { node: { type: 'function', name: funcName, args: args }, pos: pos };
        }
    }

    // Parenthesized expression
    if (token.type === 'punct' && token.value === '(') {
        pos++; // skip (
        var result = parseExpression(tokens, pos);
        pos = result.pos;
        if (pos < tokens.length && tokens[pos].value === ')') pos++;
        return { node: result.node, pos: pos };
    }

    // Default: return 0
    return { node: { type: 'number', value: 0 }, pos: pos + 1 };
}

// Evaluate parsed expression against data
// Returns an array of values, one per data row
function evaluateExpression(node, data) {
    if (!node) return data.map(function() { return 0; });

    switch (node.type) {
        case 'number':
            return data.map(function() { return node.value; });

        case 'variable':
            return data.map(function(row) {
                var val = row[node.name];
                return (typeof val === 'number') ? val : parseFloat(val) || 0;
            });

        case 'binary':
            var left = evaluateExpression(node.left, data);
            var right = evaluateExpression(node.right, data);
            return left.map(function(l, i) {
                var r = right[i];
                switch (node.op) {
                    case '+': return l + r;
                    case '-': return l - r;
                    case '*': return l * r;
                    case '/': return r !== 0 ? l / r : NaN;
                    default: return 0;
                }
            });

        case 'unary':
            var arg = evaluateExpression(node.arg, data);
            if (node.op === '-') {
                return arg.map(function(v) { return -v; });
            }
            return arg;

        case 'function':
            return evaluateFunction(node.name, node.args, data);

        default:
            return data.map(function() { return 0; });
    }
}

// Evaluate function calls
function evaluateFunction(name, args, data) {
    var lowerName = name.toLowerCase();

    // z(expr, [groups]) - z-score within groups
    if (lowerName === 'z') {
        var values = evaluateExpression(args[0], data);
        var groupCols = (args.length > 1 && args[1].type === 'array') ? args[1].items : [];
        return computeGroupedZScore(values, data, groupCols);
    }

    // q(expr, [groups]) - quantile within groups
    if (lowerName === 'q') {
        var values = evaluateExpression(args[0], data);
        var groupCols = (args.length > 1 && args[1].type === 'array') ? args[1].items : [];
        return computeGroupedQuantile(values, data, groupCols);
    }

    // PCA1(var1, var2) - first principal component
    if (lowerName === 'pca1') {
        if (args.length >= 2) {
            var v1 = evaluateExpression(args[0], data);
            var v2 = evaluateExpression(args[1], data);
            return computePCA(v1, v2, 1);
        }
        return data.map(function() { return 0; });
    }

    // PCA2(var1, var2) - second principal component
    if (lowerName === 'pca2') {
        if (args.length >= 2) {
            var v1 = evaluateExpression(args[0], data);
            var v2 = evaluateExpression(args[1], data);
            return computePCA(v1, v2, 2);
        }
        return data.map(function() { return 0; });
    }

    // r(y, x) - OLS residual (y - fitted)
    if (lowerName === 'r') {
        if (args.length >= 2) {
            var y = evaluateExpression(args[0], data);
            var x = evaluateExpression(args[1], data);
            return computeOLSResidual(y, x);
        }
        return data.map(function() { return 0; });
    }

    // f(y, x) - OLS fitted value
    if (lowerName === 'f') {
        if (args.length >= 2) {
            var y = evaluateExpression(args[0], data);
            var x = evaluateExpression(args[1], data);
            return computeOLSFitted(y, x);
        }
        return data.map(function() { return 0; });
    }

    // c(expr, min, max) - clamp values between min and max
    // Use Infinity or -Infinity to only set one bound
    if (lowerName === 'c') {
        if (args.length >= 3) {
            var values = evaluateExpression(args[0], data);
            var minVal = evaluateExpression(args[1], data);
            var maxVal = evaluateExpression(args[2], data);

            // Get min/max bounds (they're arrays from evaluateExpression, but should be constant)
            var lo = minVal[0];
            var hi = maxVal[0];

            return values.map(function(v) {
                if (isNaN(v)) return v;
                if (v < lo) return lo;
                if (v > hi) return hi;
                return v;
            });
        }
        return data.map(function() { return 0; });
    }

    // Unknown function - return zeros
    return data.map(function() { return 0; });
}

// Compute z-score within groups
function computeGroupedZScore(values, data, groupCols) {
    if (groupCols.length === 0) {
        // No grouping - compute global z-score
        var validVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
        if (validVals.length === 0) return values;
        var mean = validVals.reduce(function(a, b) { return a + b; }, 0) / validVals.length;
        var variance = validVals.reduce(function(a, b) { return a + (b - mean) * (b - mean); }, 0) / validVals.length;
        var std = Math.sqrt(variance);
        if (std === 0) return values.map(function() { return 0; });
        return values.map(function(v) { return (v - mean) / std; });
    }

    // Group by specified columns
    var groups = {};
    data.forEach(function(row, i) {
        var key = groupCols.map(function(col) { return row[col]; }).join('|');
        if (!groups[key]) groups[key] = { indices: [], values: [] };
        groups[key].indices.push(i);
        groups[key].values.push(values[i]);
    });

    // Compute z-score within each group
    var result = new Array(values.length);
    Object.keys(groups).forEach(function(key) {
        var g = groups[key];
        var validVals = g.values.filter(function(v) { return !isNaN(v) && isFinite(v); });
        if (validVals.length === 0) {
            g.indices.forEach(function(i) { result[i] = NaN; });
            return;
        }
        var mean = validVals.reduce(function(a, b) { return a + b; }, 0) / validVals.length;
        var variance = validVals.reduce(function(a, b) { return a + (b - mean) * (b - mean); }, 0) / validVals.length;
        var std = Math.sqrt(variance);
        g.indices.forEach(function(idx, j) {
            result[idx] = std === 0 ? 0 : (g.values[j] - mean) / std;
        });
    });
    return result;
}

// Compute quantile within groups
function computeGroupedQuantile(values, data, groupCols) {
    if (groupCols.length === 0) {
        // No grouping - compute global quantile
        return computeQuantileTransform(values);
    }

    // Group by specified columns
    var groups = {};
    data.forEach(function(row, i) {
        var key = groupCols.map(function(col) { return row[col]; }).join('|');
        if (!groups[key]) groups[key] = { indices: [], values: [] };
        groups[key].indices.push(i);
        groups[key].values.push(values[i]);
    });

    // Compute quantile within each group
    var result = new Array(values.length);
    Object.keys(groups).forEach(function(key) {
        var g = groups[key];
        var quantiles = computeQuantileTransform(g.values);
        g.indices.forEach(function(idx, j) {
            result[idx] = quantiles[j];
        });
    });
    return result;
}

// Compute PCA projection
// component: 1 for first PC, 2 for second PC
function computePCA(v1, v2, component) {
    var n = v1.length;
    if (n === 0) return [];

    // Filter valid pairs
    var validIndices = [];
    for (var i = 0; i < n; i++) {
        if (!isNaN(v1[i]) && isFinite(v1[i]) && !isNaN(v2[i]) && isFinite(v2[i])) {
            validIndices.push(i);
        }
    }

    if (validIndices.length < 2) {
        return v1.map(function() { return 0; });
    }

    // Compute means
    var mean1 = 0, mean2 = 0;
    validIndices.forEach(function(i) {
        mean1 += v1[i];
        mean2 += v2[i];
    });
    mean1 /= validIndices.length;
    mean2 /= validIndices.length;

    // Compute covariance matrix elements
    var cov11 = 0, cov12 = 0, cov22 = 0;
    validIndices.forEach(function(i) {
        var d1 = v1[i] - mean1;
        var d2 = v2[i] - mean2;
        cov11 += d1 * d1;
        cov12 += d1 * d2;
        cov22 += d2 * d2;
    });
    cov11 /= validIndices.length;
    cov12 /= validIndices.length;
    cov22 /= validIndices.length;

    // Compute eigenvalues and eigenvectors of 2x2 covariance matrix
    // Using closed-form solution for 2x2 symmetric matrix
    var trace = cov11 + cov22;
    var det = cov11 * cov22 - cov12 * cov12;
    var discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
    var lambda1 = trace / 2 + discriminant; // larger eigenvalue
    var lambda2 = trace / 2 - discriminant; // smaller eigenvalue

    // Eigenvector for lambda1 (first PC)
    var ev1_x, ev1_y;
    if (Math.abs(cov12) > 1e-10) {
        ev1_x = lambda1 - cov22;
        ev1_y = cov12;
    } else {
        ev1_x = 1;
        ev1_y = 0;
    }
    var norm1 = Math.sqrt(ev1_x * ev1_x + ev1_y * ev1_y);
    if (norm1 > 0) { ev1_x /= norm1; ev1_y /= norm1; }

    // Eigenvector for lambda2 (second PC) - perpendicular to first
    var ev2_x = -ev1_y;
    var ev2_y = ev1_x;

    // Choose eigenvector based on component
    var ev_x = component === 1 ? ev1_x : ev2_x;
    var ev_y = component === 1 ? ev1_y : ev2_y;

    // Project all points onto the principal component
    var result = new Array(n);
    for (var i = 0; i < n; i++) {
        if (!isNaN(v1[i]) && isFinite(v1[i]) && !isNaN(v2[i]) && isFinite(v2[i])) {
            result[i] = (v1[i] - mean1) * ev_x + (v2[i] - mean2) * ev_y;
        } else {
            result[i] = NaN;
        }
    }
    return result;
}

// Compute OLS regression coefficients (y = alpha + beta * x)
// Returns {alpha, beta} or null if regression fails
function computeOLSCoefficients(y, x) {
    var n = y.length;
    if (n === 0 || n !== x.length) return null;

    // Filter to valid pairs only
    var validPairs = [];
    for (var i = 0; i < n; i++) {
        if (!isNaN(y[i]) && isFinite(y[i]) && !isNaN(x[i]) && isFinite(x[i])) {
            validPairs.push({ y: y[i], x: x[i] });
        }
    }

    if (validPairs.length < 2) return null;

    // Compute means
    var sumX = 0, sumY = 0;
    validPairs.forEach(function(p) {
        sumX += p.x;
        sumY += p.y;
    });
    var meanX = sumX / validPairs.length;
    var meanY = sumY / validPairs.length;

    // Compute beta = Cov(x,y) / Var(x)
    var covXY = 0, varX = 0;
    validPairs.forEach(function(p) {
        var dx = p.x - meanX;
        var dy = p.y - meanY;
        covXY += dx * dy;
        varX += dx * dx;
    });

    if (varX === 0) return null; // x has no variance

    var beta = covXY / varX;
    var alpha = meanY - beta * meanX;

    return { alpha: alpha, beta: beta };
}

// Compute OLS residuals: r(y, x) = y - fitted = y - (alpha + beta * x)
function computeOLSResidual(y, x) {
    var coef = computeOLSCoefficients(y, x);
    if (!coef) {
        return y.map(function() { return NaN; });
    }

    return y.map(function(yi, i) {
        if (isNaN(yi) || !isFinite(yi) || isNaN(x[i]) || !isFinite(x[i])) {
            return NaN;
        }
        var fitted = coef.alpha + coef.beta * x[i];
        return yi - fitted;
    });
}

// Compute OLS fitted values: f(y, x) = alpha + beta * x
function computeOLSFitted(y, x) {
    var coef = computeOLSCoefficients(y, x);
    if (!coef) {
        return y.map(function() { return NaN; });
    }

    return x.map(function(xi, i) {
        if (isNaN(y[i]) || !isFinite(y[i]) || isNaN(xi) || !isFinite(xi)) {
            return NaN;
        }
        return coef.alpha + coef.beta * xi;
    });
}

// Main function to evaluate an expression string against data
function evaluateExpressionString(exprString, data) {
    if (!exprString || exprString.trim() === '') {
        return data.map(function() { return 0; });
    }
    try {
        var tokens = tokenizeExpression(exprString);
        var parseResult = parseExpression(tokens, 0);
        return evaluateExpression(parseResult.node, data);
    } catch (e) {
        console.error('Expression parsing error:', e);
        return data.map(function() { return 0; });
    }
}

// =============================================================================
// End Expression Parser
// =============================================================================

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

// Global fix for PivotTable.js filter box positioning issue
// See: https://github.com/nicolaskruchten/pivottable/issues/865
// The library calculates position incorrectly - we fix it by repositioning after creation
(function() {
    if (window._pvtFilterBoxFixApplied) return; // Only apply once
    window._pvtFilterBoxFixApplied = true;

    var lastClickedTriangle = null;

    // Helper function to reposition the filter box
    function repositionFilterBox($box, triangle) {
        if (!triangle || !$box.length) return;

        // Get triangle position relative to viewport
        var triangleRect = triangle.getBoundingClientRect();

        // Get box dimensions (use defaults if not yet rendered)
        var boxWidth = $box.outerWidth() || 300;
        var boxHeight = $box.outerHeight() || 400;

        // Calculate position relative to viewport (for position:fixed)
        var newLeft = triangleRect.left;
        var newTop = triangleRect.bottom + 5;

        // Adjust if it would go off the right edge
        if (newLeft + boxWidth > window.innerWidth - 20) {
            newLeft = triangleRect.right - boxWidth;
        }

        // Adjust if it would go off the bottom edge
        if (newTop + boxHeight > window.innerHeight - 20) {
            newTop = triangleRect.top - boxHeight - 5;
        }

        // Ensure minimum positions
        if (newLeft < 10) newLeft = 10;
        if (newTop < 10) newTop = 10;

        // Use position:fixed for viewport-relative positioning
        $box.css({
            'position': 'fixed',
            'left': newLeft + 'px',
            'top': newTop + 'px'
        });
    }

    // Capture which triangle was clicked
    $(document).on('click', '.pvtTriangle', function(e) {
        lastClickedTriangle = this;
    });

    // Watch for filter box creation and fix position
    var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1 && $(node).hasClass('pvtFilterBox')) {
                    var $box = $(node);
                    var triangle = lastClickedTriangle;

                    // Apply the fix multiple times to ensure it sticks after PivotTable.js finishes
                    // The library may set position after initial render
                    var timings = [0, 10, 50, 100, 200];
                    timings.forEach(function(delay) {
                        setTimeout(function() {
                            repositionFilterBox($box, triangle);
                        }, delay);
                    });

                    // Also reposition on any style changes to the box (in case library updates position)
                    var styleObserver = new MutationObserver(function(styleMutations) {
                        repositionFilterBox($box, triangle);
                    });
                    styleObserver.observe(node, { attributes: true, attributeFilter: ['style'] });

                    // Disconnect the style observer when the filter box is removed
                    var removalObserver = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            mutation.removedNodes.forEach(function(removedNode) {
                                if (removedNode === node) {
                                    styleObserver.disconnect();
                                    removalObserver.disconnect();
                                    lastClickedTriangle = null;
                                }
                            });
                        });
                    });
                    removalObserver.observe(document.body, { childList: true, subtree: true });
                }
            });
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
})();

(function() {
    // Configuration
    const EXECUTION_NAMES = ["Execution_1_asset_1","Execution_2_asset_2","Execution_3_asset_3","Execution_4_asset_4","Execution_5_asset_5","Execution_6_asset_6","Execution_7_asset_7","Execution_8_asset_8","Execution_9_asset_1","Execution_10_asset_2","Execution_11_asset_3","Execution_12_asset_4","Execution_13_asset_5","Execution_14_asset_6","Execution_15_asset_7","Execution_16_asset_8","Execution_17_asset_1","Execution_18_asset_2","Execution_19_asset_3","Execution_20_asset_4"];
    const COLOR_COLS = ["order_type","exchange"];
    const DEFAULT_COLOR_COL = null;
    const TOOLTIP_COLS = ["order_type","exchange"];
    const PEER_COLS = ["asset_6","asset_8","asset_3","asset_4","asset_7","asset_5","asset_2","asset_1"];
    const METADATA_COLS = [];
    const HAS_COUNTERFACTUAL = true;
    const HAS_SPREAD_CROSS = true;
    const HAS_VS_VWAP = true;
    const HAS_VOLUME = true;

    // Data storage
    let fillsData = [];
    let tobData = [];
    let summaryDataBps = [];
    let summaryDataPct = [];
    let summaryDataUsd = [];
    let volumeData = [];

    // Current state
    let currentExecution = EXECUTION_NAMES.length > 0 ? EXECUTION_NAMES[0] : null;
    let currentColorCol = DEFAULT_COLOR_COL;
    let currentUnits = 'bps';  // Default to basis points
    let currentTopView = 1;
    let showVolume = HAS_VOLUME;  // Volume on by default if available

    // Get current summary data based on selected units
    function getSummaryData() {
        switch (currentUnits) {
            case 'pct': return summaryDataPct;
            case 'usd': return summaryDataUsd;
            default: return summaryDataBps;
        }
    }

    // Get unit label for display
    function getUnitLabel() {
        switch (currentUnits) {
            case 'pct': return '%';
            case 'usd': return 'USD';
            default: return 'bps';
        }
    }

    // Color palette
    const colorPalette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                          '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];

    // Initialize controls
    function initializeControls() {
        // Populate execution dropdown
        const execSelect = document.getElementById('exec_select_execution_analysis');
        if (execSelect) {
            execSelect.innerHTML = '';
            EXECUTION_NAMES.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                if (name === currentExecution) option.selected = true;
                execSelect.appendChild(option);
            });
        }

        // Populate color dropdown
        const colorSelect = document.getElementById('color_select_execution_analysis');
        if (colorSelect) {
            colorSelect.innerHTML = '<option value="">No coloring</option>';
            COLOR_COLS.forEach(col => {
                const option = document.createElement('option');
                option.value = col;
                option.textContent = col;
                if (col === currentColorCol) option.selected = true;
                colorSelect.appendChild(option);
            });
        }

        // Set up view toggle buttons
        updateTopViewButtons();

        // Set initial volume button state
        const volBtn = document.getElementById('volume_toggle_execution_analysis');
        if (volBtn) {
            volBtn.style.backgroundColor = showVolume ? '#27ae60' : '#95a5a6';
        }
    }

    function updateTopViewButtons() {
        for (let i = 1; i <= 6; i++) {
            const btn = document.getElementById('top_view_' + i + '_execution_analysis');
            if (btn) {
                btn.style.backgroundColor = (i === currentTopView) ? '#3498db' : '#95a5a6';
            }
        }
        // Hide/show View 3 button if no peer data
        const view3Btn = document.getElementById('top_view_3_execution_analysis');
        if (view3Btn) {
            view3Btn.style.display = (HAS_COUNTERFACTUAL && PEER_COLS.length > 0) ? 'inline-block' : 'none';
        }
        // Hide/show View 2 button if no counterfactual
        const view2Btn = document.getElementById('top_view_2_execution_analysis');
        if (view2Btn) {
            view2Btn.style.display = HAS_COUNTERFACTUAL ? 'inline-block' : 'none';
        }
    }

    // Event handlers
    window.onExecChange_execution_analysis = function() {
        const select = document.getElementById('exec_select_execution_analysis');
        if (select) {
            currentExecution = select.value;
            updateChart_execution_analysis();
        }
    };

    window.onColorChange_execution_analysis = function() {
        const select = document.getElementById('color_select_execution_analysis');
        if (select) {
            currentColorCol = select.value || null;
            updateChart_execution_analysis();
        }
    };

    window.onUnitsChange_execution_analysis = function() {
        const select = document.getElementById('units_select_execution_analysis');
        if (select) {
            currentUnits = select.value;
            updateChart_execution_analysis();
        }
    };

    window.setTopView_execution_analysis = function(view) {
        currentTopView = view;
        updateTopViewButtons();
        updateChart_execution_analysis();
    };

    window.toggleVolume_execution_analysis = function() {
        showVolume = !showVolume;
        const btn = document.getElementById('volume_toggle_execution_analysis');
        if (btn) {
            btn.style.backgroundColor = showVolume ? '#27ae60' : '#95a5a6';
        }
        updateChart_execution_analysis();
    };

    // Aspect ratio control for the chart panel
    function setupAspectRatioControl_execution_analysis() {
        const slider = document.getElementById('aspect_ratio_slider_execution_analysis');
        if (!slider) return;

        function applyAspectRatio() {
            const ratio = parseFloat(slider.value);
            const panel = document.getElementById('top_panel_execution_analysis');

            if (panel) {
                const width = panel.clientWidth;
                const height = Math.round(width * ratio);
                panel.style.height = height + 'px';
                Plotly.relayout('top_panel_execution_analysis', { height: height });
            }
        }

        slider.addEventListener('input', applyAspectRatio);

        // Apply initial aspect ratio after a short delay to ensure chart is rendered
        setTimeout(applyAspectRatio, 100);
    }

    // Update summary table
    function updateSummaryTable() {
        const table = document.getElementById('summary_table_execution_analysis');
        if (!table || !currentExecution) return;

        const summaryData = getSummaryData();
        const unitLabel = getUnitLabel();
        const summary = summaryData.find(r => r.execution_name === currentExecution);
        const fills = fillsData.filter(r => r.execution_name === currentExecution);

        if (!summary || fills.length === 0) {
            table.innerHTML = '<tr><td colspan="8">No data for selected execution</td></tr>';
            return;
        }

        const asset = fills[0].asset || 'N/A';
        const side = summary.side || 'N/A';
        const desiredQty = fills[0].desired_quantity || sum(fills.map(f => f.quantity));
        const executedQty = fills.reduce((s, f) => s + f.quantity, 0);

        let html = '<tr>';
        html += '<td><strong>Asset:</strong> ' + asset + '</td>';
        html += '<td><strong>Side:</strong> ' + side + '</td>';
        html += '<td><strong>Planned Qty:</strong> ' + desiredQty.toLocaleString() + '</td>';
        html += '<td><strong>Executed Qty:</strong> ' + executedQty.toLocaleString() + '</td>';
        html += '<td><strong>Classical:</strong> ' + (summary.classical_slippage || 0).toFixed(2) + ' ' + unitLabel + '</td>';

        if (HAS_VS_VWAP && summary.vs_vwap_slippage !== undefined) {
            html += '<td><strong>vs VWAP:</strong> ' + (summary.vs_vwap_slippage || 0).toFixed(2) + ' ' + unitLabel + '</td>';
        }

        if (HAS_COUNTERFACTUAL && summary.refined_slippage !== undefined) {
            html += '<td><strong>Refined:</strong> ' + (summary.refined_slippage || 0).toFixed(2) + ' ' + unitLabel + '</td>';
        }

        if (HAS_SPREAD_CROSS && summary.spread_cross_pct !== undefined) {
            html += '<td><strong>Spread Cross:</strong> ' + ((summary.spread_cross_pct || 0) * 100).toFixed(1) + '%</td>';
        }

        // Add user-specified metadata columns
        METADATA_COLS.forEach(col => {
            if (summary[col] !== undefined) {
                let val = summary[col];
                // Format numbers nicely
                if (typeof val === 'number') {
                    val = Number.isInteger(val) ? val.toLocaleString() : val.toFixed(4);
                }
                html += '<td><strong>' + col + ':</strong> ' + val + '</td>';
            }
        });

        html += '</tr>';
        table.innerHTML = html;
    }

    // Get filtered data for current execution
    function getExecutionData() {
        const fills = fillsData.filter(r => r.execution_name === currentExecution);
        if (fills.length === 0) return { fills: [], tob: [], volume: [] };

        const asset = fills[0].asset;
        const times = fills.map(f => f.time);
        const minTime = Math.min(...times);
        const maxTime = Math.max(...times);
        const timeRange = maxTime - minTime;

        // Get TOB data for this asset and time window (with 10% buffer)
        const tob = tobData.filter(r =>
            r.symbol === asset &&
            r.time >= minTime - timeRange * 0.1 &&
            r.time <= maxTime + timeRange * 0.1
        ).sort((a, b) => a.time - b.time);

        // Get volume data if available
        const vol = volumeData.filter(r =>
            r.symbol === asset &&
            r.time_to >= minTime &&
            r.time_from <= maxTime
        ).sort((a, b) => a.time_from - b.time_from);

        return { fills: fills.sort((a, b) => a.time - b.time), tob, volume: vol };
    }

    // Render top panel based on current view
    function renderTopPanel(data) {
        const { fills, tob, volume } = data;
        if (fills.length === 0) {
            Plotly.newPlot('top_panel_execution_analysis', [], {
                title: 'No data for selected execution'
            });
            return;
        }

        const traces = [];
        const layout = {
            xaxis: { title: 'Time' },
            hovermode: 'closest',
            showlegend: true,
            legend: { orientation: 'h', y: 1.1 }
        };

        // Get color mapping for fills
        const fillColors = getFillColors(fills);

        switch (currentTopView) {
            case 1:
                // Bid/Ask + Fills
                renderBidAskView(traces, layout, fills, tob, volume, fillColors);
                break;
            case 2:
                // Mid + Counterfactual
                renderMidCounterfactualView(traces, layout, fills, tob, fillColors);
                break;
            case 3:
                // With Peers
                renderPeersView(traces, layout, fills, tob, fillColors);
                break;
            case 4:
                // Execution Progress (CDF)
                renderProgressView(traces, layout, fills, fillColors);
                break;
            case 5:
                // Spread Position
                renderSpreadPositionView(traces, layout, fills, tob, fillColors);
                break;
            case 6:
                // Accrued Slippage
                renderSlippageView(traces, layout, fills);
                break;
        }

        // Add volume overlay for views 1-3 (price-based views)
        if (showVolume && HAS_VOLUME && volume.length > 0 && currentTopView <= 3) {
            addVolumeTrace(traces, layout, volume);
        }

        Plotly.newPlot('top_panel_execution_analysis', traces, layout, {responsive: true});
    }

    // Get colors for fills based on color column
    function getFillColors(fills) {
        if (!currentColorCol) {
            return fills.map(() => colorPalette[0]);
        }

        const categories = [...new Set(fills.map(f => f[currentColorCol]))];
        const colorMap = {};
        categories.forEach((cat, i) => {
            colorMap[cat] = colorPalette[i % colorPalette.length];
        });

        return fills.map(f => colorMap[f[currentColorCol]]);
    }

    // Build tooltip text for a fill including all tooltip columns
    function buildFillTooltip(fill) {
        let text = 'Qty: ' + fill.quantity.toLocaleString() + '<br>Price: ' + fill.price.toFixed(4);

        // Add tooltip columns
        TOOLTIP_COLS.forEach(col => {
            if (fill[col] !== undefined && fill[col] !== null) {
                let val = fill[col];
                // Format numbers nicely
                if (typeof val === 'number') {
                    val = Number.isInteger(val) ? val.toLocaleString() : val.toFixed(4);
                }
                text += '<br>' + col + ': ' + val;
            }
        });

        return text;
    }

    // View 1: Bid/Ask + Fills
    function renderBidAskView(traces, layout, fills, tob, volume, fillColors) {
        // Bid line
        traces.push({
            x: tob.map(r => r.time),
            y: tob.map(r => r.bid_price),
            type: 'scatter',
            mode: 'lines',
            name: 'Bid',
            line: { color: '#006400', width: 1.5 }
        });

        // Ask line
        traces.push({
            x: tob.map(r => r.time),
            y: tob.map(r => r.ask_price),
            type: 'scatter',
            mode: 'lines',
            name: 'Ask',
            line: { color: '#d62728', width: 1.5 }
        });

        // Fill points (sized by log volume)
        traces.push({
            x: fills.map(r => r.time),
            y: fills.map(r => r.price),
            type: 'scatter',
            mode: 'markers',
            name: 'Fills',
            marker: {
                size: fills.map(r => Math.max(8, Math.log(r.quantity) * 3)),
                color: fillColors,
                line: { color: 'black', width: 1 }
            },
            text: fills.map(r => buildFillTooltip(r)),
            hoverinfo: 'text'
        });

        layout.yaxis = { title: 'Price' };
    }

    // View 2: Mid + Counterfactual
    function renderMidCounterfactualView(traces, layout, fills, tob, fillColors) {
        // Mid price line
        traces.push({
            x: tob.map(r => r.time),
            y: tob.map(r => r.mid_price),
            type: 'scatter',
            mode: 'lines',
            name: 'Mid Price',
            line: { color: '#1f77b4', width: 1.5 }
        });

        // Counterfactual price line (at fill times)
        if (HAS_COUNTERFACTUAL) {
            traces.push({
                x: fills.map(r => r.time),
                y: fills.map(r => r.counterfactual_price),
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Counterfactual',
                line: { color: '#ff7f0e', width: 2, dash: 'dash' },
                marker: { size: 6 }
            });
        }

        // Fill points
        traces.push({
            x: fills.map(r => r.time),
            y: fills.map(r => r.price),
            type: 'scatter',
            mode: 'markers',
            name: 'Fills',
            marker: {
                size: fills.map(r => Math.max(8, Math.log(r.quantity) * 3)),
                color: fillColors,
                line: { color: 'black', width: 1 }
            },
            text: fills.map(r => buildFillTooltip(r)),
            hoverinfo: 'text'
        });

        layout.yaxis = { title: 'Price' };
    }

    // View 3: With Peers
    function renderPeersView(traces, layout, fills, tob, fillColors) {
        // Get the initial price (arrival price of the first fill)
        const initialPrice = fills[0].arrival_price || fills[0].price;

        // First add peer lines (grey, semi-transparent)
        // Peer columns contain cumulative returns from time 1 to each fill time
        // We need returns relative to the first fill time, so we normalize:
        // peer_price = initialPrice * (peer_return_at_t / peer_return_at_first_fill)
        // This ensures the peer line starts at initialPrice at the first fill time
        PEER_COLS.forEach(peer => {
            const firstFillPeerReturn = fills[0][peer];
            if (firstFillPeerReturn !== undefined && firstFillPeerReturn !== 0) {
                traces.push({
                    x: fills.map(r => r.time),
                    y: fills.map(r => initialPrice * (r[peer] / firstFillPeerReturn)),
                    type: 'scatter',
                    mode: 'lines',
                    name: peer,
                    line: { color: 'rgba(150, 150, 150, 0.5)', width: 1 },
                    hoverinfo: 'name+y'
                });
            }
        });

        // Then add mid and counterfactual (on top)
        renderMidCounterfactualView(traces, layout, fills, tob, fillColors);
    }

    // View 4: Execution Progress (CDF)
    function renderProgressView(traces, layout, fills, fillColors) {
        traces.push({
            x: fills.map(r => r.time),
            y: fills.map(r => (r.pct_complete || 0) * 100),
            type: 'scatter',
            mode: 'lines+markers',
            name: '% Completed',
            line: { color: '#2ca02c', width: 2 },
            marker: {
                size: fills.map(r => Math.max(8, Math.log(r.quantity) * 3)),
                color: fillColors,
                line: { color: 'black', width: 1 }
            },
            text: fills.map(r => '% Complete: ' + ((r.pct_complete || 0) * 100).toFixed(1) + '%<br>' + buildFillTooltip(r)),
            hoverinfo: 'text',
            fill: 'tozeroy',
            fillcolor: 'rgba(44, 160, 44, 0.2)'
        });

        layout.yaxis = { title: '% Executed', range: [0, 105] };
    }

    // View 5: Spread Position
    function renderSpreadPositionView(traces, layout, fills, tob, fillColors) {
        // Bid at 0
        traces.push({
            x: tob.map(r => r.time),
            y: tob.map(() => 0),
            type: 'scatter',
            mode: 'lines',
            name: 'Bid (0)',
            line: { color: '#006400', width: 2 }
        });

        // Ask at 1
        traces.push({
            x: tob.map(r => r.time),
            y: tob.map(() => 1),
            type: 'scatter',
            mode: 'lines',
            name: 'Ask (1)',
            line: { color: '#d62728', width: 2 }
        });

        // Mid at 0.5 (dotted)
        traces.push({
            x: tob.map(r => r.time),
            y: tob.map(() => 0.5),
            type: 'scatter',
            mode: 'lines',
            name: 'Mid (0.5)',
            line: { color: '#7f7f7f', width: 1, dash: 'dot' }
        });

        // Fill positions (normalized 0-1)
        traces.push({
            x: fills.map(r => r.time),
            y: fills.map(r => r.norm_fill_pos || 0.5),
            type: 'scatter',
            mode: 'markers',
            name: 'Fills',
            marker: {
                size: fills.map(r => Math.max(8, Math.log(r.quantity) * 3)),
                color: fillColors,
                line: { color: 'black', width: 1 }
            },
            text: fills.map(r => 'Spread Position: ' + ((r.norm_fill_pos || 0.5) * 100).toFixed(1) + '%<br>' + buildFillTooltip(r)),
            hoverinfo: 'text'
        });

        layout.yaxis = { title: 'Position in Spread', range: [-0.1, 1.1] };
    }

    // Add volume bars
    function addVolumeTrace(traces, layout, volume) {
        traces.push({
            x: volume.map(r => (r.time_from + r.time_to) / 2),
            y: volume.map(r => r.volume),
            type: 'bar',
            name: 'Volume',
            yaxis: 'y2',
            marker: { color: 'rgba(100, 100, 100, 0.3)' },
            showlegend: false
        });

        layout.yaxis2 = {
            title: 'Volume',
            overlaying: 'y',
            side: 'right',
            showgrid: false
        };
    }

    // View 6: Accrued Slippage
    function renderSlippageView(traces, layout, fills) {
        const unitLabel = getUnitLabel();

        // Get the column suffix based on current units
        const unitSuffix = currentUnits;  // 'bps', 'pct', or 'usd'

        // Classical slippage
        const classicalCol = 'cum_classical_slippage_' + unitSuffix;
        traces.push({
            x: fills.map(r => r.time),
            y: fills.map(r => r[classicalCol] || 0),
            type: 'scatter',
            mode: 'lines+markers',
            name: 'Classical',
            line: { color: '#8B4513', width: 2 },
            marker: { size: 6 }
        });

        // vs VWAP slippage (if available)
        const vwapCol = 'cum_vs_vwap_slippage_' + unitSuffix;
        if (HAS_VS_VWAP && fills[0][vwapCol] !== undefined) {
            traces.push({
                x: fills.map(r => r.time),
                y: fills.map(r => r[vwapCol] || 0),
                type: 'scatter',
                mode: 'lines+markers',
                name: 'vs VWAP',
                line: { color: '#4169E1', width: 2 },
                marker: { size: 6 }
            });
        }

        // Refined slippage (if available)
        const refinedCol = 'cum_refined_slippage_' + unitSuffix;
        if (HAS_COUNTERFACTUAL && fills[0][refinedCol] !== undefined) {
            traces.push({
                x: fills.map(r => r.time),
                y: fills.map(r => r[refinedCol] || 0),
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Refined',
                line: { color: '#000000', width: 2 },
                marker: { size: 6 }
            });
        }

        layout.yaxis = { title: 'Cumulative Slippage (' + unitLabel + ')' };
    }

    // Main update function
    window.updateChart_execution_analysis = function() {
        updateSummaryTable();
        const data = getExecutionData();
        renderTopPanel(data);

        // Setup aspect ratio control
        setupAspectRatioControl_execution_analysis();
    };

    // Check if summary_pct and summary_usd are available
    const HAS_SUMMARY_PCT = true;
    const HAS_SUMMARY_USD = true;

    // Load data and initialize
    Promise.all([
        loadDataset('exec_data.fills'),
        loadDataset('exec_data.tob'),
        loadDataset('exec_data.summary_bps'),
        HAS_VOLUME ? loadDataset('exec_data.volume') : Promise.resolve([]),
        HAS_SUMMARY_PCT ? loadDataset('exec_data.summary_pct') : Promise.resolve([]),
        HAS_SUMMARY_USD ? loadDataset('exec_data.summary_usd') : Promise.resolve([])
    ]).then(function([fills, tob, summaryBps, volume, summaryPct, summaryUsd]) {
        fillsData = fills;
        tobData = tob;
        summaryDataBps = summaryBps;
        summaryDataPct = HAS_SUMMARY_PCT ? summaryPct : summaryBps;  // Fallback to bps if not available
        summaryDataUsd = HAS_SUMMARY_USD ? summaryUsd : summaryBps;  // Fallback to bps if not available
        volumeData = volume;

        initializeControls();
        updateChart_execution_analysis();
    }).catch(function(error) {
        console.error('Error loading execution data:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="exec_data.summary_pct" data-format="parquet" data-src="data/exec_data/summary_pct.parquet"></script><script type="text/plain" id="exec_data.fills" data-format="parquet" data-src="data/exec_data/fills.parquet"></script><script type="text/plain" id="exec_data.summary_bps" data-format="parquet" data-src="data/exec_data/summary_bps.parquet"></script><script type="text/plain" id="exec_data.volume" data-format="parquet" data-src="data/exec_data/volume.parquet"></script><script type="text/plain" id="exec_data.tob" data-format="parquet" data-src="data/exec_data/tob.parquet"></script><script type="text/plain" id="exec_data.summary_usd" data-format="parquet" data-src="data/exec_data/summary_usd.parquet"></script><script type="text/plain" id="exec_data.fill_returns" data-format="parquet" data-src="data/exec_data/fill_returns.parquet"></script>

<!-- ACTUAL CONTENT -->

<h1>Trading Execution Analysis</h1>
<p>Analyze execution quality across multiple orders with refined slippage methodology.</p>

<div class="chart-wrapper" style="margin: 20px 0;">
    <div class="chart-header" style="margin-bottom: 15px;">
        <h3 style="margin: 0;">Order Execution Analysis</h3>
    </div>

    <!-- Controls Row 1: Execution, Color, and Units dropdowns -->
    <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
        <div>
            <label><strong>Execution:</strong></label>
            <select id="exec_select_execution_analysis" onchange="onExecChange_execution_analysis()"
                    style="margin-left: 5px; padding: 4px 8px; min-width: 200px;">
            </select>
        </div>
        <div>
            <label><strong>Color by:</strong></label>
            <select id="color_select_execution_analysis" onchange="onColorChange_execution_analysis()"
                    style="margin-left: 5px; padding: 4px 8px; min-width: 150px;">
            </select>
        </div>
        <div>
            <label><strong>Units:</strong></label>
            <select id="units_select_execution_analysis" onchange="onUnitsChange_execution_analysis()"
                    style="margin-left: 5px; padding: 4px 8px; min-width: 80px;">
                <option value="bps" selected>bps</option>
                <option value="pct">%</option>
                <option value="usd">USD</option>
            </select>
        </div>
    </div>

    <!-- Summary Table -->
    <div style="margin-bottom: 15px; overflow-x: auto;">
        <table id="summary_table_execution_analysis" style="width: 100%; border-collapse: collapse; font-size: 13px;">
            <tr><td colspan="8" style="padding: 8px; background: #f5f5f5;">Loading...</td></tr>
        </table>
    </div>

    <!-- Controls Row 2: View buttons - Top and Bottom on same row -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;">
        <!-- Top Panel View Buttons -->
        <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
            <span><strong>Top:</strong></span>
            <button id="top_view_1_execution_analysis" onclick="setTopView_execution_analysis(1)"
                    style="padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #3498db; font-size: 12px;">
                Bid/Ask
            </button>
            <button id="top_view_2_execution_analysis" onclick="setTopView_execution_analysis(2)"
                    style="padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #95a5a6; font-size: 12px;">
                Mid+CF
            </button>
            <button id="top_view_3_execution_analysis" onclick="setTopView_execution_analysis(3)"
                    style="padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #95a5a6; font-size: 12px;">
                +Peers
            </button>
            <button id="top_view_4_execution_analysis" onclick="setTopView_execution_analysis(4)"
                    style="padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #95a5a6; font-size: 12px;">
                Progress
            </button>
            <button id="top_view_5_execution_analysis" onclick="setTopView_execution_analysis(5)"
                    style="padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #95a5a6; font-size: 12px;">
                Spread Pos
            </button>
            <button id="top_view_6_execution_analysis" onclick="setTopView_execution_analysis(6)"
                    style="padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #95a5a6; font-size: 12px;">
                Slippage
            </button>
            <button id="volume_toggle_execution_analysis" onclick="toggleVolume_execution_analysis()"
                    style="padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #95a5a6; font-size: 12px;">
                Volume
            </button>
        </div>
    </div>

    <!-- Aspect Ratio Slider -->
    <div style="margin-bottom: 15px;">
        <label for="aspect_ratio_slider_execution_analysis"><strong>Aspect Ratio:</strong></label>
        <input type="range" id="aspect_ratio_slider_execution_analysis" min="0.3" max="0.8" step="0.02" value="0.5"
               style="width: 70%; vertical-align: middle; margin-left: 10px;">
    </div>

    <!-- Chart Panel -->
    <div id="top_panel_execution_analysis" style="width: 100%; height: 400px;"></div>

    <div style="margin-top: 10px; font-size: 12px; color: #666;">Interactive execution analysis showing bid/ask spreads, fills, counterfactual prices, and slippage metrics. Use the top panel buttons to switch between views: Bid/Ask shows market spread with fills, Mid+CF shows counterfactual prices, +Peers adds peer asset lines, Progress shows execution completion over time, Spread Pos shows where fills occurred within the spread. The bottom panel shows cumulative slippage (Classical, vs VWAP, Refined), spread crossing percentage, or volume distribution.</div>

    <!-- Data Sources -->
    <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 11px; color: #666;">
        <strong>Data Sources:</strong> This visualization uses data from <code>RefinedSlippage.ExecutionData</code>.
        <ul style="margin: 5px 0 0 15px; padding: 0;">
            <li><strong>Fills:</strong> Trade executions from <code>exec_data.fills</code> (time, price, quantity, execution_name, asset)</li>
            <li><strong>Bid/Ask:</strong> Top-of-book quotes from <code>exec_data.tob</code> (time, symbol, bid_price, ask_price)</li>
            <li><strong>Volume:</strong> Market volume from <code>exec_data.volume</code> (time_from, time_to, symbol, volume) - optional</li>
            <li><strong>Peer Returns:</strong> Correlated asset returns from <code>exec_data.fill_returns</code> columns (computed via covariance matrix)</li>
            <li><strong>Slippage Metrics:</strong> Summary statistics from <code>exec_data.summary_bps</code> (classical, refined, vs_vwap slippage)</li>
        </ul>
        To regenerate: <code>exec_data = ExecutionData(fills, metadata, tob, covar_matrix; volume=volume)</code> then <code>calculate_slippage!(exec_data)</code>
    </div>
</div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: exec_data.parquet</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.6.0.</small></p>
</body>
</html>
