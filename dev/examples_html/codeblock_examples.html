<!DOCTYPE html>
<html>
<head>
    <title>CodeBlock Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-julia.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['day'];
    const Y_COLS = ['stock_a', 'stock_b'];
    const COLOR_COLS = [];
    const COLOR_MAPS = {};
    const DEFAULT_X_COL = 'day';
    const DEFAULT_Y_COL = 'stock_a';
    const DEFAULT_COLOR_COL = '__no_color__';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_stock_chart = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stock_chart');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stock_chart');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_stock_chart');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_stock_chart');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_stock_chart');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_stock_chart' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_stock_chart');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_stock_chart');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stock_chart');
        const facet2Select = document.getElementById('facet2_select_stock_chart');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'stock_chart',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                let xValues = result.xValues;
                let yValues = result.yValues;

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('stock_chart', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    let xValues = result.xValues;
                    let yValues = result.yValues;

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stock_chart', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        let xValues = result.xValues;
                        let yValues = result.yValues;

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stock_chart', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('df1').then(function(data) {
        allData = data;
        window.updateChart_stock_chart();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('stock_chart');
    }).catch(function(error) {
        console.error('Error loading data for chart stock_chart:', error);
    });
})();
(function() {
    // Configuration
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const VALUE_COLS = ['sales'];
    const COLOR_COLS = ['category'];
    const COLOR_MAPS = {'category': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product D': '#ab63fa', 'Product B': '#EF553B'}};
    const DEFAULT_VALUE_COL = 'sales';
    const DEFAULT_COLOR_COL = 'category';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_sales_pie = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and color columns
        const valueColSelect = document.getElementById('value_col_select_sales_pie');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const colorColSelect = document.getElementById('color_col_select_sales_pie');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get color map for current color selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Get categorical filter values (multiple selections)
        const filters = {};
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_sales_pie');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get continuous filter values (range sliders)
        const rangeFilters = {};
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_sales_pie' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'sales_pie',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_sales_pie');
        const facet2Select = document.getElementById('facet2_select_sales_pie');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, COLOR_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('sales_pie', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, COLOR_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('sales_pie', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, COLOR_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('sales_pie', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('pie_data').then(function(data) {
        allData = data;
        window.updateChart_sales_pie();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('sales_pie');
    }).catch(function(error) {
        console.error('Error loading data for chart sales_pie:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const CATEGORICAL_FILTERS = [];
    const CONTINUOUS_FILTERS = [];
    const X_COLS = ['date'];
    const Y_COLS = ['temperature', 'humidity'];
    const COLOR_COLS = [];
    const COLOR_MAPS = {};
    const DEFAULT_X_COL = 'date';
    const DEFAULT_Y_COL = 'temperature';
    const DEFAULT_COLOR_COL = '__no_color__';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;  // Return all values when no aggregation
        if (method === 'count') return [values.length];
        if (method === 'sum') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum];
        }
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Centralized aggregation logic
    // Takes data that has already been filtered by facets and color
    // Groups by X and aggregates Y values
    function aggregateGroupData(groupData, xCol, yCol, aggregator) {
        // Note: Date parsing is now handled centrally in loadDataset()
        // All dates are already JavaScript Date objects by the time we get here

        let xValues, yValues;

        if (aggregator === 'none') {
            // No aggregation - return all rows with duplicates
            xValues = groupData.map(row => row[xCol]);
            yValues = groupData.map(row => row[yCol]);
        } else {
            // Group by x value and aggregate y values
            // Keep track of original x values (including Date objects)
            const xGroups = {};
            const xOriginalValues = {};  // Store original values to preserve Date objects

            groupData.forEach(row => {
                const xVal = row[xCol];
                const xKey = String(xVal);  // Use string as key
                if (!xGroups[xKey]) {
                    xGroups[xKey] = [];
                    xOriginalValues[xKey] = xVal;  // Keep original value (Date object if it's a date)
                }
                xGroups[xKey].push(row[yCol]);
            });

            xValues = [];
            yValues = [];

            // Check first original value to determine type
            const firstKey = Object.keys(xGroups)[0];
            const firstOriginal = xOriginalValues[firstKey];
            const isDate = firstOriginal instanceof Date;

            // Sort keys appropriately
            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                if (isDate) {
                    // For dates, compare the actual Date objects
                    const dateA = xOriginalValues[a];
                    const dateB = xOriginalValues[b];
                    return dateA - dateB;  // Date subtraction gives milliseconds difference
                }
                const aNum = parseFloat(a);
                const bNum = parseFloat(b);
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }
                return String(a).localeCompare(String(b));
            });

            // Aggregate y values for each unique x
            sortedKeys.forEach(xKey => {
                const aggregated = aggregate(xGroups[xKey], aggregator);
                if (aggregated && aggregated.length > 0) {
                    xValues.push(xOriginalValues[xKey]);  // Use original value (preserves Date objects)
                    yValues.push(aggregated[0]);
                }
            });
        }

        return {xValues, yValues};
    }

    // Make it global so inline onchange can see it
    window.updateChart_weather = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_weather');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_weather');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current axis transformations
        const xTransformSelect = document.getElementById('x_transform_select_weather');
        const X_TRANSFORM = xTransformSelect ? xTransformSelect.value : 'identity';

        const yTransformSelect = document.getElementById('y_transform_select_weather');
        const Y_TRANSFORM = yTransformSelect ? yTransformSelect.value : 'identity';

        // Get current filter values
        const filters = {};
        const rangeFilters = {};

        // Read categorical filters (dropdowns)
        CATEGORICAL_FILTERS.forEach(col => {
            const select = document.getElementById(col + '_select_weather');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Read continuous filters (range sliders)
        CONTINUOUS_FILTERS.forEach(col => {
            const slider = $('#' + col + '_range_weather' + '_slider');
            if (slider.length > 0) {
                rangeFilters[col] = {
                    min: slider.slider("values", 0),
                    max: slider.slider("values", 1)
                };
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_weather');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_weather');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_weather');
        const facet2Select = document.getElementById('facet2_select_weather');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Apply filters with observation counting (centralized function)
        const filteredData = applyFiltersWithCounting(
            allData,
            'weather',
            CATEGORICAL_FILTERS,
            CONTINUOUS_FILTERS,
            filters,
            rangeFilters
        );

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                // Robust sort that handles dates, numbers, and strings
                group.data.sort((a, b) => {
                    const aVal = a[X_COL];
                    const bVal = b[X_COL];

                    // Check if values are Date objects
                    if (aVal instanceof Date && bVal instanceof Date) {
                        return aVal - bVal;
                    }

                    const aStr = String(aVal);
                    const bStr = String(bVal);

                    // Try numeric comparison
                    const aNum = parseFloat(aVal);
                    const bNum = parseFloat(bVal);
                    if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                        return aNum - bNum;
                    }

                    // Fall back to string comparison
                    return aStr.localeCompare(bStr);
                });

                // Use centralized aggregation function
                const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                let xValues = result.xValues;
                let yValues = result.yValues;

                // Apply axis transformations
                xValues = applyAxisTransform(xValues, X_TRANSFORM);
                yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: getAxisLabel(X_COL, X_TRANSFORM) },
                yaxis: { title: getAxisLabel(Y_COL, Y_TRANSFORM) },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('weather', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    // Robust sort that handles dates, numbers, and strings
                    group.data.sort((a, b) => {
                        const aVal = a[X_COL];
                        const bVal = b[X_COL];

                        // Check if values are Date objects
                        if (aVal instanceof Date && bVal instanceof Date) {
                            return aVal - bVal;
                        }

                        const aStr = String(aVal);
                        const bStr = String(bVal);

                        // Try numeric comparison
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                            return aNum - bNum;
                        }

                        // Fall back to string comparison
                        return aStr.localeCompare(bStr);
                    });

                    // Use centralized aggregation function
                    const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                    let xValues = result.xValues;
                    let yValues = result.yValues;

                    // Apply axis transformations
                    xValues = applyAxisTransform(xValues, X_TRANSFORM);
                    yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('weather', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        // Robust sort that handles dates, numbers, and strings
                        group.data.sort((a, b) => {
                            const aVal = a[X_COL];
                            const bVal = b[X_COL];

                            // Check if values are Date objects
                            if (aVal instanceof Date && bVal instanceof Date) {
                                return aVal - bVal;
                            }

                            const aStr = String(aVal);
                            const bStr = String(bVal);

                            // Try numeric comparison
                            const aNum = parseFloat(aVal);
                            const bNum = parseFloat(bVal);
                            if (!isNaN(aNum) && !isNaN(bNum) && aStr === String(aNum) && bStr === String(bNum)) {
                                return aNum - bNum;
                            }

                            // Fall back to string comparison
                            return aStr.localeCompare(bStr);
                        });

                        // Use centralized aggregation function
                        const result = aggregateGroupData(group.data, X_COL, Y_COL, AGGREGATOR);
                        let xValues = result.xValues;
                        let yValues = result.yValues;

                        // Apply axis transformations
                        xValues = applyAxisTransform(xValues, X_TRANSFORM);
                        yValues = applyAxisTransform(yValues, Y_TRANSFORM);

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? getAxisLabel(X_COL, X_TRANSFORM) : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? getAxisLabel(Y_COL, Y_TRANSFORM) : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('weather', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('weather_data').then(function(data) {
        allData = data;
        window.updateChart_weather();

        // Setup aspect ratio control after initial render
        setupAspectRatioControl('weather');
    }).catch(function(error) {
        console.error('Error loading data for chart weather:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="pie_data" data-format="csv_embedded" data-src="">
category,sales
Product A,45000
Product B,32000
Product C,28000
Product D,15000

</script><script type="text/plain" id="df1" data-format="csv_embedded" data-src="">
day,stock_a,stock_b,category
1,99.87316231034576,100.5196043144731,Tech
2,100.54004748283288,100.2055269945547,Tech
3,99.28343499327386,101.66461084530344,Tech
4,99.19843936810835,102.87109202727167,Tech
5,99.10416536326017,103.02895605058097,Tech
6,100.08205052622654,102.60232791382701,Tech
7,99.41138783193044,104.65818137476941,Tech
8,98.69664744001092,105.26884764217958,Tech
9,97.72944991120258,105.92189128848544,Tech
10,96.36526187684458,105.28457892314574,Tech
11,95.36568961687507,104.70508038282888,Tech
12,93.87370649423822,104.36262631448088,Tech
13,92.56339085303905,103.98367260307678,Tech
14,93.51962642615172,103.79313054665646,Tech
15,95.56428818961547,104.60035694178409,Tech
16,97.19874670237867,104.88971742768646,Tech
17,97.80927715417447,105.13580568528526,Tech
18,98.35643575252452,104.77535260305542,Tech
19,98.02897558549863,104.97722354743632,Tech
20,97.52222374915497,105.91387374816864,Tech
21,98.56653795514394,107.05535962825242,Tech
22,97.56103917883829,108.03372689306529,Tech
23,97.01546407055382,108.16541769665264,Tech
24,97.67581599147393,108.5611272022201,Tech
25,96.91576738570667,109.54864220386332,Tech
26,96.38953652270513,110.79166290032165,Finance
27,96.0078142857065,110.80772413410543,Finance
28,95.32735842584998,110.80912281047162,Finance
29,95.50911500083075,109.56773943657166,Finance
30,94.81587632342733,110.3405593224804,Finance
31,94.28116544687575,110.28715488370818,Finance
32,92.94854397578783,109.5237818392602,Finance
33,92.70872331620227,109.20299268549499,Finance
34,92.38603001593782,109.00039894192216,Finance
35,94.2922647381304,111.02976880990374,Finance
36,95.41895842454362,112.83003250400051,Finance
37,97.65930628227215,112.92530396273263,Finance
38,98.29174541017882,113.74130382092653,Finance
39,99.05817867049953,112.55397232985717,Finance
40,100.64459094656733,113.01092671486153,Finance
41,98.95924789083901,113.31215371520568,Finance
42,98.71810987709638,114.10457149299823,Finance
43,97.4141426484766,113.06966805458859,Finance
44,96.69489294802722,112.55367226096898,Finance
45,97.53389508618432,114.16076765268082,Finance
46,98.15011729813135,115.19663274238685,Finance
47,98.65699566191995,117.36071009576622,Finance
48,99.82456990309856,116.97199806039052,Finance
49,96.76944510806366,117.4283704307137,Finance
50,98.34807805289849,116.35385906587679,Finance

</script><script type="text/plain" id="weather_data" data-format="csv_embedded" data-src="">
date,temperature,humidity,city
2024-01-01,15.874205926089,71.32364149317732,New York
2024-01-02,17.92605400875348,75.09763454484595,New York
2024-01-03,15.928723594833105,70.09151387482557,New York
2024-01-04,23.36342039015151,68.71483264894921,New York
2024-01-05,20.27352801647028,76.12524071624168,New York
2024-01-06,20.819006454828738,68.55289933821163,New York
2024-01-07,25.31950031651269,53.33999914083305,New York
2024-01-08,26.592988020144357,62.9901198201839,New York
2024-01-09,21.318959487572954,58.56828006622417,New York
2024-01-10,25.31985242624332,54.60280357933085,New York
2024-01-11,26.115112369150356,49.90424437937599,New York
2024-01-12,18.722013527450695,54.07304283234126,New York
2024-01-13,19.618136977638233,46.2941922935986,New York
2024-01-14,17.310630197550537,46.00694012441268,New York
2024-01-15,15.072864777422666,50.20212983773374,New York
2024-01-16,17.130071236261553,49.80877358146947,New York
2024-01-17,11.722599426919972,46.77370972254224,Boston
2024-01-18,11.016707516281894,45.90681068011041,Boston
2024-01-19,8.476215439568804,37.57187674484582,Boston
2024-01-20,9.47203247528956,54.244747951947815,Boston
2024-01-21,2.5717466888909453,49.154226453865746,Boston
2024-01-22,5.585409381958428,53.88429564994749,Boston
2024-01-23,6.567286077810926,54.90304028125339,Boston
2024-01-24,4.313019834917812,56.78355426208787,Boston
2024-01-25,5.523477604040132,71.89963898828132,Boston
2024-01-26,7.845197985088049,70.53109291519021,Boston
2024-01-27,8.729973026722991,65.0886033930525,Boston
2024-01-28,7.517927206750587,71.68388025008095,Boston
2024-01-29,7.707907938818686,83.86369356110542,Boston
2024-01-30,8.963937667759913,76.60593350036682,Boston
2024-01-31,16.867106708122073,69.34266225872334,Boston

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/codeblock_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>CodeBlock Examples</h1>
<p>This page demonstrates how to use CodeBlock elements in JSPlots to display code with syntax highlighting and execute Julia code to generate visualizations.</p>
<p>CodeBlocks are perfect for creating literate programming documents where you show both the code and its output.</p>
<p><strong>Supported languages:</strong> Julia (executable), Python, R, C++, C, Java, JavaScript, SQL, PostgreSQL (PL/pgSQL), Rust, and more (display only).</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 1: CodeBlock from a Function</h2>
<p>Here we create a CodeBlock from a function that generates random stock data. The code is displayed with syntax highlighting, and we can execute it to get the data.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#230">
    <div class="codeblock-header">
        <span class="codeblock-language">Julia</span>
    </div>
    <pre><code class="language-julia">function generate_sample_data()
    n = 50
    x = 1:n
    y1 = cumsum(randn(rng, n)) .+ 100
    y2 = cumsum(randn(rng, n)) .+ 100

    return DataFrame(
        day = x,
        stock_a = y1,
        stock_b = y2,
        category = repeat([&quot;Tech&quot;, &quot;Finance&quot;], inner=25)
    )
end</code></pre>
    <div class="codeblock-notes">This function generates random walk stock price data</div>
</div>
<br>
<hr>
<br>
<h2>Stock Prices Over Time</h2>
<p>Data generated by the code above</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_stock_chart">Aggregator: </label>
                <select id="aggregator_select_stock_chart" onchange="updateChart_stock_chart()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_stock_chart_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label>X: </label>
        <span style="font-weight: bold;">day</span>
    </div>
    <div>
        <label for="x_transform_select_stock_chart">X Transform: </label>
        <select id="x_transform_select_stock_chart" style="padding: 5px 10px;" onchange="updateChart_stock_chart()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_stock_chart">Y: </label>
        <select id="y_col_select_stock_chart" style="padding: 5px 10px;" onchange="updateChart_stock_chart()">
            <option value="stock_a" selected>stock_a</option>
<option value="stock_b">stock_b</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_stock_chart">Y Transform: </label>
        <select id="y_transform_select_stock_chart" style="padding: 5px 10px;" onchange="updateChart_stock_chart()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="stock_chart_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="stock_chart_aspect_ratio_label">0.4</span>
    <input type="range" id="stock_chart_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="stock_chart"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: df1</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 2: Showing Code and Chart Together</h2>
<p>This example shows how to display the code that creates a chart, alongside the chart itself.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#231">
    <div class="codeblock-header">
        <span class="codeblock-language">Julia</span>
    </div>
    <pre><code class="language-julia">function create_pie_chart()
    df = DataFrame(
        category = [&quot;Product A&quot;, &quot;Product B&quot;, &quot;Product C&quot;, &quot;Product D&quot;],
        sales = [45000, 32000, 28000, 15000]
    )

    return PieChart(:sales_pie, df, :pie_data;
        color_cols = [:category],
        value_cols = [:sales],
        title = &quot;Sales by Product&quot;
    ), df
end</code></pre>
    <div class="codeblock-notes">This function creates a pie chart showing sales by product</div>
</div>
<br>
<hr>
<br>
<h2>Sales by Product</h2>
<p></p>



<!-- Chart -->
<div id="sales_pie"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: pie_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 3: CodeBlock from a Code String</h2>
<p>Sometimes you want to show code for educational purposes without executing it. Here's an example:</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#232">
    <div class="codeblock-header">
        <span class="codeblock-language">julia</span>
    </div>
    <pre><code class="language-julia"># Tutorial: Creating a Simple Scatter Plot
using JSPlots, DataFrames, StableRNGs
rng = StableRNG(42)

# Step 1: Create your data
df = DataFrame(
    x = rand(rng, 100),
    y = rand(rng, 100),
    size = rand(rng, 100) .* 50,
    color = rand(rng, [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;], 100)
)

# Step 2: Create the scatter plot
scatter = ScatterPlot(:my_scatter, df, :my_data;
    x_cols = [:x],
    y_cols = [:y],
    size_col = :size,
    color_cols = [:color],
    title = &quot;My First Scatter Plot&quot;
)

# Step 3: Export to HTML
create_html(scatter, &quot;output.html&quot;)
</code></pre>
    
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 4: Multi-Step Workflow</h2>
<p>This example demonstrates how to show multiple code blocks that build on each other, creating a complete data analysis workflow.</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h3>Step 1: Prepare the Data</h3>
    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#233">
    <div class="codeblock-header">
        <span class="codeblock-language">Julia</span>
    </div>
    <pre><code class="language-julia">function prepare_analysis_data()
    dates = Date(2024,1,1):Day(1):Date(2024,1,31)
    df = DataFrame(
        date = dates,
        temperature = 15 .+ 10 .* sin.(2Ï .* (1:31) ./ 31) .+ randn(rng, 31) .* 2,
        humidity = 60 .+ 15 .* cos.(2Ï .* (1:31) ./ 31) .+ randn(rng, 31) .* 5,
        city = repeat([&quot;New York&quot;, &quot;Boston&quot;], inner=16)[1:31]
    )
    return df
end</code></pre>
    <div class="codeblock-notes">Generate synthetic weather data for analysis</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h3>Step 2: Visualize the Data</h3>
    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#234">
    <div class="codeblock-header">
        <span class="codeblock-language">julia</span>
    </div>
    <pre><code class="language-julia"># Create a line chart showing temperature trends
weather_chart = LineChart(:weather, weather_df, :weather_data;
    x_cols = [:date],
    y_cols = [:temperature, :humidity],
    title = &quot;January Weather Patterns&quot;,
    notes = &quot;Temperature (Â°C) and Humidity (%)&quot;
)
</code></pre>
    <div class="codeblock-notes">Code to create the weather visualization</div>
</div>
<br>
<hr>
<br>
<h2>January Weather Patterns</h2>
<p></p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px; display: flex; align-items: center;">
            <div style="flex: 0 0 70%;">
                <label for="aggregator_select_weather">Aggregator: </label>
                <select id="aggregator_select_weather" onchange="updateChart_weather()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
                <option value="sum">sum</option>
            </select>
            </div>
            <div style="flex: 0 0 30%; text-align: right; padding-right: 10px;">
                <span id="aggregator_select_weather_obs_count" style="font-size: 0.9em; color: #666;"></span>
            </div>
        </div>
        <h4 style="margin-top: 15px; margin-bottom: 10px; border-top: 1px solid #ddd; padding-top: 10px;">Axes</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div>
        <label>X: </label>
        <span style="font-weight: bold;">date</span>
    </div>
    <div>
        <label for="x_transform_select_weather">X Transform: </label>
        <select id="x_transform_select_weather" style="padding: 5px 10px;" onchange="updateChart_weather()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
    <div>
        <label for="y_col_select_weather">Y: </label>
        <select id="y_col_select_weather" style="padding: 5px 10px;" onchange="updateChart_weather()">
            <option value="temperature" selected>temperature</option>
<option value="humidity">humidity</option>
        </select>
    </div>
    <div>
        <label for="y_transform_select_weather">Y Transform: </label>
        <select id="y_transform_select_weather" style="padding: 5px 10px;" onchange="updateChart_weather()">
            <option value="identity" selected>identity</option>
<option value="log">log</option>
<option value="z_score">z_score</option>
<option value="quantile">quantile</option>
<option value="inverse_cdf">inverse_cdf</option>
        </select>
    </div>
</div>
<div style="margin: 15px 0; padding-top: 10px; border-top: 1px solid #ddd;">
    <label for="weather_aspect_ratio_slider">Aspect Ratio: </label>
    <span id="weather_aspect_ratio_label">0.4</span>
    <input type="range" id="weather_aspect_ratio_slider"
           min="-1.3862943611198906" max="0.9162907318741551" step="0.01" value="-0.916290731874155"
           style="width: 75%; margin-left: 10px;">
    <span style="margin-left: 10px; color: #666; font-size: 0.9em;">(0.25 - 2.5)</span>
</div>

</div>

<!-- Chart -->
<div id="weather"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: weather_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <hr style="border: 2px solid #0066cc; margin: 40px 0;">
<h1 style="color: #0066cc;">Multi-Language Code Display</h1>
<p>CodeBlock supports displaying code in multiple programming languages with proper syntax highlighting.</p>
<p>Note: Only Julia code can be executed. Code in other languages is for display purposes only.</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>5. Python Code</h2>
<p>Python code is displayed with proper syntax highlighting.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#235">
    <div class="codeblock-header">
        <span class="codeblock-language">python</span>
    </div>
    <pre><code class="language-python">def merge_sort(arr):
    if len(arr) &lt;= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt; right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result

# Example usage
numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = merge_sort(numbers)
print(f&quot;Sorted array: {sorted_numbers}&quot;)
</code></pre>
    <div class="codeblock-notes">Python merge sort implementation</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>6. R Code</h2>
<p>R statistical code with proper syntax highlighting.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#236">
    <div class="codeblock-header">
        <span class="codeblock-language">r</span>
    </div>
    <pre><code class="language-r"># Multiple linear regression in R
# Load the mtcars dataset
data(mtcars)

# Fit a linear model
model &lt;- lm(mpg ~ cyl + hp + wt, data = mtcars)

# Display the summary
summary(model)

# Create a plot
plot(model$fitted.values, model$residuals,
     main = &quot;Residual Plot&quot;,
     xlab = &quot;Fitted Values&quot;,
     ylab = &quot;Residuals&quot;)
abline(h = 0, col = &quot;red&quot;, lty = 2)

# Calculate predictions
new_data &lt;- data.frame(cyl = c(4, 6, 8), hp = c(110, 150, 200), wt = c(2.5, 3.0, 3.5))
predictions &lt;- predict(model, newdata = new_data)
print(predictions)
</code></pre>
    <div class="codeblock-notes">R linear regression analysis on mtcars dataset</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>7. SQL Code</h2>
<p>SQL queries with proper syntax highlighting.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#237">
    <div class="codeblock-header">
        <span class="codeblock-language">sql</span>
    </div>
    <pre><code class="language-sql">-- Complex customer analytics query
WITH customer_metrics AS (
    SELECT
        c.customer_id,
        c.name,
        COUNT(DISTINCT o.order_id) as total_orders,
        SUM(o.total_amount) as lifetime_value,
        AVG(o.total_amount) as avg_order_value,
        MAX(o.order_date) as last_order_date
    FROM customers c
    LEFT JOIN orders o ON c.customer_id = o.customer_id
    WHERE o.order_date &gt;= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
    GROUP BY c.customer_id, c.name
),
customer_segments AS (
    SELECT
        *,
        CASE
            WHEN lifetime_value &gt; 10000 THEN 'VIP'
            WHEN lifetime_value &gt; 5000 THEN 'Premium'
            WHEN lifetime_value &gt; 1000 THEN 'Standard'
            ELSE 'Basic'
        END as segment
    FROM customer_metrics
)
SELECT
    segment,
    COUNT(*) as customer_count,
    AVG(total_orders) as avg_orders_per_customer,
    SUM(lifetime_value) as segment_revenue
FROM customer_segments
GROUP BY segment
ORDER BY segment_revenue DESC;
</code></pre>
    <div class="codeblock-notes">SQL customer segmentation and analytics query</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>8. C++ Code</h2>
<p>C++ code with proper syntax highlighting.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#238">
    <div class="codeblock-header">
        <span class="codeblock-language">c++</span>
    </div>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

// Template class for a simple generic stack
template&lt;typename T&gt;
class Stack {
private:
    std::vector&lt;T&gt; elements;

public:
    void push(const T&amp; element) {
        elements.push_back(element);
    }

    T pop() {
        if (elements.empty()) {
            throw std::out_of_range(&quot;Stack is empty&quot;);
        }
        T top = elements.back();
        elements.pop_back();
        return top;
    }

    bool empty() const {
        return elements.empty();
    }

    size_t size() const {
        return elements.size();
    }
};

int main() {
    // Example usage
    Stack&lt;int&gt; numbers;

    // Push numbers
    for (int i = 1; i &lt;= 5; ++i) {
        numbers.push(i * 10);
    }

    // Pop and print
    while (!numbers.empty()) {
        std::cout &lt;&lt; numbers.pop() &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>
    <div class="codeblock-notes">C++ template stack implementation</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>9. JavaScript Code</h2>
<p>Modern JavaScript (ES6+) code with proper syntax highlighting.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#239">
    <div class="codeblock-header">
        <span class="codeblock-language">javascript</span>
    </div>
    <pre><code class="language-javascript">// Asynchronous data fetching and processing
class DataProcessor {
    constructor(apiUrl) {
        this.apiUrl = apiUrl;
        this.cache = new Map();
    }

    // Fetch data with caching
    async fetchData(endpoint) {
        const cacheKey = `${this.apiUrl}/${endpoint}`;

        if (this.cache.has(cacheKey)) {
            console.log('Returning cached data');
            return this.cache.get(cacheKey);
        }

        try {
            const response = await fetch(cacheKey);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            this.cache.set(cacheKey, data);
            return data;
        } catch (error) {
            console.error('Failed to fetch data:', error);
            throw error;
        }
    }

    // Process data with array methods
    processUsers(users) {
        return users
            .filter(user =&gt; user.active)
            .map(user =&gt; ({
                id: user.id,
                name: user.name,
                email: user.email,
                joinDate: new Date(user.created_at)
            }))
            .sort((a, b) =&gt; b.joinDate - a.joinDate)
            .slice(0, 10);
    }
}

// Usage example
const processor = new DataProcessor('https://api.example.com');

async function displayTopUsers() {
    try {
        const users = await processor.fetchData('users');
        const topUsers = processor.processUsers(users);

        topUsers.forEach(user =&gt; {
            console.log(`${user.name} - ${user.email}`);
        });
    } catch (error) {
        console.error('Error displaying users:', error);
    }
}

displayTopUsers();
</code></pre>
    <div class="codeblock-notes">Modern JavaScript with async/await and array methods</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>10. Rust Code</h2>
<p>Rust provides memory safety without garbage collection through its ownership system.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#240">
    <div class="codeblock-header">
        <span class="codeblock-language">rust</span>
    </div>
    <pre><code class="language-rust">#[derive(Debug)]
enum ParseError {
    InvalidFormat,
    OutOfRange,
}

struct DataPoint {
    timestamp: i64,
    value: f64,
}

impl DataPoint {
    fn new(timestamp: i64, value: f64) -&gt; Result&lt;Self, ParseError&gt; {
        if value &lt; 0.0 || value &gt; 100.0 {
            return Err(ParseError::OutOfRange);
        }
        Ok(DataPoint { timestamp, value })
    }
}

fn parse_data(input: &amp;str) -&gt; Result&lt;Vec&lt;DataPoint&gt;, ParseError&gt; {
    input
        .lines()
        .filter(|line| !line.trim().is_empty())
        .map(|line| {
            let parts: Vec&lt;&amp;str&gt; = line.split(',').collect();
            if parts.len() != 2 {
                return Err(ParseError::InvalidFormat);
            }

            let timestamp = parts[0]
                .trim()
                .parse::&lt;i64&gt;()
                .map_err(|_| ParseError::InvalidFormat)?;

            let value = parts[1]
                .trim()
                .parse::&lt;f64&gt;()
                .map_err(|_| ParseError::InvalidFormat)?;

            DataPoint::new(timestamp, value)
        })
        .collect()
}

fn calculate_statistics(data: &amp;[DataPoint]) -&gt; (f64, f64) {
    let sum: f64 = data.iter().map(|dp| dp.value).sum();
    let mean = sum / data.len() as f64;

    let variance: f64 = data
        .iter()
        .map(|dp| (dp.value - mean).powi(2))
        .sum::&lt;f64&gt;() / data.len() as f64;

    (mean, variance.sqrt())
}

fn main() {
    let input = &quot;1609459200,45.5\n1609545600,52.3\n1609632000,48.9&quot;;

    match parse_data(input) {
        Ok(data) =&gt; {
            let (mean, std_dev) = calculate_statistics(&amp;data);
            println!(&quot;Mean: {:.2}, Std Dev: {:.2}&quot;, mean, std_dev);
        }
        Err(e) =&gt; eprintln!(&quot;Error parsing data: {:?}&quot;, e),
    }
}
</code></pre>
    <div class="codeblock-notes">Demonstrates Rust's ownership, pattern matching, and functional iterators</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>11. Language Comparison - Binary Search</h2>
<p>The same algorithm implemented in different languages:</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#241">
    <div class="codeblock-header">
        <span class="codeblock-language">julia</span>
    </div>
    <pre><code class="language-julia">function binary_search(arr::Vector, target)
    left, right = 1, length(arr)

    while left &lt;= right
        mid = div(left + right, 2)

        if arr[mid] == target
            return mid
        elseif arr[mid] &lt; target
            left = mid + 1
        else
            right = mid - 1
        end
    end

    return nothing  # Not found
end
</code></pre>
    <div class="codeblock-notes">Binary search in Julia</div>
</div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#242">
    <div class="codeblock-header">
        <span class="codeblock-language">python</span>
    </div>
    <pre><code class="language-python">def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left &lt;= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] &lt; target:
            left = mid + 1
        else:
            right = mid - 1

    return None  # Not found
</code></pre>
    <div class="codeblock-notes">Binary search in Python</div>
</div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#243">
    <div class="codeblock-header">
        <span class="codeblock-language">c++</span>
    </div>
    <pre><code class="language-cpp">int binary_search(const std::vector&lt;int&gt;&amp; arr, int target) {
    int left = 0;
    int right = arr.size() - 1;

    while (left &lt;= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] &lt; target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;  // Not found
}
</code></pre>
    <div class="codeblock-notes">Binary search in C++</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Best Practices for Using CodeBlock</h2>
<div style="background-color: #f0f7ff; padding: 20px; border-left: 4px solid #0066cc; margin: 20px 0;">
    <h3>When to Use CodeBlock</h3>
    <ul>
        <li><strong>Documentation:</strong> Show how to use your analysis code</li>
        <li><strong>Reproducibility:</strong> Display the exact code that generated results</li>
        <li><strong>Teaching:</strong> Create tutorials with code examples</li>
        <li><strong>Reports:</strong> Include methodology alongside visualizations</li>
    </ul>

    <h3>CodeBlock Creation Methods</h3>
    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
        <thead>
            <tr style="background-color: #e6f2ff;">
                <th style="padding: 10px; text-align: left; border: 1px solid #ccc;">Method</th>
                <th style="padding: 10px; text-align: left; border: 1px solid #ccc;">Syntax</th>
                <th style="padding: 10px; text-align: left; border: 1px solid #ccc;">Executable?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="padding: 10px; border: 1px solid #ccc;">From Function</td>
                <td style="padding: 10px; border: 1px solid #ccc;"><code>CodeBlock(my_function)</code></td>
                <td style="padding: 10px; border: 1px solid #ccc;">â Yes</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ccc;">From File</td>
                <td style="padding: 10px; border: 1px solid #ccc;"><code>CodeBlock("script.jl")</code></td>
                <td style="padding: 10px; border: 1px solid #ccc;">â Yes</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ccc;">From String</td>
                <td style="padding: 10px; border: 1px solid #ccc;"><code>CodeBlock(code_str, Val(:code))</code></td>
                <td style="padding: 10px; border: 1px solid #ccc;">â No</td>
            </tr>
        </tbody>
    </table>

    <h3>Executing Code</h3>
    <p>For executable CodeBlocks, call them like functions using <code>codeblock()</code>:</p>
    <pre style="background-color: #f5f5f5; padding: 10px; border-radius: 5px;">
# Single return value
data = code_block()

# Multiple return values
chart, data = code_block()

# Alternative (but cb() is preferred)
data = execute_codeblock(code_block)
    </pre>

    <h3>Tips</h3>
    <ul>
        <li>Use the <code>notes</code> parameter to provide context about what the code does</li>
        <li>Combine CodeBlocks with charts to show both process and result</li>
        <li>For source extraction from functions, consider installing <code>CodeTracking.jl</code> for better results</li>
        <li>Use display-only CodeBlocks for tutorials or examples that shouldn't be executed</li>
    </ul>
</div>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary</h2>
<p>This page demonstrated CodeBlock features:</p>
<ul>
    <li><strong>Function-based CodeBlocks:</strong> Extract and display function source code</li>
    <li><strong>Executable code:</strong> Run Julia code and use the results in visualizations</li>
    <li><strong>Display-only blocks:</strong> Show tutorial or example code</li>
    <li><strong>Multi-step workflows:</strong> Document complete analysis processes</li>
    <li><strong>Integration with charts:</strong> Show code alongside its output</li>
    <li><strong>Multi-language support:</strong> Display code in Python, R, SQL, C++, JavaScript, Rust, and more</li>
    <li><strong>Language comparison:</strong> Show the same algorithm in different languages</li>
</ul>
<p><strong>Key Points:</strong></p>
<ul>
    <li>Only Julia code can be executed - all other languages are display-only</li>
    <li>Automatic syntax highlighting for all supported languages</li>
    <li>Only loads Prism.js components for languages actually used in the page</li>
    <li>Perfect for documentation, tutorials, and reproducible research</li>
</ul>
<p><strong>CodeBlocks make your analyses reproducible and educational by showing the code that generated every visualization!</strong></p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.3.3.</small></p>
</body>
</html>
