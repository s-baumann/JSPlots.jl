<!DOCTYPE html>
<html>
<head>
    <title>CodeBlock Examples</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-julia.min.js"></script>
</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                resolve(results.data);
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                resolve(data);
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        resolve(results.data);
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['day'];
    const Y_COLS = ['stock_a', 'stock_b'];
    const COLOR_COLS = [];
    const COLOR_MAPS = {};
    const DEFAULT_X_COL = 'day';
    const DEFAULT_Y_COL = 'stock_a';
    const DEFAULT_COLOR_COL = '__no_color__';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_stock_chart = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_stock_chart');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_stock_chart');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_stock_chart');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_stock_chart');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_stock_chart');
        const facet2Select = document.getElementById('facet2_select_stock_chart');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        if (!xGroups[xVal]) xGroups[xVal] = [];
                        xGroups[xVal].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];
                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xVal => {
                        const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // Keep original value type (don't force to float for strings)
                            const numVal = parseFloat(xVal);
                            xValues.push(isNaN(numVal) ? xVal : numVal);
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('stock_chart', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            if (!xGroups[xVal]) xGroups[xVal] = [];
                            xGroups[xVal].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];
                        // Sort keys - try numeric sort first, fall back to string sort
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xVal => {
                            const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                // Keep original value type (don't force to float for strings)
                                const numVal = parseFloat(xVal);
                                xValues.push(isNaN(numVal) ? xVal : numVal);
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('stock_chart', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                if (!xGroups[xVal]) xGroups[xVal] = [];
                                xGroups[xVal].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];
                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xVal => {
                                const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    const numVal = parseFloat(xVal);
                                    xValues.push(isNaN(numVal) ? xVal : numVal);
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('stock_chart', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('df1').then(function(data) {
        allData = data;
        window.updateChart_stock_chart();
    }).catch(function(error) {
        console.error('Error loading data for chart stock_chart:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const VALUE_COLS = ['sales'];
    const LABEL_COLS = ['category'];
    const COLOR_MAPS = {'category': {'Product A': '#636efa', 'Product C': '#00cc96', 'Product D': '#ab63fa', 'Product B': '#EF553B'}};
    const DEFAULT_VALUE_COL = 'sales';
    const DEFAULT_LABEL_COL = 'category';
    const HOLE = 0.0;
    const SHOW_LEGEND = true;

    // Store data globally
    let allData = [];

    // Function to aggregate data for pie chart
    function aggregateData(data, labelCol, valueCol) {
        const aggregated = {};
        for (const row of data) {
            const label = String(row[labelCol]);
            const value = Number(row[valueCol]) || 0;
            if (aggregated[label]) {
                aggregated[label] += value;
            } else {
                aggregated[label] = value;
            }
        }
        return aggregated;
    }

    // Make it global so inline onchange can see it
    window.updateChart_sales_pie = function() {
        // Check if data is loaded
        if (!allData || allData.length === 0) {
            return;
        }

        // Get current value and label columns
        const valueColSelect = document.getElementById('value_col_select_sales_pie');
        const VALUE_COL = valueColSelect ? valueColSelect.value : DEFAULT_VALUE_COL;

        const labelColSelect = document.getElementById('label_col_select_sales_pie');
        const LABEL_COL = labelColSelect ? labelColSelect.value : DEFAULT_LABEL_COL;

        // Get color map for current label selection
        const COLOR_MAP = COLOR_MAPS[LABEL_COL] || {};

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select_sales_pie');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_sales_pie');
        const facet2Select = document.getElementById('facet2_select_sales_pie');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        if (!facet1) {
            // No faceting - single pie chart
            const aggregated = aggregateData(filteredData, LABEL_COL, VALUE_COL);
            const labels = Object.keys(aggregated);
            const values = Object.values(aggregated);
            const colors = labels.map(label => COLOR_MAP[label] || '#808080');

            const trace = {
                type: 'pie',
                labels: labels,
                values: values,
                marker: { colors: colors },
                hole: HOLE,
                textposition: 'auto',
                hoverinfo: 'label+value+percent'
            };

            const layout = {
                showlegend: SHOW_LEGEND,
                margin: {l: 50, r: 50, t: 50, b: 50},
                height: 500
            };

            Plotly.newPlot('sales_pie', [trace], layout, {responsive: true});

        } else if (facet1 && !facet2) {
            // Facet wrap (1 variable)
            const facetValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const nFacets = facetValues.length;
            const nCols = Math.min(3, nFacets);
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const annotations = [];

            for (let i = 0; i < nFacets; i++) {
                const facetValue = facetValues[i];
                const facetData = filteredData.filter(row => String(row[facet1]) === facetValue);
                const aggregated = aggregateData(facetData, LABEL_COL, VALUE_COL);
                const labels = Object.keys(aggregated);
                const values = Object.values(aggregated);
                const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                const row = Math.floor(i / nCols);
                const col = i % nCols;

                const domain = {
                    x: [col / nCols + 0.01, (col + 1) / nCols - 0.01],
                    y: [1 - (row + 1) / nRows + 0.01, 1 - row / nRows - 0.01]
                };

                traces.push({
                    type: 'pie',
                    labels: labels,
                    values: values,
                    marker: {colors: colors},
                    hole: HOLE,
                    domain: domain,
                    name: facetValue,
                    hoverinfo: 'label+value+percent',
                    textposition: 'auto'
                });

                // Add facet label
                annotations.push({
                    text: facet1 + ': ' + facetValue,
                    showarrow: false,
                    x: (col + 0.5) / nCols,
                    y: 1 - row / nRows - 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'top',
                    font: {size: 12, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 20, r: 20, t: 40, b: 20}
            };

            Plotly.newPlot('sales_pie', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 variables)
            const rowValues = [...new Set(filteredData.map(row => String(row[facet1])))].sort();
            const colValues = [...new Set(filteredData.map(row => String(row[facet2])))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const annotations = [];

            for (let r = 0; r < nRows; r++) {
                for (let c = 0; c < nCols; c++) {
                    const rowVal = rowValues[r];
                    const colVal = colValues[c];
                    const cellData = filteredData.filter(row =>
                        String(row[facet1]) === rowVal &&
                        String(row[facet2]) === colVal
                    );

                    if (cellData.length > 0) {
                        const aggregated = aggregateData(cellData, LABEL_COL, VALUE_COL);
                        const labels = Object.keys(aggregated);
                        const values = Object.values(aggregated);
                        const colors = labels.map(label => COLOR_MAP[label] || '#808080');

                        const domain = {
                            x: [c / nCols + 0.01, (c + 1) / nCols - 0.01],
                            y: [1 - (r + 1) / nRows + 0.01, 1 - r / nRows - 0.01]
                        };

                        traces.push({
                            type: 'pie',
                            labels: labels,
                            values: values,
                            marker: {colors: colors},
                            hole: HOLE,
                            domain: domain,
                            hoverinfo: 'label+value+percent',
                            textposition: 'auto',
                            showlegend: false
                        });
                    }
                }
            }

            // Add column headers
            for (let c = 0; c < nCols; c++) {
                annotations.push({
                    text: facet2 + ': ' + colValues[c],
                    showarrow: false,
                    x: (c + 0.5) / nCols,
                    y: 1.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 11, weight: 'bold'}
                });
            }

            // Add row headers
            for (let r = 0; r < nRows; r++) {
                annotations.push({
                    text: facet1 + ': ' + rowValues[r],
                    showarrow: false,
                    x: -0.02,
                    y: 1 - (r + 0.5) / nRows,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'middle',
                    font: {size: 11, weight: 'bold'}
                });
            }

            const layout = {
                showlegend: SHOW_LEGEND && nRows * nCols <= 4,
                annotations: annotations,
                height: 300 * nRows,
                margin: {l: 80, r: 20, t: 60, b: 20}
            };

            Plotly.newPlot('sales_pie', traces, layout, {responsive: true});
        }
    };

    // Load and parse data
    loadDataset('pie_data').then(function(data) {
        allData = data;
        window.updateChart_sales_pie();
    }).catch(function(error) {
        console.error('Error loading data for chart sales_pie:', error);
    });
})();
(function() {
    // Configuration
    const FILTER_COLS = [];
    const X_COLS = ['date'];
    const Y_COLS = ['temperature', 'humidity'];
    const COLOR_COLS = [];
    const COLOR_MAPS = {};
    const DEFAULT_X_COL = 'date';
    const DEFAULT_Y_COL = 'temperature';
    const DEFAULT_COLOR_COL = '__no_color__';

    let allData = [];

    // Aggregation functions
    function aggregate(values, method) {
        if (values.length === 0) return null;
        if (method === 'none') return values;
        if (method === 'count') return [values.length];
        if (method === 'mean') {
            const sum = values.reduce((a, b) => a + b, 0);
            return [sum / values.length];
        }
        if (method === 'median') {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                [(sorted[mid - 1] + sorted[mid]) / 2] :
                [sorted[mid]];
        }
        if (method === 'min') return [Math.min(...values)];
        if (method === 'max') return [Math.max(...values)];
        return values;
    }

    // Make it global so inline onchange can see it
    window.updateChart_weather = function() {
        // Get current X and Y columns
        const xColSelect = document.getElementById('x_col_select_weather');
        const X_COL = xColSelect ? xColSelect.value : DEFAULT_X_COL;

        const yColSelect = document.getElementById('y_col_select_weather');
        const Y_COL = yColSelect ? yColSelect.value : DEFAULT_Y_COL;

        // Get current filter values (multiple selections)
        const filters = {};
        FILTER_COLS.forEach(col => {
            const select = document.getElementById(col + '_select');
            if (select) {
                filters[col] = Array.from(select.selectedOptions).map(opt => opt.value);
            }
        });

        // Get current color column
        const colorColSelect = document.getElementById('color_col_select_weather');
        const COLOR_COL = colorColSelect ? colorColSelect.value : DEFAULT_COLOR_COL;

        // Get current aggregator
        const aggregatorSelect = document.getElementById('aggregator_select_weather');
        const AGGREGATOR = aggregatorSelect ? aggregatorSelect.value : 'none';

        // Get current facet selections
        const facet1Select = document.getElementById('facet1_select_weather');
        const facet2Select = document.getElementById('facet2_select_weather');
        const facet1 = facet1Select && facet1Select.value !== 'None' ? facet1Select.value : null;
        const facet2 = facet2Select && facet2Select.value !== 'None' ? facet2Select.value : null;

        // Build FACET_COLS array based on selections
        const FACET_COLS = [];
        if (facet1) FACET_COLS.push(facet1);
        if (facet2) FACET_COLS.push(facet2);

        // Get color map for current selection
        const COLOR_MAP = COLOR_MAPS[COLOR_COL] || {};

        // Filter data (support multiple selections per filter)
        const filteredData = allData.filter(row => {
            for (let col in filters) {
                const selectedValues = filters[col];
                if (selectedValues.length > 0 && !selectedValues.includes(String(row[col]))) {
                    return false;
                }
            }
            return true;
        });

        if (FACET_COLS.length === 0) {
            // No faceting - group by color
            const groupedData = {};
            filteredData.forEach(row => {
                const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                if (!groupedData[colorVal]) {
                    groupedData[colorVal] = {
                        data: [],
                        color: colorVal
                    };
                }
                groupedData[colorVal].data.push(row);
            });

            const traces = [];
            for (let groupKey in groupedData) {
                const group = groupedData[groupKey];
                group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                let xValues, yValues;
                if (AGGREGATOR === 'none') {
                    xValues = group.data.map(row => row[X_COL]);
                    yValues = group.data.map(row => row[Y_COL]);
                } else {
                    // Group by x value and aggregate
                    const xGroups = {};
                    group.data.forEach(row => {
                        const xVal = row[X_COL];
                        if (!xGroups[xVal]) xGroups[xVal] = [];
                        xGroups[xVal].push(row[Y_COL]);
                    });

                    xValues = [];
                    yValues = [];
                    // Sort keys - try numeric sort first, fall back to string sort
                    const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                        const aNum = parseFloat(a);
                        const bNum = parseFloat(b);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        return String(a).localeCompare(String(b));
                    });

                    sortedKeys.forEach(xVal => {
                        const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                        if (aggregated && aggregated.length > 0) {
                            // Keep original value type (don't force to float for strings)
                            const numVal = parseFloat(xVal);
                            xValues.push(isNaN(numVal) ? xVal : numVal);
                            yValues.push(aggregated[0]);
                        }
                    });
                }

                traces.push({
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: group.color,
                    line: {
                        color: COLOR_MAP[group.color] || '#000000',
                        width: 1
                    },
                    marker: { size: 1 }
                });
            }

            const layout = {
                xaxis: { title: X_COL },
                yaxis: { title: Y_COL },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('weather', traces, layout, {responsive: true});

        } else if (FACET_COLS.length === 1) {
            // Facet wrap
            const facetCol = FACET_COLS[0];
            const facetValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nFacets = facetValues.length;

            // Calculate grid dimensions (prefer wider grids)
            const nCols = Math.ceil(Math.sqrt(nFacets * 1.5));
            const nRows = Math.ceil(nFacets / nCols);

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            facetValues.forEach((facetVal, idx) => {
                const facetData = filteredData.filter(row => row[facetCol] === facetVal);

                // Group by color within this facet
                const groupedData = {};
                facetData.forEach(row => {
                    const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                    if (!groupedData[colorVal]) {
                        groupedData[colorVal] = {
                            data: [],
                            color: colorVal
                        };
                    }
                    groupedData[colorVal].data.push(row);
                });

                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                for (let groupKey in groupedData) {
                    const group = groupedData[groupKey];
                    group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                    let xValues, yValues;
                    if (AGGREGATOR === 'none') {
                        xValues = group.data.map(row => row[X_COL]);
                        yValues = group.data.map(row => row[Y_COL]);
                    } else {
                        // Group by x value and aggregate
                        const xGroups = {};
                        group.data.forEach(row => {
                            const xVal = row[X_COL];
                            if (!xGroups[xVal]) xGroups[xVal] = [];
                            xGroups[xVal].push(row[Y_COL]);
                        });

                        xValues = [];
                        yValues = [];
                        // Sort keys - try numeric sort first, fall back to string sort
                        const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                            const aNum = parseFloat(a);
                            const bNum = parseFloat(b);
                            if (!isNaN(aNum) && !isNaN(bNum)) {
                                return aNum - bNum;
                            }
                            return String(a).localeCompare(String(b));
                        });

                        sortedKeys.forEach(xVal => {
                            const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                            if (aggregated && aggregated.length > 0) {
                                // Keep original value type (don't force to float for strings)
                                const numVal = parseFloat(xVal);
                                xValues.push(isNaN(numVal) ? xVal : numVal);
                                yValues.push(aggregated[0]);
                            }
                        });
                    }

                    const legendGroup = group.color;

                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: group.color,
                        legendgroup: legendGroup,
                        showlegend: idx === 0,
                        xaxis: xaxis,
                        yaxis: yaxis,
                        line: {
                            color: COLOR_MAP[group.color] || '#000000',
                            width: 1
                        },
                        marker: { size: 1 }
                    });
                }

                // Add axis configuration
                layout[xaxis] = {
                    title: row === nRows ? X_COL : '',
                    anchor: yaxis
                };
                layout[yaxis] = {
                    title: col === 1 ? Y_COL : '',
                    anchor: xaxis
                };

                // Add annotation for facet label
                if (!layout.annotations) layout.annotations = [];
                layout.annotations.push({
                    text: facetCol + ': ' + facetVal,
                    showarrow: false,
                    xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                    yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {size: 10}
                });
            });

            Plotly.newPlot('weather', traces, layout, {responsive: true});

        } else {
            // Facet grid (2 facet columns)
            const facetRow = FACET_COLS[0];
            const facetCol = FACET_COLS[1];
            const rowValues = [...new Set(filteredData.map(row => row[facetRow]))].sort();
            const colValues = [...new Set(filteredData.map(row => row[facetCol]))].sort();
            const nRows = rowValues.length;
            const nCols = colValues.length;

            const traces = [];
            const layout = {
                hovermode: 'closest',
                showlegend: true,
                grid: {rows: nRows, columns: nCols, pattern: 'independent'}
            };

            rowValues.forEach((rowVal, rowIdx) => {
                colValues.forEach((colVal, colIdx) => {
                    const facetData = filteredData.filter(row =>
                        row[facetRow] === rowVal && row[facetCol] === colVal
                    );

                    // Group by color within this facet
                    const groupedData = {};
                    facetData.forEach(row => {
                        const colorVal = (COLOR_COL === '__no_color__') ? 'all' : String(row[COLOR_COL]);
                        if (!groupedData[colorVal]) {
                            groupedData[colorVal] = {
                                data: [],
                                color: colorVal
                            };
                        }
                        groupedData[colorVal].data.push(row);
                    });

                    const idx = rowIdx * nCols + colIdx;
                    const xaxis = idx === 0 ? 'x' : 'x' + (idx + 1);
                    const yaxis = idx === 0 ? 'y' : 'y' + (idx + 1);

                    for (let groupKey in groupedData) {
                        const group = groupedData[groupKey];
                        group.data.sort((a, b) => a[X_COL] - b[X_COL]);

                        let xValues, yValues;
                        if (AGGREGATOR === 'none') {
                            xValues = group.data.map(row => row[X_COL]);
                            yValues = group.data.map(row => row[Y_COL]);
                        } else {
                            // Group by x value and aggregate
                            const xGroups = {};
                            group.data.forEach(row => {
                                const xVal = row[X_COL];
                                if (!xGroups[xVal]) xGroups[xVal] = [];
                                xGroups[xVal].push(row[Y_COL]);
                            });

                            xValues = [];
                            yValues = [];
                            const sortedKeys = Object.keys(xGroups).sort((a, b) => {
                                const aNum = parseFloat(a);
                                const bNum = parseFloat(b);
                                if (!isNaN(aNum) && !isNaN(bNum)) {
                                    return aNum - bNum;
                                }
                                return String(a).localeCompare(String(b));
                            });

                            sortedKeys.forEach(xVal => {
                                const aggregated = aggregate(xGroups[xVal], AGGREGATOR);
                                if (aggregated && aggregated.length > 0) {
                                    const numVal = parseFloat(xVal);
                                    xValues.push(isNaN(numVal) ? xVal : numVal);
                                    yValues.push(aggregated[0]);
                                }
                            });
                        }

                        const legendGroup = group.color;

                        traces.push({
                            x: xValues,
                            y: yValues,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: group.color,
                            legendgroup: legendGroup,
                            showlegend: idx === 0,
                            xaxis: xaxis,
                            yaxis: yaxis,
                            line: {
                                color: COLOR_MAP[group.color] || '#000000',
                                width: 1
                            },
                            marker: { size: 1 }
                        });
                    }

                    // Add axis configuration
                    layout[xaxis] = {
                        title: rowIdx === nRows - 1 ? X_COL : '',
                        anchor: yaxis
                    };
                    layout[yaxis] = {
                        title: colIdx === 0 ? Y_COL : '',
                        anchor: xaxis
                    };

                    // Add annotations for facet labels
                    if (!layout.annotations) layout.annotations = [];

                    // Column header
                    if (rowIdx === 0) {
                        layout.annotations.push({
                            text: facetCol + ': ' + colVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 0.5,
                            y: 1.1,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            font: {size: 10}
                        });
                    }

                    // Row label
                    if (colIdx === nCols - 1) {
                        layout.annotations.push({
                            text: facetRow + ': ' + rowVal,
                            showarrow: false,
                            xref: xaxis === 'x' ? 'x domain' : xaxis + ' domain',
                            yref: yaxis === 'y' ? 'y domain' : yaxis + ' domain',
                            x: 1.05,
                            y: 0.5,
                            xanchor: 'left',
                            yanchor: 'middle',
                            textangle: -90,
                            font: {size: 10}
                        });
                    }
                });
            });

            Plotly.newPlot('weather', traces, layout, {responsive: true});
        }
    };

    // Load and parse CSV data using centralized parser
    loadDataset('weather_data').then(function(data) {
        allData = data;
        window.updateChart_weather();
    }).catch(function(error) {
        console.error('Error loading data for chart weather:', error);
    });
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="pie_data" data-format="csv_embedded" data-src="">
category,sales
Product A,45000
Product B,32000
Product C,28000
Product D,15000

</script><script type="text/plain" id="df1" data-format="csv_embedded" data-src="">
day,stock_a,stock_b,category
1,99.18071052703158,98.27888427430203,Tech
2,98.32816554336851,98.43862831001908,Tech
3,99.27768877070139,97.94096571620206,Tech
4,99.52488698406124,98.37401066493759,Tech
5,99.26088058941866,97.8663353197746,Tech
6,98.13873722696229,96.74436933617142,Tech
7,96.43774291887279,96.06185764553425,Tech
8,96.17771576891433,97.76168740008028,Tech
9,96.26448190462928,96.9547212782765,Tech
10,93.96926713895822,98.81340230818907,Tech
11,93.3289101500578,98.05715068156516,Tech
12,94.3397582689833,99.07164788625049,Tech
13,94.82692356888212,98.770509122343,Tech
14,93.84688475910826,98.5639010308071,Tech
15,92.71213487123973,98.53830914660989,Tech
16,92.15472223637252,97.28936074147582,Tech
17,92.21591434412014,96.9219632261592,Tech
18,91.62506386401319,97.28430646063615,Tech
19,92.38017843278215,97.67190172750637,Tech
20,90.71828720204883,98.03827355959027,Tech
21,91.17856067928874,100.55903592198354,Tech
22,90.54578524803203,101.0874109272015,Tech
23,91.40841922432615,100.44897937081001,Tech
24,92.08051868406994,101.44735161016504,Tech
25,91.58119819346584,101.46127539291835,Tech
26,92.57898490736429,99.85169489139598,Finance
27,90.73623825787939,99.63530254289108,Finance
28,89.7319188999988,99.01969605745063,Finance
29,89.9035709993807,99.27681467202332,Finance
30,89.17996922258499,98.27208734461183,Finance
31,88.24840268368845,97.31871327112987,Finance
32,88.8539319800982,97.44971686465342,Finance
33,87.99267728682457,95.46854522396984,Finance
34,88.54877649985139,96.511854831957,Finance
35,88.33093060483432,95.3188259087223,Finance
36,89.79109435476124,95.26745665753072,Finance
37,92.02567341244082,94.14491466338269,Finance
38,90.85814354935113,92.27346895424806,Finance
39,90.41474906807352,91.55567814989712,Finance
40,89.49041564582922,91.74792930344056,Finance
41,87.59527346374591,91.95811070444783,Finance
42,88.01268876000493,92.81226435528701,Finance
43,89.38886238683827,92.58052983049808,Finance
44,87.98697401912372,93.38784255438854,Finance
45,87.47974189333503,91.70048345388135,Finance
46,87.73153581531425,91.98351639448461,Finance
47,87.6477111027446,91.16385758856254,Finance
48,87.37143341433965,93.27578550795765,Finance
49,87.53281072922323,90.9978197276234,Finance
50,87.80803364231727,90.72484815183827,Finance

</script><script type="text/plain" id="weather_data" data-format="csv_embedded" data-src="">
date,temperature,humidity,city
2024-01-01,11.730990831035623,85.74213611200359,New York
2024-01-02,19.81412049771926,66.39431385033728,New York
2024-01-03,16.960206506591394,73.64720622579577,New York
2024-01-04,24.318447149015203,63.28863902497481,New York
2024-01-05,23.92529795081478,73.90907340761669,New York
2024-01-06,19.100686673541322,63.15763607148668,New York
2024-01-07,26.532163243536484,64.38724220973918,New York
2024-01-08,26.822021759405484,62.08011938652119,New York
2024-01-09,25.608867079438248,51.11702272911351,New York
2024-01-10,23.336571727342513,56.63223387227692,New York
2024-01-11,22.39890069288616,49.92866386466133,New York
2024-01-12,21.89575363946972,46.122478680914085,New York
2024-01-13,20.08390966265782,47.86446824816943,New York
2024-01-14,16.8102641187813,48.29375277524512,New York
2024-01-15,16.02265641168701,46.55417263500412,New York
2024-01-16,13.966121934663633,51.400818677421526,New York
2024-01-17,13.593644786690394,42.235192789890206,Boston
2024-01-18,8.919861605342174,40.72690134510577,Boston
2024-01-19,8.128532893501074,60.50166311576617,Boston
2024-01-20,4.704298434162366,55.36197049743631,Boston
2024-01-21,8.629699332817598,52.33325476629834,Boston
2024-01-22,7.75231985240632,52.8165141452807,Boston
2024-01-23,5.177432458722264,60.665855478467726,Boston
2024-01-24,5.007434291891824,61.91580202939026,Boston
2024-01-25,11.557767710101675,56.78988022588801,Boston
2024-01-26,4.653692239648176,73.53140069204109,Boston
2024-01-27,8.877624428054185,69.22995147011999,Boston
2024-01-28,10.886728590091213,62.722152266021965,Boston
2024-01-29,10.574681998246065,74.30374200674164,Boston
2024-01-30,14.771399794489948,73.78157640024837,Boston
2024-01-31,18.203190260445748,82.45235614246488,Boston

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <h1>CodeBlock Examples</h1>
<p>This page demonstrates how to use CodeBlock elements in JSPlots to display Julia code with syntax highlighting and execute it to generate visualizations.</p>
<p>CodeBlocks are perfect for creating literate programming documents where you show both the code and its output.</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 1: CodeBlock from a Function</h2>
<p>Here we create a CodeBlock from a function that generates random stock data. The code is displayed with syntax highlighting, and we can execute it to get the data.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#230">
    <div class="codeblock-header">
        <span class="codeblock-language">Julia</span>
    </div>
    <pre><code class="language-julia">function generate_sample_data()
    n = 50
    x = 1:n
    y1 = cumsum(randn(n)) .+ 100
    y2 = cumsum(randn(n)) .+ 100

    return DataFrame(
        day = x,
        stock_a = y1,
        stock_b = y2,
        category = repeat([&quot;Tech&quot;, &quot;Finance&quot;], inner=25)
    )
end</code></pre>
    <div class="codeblock-notes">This function generates random walk stock price data</div>
</div>
<br>
<hr>
<br>
<h2>Stock Prices Over Time</h2>
<p>Data generated by the code above</p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="y_col_select_stock_chart">Y dimension: </label>
            <select id="y_col_select_stock_chart" onchange="updateChart_stock_chart()">
                <option value="stock_a" selected>stock_a</option>
                <option value="stock_b">stock_b</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="aggregator_select_stock_chart">Aggregator: </label>
            <select id="aggregator_select_stock_chart" onchange="updateChart_stock_chart()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="stock_chart"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: df1</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 2: Showing Code and Chart Together</h2>
<p>This example shows how to display the code that creates a chart, alongside the chart itself.</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#231">
    <div class="codeblock-header">
        <span class="codeblock-language">Julia</span>
    </div>
    <pre><code class="language-julia">function create_pie_chart()
    df = DataFrame(
        category = [&quot;Product A&quot;, &quot;Product B&quot;, &quot;Product C&quot;, &quot;Product D&quot;],
        sales = [45000, 32000, 28000, 15000]
    )

    return PieChart(:sales_pie, df, :pie_data;
        label_cols = [:category],
        value_cols = [:sales],
        title = &quot;Sales by Product&quot;
    ), df
end</code></pre>
    <div class="codeblock-notes">This function creates a pie chart showing sales by product</div>
</div>
<br>
<hr>
<br>
<h2>Sales by Product</h2>
<p></p>




<!-- Chart -->
<div id="sales_pie"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: pie_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 3: CodeBlock from a Code String</h2>
<p>Sometimes you want to show code for educational purposes without executing it. Here's an example:</p>

    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#232">
    <div class="codeblock-header">
        <span class="codeblock-language">julia</span>
    </div>
    <pre><code class="language-julia"># Tutorial: Creating a Simple Scatter Plot

# Step 1: Create your data
df = DataFrame(
    x = rand(100),
    y = rand(100),
    size = rand(100) .* 50,
    color = rand([&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;], 100)
)

# Step 2: Create the scatter plot
scatter = ScatterPlot(:my_scatter, df, :my_data;
    x_cols = [:x],
    y_cols = [:y],
    size_col = :size,
    color_cols = [:color],
    title = &quot;My First Scatter Plot&quot;
)

# Step 3: Export to HTML
create_html(scatter, &quot;output.html&quot;)
</code></pre>
    <div class="codeblock-notes">This code is for display only - not executed in this example</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Example 4: Multi-Step Workflow</h2>
<p>This example demonstrates how to show multiple code blocks that build on each other, creating a complete data analysis workflow.</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h3>Step 1: Prepare the Data</h3>
    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#233">
    <div class="codeblock-header">
        <span class="codeblock-language">Julia</span>
    </div>
    <pre><code class="language-julia">function prepare_analysis_data()
    dates = Date(2024,1,1):Day(1):Date(2024,1,31)
    df = DataFrame(
        date = dates,
        temperature = 15 .+ 10 .* sin.(2 .* (1:31) ./ 31) .+ randn(31) .* 2,
        humidity = 60 .+ 15 .* cos.(2 .* (1:31) ./ 31) .+ randn(31) .* 5,
        city = repeat([&quot;New York&quot;, &quot;Boston&quot;], inner=16)[1:31]
    )
    return df
end</code></pre>
    <div class="codeblock-notes">Generate synthetic weather data for analysis</div>
</div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h3>Step 2: Visualize the Data</h3>
    </div>
<br>
<hr>
<br>
<style>
.codeblock-container {
    margin: 20px 0;
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    overflow: hidden;
    background-color: #ffffff;
}

.codeblock-header {
    background-color: #f6f8fa;
    padding: 8px 16px;
    border-bottom: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
}

.codeblock-language {
    font-size: 12px;
    font-weight: 600;
    color: #586069;
    text-transform: uppercase;
}

.codeblock-container pre {
    margin: 0;
    padding: 16px;
    overflow-x: auto;
    background-color: #f6f8fa;
}

.codeblock-container code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 13px;
    line-height: 1.6;
}

.codeblock-notes {
    padding: 12px 16px;
    background-color: #fffbdd;
    border-top: 1px solid #e1e4e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #24292e;
}
</style>
<div class="codeblock-container" id="##codeblock#234">
    <div class="codeblock-header">
        <span class="codeblock-language">julia</span>
    </div>
    <pre><code class="language-julia"># Create a line chart showing temperature trends
weather_chart = LineChart(:weather, weather_df, :weather_data;
    x_cols = [:date],
    y_cols = [:temperature, :humidity],
    title = &quot;January Weather Patterns&quot;,
    notes = &quot;Temperature (C) and Humidity (%)&quot;
)
</code></pre>
    <div class="codeblock-notes">Code to create the weather visualization</div>
</div>
<br>
<hr>
<br>
<h2>January Weather Patterns</h2>
<p></p>


<div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; background-color: #f0fff0;">
    <h4 style="margin-top: 0;">Plot Attributes</h4>
            <div style="margin: 10px;">
            <label for="y_col_select_weather">Y dimension: </label>
            <select id="y_col_select_weather" onchange="updateChart_weather()">
                <option value="temperature" selected>temperature</option>
                <option value="humidity">humidity</option>
            </select>
        </div>
                <div style="margin: 10px;">
            <label for="aggregator_select_weather">Aggregator: </label>
            <select id="aggregator_select_weather" onchange="updateChart_weather()">
                <option value="none" selected>none</option>
                <option value="mean">mean</option>
                <option value="median">median</option>
                <option value="count">count</option>
                <option value="min">min</option>
                <option value="max">max</option>
            </select>
        </div>
        
</div>


<!-- Chart -->
<div id="weather"></div>
<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: weather_data</p><br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Best Practices for Using CodeBlock</h2>
<div style="background-color: #f0f7ff; padding: 20px; border-left: 4px solid #0066cc; margin: 20px 0;">
    <h3>When to Use CodeBlock</h3>
    <ul>
        <li><strong>Documentation:</strong> Show how to use your analysis code</li>
        <li><strong>Reproducibility:</strong> Display the exact code that generated results</li>
        <li><strong>Teaching:</strong> Create tutorials with code examples</li>
        <li><strong>Reports:</strong> Include methodology alongside visualizations</li>
    </ul>

    <h3>CodeBlock Creation Methods</h3>
    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
        <thead>
            <tr style="background-color: #e6f2ff;">
                <th style="padding: 10px; text-align: left; border: 1px solid #ccc;">Method</th>
                <th style="padding: 10px; text-align: left; border: 1px solid #ccc;">Syntax</th>
                <th style="padding: 10px; text-align: left; border: 1px solid #ccc;">Executable?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="padding: 10px; border: 1px solid #ccc;">From Function</td>
                <td style="padding: 10px; border: 1px solid #ccc;"><code>CodeBlock(my_function)</code></td>
                <td style="padding: 10px; border: 1px solid #ccc;"> Yes</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ccc;">From File</td>
                <td style="padding: 10px; border: 1px solid #ccc;"><code>CodeBlock("script.jl")</code></td>
                <td style="padding: 10px; border: 1px solid #ccc;"> Yes</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ccc;">From String</td>
                <td style="padding: 10px; border: 1px solid #ccc;"><code>CodeBlock(code_str, Val(:code))</code></td>
                <td style="padding: 10px; border: 1px solid #ccc;"> No</td>
            </tr>
        </tbody>
    </table>

    <h3>Executing Code</h3>
    <p>For executable CodeBlocks, call them like functions using <code>codeblock()</code>:</p>
    <pre style="background-color: #f5f5f5; padding: 10px; border-radius: 5px;">
# Single return value
data = code_block()

# Multiple return values
chart, data = code_block()

# Alternative (but cb() is preferred)
data = execute_codeblock(code_block)
    </pre>

    <h3>Tips</h3>
    <ul>
        <li>Use the <code>notes</code> parameter to provide context about what the code does</li>
        <li>Combine CodeBlocks with charts to show both process and result</li>
        <li>For source extraction from functions, consider installing <code>CodeTracking.jl</code> for better results</li>
        <li>Use display-only CodeBlocks for tutorials or examples that shouldn't be executed</li>
    </ul>
</div>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary</h2>
<p>This page demonstrated CodeBlock features:</p>
<ul>
    <li><strong>Function-based CodeBlocks:</strong> Extract and display function source code</li>
    <li><strong>Executable code:</strong> Run code and use the results in visualizations</li>
    <li><strong>Display-only blocks:</strong> Show tutorial or example code</li>
    <li><strong>Multi-step workflows:</strong> Document complete analysis processes</li>
    <li><strong>Integration with charts:</strong> Show code alongside its output</li>
</ul>
<p><strong>CodeBlocks make your analyses reproducible and educational by showing the code that generated every visualization!</strong></p>

    </div>


<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a>.</small></p>
</body>
</html>
