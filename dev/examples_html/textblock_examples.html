<!DOCTYPE html>
<html>
<head>
    <title>TextBlock Examples</title>
    <meta charset="UTF-8">

    <!-- External JavaScript libraries (loaded based on chart types used) -->
        <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
        <style>
        .textblock-content {
            padding: 20px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .textblock-content h1 {
            font-size: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h2 {
            font-size: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content h3 {
            font-size: 1.25em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .textblock-content p {
            margin: 0.5em 0;
        }

        .textblock-content ul, .textblock-content ol {
            margin: 0.5em 0;
            padding-left: 2em;
        }

        .textblock-content code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .textblock-content pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .textblock-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .textblock-content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin-left: 0;
            color: #666;
        }

        .textblock-content a {
            color: #0066cc;
            text-decoration: none;
        }

        .textblock-content a:hover {
            text-decoration: underline;
        }

        .textblock-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .textblock-content th, .textblock-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .textblock-content th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
    </style>


    <!-- Prism.js language components for CodeBlocks -->
    

</head>

<body>

<!-- Parquet support (loaded if using parquet dataformat) -->


<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts various date formats to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
// Handles: ISO strings, Date objects (from Arrow/Parquet), timestamps, and day counts
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Timestamp range for reasonable dates (2000-01-01 to 2100-01-01 in milliseconds)
    // Using year 2000 as minimum to avoid false positives with regular numeric values
    var MIN_TIMESTAMP_MS = 946684800000;  // 2000-01-01
    var MAX_TIMESTAMP_MS = 4102444800000;  // 2100-01-01

    // Day count range (for dates stored as days since epoch, e.g., from some Parquet files)
    // Reasonable range: 0 (1970-01-01) to ~47500 (~2100-01-01)
    var MIN_DAYS = 0;
    var MAX_DAYS = 50000;
    var MS_PER_DAY = 86400000;

    // Scan multiple rows to better detect column types (some rows might have missing values)
    var rowsToCheck = Math.min(10, data.length);
    var dateColumns = [];
    var timeColumns = [];
    var timestampColumns = [];
    var dayCountColumns = [];
    var alreadyDateColumns = [];

    // Helper to check if a numeric value looks like a timestamp (milliseconds since epoch)
    function looksLikeTimestamp(value) {
        return typeof value === 'number' && value >= MIN_TIMESTAMP_MS && value <= MAX_TIMESTAMP_MS && value > MAX_DAYS;
    }

    // Helper to check if a numeric value looks like a day count since epoch
    // DISABLED: This was too aggressive and incorrectly converted normal numeric values
    // (like Month=1, Year=2022, Sales=120) to dates. Only enable for columns with
    // explicit date-like names if needed in the future.
    function looksLikeDayCount(value) {
        return false;  // Disabled - too many false positives
    }

    // Build list of keys from first row
    var keys = Object.keys(data[0]);

    // Check each column across multiple rows
    keys.forEach(function(key) {
        var stringDateCount = 0;
        var timeCount = 0;
        var timestampCount = 0;
        var dayCountCount = 0;
        var alreadyDateCount = 0;
        var nonNullCount = 0;

        for (var i = 0; i < rowsToCheck; i++) {
            var value = data[i][key];
            if (value === null || value === undefined) continue;
            nonNullCount++;

            if (value instanceof Date) {
                alreadyDateCount++;
            } else if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    stringDateCount++;
                } else if (timePattern.test(value)) {
                    timeCount++;
                }
            } else if (typeof value === 'number') {
                if (looksLikeTimestamp(value)) {
                    timestampCount++;
                } else if (looksLikeDayCount(value)) {
                    dayCountCount++;
                }
            }
        }

        // Classify column if majority of non-null values match a pattern
        var threshold = nonNullCount * 0.5;
        if (alreadyDateCount > threshold) {
            alreadyDateColumns.push(key);
        } else if (stringDateCount > threshold) {
            dateColumns.push(key);
        } else if (timeCount > threshold) {
            timeColumns.push(key);
        } else if (timestampCount > threshold) {
            timestampColumns.push(key);
        } else if (dayCountCount > threshold && dayCountCount >= 3) {
            // Be more conservative with day counts - require at least 3 matches
            dayCountColumns.push(key);
        }
    });

    // If no date/time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0 &&
        timestampColumns.length === 0 && dayCountColumns.length === 0 &&
        alreadyDateColumns.length === 0) {
        return data;
    }

    // Convert values in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                var value = row[key];

                if (alreadyDateColumns.indexOf(key) !== -1) {
                    // Already a Date object - keep as is
                    newRow[key] = value;
                } else if (dateColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // ISO date string - convert to Date
                    newRow[key] = new Date(value);
                } else if (timeColumns.indexOf(key) !== -1 && typeof value === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = value.split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else if (timestampColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Timestamp in milliseconds - convert to Date
                    newRow[key] = new Date(value);
                } else if (dayCountColumns.indexOf(key) !== -1 && typeof value === 'number') {
                    // Day count since epoch - convert to Date
                    newRow[key] = new Date(value * MS_PER_DAY);
                } else {
                    newRow[key] = value;
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
// Now supports optional choice filters (single-select) in addition to categorical filters (multi-select)
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters, choiceFilters, choices) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply choice filters first (single-select, exact match)
    if (choiceFilters && choices) {
        choiceFilters.forEach(function(col) {
            if (choices[col] !== undefined && choices[col] !== null && choices[col] !== '') {
                currentData = currentData.filter(function(row) {
                    var rowValueStr = temporalValueToString(row[col]);
                    return rowValueStr === choices[col];
                });
            }
        });
    }

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        case 'cumulative':
        case 'cumprod':
            // These are handled specially in chart code (computed per group)
            // Here they act as identity
            return values;

        default:
            return values;
    }
}

// Compute cumulative sum of values
// Returns array of same length: [y[0], y[0]+y[1], y[0]+y[1]+y[2], ...]
function computeCumulativeSum(values) {
    if (!values || values.length === 0) return [];
    var result = [];
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);  // Explicitly convert to number
        if (!isNaN(v) && isFinite(v)) {
            sum += v;
        }
        result.push(sum);
    }
    return result;
}

// Compute cumulative product of values for returns data
// For returns r_i, computes: cumprod(1 + r_i) - 1
// This converts returns to growth factors, compounds them, then converts back to cumulative return
// Example: returns [0.1, 0.2, -0.1] -> (1+r): [1.1, 1.2, 0.9] -> cumprod: [1.1, 1.32, 1.188] -> result: [0.1, 0.32, 0.188]
function computeCumulativeProduct(values) {
    if (!values || values.length === 0) return [];
    var result = [];
    var product = 1;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);  // Explicitly convert to number
        if (!isNaN(v) && isFinite(v)) {
            product *= (1 + v);  // Convert return to growth factor and multiply
        }
        result.push(product - 1);  // Convert back to cumulative return
    }
    return result;
}

// Compute Exponentially Weighted Moving Average
// weight: weight on newest observation, with warmup max(1/(i+1), weight)
function computeEWMA(values, weight) {
    var result = [];
    var ewma = NaN;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);
        var wt = Math.max(1 / (i + 1), weight);
        if (isNaN(v) || !isFinite(v)) {
            result.push(ewma);
        } else if (isNaN(ewma)) {
            ewma = v;
            result.push(ewma);
        } else {
            ewma = v * wt + ewma * (1 - wt);
            result.push(ewma);
        }
    }
    return result;
}

// Compute Exponentially Weighted Moving Standard Deviation
// Tracks EWMA of value and EWMA of value squared, std = sqrt(E[X^2] - E[X]^2)
// weight: weight on newest observation, with warmup max(1/(i+1), weight)
function computeEWMSTD(values, weight) {
    var result = [];
    var ewmaMean = NaN;
    var ewmaSq = NaN;
    for (var i = 0; i < values.length; i++) {
        var v = parseFloat(values[i]);
        var wt = Math.max(1 / (i + 1), weight);
        if (isNaN(v) || !isFinite(v)) {
            result.push(isNaN(ewmaMean) ? NaN : Math.sqrt(Math.max(0, ewmaSq - ewmaMean * ewmaMean)));
        } else if (isNaN(ewmaMean)) {
            ewmaMean = v;
            ewmaSq = v * v;
            result.push(0);
        } else {
            ewmaMean = v * wt + ewmaMean * (1 - wt);
            ewmaSq = (v * v) * wt + ewmaSq * (1 - wt);
            result.push(Math.sqrt(Math.max(0, ewmaSq - ewmaMean * ewmaMean)));
        }
    }
    return result;
}

// Compute Simple Moving Average over last windowSize periods
function computeSMA(values, windowSize) {
    var result = [];
    for (var i = 0; i < values.length; i++) {
        var start = Math.max(0, i - windowSize + 1);
        var sum = 0, count = 0;
        for (var j = start; j <= i; j++) {
            var v = parseFloat(values[j]);
            if (!isNaN(v) && isFinite(v)) { sum += v; count++; }
        }
        result.push(count > 0 ? sum / count : NaN);
    }
    return result;
}

// Compute a moving statistic on an array of values
// windowType: "fixed_interval" | "fixed_interval_around" | "exponential_decay"
// aggregation: "mean" | "std" | "skewness" | "kurtosis"
// parameter: window size (for fixed_interval/fixed_interval_around) or decay weight (for exponential_decay)
function computeMovingStatistic(values, windowType, aggregation, parameter) {
    if (!values || values.length === 0) return [];

    if (windowType === 'exponential_decay') {
        return computeEWMStatistic(values, aggregation, parameter);
    }

    var result = [];
    var windowSize = Math.max(1, Math.round(parameter));

    for (var i = 0; i < values.length; i++) {
        var start, end;
        if (windowType === 'fixed_interval') {
            // Backward-looking: [i - windowSize + 1, i]
            start = Math.max(0, i - windowSize + 1);
            end = i + 1;
        } else {
            // Centered: [i - half, i + half]
            var half = Math.floor(windowSize / 2);
            start = Math.max(0, i - half);
            end = Math.min(values.length, i + half + 1);
        }

        var windowValues = [];
        for (var j = start; j < end; j++) {
            var v = parseFloat(values[j]);
            if (!isNaN(v) && isFinite(v)) {
                windowValues.push(v);
            }
        }

        result.push(computeWindowAggregation(windowValues, aggregation));
    }
    return result;
}

// Compute aggregation over a window of values
function computeWindowAggregation(windowValues, aggregation) {
    var n = windowValues.length;
    if (n === 0) return NaN;

    var sum = 0;
    for (var i = 0; i < n; i++) sum += windowValues[i];
    var mean = sum / n;

    if (aggregation === 'mean') return mean;

    // For std, skewness, kurtosis we need central moments
    var m2 = 0, m3 = 0, m4 = 0;
    for (var i = 0; i < n; i++) {
        var d = windowValues[i] - mean;
        m2 += d * d;
        m3 += d * d * d;
        m4 += d * d * d * d;
    }

    var variance = n > 1 ? m2 / (n - 1) : 0;
    var stddev = Math.sqrt(variance);

    if (aggregation === 'std') return stddev;

    // Population moments for skewness/kurtosis
    var popM2 = m2 / n;
    var popM3 = m3 / n;
    var popM4 = m4 / n;

    if (popM2 === 0) return 0;

    if (aggregation === 'skewness') {
        return popM3 / Math.pow(popM2, 1.5);
    }

    if (aggregation === 'kurtosis') {
        // Excess kurtosis (normal = 0)
        return (popM4 / (popM2 * popM2)) - 3;
    }

    return NaN;
}

// Exponentially weighted moving statistic
// alpha is weight on the LATEST value: EWMA_t = alpha * x_t + (1 - alpha) * EWMA_{t-1}
function computeEWMStatistic(values, aggregation, alpha) {
    if (!values || values.length === 0) return [];
    var result = [];

    if (aggregation === 'mean') {
        var ewma = parseFloat(values[0]);
        result.push(isNaN(ewma) ? NaN : ewma);
        for (var i = 1; i < values.length; i++) {
            var v = parseFloat(values[i]);
            if (!isNaN(v) && isFinite(v)) {
                ewma = alpha * v + (1 - alpha) * ewma;
            }
            result.push(ewma);
        }
        return result;
    }

    // For std, skewness, kurtosis: track exponentially weighted moments
    var ewmMean = parseFloat(values[0]);
    var ewmVar = 0;
    var ewmM3 = 0;
    var ewmM4 = 0;

    result.push(0);  // First value: no variance/skew/kurtosis yet

    for (var i = 1; i < values.length; i++) {
        var v = parseFloat(values[i]);
        if (isNaN(v) || !isFinite(v)) {
            result.push(result[result.length - 1]);
            continue;
        }
        var delta = v - ewmMean;
        ewmMean = alpha * v + (1 - alpha) * ewmMean;
        var delta2 = v - ewmMean;
        ewmVar = (1 - alpha) * (ewmVar + alpha * delta * delta2);

        if (aggregation === 'std') {
            result.push(Math.sqrt(Math.max(0, ewmVar)));
        } else {
            var ewmStd = Math.sqrt(Math.max(0, ewmVar));
            ewmM3 = (1 - alpha) * (ewmM3 + alpha * delta * delta * delta);
            ewmM4 = (1 - alpha) * (ewmM4 + alpha * delta * delta * delta * delta);

            if (ewmStd > 0 && ewmVar > 0) {
                if (aggregation === 'skewness') {
                    result.push(ewmM3 / (ewmStd * ewmStd * ewmStd));
                } else {
                    // Excess kurtosis
                    result.push((ewmM4 / (ewmVar * ewmVar)) - 3);
                }
            } else {
                result.push(0);
            }
        }
    }
    return result;
}

// Compute quantile transformation of values (rank-based, maps to [0, 1])
function computeQuantileTransform(values) {
    if (!values || values.length === 0) return [];

    var indexedValues = values.map(function(v, i) {
        return { value: parseFloat(v), index: i };  // Explicitly convert to number
    });

    var validValues = indexedValues.filter(function(item) {
        return !isNaN(item.value) && isFinite(item.value);
    }).sort(function(a, b) {
        return a.value - b.value;
    });

    if (validValues.length === 0) return values;

    var ranks = new Array(values.length).fill(NaN);
    validValues.forEach(function(item, rank) {
        ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
    });

    return ranks;
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        case 'cumulative':
            return 'cumulative(' + originalLabel + ')';
        case 'cumprod':
            return 'cumprod(' + originalLabel + ')';
        case 'ewma':
            return 'ewma(' + originalLabel + ')';
        case 'ewmstd':
            return 'ewmstd(' + originalLabel + ')';
        case 'sma':
            return 'sma(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// =============================================================================
// Expression Parser for ScatterTwo
// Supports: +, -, *, /, variable references (:var or var), and functions:
//   z(expr, [groups]) - z-score within groups
//   q(expr, [groups]) - quantile within groups
//   PCA1(var1, var2) - projection on first principal component
//   PCA2(var1, var2) - projection on second principal component
// =============================================================================

// Tokenizer for expression parsing
function tokenizeExpression(expr) {
    var tokens = [];
    var i = 0;
    while (i < expr.length) {
        var ch = expr[i];

        // Skip whitespace
        if (/\s/.test(ch)) { i++; continue; }

        // Operators and punctuation
        if ('+-*/(),[]'.indexOf(ch) !== -1) {
            tokens.push({ type: 'punct', value: ch });
            i++;
            continue;
        }

        // Numbers
        if (/[0-9.]/.test(ch)) {
            var num = '';
            while (i < expr.length && /[0-9.]/.test(expr[i])) {
                num += expr[i++];
            }
            tokens.push({ type: 'number', value: parseFloat(num) });
            continue;
        }

        // Variable with colon prefix :varname
        if (ch === ':') {
            i++; // skip colon
            var name = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) {
                name += expr[i++];
            }
            tokens.push({ type: 'variable', value: name });
            continue;
        }

        // Identifiers (function names or variable names without colon)
        if (/[a-zA-Z_]/.test(ch)) {
            var ident = '';
            while (i < expr.length && /[a-zA-Z0-9_]/.test(expr[i])) {
                ident += expr[i++];
            }
            // Check if it's a function (followed by open paren)
            var j = i;
            while (j < expr.length && /\s/.test(expr[j])) j++;
            if (j < expr.length && expr[j] === '(') {
                tokens.push({ type: 'function', value: ident });
            } else {
                tokens.push({ type: 'variable', value: ident });
            }
            continue;
        }

        // Unknown character - skip
        i++;
    }
    return tokens;
}

// Simple recursive descent parser
function parseExpression(tokens, pos) {
    return parseAddSub(tokens, pos);
}

function parseAddSub(tokens, pos) {
    var result = parseMulDiv(tokens, pos);
    var node = result.node;
    pos = result.pos;

    while (pos < tokens.length && tokens[pos].type === 'punct' &&
           (tokens[pos].value === '+' || tokens[pos].value === '-')) {
        var op = tokens[pos].value;
        pos++;
        var right = parseMulDiv(tokens, pos);
        node = { type: 'binary', op: op, left: node, right: right.node };
        pos = right.pos;
    }
    return { node: node, pos: pos };
}

function parseMulDiv(tokens, pos) {
    var result = parseUnary(tokens, pos);
    var node = result.node;
    pos = result.pos;

    while (pos < tokens.length && tokens[pos].type === 'punct' &&
           (tokens[pos].value === '*' || tokens[pos].value === '/')) {
        var op = tokens[pos].value;
        pos++;
        var right = parseUnary(tokens, pos);
        node = { type: 'binary', op: op, left: node, right: right.node };
        pos = right.pos;
    }
    return { node: node, pos: pos };
}

function parseUnary(tokens, pos) {
    if (pos < tokens.length && tokens[pos].type === 'punct' && tokens[pos].value === '-') {
        pos++;
        var result = parseUnary(tokens, pos);
        return { node: { type: 'unary', op: '-', arg: result.node }, pos: result.pos };
    }
    return parsePrimary(tokens, pos);
}

function parsePrimary(tokens, pos) {
    if (pos >= tokens.length) {
        return { node: { type: 'number', value: 0 }, pos: pos };
    }

    var token = tokens[pos];

    // Number literal
    if (token.type === 'number') {
        return { node: { type: 'number', value: token.value }, pos: pos + 1 };
    }

    // Variable reference
    if (token.type === 'variable') {
        return { node: { type: 'variable', name: token.value }, pos: pos + 1 };
    }

    // Function call
    if (token.type === 'function') {
        var funcName = token.value;
        pos++; // skip function name
        if (pos < tokens.length && tokens[pos].value === '(') {
            pos++; // skip (
            var args = [];
            while (pos < tokens.length && tokens[pos].value !== ')') {
                // Check for array literal [...]
                if (tokens[pos].value === '[') {
                    pos++; // skip [
                    var arrayItems = [];
                    while (pos < tokens.length && tokens[pos].value !== ']') {
                        if (tokens[pos].type === 'variable') {
                            arrayItems.push(tokens[pos].value);
                        }
                        pos++;
                        if (pos < tokens.length && tokens[pos].value === ',') pos++;
                    }
                    if (pos < tokens.length && tokens[pos].value === ']') pos++;
                    args.push({ type: 'array', items: arrayItems });
                } else {
                    var argResult = parseExpression(tokens, pos);
                    args.push(argResult.node);
                    pos = argResult.pos;
                }
                if (pos < tokens.length && tokens[pos].value === ',') pos++;
            }
            if (pos < tokens.length && tokens[pos].value === ')') pos++;
            return { node: { type: 'function', name: funcName, args: args }, pos: pos };
        }
    }

    // Parenthesized expression
    if (token.type === 'punct' && token.value === '(') {
        pos++; // skip (
        var result = parseExpression(tokens, pos);
        pos = result.pos;
        if (pos < tokens.length && tokens[pos].value === ')') pos++;
        return { node: result.node, pos: pos };
    }

    // Default: return 0
    return { node: { type: 'number', value: 0 }, pos: pos + 1 };
}

// Evaluate parsed expression against data
// Returns an array of values, one per data row
function evaluateExpression(node, data) {
    if (!node) return data.map(function() { return 0; });

    switch (node.type) {
        case 'number':
            return data.map(function() { return node.value; });

        case 'variable':
            return data.map(function(row) {
                var val = row[node.name];
                return (typeof val === 'number') ? val : parseFloat(val) || 0;
            });

        case 'binary':
            var left = evaluateExpression(node.left, data);
            var right = evaluateExpression(node.right, data);
            return left.map(function(l, i) {
                var r = right[i];
                switch (node.op) {
                    case '+': return l + r;
                    case '-': return l - r;
                    case '*': return l * r;
                    case '/': return r !== 0 ? l / r : NaN;
                    default: return 0;
                }
            });

        case 'unary':
            var arg = evaluateExpression(node.arg, data);
            if (node.op === '-') {
                return arg.map(function(v) { return -v; });
            }
            return arg;

        case 'function':
            return evaluateFunction(node.name, node.args, data);

        default:
            return data.map(function() { return 0; });
    }
}

// Evaluate function calls
function evaluateFunction(name, args, data) {
    var lowerName = name.toLowerCase();

    // z(expr, [groups]) - z-score within groups
    if (lowerName === 'z') {
        var values = evaluateExpression(args[0], data);
        var groupCols = (args.length > 1 && args[1].type === 'array') ? args[1].items : [];
        return computeGroupedZScore(values, data, groupCols);
    }

    // q(expr, [groups]) - quantile within groups
    if (lowerName === 'q') {
        var values = evaluateExpression(args[0], data);
        var groupCols = (args.length > 1 && args[1].type === 'array') ? args[1].items : [];
        return computeGroupedQuantile(values, data, groupCols);
    }

    // PCA1(var1, var2) - first principal component
    if (lowerName === 'pca1') {
        if (args.length >= 2) {
            var v1 = evaluateExpression(args[0], data);
            var v2 = evaluateExpression(args[1], data);
            return computePCA(v1, v2, 1);
        }
        return data.map(function() { return 0; });
    }

    // PCA2(var1, var2) - second principal component
    if (lowerName === 'pca2') {
        if (args.length >= 2) {
            var v1 = evaluateExpression(args[0], data);
            var v2 = evaluateExpression(args[1], data);
            return computePCA(v1, v2, 2);
        }
        return data.map(function() { return 0; });
    }

    // r(y, x) - OLS residual (y - fitted)
    if (lowerName === 'r') {
        if (args.length >= 2) {
            var y = evaluateExpression(args[0], data);
            var x = evaluateExpression(args[1], data);
            return computeOLSResidual(y, x);
        }
        return data.map(function() { return 0; });
    }

    // f(y, x) - OLS fitted value
    if (lowerName === 'f') {
        if (args.length >= 2) {
            var y = evaluateExpression(args[0], data);
            var x = evaluateExpression(args[1], data);
            return computeOLSFitted(y, x);
        }
        return data.map(function() { return 0; });
    }

    // c(expr, min, max) - clamp values between min and max
    // Use Infinity or -Infinity to only set one bound
    if (lowerName === 'c') {
        if (args.length >= 3) {
            var values = evaluateExpression(args[0], data);
            var minVal = evaluateExpression(args[1], data);
            var maxVal = evaluateExpression(args[2], data);

            // Get min/max bounds (they're arrays from evaluateExpression, but should be constant)
            var lo = minVal[0];
            var hi = maxVal[0];

            return values.map(function(v) {
                if (isNaN(v)) return v;
                if (v < lo) return lo;
                if (v > hi) return hi;
                return v;
            });
        }
        return data.map(function() { return 0; });
    }

    // Unknown function - return zeros
    return data.map(function() { return 0; });
}

// Compute z-score within groups
function computeGroupedZScore(values, data, groupCols) {
    if (groupCols.length === 0) {
        // No grouping - compute global z-score
        var validVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
        if (validVals.length === 0) return values;
        var mean = validVals.reduce(function(a, b) { return a + b; }, 0) / validVals.length;
        var variance = validVals.reduce(function(a, b) { return a + (b - mean) * (b - mean); }, 0) / validVals.length;
        var std = Math.sqrt(variance);
        if (std === 0) return values.map(function() { return 0; });
        return values.map(function(v) { return (v - mean) / std; });
    }

    // Group by specified columns
    var groups = {};
    data.forEach(function(row, i) {
        var key = groupCols.map(function(col) { return row[col]; }).join('|');
        if (!groups[key]) groups[key] = { indices: [], values: [] };
        groups[key].indices.push(i);
        groups[key].values.push(values[i]);
    });

    // Compute z-score within each group
    var result = new Array(values.length);
    Object.keys(groups).forEach(function(key) {
        var g = groups[key];
        var validVals = g.values.filter(function(v) { return !isNaN(v) && isFinite(v); });
        if (validVals.length === 0) {
            g.indices.forEach(function(i) { result[i] = NaN; });
            return;
        }
        var mean = validVals.reduce(function(a, b) { return a + b; }, 0) / validVals.length;
        var variance = validVals.reduce(function(a, b) { return a + (b - mean) * (b - mean); }, 0) / validVals.length;
        var std = Math.sqrt(variance);
        g.indices.forEach(function(idx, j) {
            result[idx] = std === 0 ? 0 : (g.values[j] - mean) / std;
        });
    });
    return result;
}

// Compute quantile within groups
function computeGroupedQuantile(values, data, groupCols) {
    if (groupCols.length === 0) {
        // No grouping - compute global quantile
        return computeQuantileTransform(values);
    }

    // Group by specified columns
    var groups = {};
    data.forEach(function(row, i) {
        var key = groupCols.map(function(col) { return row[col]; }).join('|');
        if (!groups[key]) groups[key] = { indices: [], values: [] };
        groups[key].indices.push(i);
        groups[key].values.push(values[i]);
    });

    // Compute quantile within each group
    var result = new Array(values.length);
    Object.keys(groups).forEach(function(key) {
        var g = groups[key];
        var quantiles = computeQuantileTransform(g.values);
        g.indices.forEach(function(idx, j) {
            result[idx] = quantiles[j];
        });
    });
    return result;
}

// Compute PCA projection
// component: 1 for first PC, 2 for second PC
function computePCA(v1, v2, component) {
    var n = v1.length;
    if (n === 0) return [];

    // Filter valid pairs
    var validIndices = [];
    for (var i = 0; i < n; i++) {
        if (!isNaN(v1[i]) && isFinite(v1[i]) && !isNaN(v2[i]) && isFinite(v2[i])) {
            validIndices.push(i);
        }
    }

    if (validIndices.length < 2) {
        return v1.map(function() { return 0; });
    }

    // Compute means
    var mean1 = 0, mean2 = 0;
    validIndices.forEach(function(i) {
        mean1 += v1[i];
        mean2 += v2[i];
    });
    mean1 /= validIndices.length;
    mean2 /= validIndices.length;

    // Compute covariance matrix elements
    var cov11 = 0, cov12 = 0, cov22 = 0;
    validIndices.forEach(function(i) {
        var d1 = v1[i] - mean1;
        var d2 = v2[i] - mean2;
        cov11 += d1 * d1;
        cov12 += d1 * d2;
        cov22 += d2 * d2;
    });
    cov11 /= validIndices.length;
    cov12 /= validIndices.length;
    cov22 /= validIndices.length;

    // Compute eigenvalues and eigenvectors of 2x2 covariance matrix
    // Using closed-form solution for 2x2 symmetric matrix
    var trace = cov11 + cov22;
    var det = cov11 * cov22 - cov12 * cov12;
    var discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
    var lambda1 = trace / 2 + discriminant; // larger eigenvalue
    var lambda2 = trace / 2 - discriminant; // smaller eigenvalue

    // Eigenvector for lambda1 (first PC)
    var ev1_x, ev1_y;
    if (Math.abs(cov12) > 1e-10) {
        ev1_x = lambda1 - cov22;
        ev1_y = cov12;
    } else {
        ev1_x = 1;
        ev1_y = 0;
    }
    var norm1 = Math.sqrt(ev1_x * ev1_x + ev1_y * ev1_y);
    if (norm1 > 0) { ev1_x /= norm1; ev1_y /= norm1; }

    // Eigenvector for lambda2 (second PC) - perpendicular to first
    var ev2_x = -ev1_y;
    var ev2_y = ev1_x;

    // Choose eigenvector based on component
    var ev_x = component === 1 ? ev1_x : ev2_x;
    var ev_y = component === 1 ? ev1_y : ev2_y;

    // Project all points onto the principal component
    var result = new Array(n);
    for (var i = 0; i < n; i++) {
        if (!isNaN(v1[i]) && isFinite(v1[i]) && !isNaN(v2[i]) && isFinite(v2[i])) {
            result[i] = (v1[i] - mean1) * ev_x + (v2[i] - mean2) * ev_y;
        } else {
            result[i] = NaN;
        }
    }
    return result;
}

// Compute OLS regression coefficients (y = alpha + beta * x)
// Returns {alpha, beta} or null if regression fails
function computeOLSCoefficients(y, x) {
    var n = y.length;
    if (n === 0 || n !== x.length) return null;

    // Filter to valid pairs only
    var validPairs = [];
    for (var i = 0; i < n; i++) {
        if (!isNaN(y[i]) && isFinite(y[i]) && !isNaN(x[i]) && isFinite(x[i])) {
            validPairs.push({ y: y[i], x: x[i] });
        }
    }

    if (validPairs.length < 2) return null;

    // Compute means
    var sumX = 0, sumY = 0;
    validPairs.forEach(function(p) {
        sumX += p.x;
        sumY += p.y;
    });
    var meanX = sumX / validPairs.length;
    var meanY = sumY / validPairs.length;

    // Compute beta = Cov(x,y) / Var(x)
    var covXY = 0, varX = 0;
    validPairs.forEach(function(p) {
        var dx = p.x - meanX;
        var dy = p.y - meanY;
        covXY += dx * dy;
        varX += dx * dx;
    });

    if (varX === 0) return null; // x has no variance

    var beta = covXY / varX;
    var alpha = meanY - beta * meanX;

    return { alpha: alpha, beta: beta };
}

// Compute OLS residuals: r(y, x) = y - fitted = y - (alpha + beta * x)
function computeOLSResidual(y, x) {
    var coef = computeOLSCoefficients(y, x);
    if (!coef) {
        return y.map(function() { return NaN; });
    }

    return y.map(function(yi, i) {
        if (isNaN(yi) || !isFinite(yi) || isNaN(x[i]) || !isFinite(x[i])) {
            return NaN;
        }
        var fitted = coef.alpha + coef.beta * x[i];
        return yi - fitted;
    });
}

// Compute OLS fitted values: f(y, x) = alpha + beta * x
function computeOLSFitted(y, x) {
    var coef = computeOLSCoefficients(y, x);
    if (!coef) {
        return y.map(function() { return NaN; });
    }

    return x.map(function(xi, i) {
        if (isNaN(y[i]) || !isFinite(y[i]) || isNaN(xi) || !isFinite(xi)) {
            return NaN;
        }
        return coef.alpha + coef.beta * xi;
    });
}

// Main function to evaluate an expression string against data
function evaluateExpressionString(exprString, data) {
    if (!exprString || exprString.trim() === '') {
        return data.map(function() { return 0; });
    }
    try {
        var tokens = tokenizeExpression(exprString);
        var parseResult = parseExpression(tokens, 0);
        return evaluateExpression(parseResult.node, data);
    } catch (e) {
        console.error('Expression parsing error:', e);
        return data.map(function() { return 0; });
    }
}

// =============================================================================
// End Expression Parser
// =============================================================================

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
// Note: Data elements have IDs prefixed with "data_" to avoid collisions with chart container IDs
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        // Sanitize the label: replace spaces and special chars with underscores
        var sanitizedLabel = dataLabel.replace(/[\s\-\.:/\\]/g, '_');
        var dataElementId = 'data_' + sanitizedLabel;
        var dataElement = document.getElementById(dataElementId);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataElementId + ' (from label: ' + dataLabel + ')'));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    // Parse dates in Parquet data (centralized date handling)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

// Global fix for PivotTable.js filter box positioning issue
// See: https://github.com/nicolaskruchten/pivottable/issues/865
// The library calculates position incorrectly - we fix it by repositioning after creation
(function() {
    if (window._pvtFilterBoxFixApplied) return; // Only apply once
    window._pvtFilterBoxFixApplied = true;

    var lastClickedTriangle = null;

    // Helper function to reposition the filter box
    function repositionFilterBox($box, triangle) {
        if (!triangle || !$box.length) return;

        // Get triangle position relative to viewport
        var triangleRect = triangle.getBoundingClientRect();

        // Get box dimensions (use defaults if not yet rendered)
        var boxWidth = $box.outerWidth() || 300;
        var boxHeight = $box.outerHeight() || 400;

        // Calculate position relative to viewport (for position:fixed)
        var newLeft = triangleRect.left;
        var newTop = triangleRect.bottom + 5;

        // Adjust if it would go off the right edge
        if (newLeft + boxWidth > window.innerWidth - 20) {
            newLeft = triangleRect.right - boxWidth;
        }

        // Adjust if it would go off the bottom edge
        if (newTop + boxHeight > window.innerHeight - 20) {
            newTop = triangleRect.top - boxHeight - 5;
        }

        // Ensure minimum positions
        if (newLeft < 10) newLeft = 10;
        if (newTop < 10) newTop = 10;

        // Use position:fixed for viewport-relative positioning
        $box.css({
            'position': 'fixed',
            'left': newLeft + 'px',
            'top': newTop + 'px'
        });
    }

    // Capture which triangle was clicked
    $(document).on('click', '.pvtTriangle', function(e) {
        lastClickedTriangle = this;
    });

    // Watch for filter box creation and fix position
    var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1 && $(node).hasClass('pvtFilterBox')) {
                    var $box = $(node);
                    var triangle = lastClickedTriangle;

                    // Apply the fix multiple times to ensure it sticks after PivotTable.js finishes
                    // The library may set position after initial render
                    var timings = [0, 10, 50, 100, 200];
                    timings.forEach(function(delay) {
                        setTimeout(function() {
                            repositionFilterBox($box, triangle);
                        }, delay);
                    });

                    // Also reposition on any style changes to the box (in case library updates position)
                    var styleObserver = new MutationObserver(function(styleMutations) {
                        repositionFilterBox($box, triangle);
                    });
                    styleObserver.observe(node, { attributes: true, attributeFilter: ['style'] });

                    // Disconnect the style observer when the filter box is removed
                    var removalObserver = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            mutation.removedNodes.forEach(function(removedNode) {
                                if (removedNode === node) {
                                    styleObserver.disconnect();
                                    removalObserver.disconnect();
                                    lastClickedTriangle = null;
                                }
                            });
                        });
                    });
                    removalObserver.observe(document.body, { childList: true, subtree: true });
                }
            });
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });
})();



});
</script>

<!-- DATASETS -->



<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

    <div class="textblock-content">
        <a href="https://github.com/s-baumann/JSPlots.jl/blob/main/examples/textblock_examples.jl" style="color: blue; font-weight: bold;">See here for the example code that generated this page</a>
<h1>TextBlock Examples</h1>
<p>This page demonstrates how to use TextBlock elements in JSPlots to add formatted text, documentation, images, and context to your visualizations.</p>
<p>TextBlocks support full HTML formatting including headings, paragraphs, lists, tables, and embedded images.</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Basic HTML Formatting</h2>
<p>This is a simple text block that provides context for the visualizations below.</p>
<p>You can use standard HTML formatting including <strong>bold</strong>, <em>italic</em>, and <code>code</code>.</p>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Key Findings</h2>
<ul>
    <li>The distribution shows a clear bimodal pattern</li>
    <li>Group A has a higher mean than Group B</li>
    <li>Outliers are present in both groups</li>
</ul>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary Statistics</h2>
<table>
    <thead>
        <tr>
            <th>Metric</th>
            <th>Group A</th>
            <th>Group B</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Mean</td>
            <td>105.3</td>
            <td>98.7</td>
        </tr>
        <tr>
            <td>Std Dev</td>
            <td>12.4</td>
            <td>15.8</td>
        </tr>
        <tr>
            <td>Sample Size</td>
            <td>150</td>
            <td>150</td>
        </tr>
    </tbody>
</table>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <div style="display: flex; align-items: center; justify-content: space-between; background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
    <div style="flex: 1;">
        <h1 style="margin: 0; color: #2c3e50;">TuxCorp Analytics</h1>
        <p style="margin: 5px 0 0 0; color: #7f8c8d;">Data-Driven Insights for Better Decisions</p>
    </div>
    <div style="flex: 0 0 auto;">
        <img src="data:image/jpeg;base64,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" alt="logo" />
    </div>
</div>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Product Showcase</h2>
<p>Welcome to our product showcase. Here we demonstrate our flagship products:</p>

<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
    <div style="border: 1px solid #ddd; padding: 15px; border-radius: 8px;">
        <h3>Product A</h3>
        <img src="data:image/jpeg;base64,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" alt="product_a" />
        <p>Our premium offering with advanced features.</p>
    </div>
    <div style="border: 1px solid #ddd; padding: 15px; border-radius: 8px;">
        <h3>Product B</h3>
        <img src="data:image/jpeg;base64,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" alt="product_b" />
        <p>The essential solution for everyday needs.</p>
    </div>
</div>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>About Our Mascot</h2>
<div style="display: flex; align-items: start; gap: 20px;">
    <div style="flex: 0 0 200px;">
        <img src="data:image/jpeg;base64,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" alt="mascot" />
    </div>
    <div style="flex: 1;">
        <p>Meet Tux, our beloved mascot! Tux has been representing our company since its inception, embodying the values of openness, collaboration, and innovation that drive our mission.</p>
        <p>As the face of our brand, Tux appears in all our marketing materials and serves as a constant reminder of our commitment to excellence and community.</p>
    </div>
</div>

    </div>
<br>
<hr>
<br>
    <div class="textblock-content">
        <h2>Summary</h2>
<p>This page demonstrated TextBlock features:</p>
<ul>
    <li><strong>Basic HTML formatting:</strong> Bold, italic, code</li>
    <li><strong>Lists:</strong> Unordered and ordered</li>
    <li><strong>HTML tables:</strong> Structured data display</li>
    <li><strong>Embedded images:</strong> Company logos, product images, mascots</li>
    <li><strong>Flexible layouts:</strong> Grid layouts, side-by-side content</li>
    <li><strong>Combined with plots:</strong> Creating complete analysis reports</li>
</ul>
<p><strong>Tip:</strong> TextBlocks can include any valid HTML and embedded images using {{IMAGE:id}} syntax, making them perfect for professional reports with branding!</p>

    </div>


<hr><div style="display: flex; justify-content: space-between; align-items: center;">
<small></small>
<small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.6.3.</small>
</div>
</body>
</html>
