<!DOCTYPE html>
<html>
<head>
    <title>JSPlots.jl</title>
    <meta charset="UTF-8">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #$div_id {
            width: 100%;
            height: 600px;
        }
    </style>
    

    <!-- external libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.71/jquery.csv-0.71.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/pivot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/d3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/c3_renderers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.19.0/export_renderers.min.js"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    

</head>

<body>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script type="module">
// Import parquet-wasm for Parquet file support
import * as parquet from 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm.js';

// Initialize parquet-wasm
await parquet.default();

// Make parquet available globally for loadDataset
window.parquetWasm = parquet;
window.parquetReady = true;
console.log('Parquet-wasm library loaded successfully');
</script>

<script>
// Helper function to wait for parquet-wasm to be loaded
function waitForParquet() {
    return new Promise(function(resolve) {
        if (window.parquetReady) {
            resolve();
            return;
        }
        var checkInterval = setInterval(function() {
            if (window.parquetReady) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 50);
    });
}

// Centralized data loading function
// Centralized date parsing function
// Converts ISO date strings to JavaScript Date objects
// This is the ONLY place in the package where date parsing happens
function parseDatesInData(data) {
    if (!data || data.length === 0) return data;

    // Regex patterns for ISO date formats
    var datePattern = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    var datetimePattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;  // YYYY-MM-DDTHH:MM:SS
    var timePattern = /^\d{2}:\d{2}:\d{2}(\.\d+)?$/;  // HH:MM:SS or HH:MM:SS.sss

    // Check first row to identify date and time columns
    var firstRow = data[0];
    var dateColumns = [];
    var timeColumns = [];

    for (var key in firstRow) {
        if (firstRow.hasOwnProperty(key)) {
            var value = firstRow[key];
            if (typeof value === 'string') {
                if (datetimePattern.test(value) || datePattern.test(value)) {
                    dateColumns.push(key);
                } else if (timePattern.test(value)) {
                    timeColumns.push(key);
                }
            }
        }
    }

    // If no date or time columns found, return data unchanged
    if (dateColumns.length === 0 && timeColumns.length === 0) return data;

    // Convert date strings to Date objects and time strings to milliseconds in all rows
    return data.map(function(row) {
        var newRow = {};
        for (var key in row) {
            if (row.hasOwnProperty(key)) {
                if (dateColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    newRow[key] = new Date(row[key]);
                } else if (timeColumns.indexOf(key) !== -1 && typeof row[key] === 'string') {
                    // Convert HH:MM:SS or HH:MM:SS.sss to milliseconds since midnight
                    var parts = row[key].split(':');
                    var hours = parseInt(parts[0], 10);
                    var minutes = parseInt(parts[1], 10);
                    var seconds = parseFloat(parts[2]);  // Use parseFloat to handle decimal seconds
                    newRow[key] = (hours * 3600 + minutes * 60 + seconds) * 1000;
                } else {
                    newRow[key] = row[key];
                }
            }
        }
        return newRow;
    });
}

// Helper function to convert temporal values back to string format for categorical filtering
// Takes a value and returns the appropriate string representation
function temporalValueToString(value) {
    if (value instanceof Date) {
        // Convert Date to ISO string
        var year = value.getFullYear();
        var month = String(value.getMonth() + 1).padStart(2, '0');
        var day = String(value.getDate()).padStart(2, '0');
        var hours = String(value.getHours()).padStart(2, '0');
        var minutes = String(value.getMinutes()).padStart(2, '0');
        var seconds = String(value.getSeconds()).padStart(2, '0');

        // Check if this is a date-only value (time is midnight UTC)
        if (hours === '00' && minutes === '00' && seconds === '00') {
            return year + '-' + month + '-' + day;
        } else {
            return year + '-' + month + '-' + day + 'T' + hours + ':' + minutes + ':' + seconds;
        }
    } else if (typeof value === 'number' && value >= 0 && value < 86400000) {
        // Likely a Time value (milliseconds since midnight, less than 24 hours)
        var totalSeconds = Math.floor(value / 1000);
        var hours = Math.floor(totalSeconds / 3600);
        var minutes = Math.floor((totalSeconds % 3600) / 60);
        var seconds = totalSeconds % 60;
        var milliseconds = value % 1000;

        var timeStr = String(hours).padStart(2, '0') + ':' +
                      String(minutes).padStart(2, '0') + ':' +
                      String(seconds).padStart(2, '0');

        // Add decimal part if there are milliseconds
        if (milliseconds > 0) {
            timeStr += '.' + String(milliseconds);
        }

        return timeStr;
    } else {
        // Return as-is for other types
        return String(value);
    }
}

// Centralized observation counting and filtering function
// Applies filters incrementally while updating observation count displays
// Returns filtered data
function applyFiltersWithCounting(allData, chartTitle, categoricalFilters, continuousFilters, filters, rangeFilters) {
    var totalObs = allData.length;

    // Update total observation count
    var totalObsElement = document.getElementById(chartTitle + '_total_obs');
    if (totalObsElement) {
        totalObsElement.textContent = totalObs + ' observations';
    }

    // Apply filters incrementally to track observation counts
    var currentData = allData;

    // Apply categorical filters and update counts
    categoricalFilters.forEach(function(col) {
        if (filters[col] && filters[col].length > 0) {
            currentData = currentData.filter(function(row) {
                var rowValueStr = temporalValueToString(row[col]);
                return filters[col].includes(rowValueStr);
            });
        }

        var countElement = document.getElementById(col + '_select_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    // Apply continuous filters and update counts
    continuousFilters.forEach(function(col) {
        if (rangeFilters[col]) {
            var range = rangeFilters[col];
            currentData = currentData.filter(function(row) {
                var rawValue = row[col];
                var value;
                if (rawValue instanceof Date) {
                    value = rawValue.getTime();
                } else {
                    value = parseFloat(rawValue);
                }
                return value >= range.min && value <= range.max;
            });
        }

        var countElement = document.getElementById(col + '_range_' + chartTitle + '_obs_count');
        if (countElement) {
            var pct = totalObs > 0 ? Math.round((currentData.length / totalObs) * 100) : 100;
            countElement.textContent = pct + '% (' + currentData.length + ') remaining';
        }
    });

    return currentData;
}

// Axis transformation functions
// These transform data values according to selected transformation type
function applyAxisTransform(values, transformType) {
    if (!values || values.length === 0) return [];

    switch(transformType) {
        case 'identity':
            return values;

        case 'log':
            return values.map(function(v) {
                return v > 0 ? Math.log(v) : NaN;
            });

        case 'z_score':
            // Z-score standardization: (x - mean) / std
            var numericVals = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals.length === 0) return values;

            var mean = numericVals.reduce(function(a, b) { return a + b; }, 0) / numericVals.length;
            var variance = numericVals.reduce(function(sum, v) {
                return sum + Math.pow(v - mean, 2);
            }, 0) / numericVals.length;
            var std = Math.sqrt(variance);

            if (std === 0) return values;

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                return (v - mean) / std;
            });

        case 'quantile':
            // Rank-based transformation to [0, 1]
            // Create array of {value, originalIndex} pairs
            var indexedValues = values.map(function(v, i) {
                return { value: v, index: i };
            });

            // Filter out invalid values and sort
            var validValues = indexedValues.filter(function(item) {
                return !isNaN(item.value) && isFinite(item.value);
            }).sort(function(a, b) {
                return a.value - b.value;
            });

            if (validValues.length === 0) return values;

            // Assign ranks (0 to 1)
            var ranks = new Array(values.length).fill(NaN);
            validValues.forEach(function(item, rank) {
                // Map rank to [0, 1] where lowest = 0, highest = 1
                ranks[item.index] = validValues.length === 1 ? 0.5 : rank / (validValues.length - 1);
            });

            return ranks;

        case 'inverse_cdf':
            // Z-score followed by normal CDF transformation to [0, 1]
            var numericVals2 = values.filter(function(v) { return !isNaN(v) && isFinite(v); });
            if (numericVals2.length === 0) return values;

            var mean2 = numericVals2.reduce(function(a, b) { return a + b; }, 0) / numericVals2.length;
            var variance2 = numericVals2.reduce(function(sum, v) {
                return sum + Math.pow(v - mean2, 2);
            }, 0) / numericVals2.length;
            var std2 = Math.sqrt(variance2);

            if (std2 === 0) return values.map(function() { return 0.5; });

            return values.map(function(v) {
                if (isNaN(v) || !isFinite(v)) return NaN;
                var zscore = (v - mean2) / std2;
                return normalCDF(zscore);
            });

        default:
            return values;
    }
}

// Normal CDF (cumulative distribution function) for standard normal
function normalCDF(x) {
    // Using error function approximation
    var t = 1 / (1 + 0.2316419 * Math.abs(x));
    var d = 0.3989423 * Math.exp(-x * x / 2);
    var prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
    return x > 0 ? 1 - prob : prob;
}

// Inverse normal CDF (quantile function) for standard normal
function inverseNormalCDF(p) {
    // Rational approximation for inverse normal CDF
    // Valid for 0 < p < 1
    if (p <= 0 || p >= 1) {
        return NaN;
    }

    var a = [0, -3.969683028665376e+01, 2.209460984245205e+02,
             -2.759285104469687e+02, 1.383577518672690e+02,
             -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [0, -5.447609879822406e+01, 1.615858368580409e+02,
             -1.556989798598866e+02, 6.680131188771972e+01,
             -1.328068155288572e+01];
    var c = [0, -7.784894002430293e-03, -3.223964580411365e-01,
             -2.400758277161838e+00, -2.549732539343734e+00,
             4.374664141464968e+00, 2.938163982698783e+00];
    var d = [0, 7.784695709041462e-03, 3.224671290700398e-01,
             2.445134137142996e+00, 3.754408661907416e+00];

    var q, r, result;

    if (p < 0.02425) {
        q = Math.sqrt(-2 * Math.log(p));
        result = (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                 ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else if (p > 0.97575) {
        q = Math.sqrt(-2 * Math.log(1 - p));
        result = -(((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q + c[6]) /
                  ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1);
    } else {
        q = p - 0.5;
        r = q * q;
        result = (((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r + a[6]) * q /
                 (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1);
    }

    return result;
}

// Get axis label with transformation applied
function getAxisLabel(originalLabel, transformType) {
    switch(transformType) {
        case 'log':
            return 'log(' + originalLabel + ')';
        case 'z_score':
            return 'z(' + originalLabel + ')';
        case 'quantile':
            return 'quantile(' + originalLabel + ')';
        case 'inverse_cdf':
            return 'Î¦(' + originalLabel + ')';
        default:
            return originalLabel;
    }
}

// Setup aspect ratio control for a chart
// This should be called after the chart is first rendered
// Uses logarithmic scale for better precision at smaller aspect ratios
function setupAspectRatioControl(chartId, updateCallback) {
    var slider = document.getElementById(chartId + '_aspect_ratio_slider');
    var label = document.getElementById(chartId + '_aspect_ratio_label');

    if (!slider || !label) return; // Not all charts have aspect ratio control

    slider.addEventListener('input', function() {
        // Convert from log space to linear space
        var logValue = parseFloat(this.value);
        var aspectRatio = Math.exp(logValue);
        label.textContent = aspectRatio.toFixed(2);

        // Get current width of chart div
        var chartDiv = document.getElementById(chartId);
        if (!chartDiv) return;

        var width = chartDiv.offsetWidth;
        var height = width * aspectRatio;

        // Update chart layout with new height
        Plotly.relayout(chartId, { height: height });

        // Call the optional callback if provided
        if (updateCallback && typeof updateCallback === 'function') {
            updateCallback(height);
        }
    });

    // Trigger initial sizing
    var initialLogValue = parseFloat(slider.value);
    var initialAspectRatio = Math.exp(initialLogValue);
    label.textContent = initialAspectRatio.toFixed(2);
    var chartDiv = document.getElementById(chartId);
    if (chartDiv) {
        var width = chartDiv.offsetWidth;
        var height = width * initialAspectRatio;
        Plotly.relayout(chartId, { height: height });
    }
}

// This function parses data from embedded or external sources and returns a Promise
// Supports CSV (embedded/external), JSON (embedded/external), and Parquet (external) formats
// Usage: loadDataset('dataLabel').then(function(data) { /* use data */ });
function loadDataset(dataLabel) {
    return new Promise(function(resolve, reject) {
        var dataElement = document.getElementById(dataLabel);
        if (!dataElement) {
            reject(new Error('Data element not found: ' + dataLabel));
            return;
        }

        var format = dataElement.getAttribute('data-format') || 'csv_embedded';
        var dataSrc = dataElement.getAttribute('data-src');

        // Handle external JSON files
        if (format === 'json_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Parse dates in JSON data (centralized)
                    resolve(parseDatesInData(data));
                })
                .catch(function(error) {
                    console.error('Error loading external JSON:', error);
                    reject(error);
                });
            return;
        }

        // Handle external Parquet files
        if (format === 'parquet' && dataSrc) {
            // Wait for parquet-wasm to be loaded first
            waitForParquet()
                .then(function() {
                    return fetch(dataSrc);
                })
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.arrayBuffer();
                })
                .then(function(arrayBuffer) {
                    // Use parquet-wasm to read the file
                    var uint8Array = new Uint8Array(arrayBuffer);

                    // readParquet returns an Arrow Table
                    var wasmTable = window.parquetWasm.readParquet(uint8Array);

                    // Convert to Arrow IPC stream
                    var ipcStream = wasmTable.intoIPCStream();

                    // Use Apache Arrow JS to read the IPC stream
                    var arrowTable = window.Arrow.tableFromIPC(ipcStream);

                    // Convert Arrow Table to array of JavaScript objects
                    var data = [];
                    for (var i = 0; i < arrowTable.numRows; i++) {
                        var row = {};
                        arrowTable.schema.fields.forEach(function(field) {
                            var column = arrowTable.getChild(field.name);
                            var value = column.get(i);

                            // Convert BigInt to Number (Arrow returns BigInt for Int64)
                            if (typeof value === 'bigint') {
                                value = Number(value);
                            }

                            row[field.name] = value;
                        });
                        data.push(row);
                    }

                    resolve(data);
                })
                .catch(function(error) {
                    console.error('Error loading external Parquet:', error);
                    reject(error);
                });
            return;
        }

        // Handle external CSV files
        if (format === 'csv_external' && dataSrc) {
            fetch(dataSrc)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + dataSrc + ': ' + response.statusText);
                    }
                    return response.text();
                })
                .then(function(csvText) {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            // Check for fatal errors only (not warnings)
                            var fatalErrors = results.errors.filter(function(err) {
                                return err.type !== 'Delimiter';
                            });

                            if (fatalErrors.length > 0) {
                                console.error('CSV parsing errors:', fatalErrors);
                                reject(fatalErrors);
                            } else if (results.data && results.data.length > 0) {
                                // Parse dates in CSV data (centralized)
                                resolve(parseDatesInData(results.data));
                            } else {
                                reject(new Error('No data parsed from CSV'));
                            }
                        },
                        error: function(error) {
                            console.error('CSV parsing error:', error);
                            reject(error);
                        }
                    });
                })
                .catch(function(error) {
                    console.error('Error loading external CSV:', error);
                    reject(error);
                });
            return;
        }

        // Handle embedded data
        var dataText = dataElement.textContent.trim();

        if (format === 'json_embedded') {
            // Parse JSON data
            try {
                var data = JSON.parse(dataText);
                // Parse dates in JSON data (centralized)
                resolve(parseDatesInData(data));
            } catch (error) {
                console.error('JSON parsing error:', error);
                reject(error);
            }
        } else if (format === 'csv_embedded') {
            // Parse CSV data using PapaParse
            Papa.parse(dataText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Check for fatal errors only (not warnings)
                    // PapaParse includes non-fatal warnings in errors array
                    var fatalErrors = results.errors.filter(function(err) {
                        // Filter out delimiter detection warnings - these aren't fatal
                        // (common for single-column CSVs)
                        return err.type !== 'Delimiter';
                    });

                    if (fatalErrors.length > 0) {
                        console.error('CSV parsing errors:', fatalErrors);
                        reject(fatalErrors);
                    } else if (results.data && results.data.length > 0) {
                        // Parse dates in CSV data (centralized)
                        resolve(parseDatesInData(results.data));
                    } else {
                        reject(new Error('No data parsed from CSV'));
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    reject(error);
                }
            });
        } else {
            reject(new Error('Unsupported data format: ' + format));
        }
    });
}

$(function(){

(function() {
    const scenarios = ["default"];
    const hasScenarios = false;
    let currentScenario = "default";
    let selectedVars = ["A","B","C","D","E"];
    let manualOrder = [];
    let corrDataRaw = null;
    let allVars = [];

    // Helper function to wait for ml-hclust to be loaded
    function waitForHclust() {
        return new Promise(function(resolve) {
            if (window.hclustReady && window.mlHclust) {
                resolve();
                return;
            }
            const checkInterval = setInterval(function() {
                if (window.hclustReady && window.mlHclust) {
                    clearInterval(checkInterval);
                    resolve();
                }
            }, 50);
            // Timeout after 5 seconds
            setTimeout(function() {
                clearInterval(checkInterval);
                console.warn('ml-hclust library failed to load within timeout');
                resolve();
            }, 5000);
        });
    }

    // Load correlation data and wait for hclust
    Promise.all([
        loadDataset('test_data'),
        waitForHclust()
    ]).then(function(results) {
        corrDataRaw = results[0];
        allVars = [...new Set(corrDataRaw.map(d => d.node1).concat(corrDataRaw.map(d => d.node2)))].sort();
        populateVarSelector_test();
        updateChart_test();
    }).catch(function(error) {
        console.error('Failed to load correlation data:', error);
        document.getElementById('corrmatrix_test').innerHTML =
            '<p style="color: red;">Error loading correlation data: ' + error.message + '</p>';
    });

    function populateVarSelector_test() {
        const select = document.getElementById('var_select_test');
        select.innerHTML = '';
        allVars.forEach(v => {
            const option = document.createElement('option');
            option.value = v;
            option.text = v;
            option.selected = selectedVars.includes(v);
            select.appendChild(option);
        });
    }

    function initializeSortable_test() {
        const container = document.getElementById('sortable_vars_test');
        if (!container) return;

        container.innerHTML = '';

        // Only show currently selected variables in manual order
        const varsToShow = manualOrder.length > 0 ?
            manualOrder.filter(v => selectedVars.includes(v)) :
            selectedVars;

        varsToShow.forEach(v => {
            const div = document.createElement('div');
            div.className = 'sortable-item';
            div.textContent = v;
            div.setAttribute('data-var', v);
            container.appendChild(div);
        });

        if (typeof Sortable !== 'undefined') {
            Sortable.create(container, {
                animation: 150,
                onEnd: function() {
                    manualOrder = Array.from(container.children).map(el => el.getAttribute('data-var'));
                    updateChart_test();
                }
            });
        }
    }

    window.updateChart_test = function() {
        if (!corrDataRaw || corrDataRaw.length === 0) {
            console.warn('Correlation data not loaded yet');
            return;
        }

        // Update scenario (if applicable)
        if (hasScenarios) {
            const scenarioSelect = document.getElementById('scenario_select_test');
            if (scenarioSelect) {
                currentScenario = scenarioSelect.value;
            }
        }

        // Update selected variables
        const varSelect = document.getElementById('var_select_test');
        const newSelectedVars = Array.from(varSelect.selectedOptions).map(opt => opt.value);

        // Check if new variables were added
        const addedVars = newSelectedVars.filter(v => !selectedVars.includes(v));
        if (addedVars.length > 0 && manualOrder.length > 0) {
            // Add new variables to end of manual order
            addedVars.forEach(v => {
                if (!manualOrder.includes(v)) {
                    manualOrder.push(v);
                }
            });
        }

        selectedVars = newSelectedVars;

        if (selectedVars.length < 2) {
            console.warn('Select at least 2 variables');
            return;
        }

        // Get correlation method
        const corrMethod = document.getElementById('corr_method_select_test').value;

        // Get order mode
        const orderModeSelect = document.getElementById('order_mode_test');
        const orderMode = orderModeSelect ? orderModeSelect.value : 'dendrogram';

        // Show/hide linkage selector
        const linkageContainer = document.getElementById('linkage_container_test');
        if (linkageContainer) {
            linkageContainer.style.display = (orderMode === 'dendrogram') ? 'block' : 'none';
        }

        // Show/hide manual ordering UI
        const manualDiv = document.getElementById('manual_order_test');
        if (manualDiv) {
            manualDiv.style.display = (orderMode === 'manual') ? 'block' : 'none';
        }

        if (orderMode === 'manual') {
            initializeSortable_test();
        }

        // Get linkage method
        const linkageMethod = document.getElementById('linkage_select_test').value;

        // Build correlation matrix for selected variables
        const n = selectedVars.length;
        const corrMatrix = [];
        for (let i = 0; i < n; i++) {
            corrMatrix[i] = [];
            for (let j = 0; j < n; j++) {
                if (i === j) {
                    corrMatrix[i][j] = 1.0;
                } else {
                    // Find correlation from data
                    const item = corrDataRaw.find(d =>
                        ((d.node1 === selectedVars[i] && d.node2 === selectedVars[j]) ||
                         (d.node1 === selectedVars[j] && d.node2 === selectedVars[i])) &&
                        d.correlation_method === corrMethod &&
                        (!hasScenarios || d.scenario === currentScenario));
                    corrMatrix[i][j] = item ? item.strength : 0;
                }
            }
        }

        // Determine variable order
        let orderedVars;
        if (orderMode === 'manual' && manualOrder.length > 0) {
            // Use manual order, filtered to selected vars
            orderedVars = manualOrder.filter(v => selectedVars.includes(v));
            // Add any selected vars not in manual order to the end
            selectedVars.forEach(v => {
                if (!orderedVars.includes(v)) {
                    orderedVars.push(v);
                }
            });
        } else if (orderMode === 'alphabetical') {
            orderedVars = selectedVars.slice().sort();
        } else {
            // Perform hierarchical clustering in browser
            orderedVars = performClustering_test(selectedVars, corrMatrix, linkageMethod);
        }

        // Reorder correlation matrix according to ordering
        const orderedIndices = orderedVars.map(v => selectedVars.indexOf(v));
        const reorderedMatrix = [];
        for (let i = 0; i < n; i++) {
            reorderedMatrix[i] = [];
            for (let j = 0; j < n; j++) {
                reorderedMatrix[i][j] = corrMatrix[orderedIndices[i]][orderedIndices[j]];
            }
        }

        // Draw heatmap
        drawHeatmap_test(orderedVars, reorderedMatrix, corrMethod);

        // Draw dendrogram (only if using dendrogram order)
        if (orderMode === 'dendrogram') {
            drawDendrogram_test(orderedVars, corrMatrix, linkageMethod);
        } else {
            document.getElementById('dendrogram_test').style.display = 'none';
        }
    };

    function performClustering_test(vars, corrMatrix, linkageMethod) {
        if (vars.length < 2) return vars;
        if (!window.mlHclust || !window.mlHclust.agnes) {
            console.warn('ml-hclust library not loaded, using original order');
            return vars;
        }

        try {
            // Convert correlation to distance matrix
            const n = vars.length;
            const distMatrix = [];
            for (let i = 0; i < n; i++) {
                distMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    // dist = sqrt(0.5 * (1 - corr))
                    const dist = Math.sqrt(Math.max(0, 0.5 * (1 - Math.abs(corrMatrix[i][j]))));
                    distMatrix[i][j] = dist;
                }
            }

            // Perform hierarchical clustering using AGNES
            const tree = window.mlHclust.agnes(distMatrix, { method: linkageMethod });

            // Extract leaf order
            const leafOrder = [];
            function getLeafOrder(node) {
                if (node.isLeaf) {
                    leafOrder.push(node.index);
                } else {
                    if (node.children) {
                        node.children.forEach(child => getLeafOrder(child));
                    }
                }
            }
            getLeafOrder(tree);

            // Return variables in dendrogram order
            return leafOrder.map(idx => vars[idx]);
        } catch (error) {
            console.warn('Clustering failed:', error);
            return vars;
        }
    }

    function drawHeatmap_test(vars, corrMatrix, corrMethod) {
        const n = vars.length;

        // Build z-values and text
        const zValues = [];
        const textValues = [];
        const hoverText = [];

        for (let i = 0; i < n; i++) {
            zValues[i] = [];
            textValues[i] = [];
            hoverText[i] = [];
            for (let j = 0; j < n; j++) {
                const corr = corrMatrix[i][j];
                zValues[i][j] = corr;

                if (i === j) {
                    textValues[i][j] = '1.00';
                    hoverText[i][j] = vars[i];
                } else if (i < j) {
                    // Upper triangle: Pearson
                    textValues[i][j] = 'P: ' + corr.toFixed(2);
                    hoverText[i][j] = vars[i] + ' vs ' + vars[j] + '<br>Pearson: ' + corr.toFixed(3);
                } else {
                    // Lower triangle: Spearman
                    textValues[i][j] = 'S: ' + corr.toFixed(2);
                    hoverText[i][j] = vars[i] + ' vs ' + vars[j] + '<br>Spearman: ' + corr.toFixed(3);
                }
            }
        }

        // Create heatmap
        const heatmapTrace = {
            z: zValues,
            x: vars,
            y: vars,
            type: 'heatmap',
            colorscale: [
                [0, '#ff0000'],    // -1: red
                [0.5, '#ffffff'],  //  0: white
                [1, '#0000ff']     //  1: blue
            ],
            zmin: -1,
            zmax: 1,
            text: hoverText,
            hovertemplate: '%{text}<extra></extra>',
            colorbar: {
                title: 'Correlation',
                titleside: 'right'
            }
        };

        const heatmapLayout = {
            xaxis: { side: 'bottom', tickangle: -45 },
            yaxis: { autorange: 'reversed' },
            annotations: [],
            margin: { l: 150, r: 50, b: 150, t: 50 }
        };

        // Add text annotations
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                heatmapLayout.annotations.push({
                    x: vars[j],
                    y: vars[i],
                    text: textValues[i][j],
                    showarrow: false,
                    font: {
                        size: 10,
                        color: Math.abs(zValues[i][j]) > 0.5 ? 'white' : 'black'
                    }
                });
            }
        }

        Plotly.newPlot('corrmatrix_test', [heatmapTrace], heatmapLayout, {responsive: true});
    }

    function drawDendrogram_test(vars, corrMatrix, linkageMethod) {
        const dendroDiv = document.getElementById('dendrogram_test');
        dendroDiv.style.display = 'block';

        if (vars.length < 2) {
            dendroDiv.innerHTML = '<p style="color: #666;">Select at least 2 variables to see dendrogram</p>';
            return;
        }

        if (!window.mlHclust || !window.mlHclust.agnes) {
            dendroDiv.innerHTML = '<p style="color: #666;">Loading clustering library...</p>';
            return;
        }

        try {
            // Convert correlation to distance matrix
            const n = vars.length;
            const distMatrix = [];
            for (let i = 0; i < n; i++) {
                distMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    const dist = Math.sqrt(Math.max(0, 0.5 * (1 - Math.abs(corrMatrix[i][j]))));
                    distMatrix[i][j] = dist;
                }
            }

            // Perform clustering using AGNES
            const tree = window.mlHclust.agnes(distMatrix, { method: linkageMethod });

            // Extract dendrogram structure
            const dendroData = extractDendrogramStructure_test(tree, vars);

            // Draw dendrogram
            const leafTrace = {
                x: dendroData.leafPositions,
                y: Array(n).fill(0),
                mode: 'text',
                type: 'scatter',
                text: dendroData.leafLabels,
                textposition: 'bottom center',
                textfont: { size: 10 },
                hoverinfo: 'text',
                showlegend: false
            };

            const dendroLayout = {
                title: 'Hierarchical Clustering Dendrogram (' + linkageMethod + ' linkage)',
                xaxis: {
                    visible: false,
                    range: [-0.5, n - 0.5]
                },
                yaxis: {
                    title: 'Height',
                    range: [0, dendroData.maxHeight * 1.15]
                },
                margin: { l: 80, r: 50, b: 120, t: 50 },
                showlegend: false,
                shapes: dendroData.shapes
            };

            Plotly.newPlot('dendrogram_test', [leafTrace], dendroLayout, {responsive: true});
        } catch (error) {
            console.error('Failed to draw dendrogram:', error);
            dendroDiv.innerHTML = '<p style="color: red;">Error drawing dendrogram</p>';
        }
    }

    function extractDendrogramStructure_test(tree, vars) {
        const n = vars.length;
        const positions = {};
        const heights = {};
        const shapes = [];
        let maxHeight = 0;
        let nextPos = 0;

        // Assign positions to leaves (in order they appear)
        function assignPositions(node) {
            if (node.isLeaf) {
                positions[node.index] = nextPos;
                heights[node.index] = 0;
                nextPos++;
                return node.index;
            } else {
                // Process children
                const leftIdx = assignPositions(node.children[0]);
                const rightIdx = assignPositions(node.children[1]);

                // Calculate merge position
                const leftPos = getClusterPos(leftIdx);
                const rightPos = getClusterPos(rightIdx);
                const leftHeight = getClusterHeight(leftIdx);
                const rightHeight = getClusterHeight(rightIdx);
                const mergePos = (leftPos + rightPos) / 2;
                const mergeHeight = node.height || 0;

                maxHeight = Math.max(maxHeight, mergeHeight);

                // Store cluster info (use negative index to distinguish from leaves)
                const clusterId = -(n + Object.keys(shapes).length / 3);
                positions[clusterId] = mergePos;
                heights[clusterId] = mergeHeight;

                // Draw U-shaped connection
                shapes.push({
                    type: 'line',
                    x0: leftPos, y0: leftHeight,
                    x1: leftPos, y1: mergeHeight,
                    line: { color: '#636efa', width: 2 }
                });
                shapes.push({
                    type: 'line',
                    x0: leftPos, y0: mergeHeight,
                    x1: rightPos, y1: mergeHeight,
                    line: { color: '#636efa', width: 2 }
                });
                shapes.push({
                    type: 'line',
                    x0: rightPos, y0: rightHeight,
                    x1: rightPos, y1: mergeHeight,
                    line: { color: '#636efa', width: 2 }
                });

                return clusterId;
            }
        }

        function getClusterPos(id) {
            return positions[id] !== undefined ? positions[id] : 0;
        }

        function getClusterHeight(id) {
            return heights[id] !== undefined ? heights[id] : 0;
        }

        assignPositions(tree);

        // Get leaf order and labels
        const leafOrder = [];
        function collectLeaves(node) {
            if (node.isLeaf) {
                leafOrder.push(node.index);
            } else {
                node.children.forEach(child => collectLeaves(child));
            }
        }
        collectLeaves(tree);

        const leafPositions = leafOrder.map((_, i) => i);
        const leafLabels = leafOrder.map(idx => vars[idx]);

        return {
            shapes: shapes,
            maxHeight: maxHeight || 1,
            leafPositions: leafPositions,
            leafLabels: leafLabels
        };
    }
})();


});
</script>

<!-- DATASETS -->

<script type="text/plain" id="test_data" data-format="csv_embedded" data-src="">
node1,node2,strength,scenario,correlation_method
A,B,-0.14740941576354155,default,pearson
A,B,-0.16973297329732973,default,spearman
A,C,0.12879007228913594,default,pearson
A,C,0.12228022802280228,default,spearman
A,D,0.037013339079501405,default,pearson
A,D,0.05284128412841284,default,spearman
A,E,-0.014546701458468581,default,pearson
A,E,-0.06393039303930394,default,spearman
B,C,0.09629451373665845,default,pearson
B,C,0.1192079207920792,default,spearman
B,D,0.03996446337609061,default,pearson
B,D,0.032943294329432944,default,spearman
B,E,0.08363933101092343,default,pearson
B,E,0.056825682568256826,default,spearman
C,D,-0.13234166378717063,default,pearson
C,D,-0.10562256225622563,default,spearman
C,E,0.19840544631277882,default,pearson
C,E,0.12732073207320732,default,spearman
D,E,-0.17324382366542154,default,pearson
D,E,-0.15375937593759376,default,spearman

</script>

<!-- ACTUAL CONTENT -->

<h1></h1>
<p></p>

<script type="module">
// Import ml-hclust as ESM module
import * as hclust from 'https://cdn.jsdelivr.net/npm/ml-hclust@4.0.0/+esm';
window.mlHclust = hclust;
window.hclustReady = true;
console.log('ml-hclust library loaded:', hclust);
</script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<div class="corrplot-container">
    <h2>Test CorrPlot</h2>
    <p></p>
    
    <div style="margin-bottom: 15px;">
    <label for="var_select_test"><strong>Select Variables:</strong></label><br>
    <select id="var_select_test" multiple size="8" style="width: 300px;" onchange="updateChart_test()">
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <label for="corr_method_select_test"><strong>Correlation method:</strong></label>
    <select id="corr_method_select_test" onchange="updateChart_test()">
        <option value="pearson" selected>Pearson</option>
        <option value="spearman">Spearman</option>
    </select>
</div>

    <div style="margin-bottom: 15px;">
    <label for="order_mode_test"><strong>Variable ordering:</strong></label>
    <select id="order_mode_test" onchange="updateChart_test()">
        <option value="dendrogram" selected>Order by dendrogram</option>
        <option value="alphabetical">Order alphabetically</option>
        <option value="manual">Order manually</option>
    </select>
</div>

    <div id="linkage_container_test" style="margin-bottom: 15px;">
    <label for="linkage_select_test"><strong>Clustering linkage:</strong></label>
    <select id="linkage_select_test" onchange="updateChart_test()">
        <option value="ward" selected>Ward</option>
        <option value="average">Average</option>
        <option value="single">Single</option>
        <option value="complete">Complete</option>
    </select>
</div>

    <div id="manual_order_test" style="margin-bottom: 15px; display: none;">
    <label><strong>Drag to Reorder:</strong></label>
    <div id="sortable_vars_test" style="padding: 10px; border: 1px solid #ccc; min-height: 50px;">
    </div>
</div>

    <div id="dendrogram_test" style="width: 100%; height: 300px;"></div>
    <div id="corrmatrix_test" style="width: 100%; height: 600px;"></div>
</div>
<style>
#sortable_vars_test .sortable-item {
    padding: 5px 10px;
    margin: 2px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    cursor: move;
    display: inline-block;
}
#sortable_vars_test .sortable-item:hover {
    background-color: #e0e0e0;
}
</style>

<br><p style="text-align: right; font-size: 0.8em; color: #666; margin-top: -10px; margin-bottom: 10px;">Data: test_data</p>

<hr><p align="right"><small>This page was created using <a href="https://github.com/s-baumann/JSPlots.jl">JSPlots.jl</a> v0.4.0.</small></p>
</body>
</html>
